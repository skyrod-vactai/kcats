#+TITLE: The kcats Programming Language (Production Implementation)
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
* Production implementation
** Base Language
We will use Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
** Status
Unstable
** Using
*** Dependencies
- rustc
- cargo
*** Build
Run =cargo build=, the binary will be placed in =./target/debug= by
default.
*** Run
Execute the binary: =./target/debug/kcats=. It will read a program
from stdin and execute it, then print the resulting stack.

** Project File
#+begin_src toml :tangle Cargo.toml
  [package]
  name = "kcats"
  version = "0.3.0"
  edition = "2021"

  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

  [dependencies]
  # serialization
  edn-format = "3.2.3"
  base64 = "0.13.0"

  # String literals
  internment = "0.6.0" 
  lazy_static = "1.4.0"

  num-integer = "0.1.44"

  # crypto stuff
  ed25519-dalek = {version="1", features=["batch_deterministic", "std", "rand"]}
  sha2 = "0.10.6"
  rand_core = "0.5.1" # careful here, having 2 versions present will make weird compile errors

  # multithreading
  futures = "0.3"
  tokio = { version = "1", features = ["full"] }
  # multiple-consumer channels
  #crossbeam-channel = "0.5" # doesn't support async send/recv
  #async-channel = "1.8.0"
  flume = "0.10.14"

  # debugging
  backtrace = "0.3.61"
  [dev-dependencies]
  test-case = "2.0.0"
#+end_src
** Internal data types
*** Basic internal types
We'll start by defining the basic data structures that kcats will use
internally, to keep track of things like the stack, expression, lists etc.
#+begin_src rust :tangle src/types.rs
  use crate::pipes::{In, Out};
  use crate::types::collection as coll;
  use crate::types::dictionary as dict;
  use crate::types::environment as env;
  use crate::types::error::Error;
  use internment::Intern;
  use lazy_static::lazy_static;
  use std::collections::{HashMap, VecDeque};
  use std::fmt;
  use std::hash::Hash;
  use std::marker::Sync;
  use std::ops::{Deref, DerefMut};
  use std::pin::Pin;

  pub mod associative;
  pub mod collection;
  pub mod dictionary;
  pub mod environment;
  pub mod error;

  // A generic newtype to contain various kinds
  #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
  pub struct Newtype<T>(pub T);

  // Access the inner value easily
  impl<T> Deref for Newtype<T> {
      type Target = T;

      fn deref(&self) -> &Self::Target {
          &self.0
      }
  }

  impl<T> DerefMut for Newtype<T> {
      fn deref_mut(&mut self) -> &mut Self::Target {
          &mut self.0
      }
  }

  impl<T: IntoIterator> IntoIterator for Newtype<T> {
      type Item = T::Item;
      type IntoIter = T::IntoIter;

      fn into_iter(self) -> Self::IntoIter {
          self.0.into_iter()
      }
  }

  // but still clone the whole thing, not the inner part
  impl<T: Clone> Clone for Newtype<T> {
      fn clone(&self) -> Self {
          Newtype(self.0.clone())
      }
  }

  pub type Word = Intern<String>;

  pub type Stack = collection::List;

  pub type Bytes = Vec<u8>;

  pub type Int = i64;

  pub type Float = f64;

  pub type Char = char;

  lazy_static! {
      pub static ref S_ASSOC: Intern<String> = Intern::new("association".to_string());
      pub static ref S_BOOLEAN: Intern<String> = Intern::new("boolean".to_string());
      pub static ref S_BYTES: Intern<String> = Intern::new("bytes".to_string());
      pub static ref S_CHAR: Intern<String> = Intern::new("character".to_string());
      pub static ref S_ENVIRONMENT: Intern<String> = Intern::new("environment".to_string());
      pub static ref S_ERROR: Intern<String> = Intern::new("error".to_string());
      pub static ref S_FLOAT: Intern<String> = Intern::new("float".to_string());
      pub static ref S_INTEGER: Intern<String> = Intern::new("integer".to_string());
      pub static ref S_ITEM: Intern<String> = Intern::new("item".to_string());
      pub static ref S_LIST: Intern<String> = Intern::new("list".to_string());
      pub static ref S_NUMBER: Intern<String> = Intern::new("number".to_string());
      pub static ref S_PIPE: Intern<String> = Intern::new("pipe".to_string());
      pub static ref S_PROGRAM: Intern<String> = Intern::new("program".to_string());
      pub static ref S_STRING: Intern<String> = Intern::new("string".to_string());
      pub static ref S_WORD: Intern<String> = Intern::new("word".to_string());
      pub static ref S_DISPENSER: Intern<String> = Intern::new("dispenser".to_string());
      pub static ref S_SIZED: Intern<String> = Intern::new("sized".to_string());
      pub static ref S_ORDERED: Intern<String> = Intern::new("ordered".to_string());
  }

  // #[derive(Debug, Clone)]
  // pub enum Sequence {
  //     Assoc(Associative),
  //     List(ListContent),
  //     Nothing,
  // }

  #[derive(Debug, Clone)]
  pub enum Item {
      Int(Int),
      Float(Float),
      Word(Word),
      Char(Char),
      Dispenser(coll::Dispenser),
      Receptacle(coll::Receptacle),
  }

  pub type Future<T> = Pin<Box<dyn std::future::Future<Output = T> + Send>>;
  pub type StepFn = dyn Fn(env::Environment) -> Future<env::Environment> + Sync + Send;

  impl PartialEq for Item {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              // same types, just use their own eq
              (Item::Int(a), Item::Int(b)) => a == b,
              (Item::Float(a), Item::Float(b)) => a == b,
              (Item::Word(a), Item::Word(b)) => a == b,
              (
                  Item::Dispenser(coll::Dispenser::Sized(a)),
                  Item::Receptacle(coll::Receptacle::Sized(b)),
              ) => a == b,
              (
                  Item::Receptacle(coll::Receptacle::Sized(a)),
                  Item::Dispenser(coll::Dispenser::Sized(b)),
              ) => a == b,
              (Item::Dispenser(a), Item::Dispenser(b)) => a == b,
              (Item::Char(a), Item::Char(b)) => a == b,
              // (Item::Assoc(a), Item::Assoc(b)) => a == b,
              // (Item::List(a), Item::List(b)) => a == b,
              // //TODO: (Item::Collection(a), Item::Collection(b)) => a == b,
              // (Item::Env(a), Item::Env(b)) => a == b,
              // (Item::Entry(a), Item::Entry(b)) => a == b,
              // (Item::Dictionary(a), Item::Dictionary(b)) => a == b,
              // (Item::Error(a), Item::Error(b)) => a == b,
              // //TODO:
              // //(Item::In(a), Item::In(b)) => a == b,
              // //(Item::Out(a), Item::Out(b)) => a == b,
              // //(Item::Tunnel(a), Item::Tunnel(b)) => a == b,
              // (Item::Nothing, Item::Nothing) => true,
              // // different types, but can be converted to the same type
              // (Item::Nothing, Item::List(l)) => l.is_empty(),
              // (Item::List(l), Item::Nothing) => l.is_empty(),

              // (Item::Nothing, Item::Assoc(l)) => l.is_empty(),
              // (Item::Assoc(l), Item::Nothing) => l.is_empty(),

              // (Item::Nothing, Item::Collection(l)) => l.is_empty(),
              // (Item::Collection(l), Item::Nothing) => l.is_empty(),

              // (Item::List(l), Item::Assoc(a)) => l.is_empty() && a.is_empty(),
              // (Item::Assoc(a), Item::List(l)) => l.is_empty() && a.is_empty(),
              //(Item::Error(i), Item::Assoc(j)) => (*i).data == *j,
              //(Item::Assoc(i), Item::Error(j)) => (*j).data == *i,

              //TODO Definition, Associative etc
              _ => false,
          }
      }
  }

  // The default Item is NOTHING.
  impl Default for Item {
      fn default() -> Self {
          coll::NOTHING
      }
  }

  pub fn wrap(i: Item) -> coll::List {
      coll::List::from_iter([i])
  }

  impl TryFrom<Item> for Int {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Int(i) => Ok(i),
              i => Err(Error::expected("integer", i)),
          }
      }
  }

  impl TryFrom<Item> for Float {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Float(i) => Ok(i),
              i => Err(Error::expected("float", i)),
          }
      }
  }

  impl TryFrom<Item> for String {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let s = coll::Sized::try_from(i)?;
          match s {
              coll::Sized::String(i) => Ok(i),
              i => Err(Error::expected("string", i.into())),
          }
      }
  }

  impl TryFrom<Item> for Word {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Word(i) => Ok(i),
              i => Err(Error::expected("word", i)),
          }
      }
  }

  impl TryFrom<Item> for Bytes {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let s = coll::Sized::try_from(i)?;
          match s {
              coll::Sized::Bytes(b) => Ok(b),
              b => Err(Error::expected("bytes", b.into())),
          }
      }
  }

  // impl TryFrom<Item> for Association {
  //     type Error = Error;
  //     fn try_from(i: Item) -> Result<Self, Self::Error> {
  //         match i {
  //             Item::Assoc(a) => Ok(a),
  //             Item::List(l) => Ok(to_hash(l)?),
  //             Item::Nothing => Ok(Arc::new(AssociationContent::new())),
  //             Item::DerivedDef(d) => Ok(Association::from(d)),
  //             Item::AxiomDef(a) => Ok(Association::from(a)),
  //             Item::Env(e) => Ok(Association::from(e)),
  //             Item::Error(e) => Ok(Association::from(e)),
  //             _ => Err(Error::expected("association")),
  //         }
  //     }
  // }

  impl TryFrom<Item> for In {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Receptacle(coll::Receptacle::In(i)) => Ok(i),
              i => Err(Error::expected("pipe", i)),
          }
      }
  }

  impl TryFrom<Item> for Out {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Dispenser(coll::Dispenser::Out(o)) => Ok(o),
              i => Err(Error::expected("pipe", i)),
          }
      }
  }

  // As there are no real booleans, we use the word 'true' but literally
  // any value except the empty list is truthy. If we read a value
  // 'false' in edn, that's not actually a boolean, it's just the
  // symbol/word false.
  impl From<bool> for Item {
      fn from(b: bool) -> Item {
          if b {
              "true".into()
          } else {
              coll::NOTHING
          }
      }
  }

  // impl From<Environment> for Association {
  //     fn from(env: Environment) -> Association {
  //         let mut a = AssociationContent::new();
  //         a.insert(word_key("stack"), Item::List(env.stack.clone()));
  //         a.insert(word_key("expression"), Item::List(env.expression.clone()));
  //         a.insert(word_key("dictionary"), Item::Assoc(env.dictionary.clone()));
  //         Arc::new(a)
  //     }
  // }

  impl From<std::io::Error> for Error {
      fn from(err: std::io::Error) -> Error {
          Error::create(wrap("io".into()), &err.to_string(), None)
      }
  }

  impl From<&str> for Item {
      fn from(i: &str) -> Self {
          Item::Word(Word::from(i))
      }
  }

  impl From<String> for Item {
      fn from(i: String) -> Self {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(i)))
      }
  }

  impl From<Bytes> for Item {
      fn from(b: Bytes) -> Self {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(b)))
      }
  }

  impl From<Char> for Item {
      fn from(c: Char) -> Self {
          Item::Char(c)
      }
  }

  impl From<Int> for Item {
      fn from(c: Int) -> Self {
          Item::Int(c)
      }
  }
#+end_src
*** Collection types
#+begin_src rust :tangle src/types/collection.rs
  use futures::FutureExt;

  use crate::pipes as pipe;
  use crate::types::associative as assoc;
  use crate::types::*;
  use std::{collections::HashSet, future, sync};

  pub type Arc<T> = Newtype<sync::Arc<T>>;
  pub type Listy<I> = Newtype<VecDeque<I>>;
  pub type Setty<I> = Newtype<HashSet<I>>;
  // impl<T: PartialEq> PartialEq for Newtype<Arc<T>> {
  //     fn eq(&self, other: &Self) -> bool {
  //         **self.0 == **other.0
  //     }
  // }

  impl<T: Clone> Arc<T> {
      pub fn make_mut(&mut self) -> &mut T {
          sync::Arc::make_mut(&mut self.0)
      }

      pub fn inner(&mut self) -> T {
          sync::Arc::try_unwrap(self.0.clone()).unwrap_or_else(|rc| (*rc).clone())
      }

      pub fn wrap(inner: T) -> Self {
          Self(sync::Arc::new(inner))
      }
  }

  pub type ListContent = Listy<Item>;
  pub type List = Arc<ListContent>;
  pub type Set = Arc<Setty<assoc::KeyItem>>;

  impl List {
      pub fn new() -> List {
          Newtype(sync::Arc::new(Newtype(VecDeque::new())))
      }
  }

  impl Set {
      pub fn from(h: HashSet<assoc::KeyItem>) -> Set {
          Newtype(sync::Arc::new(Newtype(h)))
      }

      pub fn new() -> Set {
          Set::from(HashSet::new())
      }
  }

  impl FromIterator<Item> for List {
      fn from_iter<I>(iter: I) -> Self
      where
          I: IntoIterator<Item = Item>,
      {
          Newtype(sync::Arc::new(Newtype(
              iter.into_iter().collect::<VecDeque<Item>>(),
          )))
      }
  }

  // Most generic collection type, all we know is it can contain
  // multiple items.
  #[derive(Debug, Clone, PartialEq)]
  pub enum Dispenser {
      Sized(Sized),
      Out(pipe::Out),
      Tunnel(pipe::Tunnel),
  }

  #[derive(Debug, Clone, PartialEq)]
  pub enum Receptacle {
      Sized(Sized),
      In(pipe::In),
      Tunnel(pipe::Tunnel),
  }

  // Collection that has a definite size that we can access. Implies
  // that it can also be appended to.
  #[derive(Debug, Clone)]
  pub enum Sized {
      Associative(assoc::Associative),
      List(List),
      Set(Set),
      String(String),
      Bytes(Bytes),
      Nothing,
  }

  pub struct Iterable<'a, T> {
      data: Arc<Vec<T>>,
      index: usize,
      phantom: std::marker::PhantomData<&'a T>,
  }

  impl<'a, T> Iterable<'a, T> {
      pub fn new(data: Arc<Vec<T>>) -> Self {
          Self {
              data,
              index: 0,
              phantom: std::marker::PhantomData,
          }
      }
  }

  impl<'a, T> Iterator for Iterable<'a, T> {
      type Item = &'a T;

      fn next(&mut self) -> Option<Self::Item> {
          if self.index >= self.data.len() {
              return None;
          }

          let item = unsafe {
              // SAFETY: We have ensured that the index is within bounds
              // of the vector, and we ensure that the vector is not
              // modified during iteration, by always using make_mut to
              // modify (which copies on write), so this pointer
              // dereference should always be safe.
              let ptr: *const T = &self.data[self.index];
              &*ptr
          };

          self.index += 1;
          Some(item)
      }
  }

  impl PartialEq for Sized {
      fn eq(&self, other: &Self) -> bool {
          if self.is_empty() && other.is_empty() {
              return true;
          }
          match (self, other) {
              (Sized::Associative(a), Sized::Associative(b)) => a == b,
              (Sized::List(a), Sized::List(b)) => a == b,
              (Sized::String(a), Sized::String(b)) => a == b,
              (Sized::Bytes(a), Sized::Bytes(b)) => a == b,
              (Sized::Set(a), Sized::Set(b)) => a == b,
              (Sized::Nothing, Sized::Nothing) => true,
              (Sized::Nothing, l) => l.is_empty(),
              (l, Sized::Nothing) => l.is_empty(),
              _ => false,
          }
      }
  }
  // a const Item value for Nothing
  pub const NOTHING: Item = Item::Dispenser(Dispenser::Sized(Sized::Nothing));

  impl Dispenser {
      pub fn take(self) -> Future<(Dispenser, Option<Item>)> {
          match self {
              Dispenser::Sized(s) => Box::pin(future::ready(s.take())),
              Dispenser::Out(mut o) => Box::pin({
                  let i = o.take();
                  i.map(|r| {
                      (
                          Dispenser::Out(o),
                          match r {
                              Ok(Some(i)) => Some(i),
                              Ok(None) => None,
                              Err(e) => Some(Item::from(e)),
                          },
                      )
                  })
              }),
              Dispenser::Tunnel(mut t) => Box::pin({
                  let i = t.take();
                  i.map(|r| {
                      (
                          Dispenser::Tunnel(t),
                          match r {
                              Ok(Some(i)) => Some(i),
                              Ok(None) => None,
                              Err(e) => Some(Item::from(e)),
                          },
                      )
                  })
              }),
          }
      }
  }

  impl Sized {
      pub fn is_empty(&self) -> bool {
          self.len() == 0
      }

      pub fn len(&self) -> usize {
          match self {
              Sized::Associative(a) => a.len(),
              Sized::List(l) => l.len(),
              Sized::String(s) => s.len(),
              Sized::Bytes(b) => b.len(),
              Sized::Set(s) => s.len(),
              Sized::Nothing => 0,
          }
      }

      pub fn take(self) -> (Dispenser, Option<Item>) {
          match self {
              Sized::Associative(a) => a.take(),
              Sized::List(mut l) => {
                  let lm = l.make_mut();
                  let i = lm.pop_front();
                  (Dispenser::Sized(Sized::List(l)), i)
              }
              Sized::Nothing => (Dispenser::Sized(Sized::Nothing), None),
              Sized::String(mut s) => {
                  let i = s.pop().map(Item::Char);
                  (Dispenser::Sized(Sized::String(s)), i)
              }
              Sized::Bytes(mut b) => {
                  let i = b.pop().map(|b| Item::Int(b as i64));
                  (Dispenser::Sized(Sized::Bytes(b)), i)
              }
              Sized::Set(mut s) => {
                  let i = s.iter().next().cloned();
                  let sm = s.make_mut();
                  if let Some(i) = i.clone() {
                      sm.take(&i);
                  }
                  (Dispenser::Sized(Sized::Set(s)), i.map(Item::from))
              }
          }
      }

      pub fn put(self, other: Item) -> Result<Sized, Error> {
          match (self, other) {
              (Sized::List(mut c), i) => {
                  c.make_mut().push_back(i);
                  Ok(Sized::List(c))
              }
              (Sized::Associative(a), l) => Ok(Sized::Associative(a.put(l)?)),
              (Sized::Set(mut s), i) => {
                  s.make_mut().insert(assoc::KeyItem::try_from(i)?);
                  Ok(Sized::Set(s))
              }
              (Sized::Bytes(mut b), Item::Int(i)) => {
                  b.push(i as u8);
                  Ok(Sized::Bytes(b))
              }
              (Sized::Nothing, i) => Ok(Sized::List(List::from_iter([i]))),
              (Sized::String(_), _) => unimplemented!(),
              (i, _) => Err(Error::expected("packable", i.into())),
          }
      }

      pub fn join(self, other: Sized) -> Result<Sized, Error> {
          Ok(match (self, other) {
              (Sized::Associative(a), Sized::List(l)) => Sized::Associative({
                  let mut a: assoc::Association = a.into();
                  let mut more = assoc::Association::try_from_iter(l.clone().inner().into_iter())?;
                  let am = a.make_mut();
                  am.extend(more.inner().into_iter());
                  assoc::Associative::Assoc(a)
              }),
              (Sized::List(l), Sized::Associative(a)) => {
                  let mut a: assoc::Association = a.into();
                  let mut la = assoc::Association::try_from_iter(l.clone().inner().into_iter())?;
                  let lam = la.make_mut();
                  lam.extend(a.inner().into_iter());
                  Sized::Associative(assoc::Associative::Assoc(la))
              }
              (Sized::Associative(a), Sized::Associative(b)) => Sized::Associative(a.join(b)),
              (Sized::List(mut a), Sized::List(mut b)) => {
                  let am = a.make_mut();
                  am.extend(b.inner());
                  Sized::List(a)
              }
              (Sized::Set(mut a), Sized::Set(mut b)) => {
                  let am = a.make_mut();
                  am.extend(b.inner());
                  Sized::Set(a)
              }
              (Sized::List(mut a), Sized::Set(mut b)) => {
                  let bm = b.make_mut();

                  bm.extend(
                      a.inner()
                          .into_iter()
                          .map(assoc::KeyItem::try_from)
                          .collect::<Result<Vec<assoc::KeyItem>, Error>>()?
                          .into_iter(),
                  );
                  Sized::Set(b)
              }
              (Sized::Set(mut a), Sized::List(mut b)) => {
                  let am = a.make_mut();

                  am.extend(
                      b.inner()
                          .into_iter()
                          .map(assoc::KeyItem::try_from)
                          .collect::<Result<Vec<assoc::KeyItem>, Error>>()?
                          .into_iter(),
                  );
                  Sized::Set(a)
              }
              (Sized::String(mut a), Sized::String(b)) => {
                  a.push_str(&b);
                  Sized::String(a)
              }
              (Sized::Bytes(mut a), Sized::Bytes(b)) => {
                  a.extend(b);
                  Sized::Bytes(a)
              }
              (Sized::Nothing, x) => x,
              (x, Sized::Nothing) => x,
              //TODO: not every combination makes sense, return error here, don't panic
              (s, other) => todo!("Cannot join {:?} and {:?}", s, other),
          })
      }

      pub fn contains(&self, other: &Item) -> bool {
          match (self, other) {
              (Sized::Associative(a), other) => {
                  assoc::KeyItem::try_from(other.clone()).map_or(false, |k| a.contains_key(&k))
              }
              (Sized::List(l), other) => l.contains(other),
              (Sized::Set(s), other) => {
                  assoc::KeyItem::try_from(other.clone()).map_or(false, |k| s.contains(&k))
              }
              _ => todo!("contains not implemented for {:?}", self),
          }
      }
  }

  impl Receptacle {
      pub fn put(self, i: Item) -> Future<Result<Receptacle, Error>> {
          match self {
              Receptacle::Sized(s) => Box::pin(future::ready(s.put(i).map(Receptacle::Sized))),
              Receptacle::In(mut p) => Box::pin(p.put(i).map(|r| r.map(|_| Receptacle::In(p)))),
              Receptacle::Tunnel(mut t) => {
                  let p = t.put(i);
                  Box::pin(p.map(|r| r.map(|_| Receptacle::Tunnel(t))))
              }
          }
      }
  }

  impl IntoIterator for Sized {
      type Item = Item;
      type IntoIter = Box<dyn Iterator<Item = Item>>;

      fn into_iter(self) -> Self::IntoIter {
          match self {
              Sized::Associative(map) => Box::new(map.into_iter().map(|kv| kv.into())),
              Sized::List(mut list) => Box::new(list.inner().into_iter()),
              Sized::Nothing => Box::new(std::iter::empty()),
              Sized::String(s) => {
                  let chars: Vec<char> = s.chars().collect();
                  Box::new(chars.into_iter().map(|c| c.into()))
              }
              Sized::Bytes(b) => {
                  let vec: Vec<Item> = b.into_iter().map(|byte| Item::from(byte as Int)).collect();
                  Box::new(vec.into_iter())
              }
              Sized::Set(mut s) => Box::new(s.inner().into_iter().map(|i| i.into())),
          }
      }
  }

  impl TryFrom<Dispenser> for Sized {
      type Error = Error;

      fn try_from(c: Dispenser) -> Result<Self, Self::Error> {
          //println!("from iterable {:?}", c);
          match c {
              Dispenser::Sized(s) => Ok(s),
              i => Err(Error::expected("sized", i.into())),
          }
      }
  }

  impl TryFrom<Receptacle> for Sized {
      type Error = Error;

      fn try_from(c: Receptacle) -> Result<Self, Self::Error> {
          match c {
              Receptacle::Sized(s) => Ok(s),
              i => Err(Error::expected("sized", Item::Receptacle(i))),
          }
      }
  }

  impl TryFrom<Sized> for List {
      type Error = Error;

      fn try_from(s: Sized) -> Result<Self, Self::Error> {
          match s {
              Sized::List(l) => Ok(l),
              Sized::Nothing => Ok(List::new()),
              Sized::Associative(a) => Ok(List::from_iter(a.into_iter().map(Item::from))),
              i => Err(Error::expected("list", i.into())),
          }
      }
  }

  impl TryFrom<Item> for List {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Dispenser(l) => Sized::try_from(l).and_then(List::try_from),
              Item::Receptacle(l) => Sized::try_from(l).and_then(List::try_from),
              i => Err(Error::expected("list", i.into())),
          }
      }
  }

  impl TryFrom<Item> for Sized {
      type Error = Error;

      fn try_from(item: Item) -> Result<Self, Self::Error> {
          match item {
              Item::Dispenser(c) => c.try_into(),
              Item::Receptacle(p) => Dispenser::try_from(p)?.try_into(),
              i => {
                  // let bt = backtrace::Backtrace::new();
                  // println!("try from item {:?},\n {:?}", i, bt);
                  Err(Error::expected("sized", i))
              }
          }
      }
  }

  impl TryFrom<Item> for Receptacle {
      type Error = Error;

      fn try_from(item: Item) -> Result<Self, Self::Error> {
          match item {
              Item::Receptacle(p) => Ok(p),
              Item::Dispenser(c) => c.try_into(),
              i => Err(Error::expected("packable", i)),
          }
      }
  }

  impl TryFrom<Dispenser> for Receptacle {
      type Error = Error;

      fn try_from(c: Dispenser) -> Result<Self, Self::Error> {
          match c {
              Dispenser::Sized(s) => Ok(Receptacle::Sized(s)),
              Dispenser::Tunnel(t) => Ok(Receptacle::Tunnel(t)),
              i => Err(Error::expected("packable", i.into())),
          }
      }
  }

  impl TryFrom<Receptacle> for Dispenser {
      type Error = Error;

      fn try_from(c: Receptacle) -> Result<Self, Self::Error> {
          match c {
              Receptacle::Sized(s) => Ok(Dispenser::Sized(s)),
              Receptacle::Tunnel(t) => Ok(Dispenser::Tunnel(t)),
              i => Err(Error::expected("iterable", Item::Receptacle(i))),
          }
      }
  }

  impl TryFrom<Item> for Box<dyn Iterator<Item = Item>> {
      type Error = Error;

      fn try_from(item: Item) -> Result<Self, Self::Error> {
          Ok(Sized::try_from(item)?.into_iter())
      }
  }

  impl From<Sized> for Box<dyn Iterator<Item = Item>> {
      fn from(sized: Sized) -> Self {
          Box::new(sized.into_iter())
      }
  }

  impl From<List> for Sized {
      fn from(l: List) -> Self {
          Sized::List(l)
      }
  }

  impl From<Sized> for Dispenser {
      fn from(s: Sized) -> Self {
          Dispenser::Sized(s)
      }
  }

  impl From<List> for Item {
      fn from(l: List) -> Self {
          Item::Dispenser(Dispenser::Sized(Sized::List(l)))
      }
  }

  impl From<Dispenser> for Item {
      fn from(c: Dispenser) -> Self {
          Item::Dispenser(c)
      }
  }

  impl From<Sized> for Item {
      fn from(s: Sized) -> Self {
          Dispenser::Sized(s).into()
      }
  }

  impl TryFrom<Item> for Dispenser {
      type Error = Error;

      fn try_from(item: Item) -> Result<Self, Self::Error> {
          match item {
              Item::Dispenser(c) => Ok(c),
              Item::Receptacle(p) => Ok(Dispenser::try_from(p)?),
              i => Err(Error::expected("iterable", i)),
          }
      }
  }

  impl TryFrom<Item> for Set {
      type Error = Error;

      fn try_from(item: Item) -> Result<Self, Self::Error> {
          let s = Sized::try_from(item)?;
          let hs: HashSet<assoc::KeyItem> = s
              .into_iter()
              .map(|i| i.try_into())
              .collect::<Result<HashSet<assoc::KeyItem>, Error>>()?;
          Ok(Set::from(hs))
      }
  }
#+end_src
*** Associative types
#+begin_src rust :tangle src/types/associative.rs
  use crate::types::collection as coll;
  use crate::types::dictionary as dict;
  use crate::types::environment as env;
  use crate::types::*;
  use std::iter::FromIterator;
  use std::sync;
  pub type Associationy<K, V> = Newtype<HashMap<K, V>>;
  pub type AssociationContent = Associationy<KeyItem, Item>;
  pub type Association = coll::Arc<AssociationContent>;

  #[derive(Debug, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]
  pub enum KeyItem {
      // Order matters here, for comparison purposes - changing the
      // order will change the result of how eg int compares to word.
      Int(Int),
      Word(Word),
      Bytes(Bytes),
      String(String),
      List(KeyList),
  }

  impl KeyList {
      pub fn try_from_iter<I>(l: I) -> Result<Self, Error>
      where
          I: IntoIterator<Item = Item>,
      {
          Ok(coll::Arc::wrap(Newtype(
              l.into_iter()
                  .map(KeyItem::try_from)
                  .collect::<Result<VecDeque<KeyItem>, Error>>()?,
          )))
      }
  }

  impl From<KeyItem> for Item {
      fn from(i: KeyItem) -> Self {
          match i {
              KeyItem::Int(i) => Item::Int(i),
              KeyItem::String(i) => i.into(),
              KeyItem::List(mut l) => {
                  coll::List::from_iter(l.inner().into_iter().map(Item::from)).into()
              }
              KeyItem::Word(w) => Item::Word(w),
              KeyItem::Bytes(bs) => bs.into(),
          }
      }
  }

  impl From<&str> for KeyItem {
      fn from(i: &str) -> Self {
          KeyItem::Word(Word::from(i))
      }
  }

  impl From<Word> for KeyItem {
      fn from(i: Word) -> Self {
          KeyItem::Word(i)
      }
  }

  impl TryFrom<Item> for KeyItem {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Error> {
          match i {
              Item::Int(i) => Ok(KeyItem::Int(i)),
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(i))) => {
                  Ok(KeyItem::String(i))
              }
              Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(i))) => {
                  Ok(KeyItem::String(i))
              }
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(i))) => Ok(KeyItem::Bytes(i)),
              Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(i))) => {
                  Ok(KeyItem::Bytes(i))
              }
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))) => Ok(KeyItem::List(
                  KeyList::try_from_iter(l.inner().into_iter())?,
              )),

              Item::Word(w) => Ok(KeyItem::Word(w)),

              i => Err(Error::expected("KeyItem", i.into())),
          }
      }
  }

  impl TryFrom<KeyItem> for Word {
      type Error = Error;
      fn try_from(k: KeyItem) -> Result<Self, Self::Error> {
          match k {
              KeyItem::Word(w) => Ok(w.clone()),
              i => Err(Error::expected("word", i.into())),
          }
      }
  }

  pub type Entry = (KeyItem, Item);

  pub type KeyListContent = coll::Listy<KeyItem>;
  pub type KeyList = coll::Arc<KeyListContent>;

  #[derive(Debug, Clone)]
  pub enum Associative {
      Assoc(Association),
      DictEntry(dict::Entry),
      Env(env::Environment),
      Error(Error),
      Dictionary(dict::Dictionary),
      Nothing,
  }

  impl PartialEq for Associative {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              (Associative::Assoc(a), Associative::Assoc(b)) => a == b,
              (Associative::DictEntry(a), Associative::DictEntry(b)) => a == b,
              (Associative::Env(a), Associative::Env(b)) => a == b,
              (Associative::Error(a), Associative::Error(b)) => a == b,
              (Associative::Dictionary(a), Associative::Dictionary(b)) => a == b,
              (Associative::Nothing, Associative::Nothing) => true,
              //(Associative::Assoc(a), b) => Association::from(a) == Association::from(b),
              //(a, Associative::Assoc(b)) => Association::from(a) == Association::from(b),
              _ => false,
          }
      }
  }

  impl Associative {
      pub fn len(&self) -> usize {
          match self {
              Associative::Assoc(a) => a.len(),
              Associative::DictEntry(a) => a.len(),
              Associative::Env(e) => e.len(),
              Associative::Error(e) => e.len(),
              Associative::Dictionary(d) => d.len(),
              Associative::Nothing => 0,
          }
      }

      pub fn is_empty(&self) -> bool {
          self.len() == 0
      }

      pub fn insert(self, k: KeyItem, v: Item) -> (Associative, Option<Item>) {
          match self {
              Associative::Assoc(mut a) => {
                  let am = coll::Arc::make_mut(&mut a);
                  let e = am.insert(k, v);
                  (Associative::Assoc(a), e)
              }
              Associative::Dictionary(mut d) => match (k, v) {
                  (KeyItem::Word(w), e) => {
                      let e2 = e.clone();
                      if let Ok(e) = dict::Entry::try_from(e) {
                          let dm = coll::Arc::make_mut(&mut d);
                          let e = dm.insert(w, e).and_then(|e| Some(Item::from(e)));
                          (Associative::Dictionary(d), e)
                      } else {
                          // TODO silently failing to insert here is bad
                          println!("Warning, failed to insert into dictionary: {:?}", e2);
                          (Associative::Dictionary(d), None)
                      }
                  }
                  _ => (Associative::Dictionary(d), None),
              },
              Associative::Env(e) => e.insert(k, v),
              _ => todo!("insert Implementations for error, env etc"),
          }
      }

      pub fn put(self, other: Item) -> Result<Associative, Error> {
          let entry: (KeyItem, Item) = other.try_into()?;
          Ok(self.insert(entry.0, entry.1).0)
      }

      pub fn join(self, other: Associative) -> Associative {
          match (self, other) {
              // same type means 2nd one wins.
              //TODO: a little more complex for types that can be extended
              (Associative::DictEntry(_), Associative::DictEntry(other)) => {
                  Associative::DictEntry(other)
              }
              (Associative::Dictionary(mut this), Associative::Dictionary(mut other)) => {
                  let thism = coll::Arc::make_mut(&mut this);
                  thism.extend(other.inner().into_iter());
                  Associative::Dictionary(this)
              }
              (Associative::Error(_), Associative::Error(other)) => Associative::Error(other),
              (Associative::Env(_), Associative::Env(other)) => Associative::Env(other),
              (Associative::Nothing, Associative::Nothing) => Associative::Nothing,
              (Associative::Assoc(mut this), other) => {
                  let thism = coll::Arc::make_mut(&mut this);
                  thism.extend(other.into_iter());
                  Associative::Assoc(this)
              }
              (this, other) => {
                  let thisa: Association = this.into();
                  (Associative::Assoc(thisa)).join(other)
              }
          }
      }

      pub fn get(&self, k: &KeyItem) -> Option<Item> {
          match self {
              Associative::Assoc(a) => a.get(k).and_then(|x| Some(x.clone())),
              Associative::Error(e) => e.data.get(k).and_then(|x| Some(x.clone())),
              Associative::Env(e) => match k {
                  KeyItem::Word(s) => e.get(s.as_str()),
                  _ => None,
              },
              Associative::DictEntry(d) => match k {
                  KeyItem::Word(s) => d.get(s.as_str()),
                  _ => None,
              },
              Associative::Dictionary(d) => match k {
                  KeyItem::Word(w) => d.get(w).and_then(|x| Some(x.clone().into())),
                  _ => None,
              },
              &Associative::Nothing => None,
          }
      }

      pub fn contains_key(&self, k: &KeyItem) -> bool {
          match self {
              Associative::Assoc(a) => a.contains_key(k),
              Associative::Error(e) => e.data.contains_key(k),
              Associative::Env(e) => e.contains_key(k),
              Associative::DictEntry(d) => d.contains_key(k),
              Associative::Dictionary(d) => match k {
                  KeyItem::Word(w) => d.contains_key(w),
                  _ => false,
              },
              &Associative::Nothing => false,
          }
      }

      //TODO remove
      pub fn remove(self, k: &KeyItem) -> (Associative, Option<Item>) {
          match self {
              Associative::Assoc(mut a) => {
                  let am = coll::Arc::make_mut(&mut a);
                  let v = am.remove(k);
                  (Associative::Assoc(a), v)
              }
              Associative::Dictionary(mut d) => {
                  let dm = coll::Arc::make_mut(&mut d);
                  let v = dm.remove(&Word::try_from(k.clone()).unwrap_or_default());
                  (Associative::Dictionary(d), v.map(|v| v.into()))
              }
              _ => todo!("Removing from other associative types"),
          }
      }

      pub fn take(self) -> (coll::Dispenser, Option<Item>) {
          match self {
              Associative::Assoc(mut a) => {
                  let maybe_key = a.inner().keys().next().cloned();
                  let am = a.make_mut();
                  let maybe_value = maybe_key.as_ref().and_then(|key| am.remove(&key));
                  (
                      coll::Dispenser::Sized(coll::Sized::Associative(Associative::Assoc(a))),
                      maybe_key.map(|key| {
                          coll::List::from_iter(
                              vec![Item::from(key), Item::from(maybe_value.unwrap_or_default())]
                                  .into_iter(),
                          )
                          .into()
                      }),
                  )
              }
              Associative::Dictionary(mut d) => {
                  let maybe_key = d.inner().keys().next().cloned();
                  let dm = d.make_mut();
                  let maybe_value = maybe_key.and_then(|key| dm.remove(&key));
                  (
                      coll::Dispenser::Sized(coll::Sized::Associative(Associative::Dictionary(d))),
                      maybe_key.map(|key| {
                          coll::List::from_iter(
                              vec![
                                  Item::Word(key),
                                  maybe_value.map(Item::from).unwrap_or(coll::NOTHING),
                              ]
                              .into_iter(),
                          )
                          .into()
                      }),
                  )
              }
              _ => unimplemented!(),
          }
      }
  }

  impl IntoIterator for Associative {
      type Item = Entry;
      type IntoIter = Box<dyn Iterator<Item = Entry>>;

      fn into_iter<'a>(self) -> Self::IntoIter {
          match self {
              Associative::Assoc(mut a) => Box::new(a.inner().into_iter()),
              Associative::DictEntry(e) => Box::new(e.into_iter()),
              Associative::Dictionary(mut d) => {
                  Box::new(d.inner().into_iter().map(|(k, v)| (k.into(), v.into())))
              }
              Associative::Error(e) => e.into_iter(),
              Associative::Env(e) => e.into_iter(),
              Associative::Nothing => Box::new(std::iter::empty()),
          }
      }
  }

  impl From<Associative> for coll::List {
      fn from(a: Associative) -> Self {
          coll::List::from_iter(a.into_iter())
      }
  }

  impl TryFrom<Item> for Associative {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Error> {
          let s = coll::Sized::try_from(i)?;
          match s {
              coll::Sized::Associative(a) => Ok(a),
              coll::Sized::String(i) => Err(Error::expected("associative", i.into())),
              coll::Sized::Bytes(i) => Err(Error::expected("associative", i.into())),
              s => Ok(Associative::Assoc(Association::try_from_iter(s)?)),
          }
      }
  }

  // Convert anything that can be iterated over as Items, to an
  // Association. The items must be pairs that are
  // convertable to Entry, otherwise it will return an error.
  impl Association {
      pub fn new() -> Association {
          coll::Arc::wrap(Newtype(HashMap::new()))
      }

      pub fn try_from_iter<I>(l: I) -> Result<Self, Error>
      where
          I: IntoIterator<Item = Item>,
      {
          Ok(coll::Arc::wrap(Newtype(
              l.into_iter()
                  .map(|i| Entry::try_from(i.clone()))
                  .collect::<Result<HashMap<KeyItem, Item>, Error>>()?,
          )))
      }
  }

  impl FromIterator<Entry> for Association {
      fn from_iter<I>(iter: I) -> Self
      where
          I: IntoIterator<Item = Entry>,
      {
          coll::Arc::wrap(Newtype(
              iter.into_iter().collect::<HashMap<KeyItem, Item>>(),
          ))
      }
  }

  impl FromIterator<Entry> for coll::List {
      fn from_iter<I>(iter: I) -> Self
      where
          I: IntoIterator<Item = Entry>,
      {
          coll::Arc::wrap(Newtype(
              iter.into_iter()
                  .map(|e| e.into())
                  .collect::<VecDeque<Item>>(),
          ))
      }
  }

  impl FromIterator<KeyItem> for KeyList {
      fn from_iter<I>(iter: I) -> Self
      where
          I: IntoIterator<Item = KeyItem>,
      {
          Newtype(sync::Arc::new(Newtype(
              iter.into_iter().collect::<VecDeque<KeyItem>>(),
          )))
      }
  }

  impl From<Entry> for Item {
      fn from(e: Entry) -> Item {
          coll::List::from_iter([Item::from(e.0), e.1]).into()
      }
  }

  impl TryFrom<Item> for Entry {
      type Error = Error;

      fn try_from(i: Item) -> Result<Self, Error> {
          let s = coll::Sized::try_from(i)?;
          if s.len() != 2 {
              Err(Error::expected("pair", s.into()))
          } else {
              let mut iter = s.into_iter();
              let key: KeyItem = iter.next().unwrap().try_into()?;
              let value = iter.next().unwrap();
              Ok((key, value))
          }
      }
  }

  impl From<Associative> for Association {
      fn from(a: Associative) -> Association {
          match a {
              Associative::Assoc(a) => a,
              a => a.into_iter().collect::<Association>(),
          }
      }
  }

  impl From<AssociationContent> for Item {
      fn from(a: AssociationContent) -> Item {
          coll::Arc::wrap(a).into()
      }
  }

  impl From<Association> for Item {
      fn from(a: Association) -> Item {
          Associative::Assoc(a).into()
      }
  }

  impl From<Associative> for Item {
      fn from(a: Associative) -> Item {
          coll::Sized::Associative(a).into()
      }
  }
#+end_src
*** Error types
#+begin_src rust :tangle src/types/error.rs
  use crate::types;
  use crate::types::associative as assoc;
  use crate::types::collection as coll;
  use crate::types::{Int, Item, Word};

  #[derive(Clone, PartialEq)]
  pub struct Error {
      pub data: assoc::Association,
      pub is_handled: bool,
  }

  impl Error {
      pub fn create(asked: coll::List, reason: &str, actual: Option<Item>) -> Error {
          // let bt = backtrace::Backtrace::new();
          let mut data: Vec<(assoc::KeyItem, Item)> = vec![
              ("type".into(), "error".into()),
              ("asked".into(), asked.into()),
              ("reason".into(), reason.to_string().into()),
              //("backtrace".into(), Item::String(format!("{:?}", bt))),
          ];
          if let Some(actual) = actual {
              data.push(("actual".into(), actual));
          }
          Error {
              is_handled: false,

              data: assoc::Association::from_iter(data),
          }
      }

      pub fn stack_underflow() -> Error {
          Error::create(
              types::wrap("consume".into()),
              "not enough items on stack",
              None,
          )
      }

      pub fn undefined(w: Word) -> Error {
          Error::create(types::wrap(Item::Word(w)), "word is not defined", None)
      }

      pub fn type_mismatch(asked: coll::List, actual: Option<Item>) -> Error {
          Error::create(asked, "type mismatch", actual)
      }

      pub fn division_by_zero() -> Error {
          Error::create(types::wrap("/".into()), "division by zero", None)
      }

      pub fn expected(typestr: &str, actual: Item) -> Error {
          Error::type_mismatch(types::wrap(typestr.into()), Some(actual))
      }

      pub fn short_list(expected: Int) -> Error {
          Error::create(
              coll::List::from_iter(["count".into(), Item::Int(expected), ">=".into()]),
              "list had too few items",
              None,
          )
      }

      pub fn list_count(expected: Int) -> Error {
          Error::create(
              coll::List::from_iter(["count".into(), Item::Int(expected), "=".into()]),
              "list had wrong number of items",
              None,
          )
      }

      pub fn parse(reason: &str) -> Error {
          Error::create(types::wrap("read".into()), reason, None)
      }

      pub fn test_assertion(program: coll::List, expected: coll::List, actual: coll::List) -> Error {
          let mut e = Error::create(program, "assertion failed", Some(actual.into()));
          let d = e.data.make_mut();
          d.insert("expected".into(), expected.into());
          return e;
      }

      pub fn len(&self) -> usize {
          self.data.len()
      }
  }

  impl From<Error> for assoc::Association {
      fn from(e: Error) -> assoc::Association {
          e.data
      }
  }

  impl TryFrom<Item> for Error {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          match i {
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                  assoc::Associative::Error(e),
              ))) => Ok(e),
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(_)))
              | Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(_))) => {
                  Err(Error::expected("error", Default::default()))
              }
              Item::Dispenser(coll::Dispenser::Sized(c)) => c.into_iter().try_into(),
              i => Err(Error::expected("error", i)),
          }
      }
  }

  impl TryFrom<Box<dyn Iterator<Item = Item>>> for Error {
      type Error = Error;
      fn try_from(i: Box<dyn Iterator<Item = Item>>) -> Result<Self, Self::Error> {
          //TODO: this can't fail, can just be a From.
          // Really though, Error should have predefined fields like Environment.
          let data = assoc::Association::try_from_iter(i)?;
          Ok(Error {
              data,
              is_handled: false,
          })
      }
  }

  impl TryFrom<assoc::Associative> for Error {
      type Error = Error;
      fn try_from(a: assoc::Associative) -> Result<Self, Self::Error> {
          match a {
              assoc::Associative::Error(e) => Ok(e),
              assoc::Associative::Assoc(a) => {
                  if a.get(&assoc::KeyItem::from("type")) != Some(&Item::from("error")) {
                      Err(Error::expected("error", a.into()))
                  } else {
                      Ok(Error {
                          data: a.clone(),
                          is_handled: true,
                      })
                  }
              }
              i => Err(Error::expected("error", i.into())),
          }
      }
  }

  impl From<Error> for Item {
      fn from(e: Error) -> Item {
          assoc::Associative::Error(e).into()
      }
  }

  impl IntoIterator for Error {
      type Item = assoc::Entry;
      type IntoIter = Box<dyn Iterator<Item = assoc::Entry>>;

      fn into_iter(mut self) -> Self::IntoIter {
          Box::new(
              self.data
                  .inner()
                  .into_iter()
                  .chain(std::iter::once(("handled".into(), self.is_handled.into()))),
          )
      }
  }
#+end_src
*** Dictionary types
#+begin_src rust :tangle src/types/dictionary.rs
  use crate::types::associative as assoc;
  use crate::types::collection as coll;
  use crate::types::*;

  #[derive(Debug, Clone)]
  pub struct Entry {
      pub examples: Option<coll::List>,
      pub spec: Option<coll::List>,
      pub definition: Definition,
  }

  impl Entry {
      pub fn len(&self) -> usize {
          3 // 3 fields
      }

      pub fn get(&self, key: &str) -> Option<Item> {
          match key {
              "spec" => self.spec.clone().and_then(|x| Some(x.into())),
              "examples" => self.examples.clone().and_then(|x| Some(x.into())),
              "definition" => Some(match self.definition.clone() {
                  dict::Definition::Axiom(_) => "builtin".into(),
                  dict::Definition::Derived(d) => d.into(),
              }),
              _ => None,
          }
      }

      pub fn contains_key(&self, key: &assoc::KeyItem) -> bool {
          Word::try_from(key.clone()).map_or(false, |w| match w.as_str() {
              "examples" => true,
              "spec" => true,
              "definition" => true,
              _ => false,
          })
      }
  }

  pub type Dictionary = coll::Arc<HashMap<Word, Entry>>;

  #[derive(Clone)]
  pub enum Definition {
      Axiom(&'static StepFn),
      Derived(coll::List),
  }

  impl PartialEq for Definition {
      fn eq(&self, _: &Self) -> bool {
          // TODO actually implement this
          true
      }
  }

  // dictionary entries are equal if they have the same function reference,
  // no need to compare the function values
  impl PartialEq for Entry {
      fn eq(&self, other: &Self) -> bool {
          self.definition == other.definition
              && self.examples == other.examples
              && self.spec == other.spec
      }
  }

  impl fmt::Debug for Definition {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          match self {
              Definition::Axiom(_) => f.write_str("Builtin"),
              Definition::Derived(d) => {
                  let mut ds = f.debug_list();
                  ds.entries(d.iter());
                  ds.finish()
              }
          }
      }
  }

  impl IntoIterator for Entry {
      type Item = assoc::Entry;
      type IntoIter = Box<dyn Iterator<Item = assoc::Entry>>;

      fn into_iter(self) -> Self::IntoIter {
          let mut v: Vec<(assoc::KeyItem, Item)> = vec![("definition".into(), {
              match self.definition {
                  dict::Definition::Derived(l) => l.into(),
                  dict::Definition::Axiom(_) => "builtin-function".into(),
              }
          })];
          if let Some(e) = self.examples {
              v.push(("examples".into(), e.into()));
          }
          if let Some(s) = self.spec {
              v.push(("spec".into(), s.into()))
          }
          Box::new(v.into_iter().map(|kv| kv.into()))
      }
  }

  impl TryFrom<Box<dyn Iterator<Item = Item>>> for Entry {
      type Error = Error;
      fn try_from(iter: Box<dyn Iterator<Item = Item>>) -> Result<Self, Error> {
          let mut examples: Option<coll::List> = None;
          let mut definition: Option<Definition> = None;
          let mut spec: Option<coll::List> = None;
          for i in iter {
              let (k, v): (assoc::KeyItem, Item) = i.try_into()?;
              //println!("k: {:?}, v: {:?}", k, v);
              if k == "examples".into() {
                  examples = Some(v.try_into()?);
              } else if k == "definition".into() {
                  definition = Some(v.try_into()?);
              } else if k == "spec".into() {
                  spec = Some(v.try_into()?);
              } else {
                  continue;
              }
          }
          Ok(Entry {
              examples,
              definition: definition.unwrap_or(Definition::Derived(coll::List::new())),
              spec,
          })
      }
  }

  impl TryFrom<Box<dyn Iterator<Item = Item>>> for Dictionary {
      type Error = Error;

      fn try_from(iter: Box<dyn Iterator<Item = Item>>) -> Result<Self, Error> {
          iter.map(|kv| <(Word, Entry)>::try_from(kv))
              .collect::<Result<HashMap<Word, Entry>, Error>>()
              .map(coll::Arc::wrap)
      }
  }

  impl TryFrom<Item> for Definition {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          coll::List::try_from(i).and_then(|l| Ok(Definition::Derived(l)))
      }
  }

  impl TryFrom<Item> for Entry {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let s = coll::Sized::try_from(i)?;
          match s {
              coll::Sized::Associative(assoc::Associative::DictEntry(d)) => Ok(d),
              c => c.into_iter().try_into(),
          }
      }
  }

  impl From<Entry> for assoc::Associative {
      fn from(d: Entry) -> assoc::Associative {
          let mut assoc = assoc::Association::new();
          let a = assoc.make_mut();
          d.examples
              .and_then(|l| a.insert("examples".into(), l.into()));
          d.spec.and_then(|l| a.insert("spec".into(), l.into()));
          match d.definition {
              Definition::Derived(d) => {
                  a.insert("definition".into(), d.into());
              }
              _ => {}
          }
          assoc::Associative::Assoc(assoc)
      }
  }

  // impl TryFrom<Associative> for Entry {
  //     type Error = Error;
  //     fn try_from(d: Associative) -> Result<Self, Error> {
  //         // TODO: This should handle cases where there's no def present
  //         // and return error
  //         let (d, def) = d.remove(&"definition".into());
  //         let (d, examples) = d.remove(&"examples".into());
  //         let (_, spec) = d.remove(&"spec".into());

  //         Ok(Entry {
  //             definition: if let Some(d) = def {
  //                 Definition::Derived(List::try_from(d).unwrap())
  //             } else {
  //                 //Err(Error::expected("definition field"))?  use a
  //                 // dummy value, presumably if this is during
  //                 // bootstrap,the definition will be replaced later.
  //                 Definition::Derived(Arc::new(ListContent::new()))
  //             },

  //             // {Box::leak(Box::new(move |env: Environment| {
  //             //    env.push(Item::Error(Error::undefined(w)))
  //             //}))}
  //             examples: examples.and_then(|i| List::try_from(i).ok()),
  //             spec: spec.and_then(|i| List::try_from(i).ok()),
  //         })
  //     }
  // }

  // impl TryFrom<List> for Entry {
  //     type Error = Error;
  //     fn try_from(l: List) -> Result<Self, Error> {
  //         let a: Associative = l.try_into()?;
  //         a.try_into()
  //     }
  // }

  // impl TryFrom<assoc::Associative> for Dictionary {
  //     type Error = Error;
  //     fn try_from(a: assoc::Associative) -> Result<Self, Self::Error> {
  //         match a {
  //             assoc::Associative::Dictionary(e) => Ok(e),
  //             assoc::Associative::Assoc(a) => {
  //                 let h = rc_inner(&a)
  //                     .into_iter()
  //                     .map(|(k, v)| {
  //                         let e: (Word, Entry) = (k.try_into()?, v.try_into()?);
  //                         Ok(e)
  //                     })
  //                     .collect::<Result<HashMap<Word, Entry>, Error>>()?;
  //                 Ok(Arc::new(h))
  //             }
  //             _ => Err(Error::expected("dictionary")),
  //         }
  //     }
  // }

  // impl From<Dictionary> for assoc::Associative {
  //     fn from(d: Dictionary) -> Self {
  //         Associative::Assoc(Arc::new(
  //             rc_inner(&d)
  //                 .into_iter()
  //                 .map(|(k, v)| (assoc::KeyItem::Word(k), Item::Entry(v)))
  //                 .collect(),
  //         ))
  //     }
  // }

  impl TryFrom<Item> for Dictionary {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let s = coll::Sized::try_from(i)?;
          match s {
              coll::Sized::Associative(assoc::Associative::Dictionary(d)) => Ok(d),
              c => c.into_iter().try_into(),
          }
      }
  }

  impl From<Entry> for Item {
      fn from(e: Entry) -> Self {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::DictEntry(e),
          )))
      }
  }

  impl From<Dictionary> for Item {
      fn from(d: Dictionary) -> Self {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::Dictionary(d),
          )))
      }
  }

  impl From<(Word, Entry)> for Item {
      fn from((k, v): (Word, Entry)) -> Item {
          coll::List::from_iter([Item::Word(k.clone()), Item::from(v.clone())]).into()
      }
  }

  impl TryFrom<Item> for (Word, Entry) {
      type Error = Error;

      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let s = coll::Sized::try_from(i)?;
          if s.len() != 2 {
              Err(Error::expected("pair", s.into()))
          } else {
              let mut iter = s.into_iter();
              let key: Word = iter.next().unwrap().try_into()?;
              let value: Entry = iter.next().unwrap().try_into()?;
              Ok((key, value))
          }
      }
  }
#+end_src
*** Environment types
#+begin_src rust :tangle src/types/environment.rs
  use crate::axiom;
  use crate::serialize;
  use crate::types::*;
  use crate::types::{associative as assoc, collection as coll, dictionary as dict};
  use std::future;

  #[derive(Clone, PartialEq)]
  pub struct Environment {
      pub stack: Stack,
      pub expression: Stack,
      pub dictionary: dict::Dictionary,
  }

  impl Environment {
      pub fn push(mut self, i: Item) -> Environment {
          coll::Arc::make_mut(&mut self.stack).push_front(i);
          self
      }

      pub fn pop(&mut self) -> Item {
          coll::Arc::make_mut(&mut self.stack).pop_front().unwrap()
      }

      pub fn push_expr(mut self, i: Item) -> Environment {
          coll::Arc::make_mut(&mut self.expression).push_front(i);
          self
      }

      pub fn pop_expr(&mut self) -> Item {
          coll::Arc::make_mut(&mut self.expression)
              .pop_front()
              .unwrap()
      }

      pub fn append_expression(mut self, mut items: coll::List) -> Environment {
          let expr = self.expression.make_mut();
          let ct = expr.len();
          expr.append(items.make_mut());
          expr.rotate_left(ct);
          self
      }

      pub fn tos<'a>(&'a self) -> Option<&'a Item> {
          self.stack.front()
      }

      pub fn len(&self) -> usize {
          3 // 3 fields
      }

      pub fn get(&self, key: &str) -> Option<Item> {
          match key {
              "stack" => Some(self.stack.clone().into()),
              "expression" => Some(self.expression.clone().into()),
              "dictionary" => Some(self.dictionary.clone().into()),
              _ => None,
          }
      }

      pub fn contains_key(&self, key: &assoc::KeyItem) -> bool {
          Word::try_from(key.clone()).map_or(false, |w| match w.as_str() {
              "stack" => true,
              "expression" => true,
              "dictionary" => true,
              _ => false,
          })
      }

      pub fn insert(mut self, k: assoc::KeyItem, v: Item) -> (assoc::Associative, Option<Item>) {
          match k {
              assoc::KeyItem::Word(w) => match w.as_str() {
                  "stack" => {
                      let l = coll::List::try_from(v.clone());
                      match l {
                          Ok(l) => {
                              let old = self.stack.clone();
                              self.stack = l;
                              (assoc::Associative::Env(self), Some(old.into()))
                          }
                          Err(_) => {
                              let mut a = assoc::Association::from_iter(self);
                              let old = a.inner().insert(k, v);
                              (assoc::Associative::Assoc(a), old)
                          }
                      }
                  }
                  "expression" => {
                      let l = coll::List::try_from(v.clone());
                      match l {
                          Ok(l) => {
                              let old = self.expression.clone();
                              self.expression = l;
                              (assoc::Associative::Env(self), Some(old.into()))
                          }
                          Err(_) => {
                              let mut a = assoc::Association::from_iter(self);
                              let old = a.inner().insert(k, v);
                              (assoc::Associative::Assoc(a), old)
                          }
                      }
                  }
                  "dictionary" => {
                      let d = dict::Dictionary::try_from(v.clone());
                      match d {
                          Ok(d) => {
                              let old = self.dictionary.clone();
                              self.dictionary = d;
                              (assoc::Associative::Env(self), Some(old.into()))
                          }
                          Err(_) => {
                              let mut a = assoc::Association::from_iter(self);
                              let old = a.inner().insert(k, v);
                              (assoc::Associative::Assoc(a), old)
                          }
                      }
                  }
                  k => {
                      let mut a = assoc::Association::from_iter(self);
                      let old = a.inner().insert(k.into(), v);
                      (assoc::Associative::Assoc(a), old)
                  }
              },
              _ => {
                  let mut a = assoc::Association::from_iter(self);
                  let old = a.inner().insert(k, v);
                  (assoc::Associative::Assoc(a), old)
              }
          }
      }
  }

  impl TryFrom<Box<dyn Iterator<Item = Item>>> for Environment {
      type Error = Error;
      fn try_from(iter: Box<dyn Iterator<Item = Item>>) -> Result<Self, Error> {
          let mut stack: Option<coll::List> = None;
          let mut expression: Option<coll::List> = None;
          let mut dictionary: Option<dict::Dictionary> = None;
          for i in iter {
              let (k, v): (assoc::KeyItem, Item) = i.try_into()?;
              if k == "stack".into() {
                  stack = Some(v.try_into()?)
              } else if k == "expression".into() {
                  expression = Some(v.try_into()?)
              } else if k == "dictionary".into() {
                  dictionary = Some(v.try_into()?)
              } else {
                  continue;
              }
          }
          let mut env = axiom::standard_env(expression, stack);
          if let Some(mut d) = dictionary {
              let edmut = env.dictionary.make_mut();
              edmut.extend(d.inner().into_iter());
          }
          Ok(env)
      }
  }
  impl TryFrom<Item> for Environment {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let s = coll::Sized::try_from(i)?;

          match s {
              coll::Sized::Associative(assoc::Associative::Env(e)) => Ok(e),
              l => l.into_iter().try_into(),
          }
      }
  }

  impl From<Environment> for Item {
      fn from(env: Environment) -> Item {
          assoc::Associative::Env(env).into()
      }
  }

  impl From<Environment> for Future<Environment> {
      fn from(env: Environment) -> Future<Environment> {
          Box::pin(future::ready(env))
      }
  }

  impl IntoIterator for Environment {
      type Item = assoc::Entry;
      type IntoIter = Box<dyn Iterator<Item = assoc::Entry>>;

      fn into_iter(self) -> Self::IntoIter {
          let v: Vec<(assoc::KeyItem, Item)> = vec![
              ("stack".into(), self.stack.into()),
              ("expression".into(), self.expression.into()),
              ("dictionary".into(), self.dictionary.into()),
          ];
          Box::new(v.into_iter().map(|kv| kv.into()))
      }
  }

  impl serialize::Display for Environment {
      fn representation(&self) -> Item {
          let mut assoc = assoc::Association::from_iter(self.clone());
          let am = assoc.make_mut();
          am.remove(&("dictionary".into()));
          assoc.into()
      }
  }
#+end_src
*** Cryptographic primitives
We'll implement certain cryptography functions in rust and make kcats
words for them (hashing, encryption, signing)
#+begin_src rust :tangle src/crypto.rs
  use crate::axiom::ItemResult;
  use crate::types::{associative as assoc, error::Error, Bytes, Item};
  use core::ops::Deref;
  use ed25519_dalek as signing;
  use ed25519_dalek::{Signer, Verifier};
  use rand_core;
  use rand_core::{CryptoRng, RngCore};
  use sha2::{self, Digest};

  pub fn hash(i: Item) -> ItemResult {
      let b = Bytes::try_from(i).unwrap();
      Ok(sha2::Sha256::digest(b).deref().to_vec().into())
  }

  type Value = Vec<u8>;

  pub struct SeededRNG {
      seed: Value,
      salt: Value,
  }

  impl SeededRNG {
      // Hash of seed|value
      fn hash(&self) -> Vec<u8> {
          let mut v = self.seed.clone();
          v.extend(self.salt.clone());
          sha2::Sha256::digest(v.as_slice()).deref().to_vec()
      }
  }

  impl RngCore for SeededRNG {
      fn next_u32(&mut self) -> u32 {
          rand_core::impls::next_u32_via_fill(self)
      }

      fn next_u64(&mut self) -> u64 {
          rand_core::impls::next_u64_via_fill(self)
      }

      fn fill_bytes(&mut self, dest: &mut [u8]) {
          let l = dest.len();
          dest.copy_from_slice(&self.hash()[..l]);
      }

      fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
          self.fill_bytes(dest);
          Ok(())
      }
  }

  impl CryptoRng for SeededRNG {}

  pub fn key(seed: Item) -> ItemResult {
      let sbs: Bytes = seed.try_into()?;
      let kp = signing::Keypair::generate(&mut SeededRNG {
          seed: vec![],
          salt: sbs,
      });
      Ok(assoc::Association::from_iter([
          ("type".into(), "elliptic-curve-key".into()),
          ("secret".into(), kp.secret.as_ref().to_vec().into()),
          ("public".into(), kp.public.as_ref().to_vec().into()),
      ])
      .into())
  }

  impl TryFrom<Item> for signing::Keypair {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let sk: signing::SecretKey = i.try_into()?;
          let pk: signing::PublicKey = (&sk).into();
          Ok(signing::Keypair {
              secret: sk,
              public: pk,
          })
      }
  }

  impl TryFrom<Item> for signing::SecretKey {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let a = assoc::Associative::try_from(i)?;
          if a.get(&"type".into()) == Some("elliptic-curve-key".into()) {
              let sk = signing::SecretKey::from_bytes(
                  &Bytes::try_from(
                      a.get(&"secret".into())
                          .ok_or_else(|| Error::expected("secret", Default::default()))?,
                  )?[..],
              )
              .map_err(|_e| Error::expected("valid-secret-key", Default::default()))?;
              Ok(sk)
          } else {
              Err(Error::expected("keypair", a.clone().into()))
          }
      }
  }

  impl TryFrom<Item> for signing::PublicKey {
      type Error = Error;
      fn try_from(i: Item) -> Result<Self, Self::Error> {
          let a = assoc::Associative::try_from(i)?;
          if a.get(&"type".into()) == Some("elliptic-curve-key".into()) {
              let pk = signing::PublicKey::from_bytes(
                  &Bytes::try_from(
                      a.get(&"public".into())
                          .ok_or_else(|| Error::expected("public", Default::default()))?,
                  )?[..],
              )
              .map_err(|_e| Error::expected("valid-public-key", Default::default()))?;
              Ok(pk)
          } else {
              Err(Error::expected("public-key", a.clone().into()))
          }
      }
  }
  //TODO: we can only call sign from a keypair, so we may want to assume
  // that we have either the kp, or just the secret key.
  pub fn sign(k: Item, m: Item) -> ItemResult {
      let kp: signing::Keypair = k.try_into()?;
      let message: Bytes = m.try_into()?;
      let signature: signing::Signature = kp.sign(&message);
      Ok(signature.as_ref().to_vec().into())
  }

  pub fn verify(k: Item, m: Item, s: Item) -> ItemResult {
      let pk: signing::PublicKey = k.try_into()?;
      let mbs: Bytes = m.try_into()?;
      let sbs: Bytes = s.try_into()?;
      let sig = signing::Signature::from_bytes(&sbs)
          .map_err(|_e| Error::expected("signature", Default::default()))?;
      Ok(pk
          .verify(&mbs, &sig)
          .map(|_| Item::from(true))
          .unwrap_or_default())
  }
#+end_src
** Serialization
We'll define how kcats data structure are parsed and written (for
example, in order to read/write to/from disk).
#+begin_src rust :tangle src/serialize.rs
  extern crate edn_format;
  use crate::types::environment::Environment;
  use crate::types::{associative as assoc, collection as coll, error::Error, *};
  use base64;
  use std::collections::VecDeque;
  use std::fmt;

  pub trait Display {
      fn representation(&self) -> Item;
  }

  const BYTE_TAG: &str = "b64";

  fn to_item(item: &edn_format::Value) -> Result<Item, Error> {
      //println!("to item {:?}", item);
      match item {
          edn_format::Value::Integer(i) => Ok(Item::Int(*i)),
          edn_format::Value::Vector(v) => Ok({
              if v.is_empty() {
                  coll::NOTHING
              } else {
                  coll::List::from_iter(
                      v.iter()
                          .map(|i| to_item(i))
                          .collect::<Result<Vec<Item>, Error>>()?,
                  )
                  .into()
              }
          }),
          edn_format::Value::Symbol(s) => Ok(Item::Word(s.to_string().into())),
          // we don't have booleans in kcats, so if we see 'false' that
          // is the word false which is not defined in the base
          // language, but might be user-defined later.
          edn_format::Value::Boolean(b) => Ok(if *b { "true".into() } else { "false".into() }),
          edn_format::Value::String(s) => Ok(s.to_string().into()),
          edn_format::Value::Float(f) => Ok(Item::Float(f.into_inner())),
          edn_format::Value::TaggedElement(tag, e) => {
              if *tag == edn_format::Symbol::from_name(BYTE_TAG) {
                  if let edn_format::Value::String(s) = &**e {
                      Ok(base64::decode(s).unwrap().into())
                  } else {
                      Err(Error::parse("Invalid tag datatype for byte literal"))
                  }
              } else {
                  Err(Error::parse("Unsupported tag"))
              }
          }
          edn_format::Value::Character(c) => Ok(Item::Char(*c)),
          _ => Err(Error::parse("Unsupported data literal")),
      }
  }

  pub fn from_item(item: &Item) -> edn_format::Value {
      match item {
          // dictionaries are big and it's ugly to print them for
          // environments.
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::Env(e),
          ))) => from_item(&e.representation()),
          Item::Int(i) => edn_format::Value::Integer(*i),
          Item::Float(f) => edn_format::Value::from(*f),
          Item::Char(c) => edn_format::Value::Character(*c),
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(s))) => {
              edn_format::Value::String(s.to_string())
          }
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(bs))) => {
              edn_format::Value::TaggedElement(
                  edn_format::Symbol::from_name("b64"),
                  Box::new(edn_format::Value::String(base64::encode(bs))),
              )
          }
          Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(s))) => {
              edn_format::Value::String(s.to_string())
          }
          Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(bs))) => {
              edn_format::Value::TaggedElement(
                  edn_format::Symbol::from_name("b64"),
                  Box::new(edn_format::Value::String(base64::encode(bs))),
              )
          }
          Item::Dispenser(coll::Dispenser::Sized(v)) => edn_format::Value::Vector(
              v.clone()
                  .into_iter()
                  .map(|i| from_item(&i))
                  .collect::<Vec<edn_format::Value>>(),
          ),
          Item::Receptacle(coll::Receptacle::Sized(v)) => {
              from_item(&Item::Dispenser(coll::Dispenser::Sized(v.clone())))
          }
          Item::Word(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(w)),
          //Item::Entry(w) => edn_format::Value::Symbol(edn_format::Symbol::from_name(&w.word)),
          Item::Dispenser(coll::Dispenser::Out(o)) => from_item(&o.representation()),
          Item::Dispenser(coll::Dispenser::Tunnel(t)) => from_item(&t.representation()),
          Item::Receptacle(coll::Receptacle::In(i)) => from_item(&i.representation()),
          Item::Receptacle(coll::Receptacle::Tunnel(t)) => from_item(&t.representation()),
      }
  }

  pub fn parse(s: String) -> Result<coll::List, Error> {
      let parser = edn_format::Parser::from_iter(s.chars(), edn_format::ParserOptions::default());
      Ok(coll::List::from_iter(
          parser
              .map(move |r| match r {
                  Ok(expr) => Ok(to_item(&expr)?),
                  Err(_) => Err(Error::parse("Invalid edn")),
              })
              .collect::<Result<Vec<Item>, Error>>()?,
      ))
  }

  pub fn emit(item: &Item) -> String {
      edn_format::emit_str(&from_item(item))
  }

  pub fn emit_all(items: &VecDeque<Item>) -> String {
      let mut s: String = String::new();
      for i in items {
          s.push_str(&emit(&i));
          s.push_str(" ".into());
      }
      s.pop();
      return s;
  }

  // print out envs in error messages
  impl fmt::Debug for Environment {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(
              f,
              "{{ stack: {}, expression: {} }}",
              emit(&Item::from(self.stack.clone())),
              emit(&Item::from(self.expression.clone())),
          )
      }
  }

  impl fmt::Debug for Error {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(f, "{}", emit(&Item::from(self.data.clone())))
      }
  }
#+end_src
** Builtin words
We'll define some words as axioms (not in terms of other words, only defined in Rust). 
#+begin_src rust :tangle src/axiom.rs
  use super::serialize;
  use crate::pipes;
  use crate::types::associative as assoc;
  use crate::types::collection as coll;
  use crate::types::dictionary as dict;
  use crate::types::environment::Environment;
  use crate::types::error::Error;
  use crate::types::*;

  use futures::future::FutureExt;
  use num_integer::Roots;
  use std::collections::HashMap;
  //use std::future::Future;
  use std::mem;
  use std::ops::Range;

  pub type ItemResult = Result<Item, Error>;

  impl From<ItemResult> for Item {
      fn from(i: ItemResult) -> Self {
          match i {
              Ok(i) => i,
              Err(e) => e.into(),
          }
      }
  }

  fn f_stack1(f: fn(Item) -> ItemResult) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          env.push(Item::from(f(x))).into()
      }
  }

  fn f_stack2(f: fn(Item, Item) -> ItemResult) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          let y = env.pop();
          env.push(Item::from(f(y, x))).into()
      }
  }

  fn f_stack3(f: fn(Item, Item, Item) -> ItemResult) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          let y = env.pop();
          let z = env.pop();
          env.push(Item::from(f(z, y, x))).into()
      }
  }

  fn f_stack2_async(
      f: fn(Item, Item) -> Future<ItemResult>,
  ) -> impl Fn(Environment) -> Future<Environment> {
      move |mut env: Environment| {
          let x = env.pop();
          let y = env.pop();
          Box::pin(f(x, y).map(|r| env.push(Item::from(r))))
      }
  }

  fn update_axiom_entries(
      mut d: dict::Dictionary,
      updates: Vec<(&str, &'static StepFn)>,
  ) -> dict::Dictionary {
      let dm = coll::Arc::make_mut(&mut d);
      for (w, f) in updates {
          dm.entry(Word::from(w)).and_modify(|e| {
              e.definition = dict::Definition::Axiom(f);
          });
      }
      d
  }

  pub fn add_builtins(d: dict::Dictionary) -> dict::Dictionary {
      update_axiom_entries(
          d,
          vec![
              ("*", Box::leak(Box::new(f_stack2(mult)))),
              ("+", Box::leak(Box::new(f_stack2(plus)))),
              ("++lookup", Box::leak(Box::new(f_stack2(lookup)))),
              ("++sort", Box::leak(Box::new(f_stack1(sort_by_key)))),
              ("-", Box::leak(Box::new(f_stack2(minus)))),
              ("/", Box::leak(Box::new(f_stack2(div)))),
              ("<", Box::leak(Box::new(f_stack2(lt)))),
              ("<=", Box::leak(Box::new(f_stack2(lte)))),
              ("=", Box::leak(Box::new(f_stack2(eq)))),
              (">", Box::leak(Box::new(f_stack2(gt)))),
              (">=", Box::leak(Box::new(f_stack2(gte)))),
              ("abs", Box::leak(Box::new(f_stack1(abs)))),
              ("and", Box::leak(Box::new(f_stack2(and)))),
              ("animate", Box::leak(Box::new(animate))),
              ("assign", Box::leak(Box::new(f_stack3(assign)))),
              ("association", Box::leak(Box::new(f_stack1(association)))),
              (
                  "association?",
                  Box::leak(Box::new(f_stack1(is_association))),
              ),
              ("branch", Box::leak(Box::new(branch))),
              ("bytes", Box::leak(Box::new(f_stack1(bytes)))),
              ("bytes?", Box::leak(Box::new(f_stack1(is_bytes)))),
              ("clone", Box::leak(Box::new(clone))),
              ("contains?", Box::leak(Box::new(f_stack2(contains)))),
              ("ceil", Box::leak(Box::new(f_stack1(ceil)))),
              ("compare", Box::leak(Box::new(f_stack2(compare)))),
              ("count", Box::leak(Box::new(f_stack1(count)))),
              ("dec", Box::leak(Box::new(f_stack1(dec)))),
              ("decide", Box::leak(Box::new(decide))),
              ("dip", Box::leak(Box::new(dip))),
              ("dictionary", Box::leak(Box::new(dictionary))),
              ("dipdown", Box::leak(Box::new(dipdown))),
              ("drop", Box::leak(Box::new(drop))),
              ("emit", Box::leak(Box::new(f_stack1(emit)))),
              ("environment", Box::leak(Box::new(f_stack1(environment)))),
              ("error?", Box::leak(Box::new(f_stack1(is_error)))),
              ("eval-step", Box::leak(Box::new(eval_step_outer))),
              ("evaluate", Box::leak(Box::new(evaluate))),
              ("even?", Box::leak(Box::new(f_stack1(is_even)))),
              ("evert", Box::leak(Box::new(evert))),
              ("execute", Box::leak(Box::new(execute))),
              ("fail", Box::leak(Box::new(f_stack1(fail)))),
              (
                  "file-in",
                  Box::leak(Box::new(f_stack1(crate::pipes::fs::file_in))),
              ),
              (
                  "file-out",
                  Box::leak(Box::new(f_stack1(crate::pipes::fs::file_out))),
              ),
              ("first", Box::leak(Box::new(f_stack1(first)))),
              ("float", Box::leak(Box::new(float))),
              ("handle", Box::leak(Box::new(f_stack1(handle)))),
              (
                  "handoff",
                  Box::leak(Box::new(crate::pipes::channel::handoff)),
              ),
              ("hash", Box::leak(Box::new(f_stack1(crate::crypto::hash)))),
              ("inc", Box::leak(Box::new(f_stack1(inc)))),
              ("inspect", Box::leak(Box::new(f_stack1(inspect)))),
              ("join", Box::leak(Box::new(f_stack2(join)))),
              ("key", Box::leak(Box::new(f_stack1(crate::crypto::key)))),
              ("last", Box::leak(Box::new(f_stack1(last)))),
              ("list?", Box::leak(Box::new(f_stack1(is_list)))),
              ("loop", Box::leak(Box::new(loop_))),
              ("mod", Box::leak(Box::new(f_stack2(mod_)))),
              ("not", Box::leak(Box::new(f_stack1(not)))),
              ("number?", Box::leak(Box::new(f_stack1(is_number)))),
              ("odd?", Box::leak(Box::new(f_stack1(is_odd)))),
              ("or", Box::leak(Box::new(f_stack2(or)))),
              ("pop", Box::leak(Box::new(pop))),
              ("put", Box::leak(Box::new(put))),
              ("pipe?", Box::leak(Box::new(f_stack1(is_pipe)))),
              ("range", Box::leak(Box::new(range))),
              ("read", Box::leak(Box::new(read))),
              ("recur", Box::leak(Box::new(recur))),
              ("redefine", Box::leak(Box::new(redefine))),
              ("resume", Box::leak(Box::new(identity))),
              ("reverse", Box::leak(Box::new(f_stack1(reverse)))),
              ("second", Box::leak(Box::new(f_stack1(second)))),
              (
                  "serversocket",
                  Box::leak(Box::new(f_stack2_async(crate::pipes::net::server_socket))),
              ),
              ("set", Box::leak(Box::new(f_stack1(set)))),
              ("set?", Box::leak(Box::new(f_stack1(is_set)))),
              ("sign", Box::leak(Box::new(f_stack2(crate::crypto::sign)))),
              ("sink", Box::leak(Box::new(sink))),
              ("sqrt", Box::leak(Box::new(f_stack1(sqrt)))),
              ("standard", Box::leak(Box::new(standard))),
              ("step", Box::leak(Box::new(step))),
              ("string", Box::leak(Box::new(f_stack1(string)))),
              ("string?", Box::leak(Box::new(f_stack1(is_string)))),
              ("swap", Box::leak(Box::new(swap))),
              ("swapdown", Box::leak(Box::new(swapdown))),
              ("timestamps", Box::leak(Box::new(timestamps))),
              ("true", Box::leak(Box::new(true_))),
              ("unassign", Box::leak(Box::new(f_stack2(unassign)))),
              ("take", Box::leak(Box::new(take))),
              ("unwrap", Box::leak(Box::new(unwrap))),
              (
                  "verify",
                  Box::leak(Box::new(f_stack3(crate::crypto::verify))),
              ),
              ("word?", Box::leak(Box::new(f_stack1(is_word)))),
              ("wrap", Box::leak(Box::new(wrap))),
              ("xor", Box::leak(Box::new(f_stack2(xor)))),
              ("zero?", Box::leak(Box::new(f_stack1(is_zero)))),
          ],
      )
  }

  pub fn read_lexicon(lexicon: String, mut env: Environment) -> Environment {
      let mut items = serialize::parse(lexicon).unwrap();
      for r in Box::new(items.inner().into_iter()) {
          let (k, def): (assoc::KeyItem, Item) = r.try_into().unwrap();
          let word: Word = k.try_into().unwrap();
          let iter: Box<dyn Iterator<Item = Item>> = def.try_into().unwrap();

          let new_entry: dict::Entry = iter.try_into().unwrap();
          let new_entry2 = new_entry.clone();
          let dict = coll::Arc::make_mut(&mut env.dictionary);
          dict.entry(word)
              .and_modify(|e| {
                  e.examples = new_entry.examples;
                  e.spec = new_entry.spec;
                  e.definition = new_entry.definition;
              })
              .or_insert(new_entry2);
      }
      env
  }

  pub fn add_standard_dictionary(env: Environment) -> Environment {
      // read builtins
      let builtins = String::from_utf8(include_bytes!("kcats/builtins.kcats").to_vec()).unwrap();
      let mut env = read_lexicon(builtins, env);
      //println!("with builtins {:?}", env.dictionary);
      env.dictionary = add_builtins(env.dictionary);
      //env = add_derivations(env);
      let lexicon = String::from_utf8(include_bytes!("kcats/lexicon.kcats").to_vec()).unwrap();
      read_lexicon(lexicon, env)
  }

  pub fn invalid_type_error(asked: coll::List, actual: Item) -> ItemResult {
      Err(Error::type_mismatch(asked, Some(actual)))
  }

  fn number_type_error(i: Item) -> ItemResult {
      invalid_type_error(crate::types::wrap(Item::Word(*S_NUMBER)), i)
  }

  fn pair(i: Item, j: Item) -> Item {
      coll::List::from_iter([i, j]).into()
  }

  pub fn plus(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i + j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i + j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float + j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i + j as Float)),
          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn minus(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i - j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i - j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float - j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i - j as Float)),
          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn mult(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i * j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::Float(i * j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::Float(i as Float * j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::Float(i * j as Float)),
          (i, j) => number_type_error(pair(i, j)),
      }
  }

  fn divide(i: Float, j: Float) -> ItemResult {
      let q = i / j;
      if q.is_nan() {
          Err(Error::division_by_zero())
      } else {
          Ok(Item::Float(q))
      }
  }

  pub fn div(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => i
              .checked_div(j)
              .ok_or_else(|| Error::division_by_zero())
              .and_then(|i| Ok(Item::Int(i))),

          (Item::Float(i), Item::Float(j)) => divide(i, j),
          (Item::Int(i), Item::Float(j)) => divide(i as Float, j),
          (Item::Float(i), Item::Int(j)) => divide(i, j as Float),
          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn mod_(i: Item, j: Item) -> ItemResult {
      let i = Int::try_from(i)?;
      let j = Int::try_from(j)?;
      Ok(Item::Int(i % j))
  }

  pub fn inc(i: Item) -> ItemResult {
      Ok(Item::Int(Int::try_from(i)? + 1))
  }

  pub fn dec(i: Item) -> ItemResult {
      Ok(Item::Int(Int::try_from(i)? - 1))
  }

  pub fn is_zero(i: Item) -> ItemResult {
      match i {
          Item::Int(i) => Ok(Item::from(i == 0)),
          Item::Float(i) => Ok(Item::from(i == 0.0)),
          i => number_type_error(i),
      }
  }

  pub fn gt(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i > j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i > j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from(i as Float > j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i > j as Float)),

          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn lt(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i < j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i < j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from((i as Float) < j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i < j as Float)),

          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn gte(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i >= j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i >= j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from(i as Float >= j)),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i >= j as Float)),

          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn lte(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::from(i <= j)),
          (Item::Float(i), Item::Float(j)) => Ok(Item::from(i <= j)),
          (Item::Int(i), Item::Float(j)) => Ok(Item::from((i as Float).le(&j))),
          (Item::Float(i), Item::Int(j)) => Ok(Item::from(i <= j as Float)),

          (i, j) => number_type_error(pair(i, j)),
      }
  }

  pub fn join(i: Item, j: Item) -> ItemResult {
      let i = coll::Sized::try_from(i)?;
      let j = coll::Sized::try_from(j)?;
      Ok(i.join(j)?.into())
  }

  pub fn put(mut env: Environment) -> Future<Environment> {
      let j = env.pop();
      let i = env.pop();
      let i2 = i.clone();
      let pr = coll::Receptacle::try_from(i);
      match pr {
          Ok(p) => Box::pin(p.put(j).map(|f| match f {
              Ok(p) => env.push(Item::Receptacle(p)).into(),
              Err(e) => env.push(i2).push(e.into()).into(),
          })),
          Err(e) => env.push(i2).push(e.into()).into(),
      }
  }

  pub fn clone(env: Environment) -> Future<Environment> {
      let clone = env.stack.front().unwrap().clone();
      env.push(clone).into()
  }

  fn swap2(mut env: Environment, offset: usize) -> Future<Environment> {
      coll::Arc::make_mut(&mut env.stack).swap(offset, offset + 1);
      env.into()
  }

  pub fn swap(env: Environment) -> Future<Environment> {
      swap2(env, 0)
  }

  pub fn swapdown(env: Environment) -> Future<Environment> {
      swap2(env, 1)
  }

  pub fn sink(mut env: Environment) -> Future<Environment> {
      let s = coll::Arc::make_mut(&mut env.stack);
      s.swap(0, 2);
      s.swap(0, 1);
      env.into()
  }

  pub fn float(mut env: Environment) -> Future<Environment> {
      let s = coll::Arc::make_mut(&mut env.stack);
      s.swap(0, 2);
      s.swap(1, 2);
      env.into()
  }

  pub fn drop(mut env: Environment) -> Future<Environment> {
      env.pop();
      env.into()
  }

  pub fn eq(i: Item, j: Item) -> ItemResult {
      Ok(Item::from(i == j))
  }

  pub fn count(i: Item) -> ItemResult {
      match i {
          Item::Dispenser(coll::Dispenser::Sized(i)) => Ok(Item::Int(i.len() as Int)),
          Item::Receptacle(coll::Receptacle::Sized(i)) => Ok(Item::Int(i.len() as Int)),
          i => Err(Error::expected("sized", i)),
      }
  }

  pub fn is_string(i: Item) -> ItemResult {
      Ok(Item::from(matches!(
          i,
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(_)))
      )))
  }

  pub fn is_bytes(i: Item) -> ItemResult {
      Ok(Item::from(matches!(
          i,
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(_)))
      )))
  }

  pub fn is_error(i: Item) -> ItemResult {
      Ok(Item::from(matches!(
          i,
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::Error(_),
          )))
      )))
  }

  pub fn is_word(i: Item) -> ItemResult {
      Ok(Item::from(match i {
          Item::Word(_) => true,
          //Item::Iterable(Item(_)) => true,
          // TODO maybe also check if it's an associative that looks like a Def?
          _ => false,
      }))
  }

  pub fn is_pipe(i: Item) -> ItemResult {
      Ok(Item::from(match i {
          Item::Dispenser(coll::Dispenser::Out(_)) => true,
          Item::Dispenser(coll::Dispenser::Tunnel(_)) => true,
          Item::Receptacle(coll::Receptacle::In(_)) => true,
          Item::Receptacle(coll::Receptacle::Tunnel(_)) => true,
          _ => false,
      }))
  }
  pub fn is_number(i: Item) -> ItemResult {
      Ok(Item::from(matches!(i, Item::Int(_) | Item::Float(_))))
  }

  pub fn is_list(i: Item) -> ItemResult {
      Ok(Item::from(matches!(
          i,
          Item::Dispenser(coll::Dispenser::Sized(_))
      )))
  }

  pub fn first(i: Item) -> ItemResult {
      let l = coll::List::try_from(i)?;
      Ok(l.front().map(|i| i.clone()).unwrap_or_default())
  }

  pub fn second(i: Item) -> ItemResult {
      let l = coll::List::try_from(i)?;
      Ok(l.get(1).map(|i| i.clone()).unwrap_or_default())
  }

  pub fn last(i: Item) -> ItemResult {
      let l = coll::List::try_from(i)?;
      Ok(l.back().map(|i| i.clone()).unwrap_or_default())
  }

  pub fn loop_(mut env: Environment) -> Future<Environment> {
      let p = coll::List::try_from(env.pop());
      match p {
          Ok(mut p) => {
              let f = env.pop();
              if is_truthy(f) {
                  let p2 = p.clone();
                  let pm = coll::Arc::make_mut(&mut p);
                  pm.push_back(Item::from(p2));
                  pm.push_back("loop".into());
                  env.append_expression(p)
              } else {
                  env
              }
          }
          Err(e) => env.push(Item::from(e)),
      }
      .into()
  }

  pub fn execute(mut env: Environment) -> Future<Environment> {
      let i = env.pop();
      match coll::List::try_from(i) {
          Ok(program) => env.append_expression(program),
          Err(e) => env.push(e.into()),
      }
      .into()
  }

  pub fn wrap(mut env: Environment) -> Future<Environment> {
      let item = env.pop();
      env.push(coll::List::from_iter([item]).into()).into()
  }

  pub fn unwrap(mut env: Environment) -> Future<Environment> {
      //println!("unwrapping");
      match coll::List::try_from(env.pop()) {
          Ok(l) => {
              let len = l.len();
              let l2 = (0..len).map(move |i| l[i].clone());
              for i in l2 {
                  env = env.push(i);
              }
              env
          }
          Err(e) => env.push(e.into()),
      }
      .into()
  }

  pub fn dip(mut env: Environment) -> Future<Environment> {
      match coll::List::try_from(env.pop()) {
          Ok(program) => {
              let item = env.pop();
              let expr = env.expression.make_mut();
              expr.push_front("unwrap".into());
              expr.push_front(coll::List::from_iter([item]).into());
              env.append_expression(program)
          }
          Err(e) => env.push(e.into()),
      }
      .into()
  }

  pub fn dipdown(mut env: Environment) -> Future<Environment> {
      match coll::List::try_from(env.pop()) {
          Ok(program) => {
              let item1 = env.pop();
              let item2 = env.pop();
              let expr = env.expression.make_mut();
              expr.push_front("unwrap".into());
              expr.push_front(coll::List::from_iter([item2, item1]).into());
              env.append_expression(program)
          }
          Err(e) => env.push(e.into()),
      }
      .into()
  }

  pub fn take(mut env: Environment) -> Future<Environment> {
      // TODO: handle Nothing case
      let coll = {
          let stack = env.stack.make_mut();
          stack.pop_front()
      };
      match coll {
          Some(i) => {
              let i2 = i.clone();
              let r = coll::Dispenser::try_from(i);
              match r {
                  Ok(it) => {
                      let f = it.take();
                      Box::pin(async move {
                          let (c, i) = f.await;
                          let stack = env.stack.make_mut();
                          stack.push_front(c.into());
                          stack.push_front(i.unwrap_or_default());
                          env
                      })
                  }
                  Err(e) => {
                      let stack = env.stack.make_mut();
                      stack.push_front(i2);
                      stack.push_front(e.into());
                      env.into()
                  }
              }
          }
          None => {
              let stack = env.stack.make_mut();
              stack.push_front(Error::stack_underflow().into());
              env.into()
          }
      }
  }

  pub fn pop(mut env: Environment) -> Future<Environment> {
      let coll = {
          let stack = env.stack.make_mut();
          stack.pop_front()
      };
      match coll {
          Some(i) => {
              let i2 = i.clone();
              let r = coll::List::try_from(i);
              match r {
                  Ok(mut it) => {
                      let itm = it.make_mut();
                      let i = itm.pop_back();
                      let stack = env.stack.make_mut();
                      stack.push_front(it.into());
                      stack.push_front(i.unwrap_or_default());
                      env.into()
                  }
                  Err(e) => {
                      let stack = env.stack.make_mut();
                      stack.push_front(i2);
                      stack.push_front(e.into());
                      env.into()
                  }
              }
          }
          None => {
              let stack = env.stack.make_mut();
              stack.push_front(Error::stack_underflow().into());
              env.into()
          }
      }
  }

  fn is_truthy(i: Item) -> bool {
      coll::Sized::try_from(i).map_or(true, |s| !s.is_empty())
  }

  // fn boolean_value(b: bool) -> Item {
  //     if b {
  //         "true".into()
  //     } else {
  //         coll::NOTHING
  //     }
  // }

  pub fn branch(mut env: Environment) -> Future<Environment> {
      match (
          coll::List::try_from(env.pop()),
          coll::List::try_from(env.pop()),
      ) {
          (Ok(false_branch), Ok(true_branch)) => {
              let b = env.pop();

              env.append_expression(if is_truthy(b) {
                  true_branch
              } else {
                  false_branch
              })
          }
          (Err(e), _) => env.push(e.into()),
          (_, Err(e)) => env.push(e.into()),
      }
      .into()
  }

  pub fn step(mut env: Environment) -> Future<Environment> {
      let p = coll::List::try_from(env.pop()).unwrap();
      let it = coll::Dispenser::try_from(env.pop()).unwrap();
      Box::pin(async move {
          if let (it, Some(litem)) = it.take().await {
              let expr = env.expression.make_mut();
              // prepare the next iteration, even if the iterator is now
              // empty
              expr.push_front("step".into());
              expr.push_front(p.clone().into());
              expr.push_front(it.into());
              expr.push_front("execute".into());

              env.push(litem).push(p.into()).into()
          } else {
              env.into()
          }
      })
  }

  pub fn range(mut env: Environment) -> Future<Environment> {
      let stepby = Int::try_from(env.pop()).unwrap();
      let to = Int::try_from(env.pop()).unwrap();
      let from = Int::try_from(env.pop()).unwrap();
      env.push(
          coll::List::from_iter((from..to).step_by(stepby as usize).map(|i| Item::Int(i))).into(),
      )
      .into()
  }

  // (effect [rec2 rec1 then pred]
  //                   ['[if]
  //[(concat rec1
  //         [[pred then rec1 rec2 'recur]] rec2)
  // then pred]])

  pub fn recur(mut env: Environment) -> Future<Environment> {
      let mut rec2 = coll::List::try_from(env.pop()).unwrap();
      let mut rec1 = coll::List::try_from(env.pop()).unwrap();
      let then = coll::List::try_from(env.pop()).unwrap();
      let pred = coll::List::try_from(env.pop()).unwrap();
      env = env.push_expr("if".into());
      let r = coll::List::from_iter([
          Item::from(pred.clone()),
          then.clone().into(),
          rec1.clone().into(),
          rec2.clone().into(),
          "recur".into(),
      ])
      .into();
      // I think i did this right - used to create a new list and extend
      // it with rec1, then push r, then extend again with rec2. now
      // start with rec1 (copied on write), then push r, then extend
      // with rec2.  That should be equivalent.
      let rm = rec1.make_mut();
      rm.push_back(r);
      rm.extend(rec2.make_mut().drain(..));

      env.push(pred.into())
          .push(then.into())
          .push(rec1.into())
          .into()
  }

  //(fn [{[l & others] 'stack :as env}]
  //            (assoc env 'stack (apply list (vec others) l)))

  pub fn evert(mut env: Environment) -> Future<Environment> {
      let mut l = coll::List::try_from(env.pop()).unwrap();
      mem::swap(&mut env.stack, &mut l);
      env.push(l.into()).into()
  }

  fn assoc_in(i: Item, ks: &[assoc::KeyItem], v: Item) -> Result<Item, Error> {
      if let [k, ks @ ..] = ks {
          if ks.is_empty() {
              match (i, k) {
                  (
                      Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))),
                      assoc::KeyItem::Int(k),
                  ) => {
                      // vector set by index
                      let lm = coll::Arc::make_mut(&mut l);
                      let idx = *k as usize;
                      // extend the size of the vector to be big enough to set
                      // the given index, pad with 'nothing' values.
                      if lm.len() <= idx {
                          lm.resize(idx + 1, coll::NOTHING);
                      }
                      lm[*k as usize] = v;
                      Ok(l.into())
                  }
                  (i, k) => {
                      //println!("assoc_in: {:?} {:?}", i, k);
                      let a = assoc::Associative::try_from(i)?;
                      Ok(a.insert(k.clone(), v).0.into())
                  }
              }
              //hm.insert(k.clone(), v);
          } else {
              match (i, k) {
                  (
                      Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))),
                      assoc::KeyItem::Int(k),
                  ) => {
                      let lm = coll::Arc::make_mut(&mut l);
                      let idx = *k as usize;
                      // extend the size of the vector to be big enough to set
                      // the given index, pad with 'nothing' values.
                      if lm.len() <= idx {
                          lm.resize(idx + 1, coll::NOTHING);
                      }
                      let inner = &lm[idx];

                      lm[*k as usize] = if let [nextk, ..] = ks {
                          let i: Item = match (inner, nextk) {
                              (
                                  Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(l))),
                                  assoc::KeyItem::Int(_),
                              ) => l.clone().into(),
                              (_, assoc::KeyItem::Int(_)) => coll::List::new().into(),
                              _ => assoc::Association::new().into(),
                          };
                          assoc_in(i, ks, v)?
                      } else {
                          v
                      };

                      //if the inner value isn't a list, overwrite it
                      Ok(l.into())
                  }
                  (i, k) => {
                      //println!("assoc_in morekeys: {:?} {:?}", i, k);
                      let a = assoc::Associative::try_from(i)?;
                      let inner = a.get(&k).unwrap_or_default().clone();
                      // if the inner value isn't a map, we're just overwriting whatever it
                      // is with a new map.

                      let i = match inner {
                          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(a))) => {
                              a.clone().into()
                          }
                          _ => assoc::Association::new().into(),
                      };
                      Ok(a.insert(k.clone(), assoc_in(i, ks, v)?).0.into())
                  }
              }
          }
      } else {
          Ok(i)
      }
  }

  fn unassoc_in(i: Item, ks: &[assoc::KeyItem]) -> Result<Item, Error> {
      if let [k, ks @ ..] = ks {
          if ks.is_empty() {
              let a = assoc::Associative::try_from(i)?;
              Ok(a.remove(&k).0.into())
          } else {
              match (i, k) {
                  (
                      Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(mut l))),
                      assoc::KeyItem::Int(k),
                  ) => {
                      let lm = l.make_mut();
                      let old_value = if let Some(item) = lm.get_mut(*k as usize) {
                          mem::replace(item, coll::NOTHING)
                      } else {
                          return Err(Error::short_list(k.clone())); // replace with your error
                      };
                      let new_value = unassoc_in(old_value, ks)?;
                      lm[*k as usize] = new_value;
                      Ok(l.into())
                  }
                  (a, k) => {
                      let a: assoc::Associative = a.try_into()?;
                      let mut a: assoc::Association = a.into_iter().collect();
                      let am = a.make_mut();
                      let mut res: Option<Result<_, Error>> = None;
                      am.entry(k.clone()).and_modify(|v| {
                          let new_value = unassoc_in(v.clone(), ks);
                          res = Some(new_value.map(|nv| {
                              ,*v = nv;
                          }));
                      });
                      if let Some(Err(e)) = res {
                          return Err(e);
                      }
                      Ok(a.into())
                  }
              }
          }
      } else {
          Ok(i)
      }
  }

  pub fn assign(m: Item, ks: Item, v: Item) -> ItemResult {
      let mut kit = coll::List::try_from(ks)?;
      let mut ksvec: assoc::KeyList = assoc::KeyList::try_from_iter(kit.inner().into_iter())?;
      ksvec.make_mut().make_contiguous();
      let (ks, _) = ksvec.as_slices();
      assoc_in(m, ks, v)
  }

  pub fn unassign(m: Item, ks: Item) -> ItemResult {
      let mut kit = coll::List::try_from(ks)?;
      let mut ksvec: assoc::KeyList = assoc::KeyList::try_from_iter(kit.inner().into_iter())?;
      ksvec.make_mut().make_contiguous();
      let (ks, _) = ksvec.as_slices();
      unassoc_in(m, ks)
  }

  pub fn association(m: Item) -> ItemResult {
      match assoc::Associative::try_from(m) {
          Ok(m) => Ok(m.into()),
          Err(e) => Err(e),
      }
  }

  pub fn lookup(i: Item, k: Item) -> ItemResult {
      //println!("lookup {:?} \n {:?}", m, k);
      let k = assoc::KeyItem::try_from(k)?;
      match (i, k) {
          (Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(l))), assoc::KeyItem::Int(k)) => {
              Ok(l.get(k as usize)
                  .and_then(|x| Some(x.clone()))
                  .unwrap_or_default())
          }
          (i, k) => {
              let m = assoc::Associative::try_from(i)?;
              Ok(m.get(&k).unwrap_or_default())
          }
      }
  }

  pub fn contains(c: Item, i: Item) -> ItemResult {
      let s = coll::Sized::try_from(c)?;
      Ok(s.contains(&i).into())
  }

  pub fn or(i: Item, j: Item) -> ItemResult {
      Ok(if is_truthy(i.clone()) {
          i
      } else {
          if is_truthy(j.clone()) {
              j
          } else {
              coll::NOTHING
          }
      })
      //Ok(Item::from(is_truthy(i) || is_truthy(j)))
  }

  pub fn and(i: Item, j: Item) -> ItemResult {
      Ok(if is_truthy(i) && is_truthy(j.clone()) {
          j
      } else {
          coll::NOTHING
      })
  }

  pub fn not(i: Item) -> ItemResult {
      Ok(Item::from(!is_truthy(i)))
  }

  pub fn is_association(i: Item) -> ItemResult {
      Ok(coll::Sized::try_from(i)
          .map(|s| matches!(s, coll::Sized::Associative(_) | coll::Sized::Nothing))
          .unwrap_or(false)
          .into())
  }

  pub fn is_set(i: Item) -> ItemResult {
      Ok(coll::Sized::try_from(i)
          .map(|s| matches!(s, coll::Sized::Set(_) | coll::Sized::Nothing))
          .unwrap_or(false)
          .into())
  }

  pub fn is_odd(i: Item) -> ItemResult {
      let i = Int::try_from(i)?;
      Ok(Item::from(i & 1 == 1))
  }

  pub fn is_even(i: Item) -> ItemResult {
      let i = Int::try_from(i)?;
      Ok(Item::from(i & 1 == 0))
  }

  pub fn decide(mut env: Environment) -> Future<Environment> {
      let mut clauses = coll::List::try_from(env.pop()).unwrap();
      let clauses_data = coll::Arc::make_mut(&mut clauses);
      let clause = clauses_data.pop_front();

      if let Some(clause) = clause {
          let clause: Result<coll::List, Error> = clause.try_into();
          match clause {
              Ok(mut clause) => {
                  if clause.len() != 2 {
                      env.push(Error::list_count(2).into()).into()
                  } else {
                      let clause_data = clause.make_mut();
                      let test: Result<coll::List, Error> = clause_data
                          .pop_front()
                          .ok_or(Error::list_count(2))
                          .and_then(|i| i.try_into());
                      let expr: Result<coll::List, Error> = clause_data
                          .pop_front()
                          .ok_or(Error::list_count(2))
                          .and_then(|i| i.try_into());

                      match (test, expr) {
                          (Ok(test), Ok(expr)) => {
                              // construct if
                              let testp = coll::List::from_iter([Item::from(test), "shield".into()]);
                              let elsep =
                                  coll::List::from_iter([Item::from(clauses), "decide".into()]);
                              let newexpr = coll::List::from_iter([
                                  Item::from(testp),
                                  expr.into(),
                                  elsep.into(),
                                  "if".into(),
                              ]);
                              env.append_expression(newexpr).into()
                          }
                          (Err(test), _) => env.push(test.into()).into(),
                          (_, Err(expr)) => env.push(expr.into()).into(),
                      }
                  }
              }
              Err(e) => env.push(e.into()).into(),
          }
      } else {
          // clauses empty, return nothing
          env.push(coll::NOTHING).into()
      }
  }

  pub fn read(mut env: Environment) -> Future<Environment> {
      let s = String::try_from(env.pop()).unwrap();
      let parsed = serialize::parse(s);
      env.push(match parsed {
          Ok(l) => l.into(),
          Err(e) => e.into(),
      })
      .into()
  }

  pub fn emit(i: Item) -> ItemResult {
      Ok(Item::Dispenser(coll::Dispenser::Sized(
          coll::Sized::String(serialize::emit(&i)),
      )))
  }

  fn check_type(i: &Item, w: Word) -> Result<(), Error> {
      match (w, i) {
          (w, _) if w == *S_ITEM => Ok(()),
          (w, Item::Dispenser(_) | Item::Receptacle(_)) if w == *S_DISPENSER => Ok(()),
          (w, Item::Int(_)) if w == *S_INTEGER || w == *S_NUMBER => Ok(()),
          (w, Item::Float(_)) if w == *S_FLOAT || w == *S_NUMBER => Ok(()),
          // TODO: also handle cases where bytes/string is a list
          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(_))),
          ) if w == *S_BYTES || w == *S_ORDERED => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(_))),
          ) if w == *S_STRING => Ok(()),
          (w, Item::Word(_)) if w == *S_WORD => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Out(_))
              | Item::Dispenser(coll::Dispenser::Tunnel(_))
              | Item::Receptacle(coll::Receptacle::Tunnel(_))
              | Item::Receptacle(coll::Receptacle::In(_)),
          ) if w == *S_PIPE => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::List(_)))
              | Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Nothing))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Nothing)),
          ) if w == *S_LIST || w == *S_PROGRAM => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(_)))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(_))),
          ) if w == *S_ASSOC => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                  assoc::Associative::Error(_),
              )))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(
                  assoc::Associative::Error(_),
              ))),
          ) if w == *S_ERROR => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(_))
              | Item::Receptacle(coll::Receptacle::Sized(_)),
          ) if w == *S_SIZED || w == *S_ORDERED => Ok(()),

          (
              w,
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                  assoc::Associative::Env(_),
              )))
              | Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(
                  assoc::Associative::Env(_),
              ))),
          ) if w == *S_ENVIRONMENT => Ok(()),
          (w, i) => {
              println!("Type check failed! wanted {} got {:?}", w, i);
              Err(Error::expected(&w, i.clone()))
          }
      }
  }

  fn check_stack_depth(env: &Environment, min_depth: usize) -> Result<(), Error> {
      //println!("Checking stack has at least {} items", min_depth);
      if env.stack.len() < min_depth {
          Err(Error::stack_underflow())
      } else {
          Ok(())
      }
  }

  fn check_input_spec(spec: &coll::List, env: &Environment) -> Result<(), Error> {
      let specs: coll::List = spec
          .front()
          .ok_or(Error::expected("specs", Default::default()))
          .and_then(|i| i.clone().try_into())?;

      check_stack_depth(env, specs.len())?;
      let indexes = Range {
          start: 0,
          end: specs.len(),
      };

      indexes
          .into_iter()
          .map(|i| {
              let item = env.stack.get(i).unwrap();
              let spec = specs.get(i).unwrap();

              match spec {
                  Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(named))) => {
                      match named.get(0).unwrap() {
                          Item::Word(w) => check_type(item, *w),
                          i => {
                              println!("Expected word, got {:?}", i);
                              Err(Error::expected("list", i.clone()))
                          }
                      }
                  }
                  Item::Word(w) => check_type(item, *w),
                  // the type might happen to also be a defined
                  // word, like 'association'
                  i => Err(Error::expected("list", i.clone())),
              }
          })
          .collect::<Result<(), Error>>()
  }

  pub fn eval_step(mut env: Environment) -> Future<Environment> {
      //println!("{:?}", env);
      let next_item = env.expression.front();

      if let Some(val) = next_item {
          match val {
              Item::Word(word) => {
                  if let Some(dfn) = env.dictionary.get(word) {
                      {
                          if let Some(spec) = &dfn.spec {
                              if let Err(e) = check_input_spec(&spec, &env) {
                                  env = env.push(e.into());
                                  return env.into();
                              }
                          } else {
                              println!("No spec for {}!", word);
                          }
                          let expr = coll::Arc::make_mut(&mut env.expression);
                          expr.pop_front();

                          match &dfn.definition {
                              dict::Definition::Axiom(a) => {
                                  // we can't keep borrowing the env, so we
                                  // clone the axiom def to release it and then
                                  // we can pass the env to the axiom def fn
                                  let f = a.clone();
                                  (f)(env)
                              }
                              dict::Definition::Derived(d) => {
                                  let items = d.clone();
                                  env.append_expression(items).into()
                              }
                          }
                      }
                  } else {
                      let w = *word;
                      env.push(Error::undefined(w).into()).into()
                  }
              }
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
                  assoc::Associative::DictEntry(entry),
              ))) => {
                  if let Some(spec) = &entry.spec {
                      if let Err(e) = check_input_spec(&spec, &env) {
                          env = env.push(e.into());
                          return env.into();
                      }
                  }
                  let expr = coll::Arc::make_mut(&mut env.expression);
                  let e: dict::Entry = expr.pop_front().unwrap().try_into().unwrap();

                  match e.definition {
                      dict::Definition::Axiom(builtin) => {
                          //let b = dict::Axiom::try_from(env.pop_expr()).unwrap();
                          (builtin)(env)
                      }
                      dict::Definition::Derived(d) => {
                          let d = d.clone();
                          env.append_expression(d).into()
                      }
                  }
              }
              _ => {
                  // not a word, just push onto stack
                  let i = env.pop_expr();
                  env.push(i).into()
              }
          }
      } else {
          env.push(Error::short_list(1).into()).into()
      }
  }

  fn reverse(i: Item) -> ItemResult {
      let mut l = coll::List::try_from(i).unwrap();
      Ok(coll::List::from_iter(l.inner().into_iter().rev()).into())
  }

  fn bytes(i: Item) -> ItemResult {
      match i {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::String(s))) => {
              Ok(s.as_bytes().to_vec().into())
          }
          Item::Receptacle(coll::Receptacle::Sized(coll::Sized::String(s))) => {
              Ok(s.as_bytes().to_vec().into())
          }
          i => Ok(Bytes::from(serialize::emit(&i)).into()),
      }
  }

  fn string(i: Item) -> ItemResult {
      match i {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(b))) => {
              Ok(Item::Dispenser(coll::Dispenser::Sized(
                  coll::Sized::String(std::str::from_utf8(&b).unwrap().to_string()),
              )))
          }
          Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(b))) => {
              Ok(Item::Receptacle(coll::Receptacle::Sized(
                  coll::Sized::String(std::str::from_utf8(&b).unwrap().to_string()),
              )))
          }
          i => Ok(Item::Dispenser(coll::Dispenser::Sized(
              coll::Sized::String(serialize::emit(&i)),
          ))),
      }
  }

  fn get_error(env: &Environment) -> Option<Error> {
      env.stack.front().and_then(|i| match i {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::Error(e),
          ))) => Some(e.clone()),
          Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Associative(
              assoc::Associative::Error(e),
          ))) => Some(e.clone()),
          _ => None,
      })
  }

  fn unwind(mut env: Environment) -> Environment {
      let err = env.pop();
      let w: &Item = &"handle".into();

      let err = match err {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::Error(mut e),
          ))) => {
              let mut next = env.expression.front();
              let mut unwound = Vec::<Item>::new();
              while next.is_some() && next.unwrap() != w {
                  let i = env.pop_expr();
                  unwound.push(i);
                  next = env.expression.front();
              }
              if next.is_some() {
                  env.pop_expr();
              }
              // set the is_handled bit
              e.is_handled = true;
              let em = coll::Arc::make_mut(&mut e.data);
              em.insert("unwound".into(), coll::List::from_iter(unwound).into());
              e.into()
          }
          i => i,
      };
      env = env.push(err);
      return env;
  }

  pub async fn eval(mut env: Environment) -> Environment {
      loop {
          if let Some(err) = get_error(&env) {
              if !err.is_handled {
                  env = unwind(env); // TODO: this should be done in eval_step
              };
          }
          if !env.expression.is_empty() {
              env = eval_step(env).await;
          } else {
              break;
          }
      }
      env
  }

  pub fn standard_env(program: Option<coll::List>, stack: Option<coll::List>) -> Environment {
      let prog_expr = match program {
          Some(p) => Stack::from(p),
          _ => Stack::new(),
      };

      let env = Environment {
          stack: stack.unwrap_or(Stack::new()),
          expression: prog_expr,
          dictionary: coll::Arc::wrap(HashMap::<Word, dict::Entry>::new()),
      };
      add_standard_dictionary(env)
  }

  fn environment(p: Item) -> ItemResult {
      Environment::try_from(p).map(|e| e.into())
  }

  pub fn eval_step_outer(mut env: Environment) -> Future<Environment> {
      let tos = env.pop();
      let inner_env = Environment::try_from(tos);
      match inner_env {
          Ok(inner) => Box::pin(eval_step(inner).map(|inner_next| env.push(inner_next.into()))),
          Err(e) => env.push(e.into()).into(),
      }
  }

  pub fn evaluate(mut env: Environment) -> Future<Environment> {
      let tos = env.pop();
      let inner_env = Environment::try_from(tos);
      match inner_env {
          Ok(inner) => Box::pin(eval(inner).map(|inner_done| env.push(inner_done.into()))),
          Err(e) => env.push(e.into()).into(),
      }
  }

  pub fn identity(env: Environment) -> Future<Environment> {
      env.into()
  }

  pub fn dictionary(env: Environment) -> Future<Environment> {
      let d = env.dictionary.clone();
      env.push(d.into()).into()
  }

  fn ceil(i: Item) -> ItemResult {
      let f = Float::try_from(i)?;
      Ok(Item::Float(f.ceil()))
  }

  fn sqrt(i: Item) -> ItemResult {
      match i {
          Item::Int(i) => Ok(Item::Int(i.sqrt())),
          Item::Float(f) => Ok(Item::Float(f.sqrt())),
          i => number_type_error(i),
      }
  }

  fn abs(i: Item) -> ItemResult {
      match i {
          Item::Int(i) => Ok(Item::Int(i.abs())),
          Item::Float(f) => Ok(Item::Float(f.abs())),
          i => number_type_error(i),
      }
  }

  fn handle(i: Item) -> ItemResult {
      match i {
          Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Associative(
              assoc::Associative::Error(mut e),
          ))) => Ok({
              e.is_handled = true;
              e.into()
          }),
          i => Ok(i),
      }
  }

  // fn inscription(env: &mut Environment) -> Result<(Word, dict::Entry), Error> {
  //     let d = env.pop();
  //     let mut wl = coll::List::try_from(env.pop())?;
  //     let w1 = coll::Arc::make_mut(&mut wl).pop_front();
  //     let x = w1.ok_or(Error::short_list(1))?;
  //     let w = Word::try_from(x.clone())?;
  //     Ok((w, dict::Entry::try_from(d)?))
  // }

  // pub fn inscribe(mut env: Environment) -> Environment {
  //     let r = inscription(&mut env);
  //     match r {
  //         Ok((w, def)) => {
  //             let d = coll::Arc::make_mut(&mut env.dictionary);
  //             d.insert(assoc::KeyItem::Word(w), Item::Entry(def));
  //             env
  //         }
  //         Err(e) => env.push(e.into()),
  //     }
  // }

  // make 'true' a word that doesn't have to be quoted, just pushes
  // itself onto the stack.
  pub fn true_(env: Environment) -> Future<Environment> {
      env.push("true".into()).into()
  }

  pub fn fail(e: Item) -> ItemResult {
      let mut e: Error = e.try_into().unwrap();
      e.is_handled = false;
      Err(e)
  }

  // fn normalize_dictionary(mut d: dict::Dictionary) -> Result<dict::Dictionary, Error> {
  //     let dm = coll::Arc::make_mut(&mut d);
  //     for (k, v) in dm.iter_mut() {
  //         match v {
  //             Item::Assoc(a) => {
  //                 let aa = a.clone();
  //                 let (aa, _) = aa.insert("word".into(), Item::try_from(k.clone()).unwrap());
  //                 *v = Item::Entry(aa.try_into()?)
  //             }
  //             Item::List(l) => {
  //                 let a: assoc::Associative = l.clone().try_into()?;
  //                 let (a, _) = a.insert("word".into(), Item::try_from(k.clone()).unwrap());
  //                 *v = Item::Entry(a.try_into()?)
  //             }
  //             Item::Entry(_) => {}
  //             _ => {
  //                 return Err(Error::expected("dictionary"));
  //             }
  //         }
  //     }
  //     Ok(d)
  // }

  pub fn redefine(mut env: Environment) -> Future<Environment> {
      let d = dict::Dictionary::try_from(env.pop());
      match d {
          Ok(d) => {
              env.dictionary = d;
              env
          }
          Err(e) => {
              env = env.push(e.into());
              env
          }
      }
      .into()
  }

  // Takes an inner environment from the top of the stack, and spawns a
  // tokio task to evaluate that environment.
  pub fn animate(mut env: Environment) -> Future<Environment> {
      let tos = env.pop();
      let inner_env = Environment::try_from(tos);
      println!("Animating: {:?}", inner_env);
      match inner_env {
          Ok(inner) => {
              tokio::spawn(async move { eval(inner).await });
              env.into()
          }
          Err(e) => env.push(e.into()).into(),
      }
  }
  fn xor_(i: Bytes, j: Bytes) -> Bytes {
      let len = std::cmp::max(i.len(), j.len());
      let mut result = Vec::with_capacity(len);
      for (byte_i, byte_j) in i
          .iter()
          .chain(std::iter::repeat(&0).take(len - i.len()))
          .zip(j.iter().chain(std::iter::repeat(&0).take(len - j.len())))
      {
          result.push(byte_i ^ byte_j);
      }
      result
  }
  pub fn xor(i: Item, j: Item) -> ItemResult {
      match (i, j) {
          (Item::Int(i), Item::Int(j)) => Ok(Item::Int(i ^ j)),
          (
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(i))),
              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Bytes(j))),
          ) => Ok(xor_(i, j).into()),
          (
              Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(i))),
              Item::Receptacle(coll::Receptacle::Sized(coll::Sized::Bytes(j))),
          ) => Ok(xor_(i, j).into()),
          (i, j) => Err(Error::expected("integers", pair(i, j))),
      }
  }

  pub fn inspect(i: Item) -> ItemResult {
      let s = format!("{:?}", i);
      Ok(Item::Dispenser(coll::Dispenser::Sized(
          coll::Sized::String(s),
      )))
  }

  pub fn timestamps(env: Environment) -> Future<Environment> {
      env.push(Item::Dispenser(coll::Dispenser::Out(pipes::Out::Time)))
          .into()
  }

  pub fn standard(env: Environment) -> Future<Environment> {
      env.push(Item::Dispenser(coll::Dispenser::Tunnel(
          pipes::Tunnel::Standard,
      )))
      .into()
  }

  pub fn set(i: Item) -> ItemResult {
      coll::Set::try_from(i).map(|s| Item::Dispenser(coll::Dispenser::Sized(coll::Sized::Set(s))))
  }

  pub fn compare(i: Item, j: Item) -> ItemResult {
      let ki = assoc::KeyItem::try_from(i)?;
      let kj = assoc::KeyItem::try_from(j)?;
      match ki.partial_cmp(&kj) {
          Some(std::cmp::Ordering::Less) => Ok("less".into()),
          Some(std::cmp::Ordering::Equal) => Ok("equal".into()),
          Some(std::cmp::Ordering::Greater) => Ok("greater".into()),
          None => Err(Error::expected("comparable", pair(ki.into(), kj.into()))),
      }
  }

  fn as_pair(i: Item) -> Result<(Item, assoc::KeyItem), Error> {
      let mut i = coll::List::try_from(i)?;
      let im = i.make_mut();
      let j = im.pop_front().ok_or(Error::short_list(1))?;
      let k = im
          .pop_front()
          .ok_or(Error::short_list(2))
          .and_then(assoc::KeyItem::try_from)?;
      Ok((j, k))
  }

  pub fn sort_by_key(i: Item) -> ItemResult {
      let mut l = coll::List::try_from(i)?;
      let it = l.inner().into_iter().map(as_pair);
      let mut it = it.collect::<Result<Vec<(Item, assoc::KeyItem)>, Error>>()?;
      it.sort_unstable_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less));
      Ok(coll::List::from_iter(it.into_iter().map(|(k, _)| k)).into())
  }
#+end_src
** Top level execution
We'll define the main module which reads input for the kcats
interpreter process, and prints output.

We'll also define how to run unit tests.
#+begin_src rust :tangle src/main.rs
  ''mod axiom;
  mod crypto;
  mod pipes;
  mod serialize;
  mod types;

  use crate::types::{environment::Environment, error, *};
  use std::io;
  use std::io::{BufRead, Read};
  use std::sync::Arc;
  use tokio;

  fn print_result(env: Environment) {
      if env.expression.is_empty() {
          println!("{}", serialize::emit_all(&env.stack));
      } else {
          println!(
              "stack: {}\nexpression: {}",
              serialize::emit(&Item::from(env.stack)),
              serialize::emit(&Item::from(env.expression))
          )
      }
  }

  fn get_stdin() -> String {
      let mut buf = String::new();
      for line in io::stdin().lock().lines() {
          buf.push_str(&line.unwrap());
          buf.push('\n');
      }
      buf
  }

  // A function that takes a handle to stdin. It reads a length from
  // stdin, then reads that many bytes and returns a string.
  async fn read_input() -> Option<String> {
      //spawn a thread to read from stdin
      //println!("Reading input");
      tokio::spawn(async move {
          let mut stdin = io::stdin().lock();
          let mut buf = String::new();
          if let Err(e) = stdin.read_line(&mut buf) {
              println!("Error reading content length {:?}", e);
              return None;
          }
          // parse an integer from buf
          let read_len = buf.trim();
          //println!("Read length {}", read_len);
          let len = read_len.parse::<usize>().unwrap_or(0 as usize);
          if len == 0 {
              return None;
          }
          // read len bytes from stdin
          let mut buf = vec![0; len];
          stdin.read_exact(&mut buf).unwrap();

          // convert the bytes to a string
          Some(String::from_utf8(buf).unwrap())
      })
      .await
      .unwrap()
  }

  async fn print(env: &Environment) {
      let result = serialize::emit_all(&env.stack);
      // first print the length of the result
      println!("{}\n{}", result.len(), result);
  }

  // a function that takes an env, and an input string. Parses the
  // string, if it parses, returns the env with the input added to the
  // expression. Otherwise returns Error.
  fn parse_input(mut env: Environment, input: String) -> Result<Environment, error::Error> {
      let mut parsed = serialize::parse(input)?;
      let expr = Arc::make_mut(&mut env.expression);
      expr.extend(Arc::make_mut(&mut parsed).drain(..));
      Ok(env)
  }

  //It converts the bytes to a
  // string, and then evaluates that string as a kcats program. It then
  // prints the length of the result, and then the result itself.
  async fn interactive_mode() {
      let mut env = axiom::standard_env(None, None);

      loop {
          if let Some(program) = read_input().await {
              if let Ok(parsed_env) = parse_input(env, program) {
                  //env = parsed_env;
                  env = axiom::eval(parsed_env).await;
                  print(&env).await;
              } else {
                  println!("Could not parse input");
                  break;
              }
          } else {
              //println!("Blank input received, exiting");
              continue;
          }
      }
  }

  #[tokio::main]
  async fn main() {
      // read command line options, to look for -i switch
      let args: Vec<String> = std::env::args().collect();
      // if args contains "-i", read via handle_stdin
      if args.contains(&"-i".to_string()) {
          interactive_mode().await;
      } else {
          // otherwise, read from stdin
          match parse_input(axiom::standard_env(None, None), get_stdin()) {
              Ok(env) => {
                  print_result(axiom::eval(env).await);
              }
              Err(e) => {
                  println!("Error parsing input: {:?}", e);
              }
          }
      }
  }

  #[cfg(test)]
  mod tests {
      // Note this useful idiom: importing names from outer (for mod tests) scope.
      use super::error::Error;
      use super::*;
      use crate::types::collection as coll;
      use internment::Intern;
      use std::borrow::Borrow;
      use test_case::test_case;
      use tokio;

      pub fn get_item(i: Item, index: usize) -> Option<Item> {
          coll::List::try_from(i)
              .ok()
              .and_then(|l| match l.get(index) {
                  Some(x) => Some(x.clone()),
                  None => None,
              })
      }

      #[tokio::main]
      async fn test_example(
          mut prog_env: Environment,
          program: coll::List,
          expected: coll::List,
      ) -> Option<Error> {
          let mut exp_env = prog_env.clone();
          prog_env = prog_env.append_expression(program.clone());
          exp_env = exp_env.append_expression(expected.clone());

          let p_fut = tokio::spawn(async move { axiom::eval(prog_env).await });

          let exp_fut = tokio::spawn(async move { axiom::eval(exp_env).await });
          let (prog_env, exp_env) = tokio::join!(p_fut, exp_fut);
          let prog_env = prog_env.unwrap();
          let exp_env = exp_env.unwrap();

          if prog_env.stack == exp_env.stack {
              println!(
                  "Nice expected {} got {}",
                  serialize::emit_all(exp_env.stack.borrow()),
                  serialize::emit_all(prog_env.stack.borrow())
              );
              None
          } else {
              println!(
                  "uh oh expected {} got {}",
                  serialize::emit_all(exp_env.stack.borrow()),
                  serialize::emit_all(prog_env.stack.borrow())
              );
              // println!(
              //     "Debug: expected {:?} got {:?}",
              //     exp_env.stack, prog_env.stack
              // );
              Some(Error::test_assertion(program, expected, prog_env.stack))
          }
      }

      fn test_word(standard_env: Environment, w: Word) -> Vec<Error> {
          if let Some(d) = standard_env.dictionary.get(&w) {
              d.examples
                  .clone()
                  .unwrap()
                  .iter()
                  .filter_map(|ex| {
                      match (
                          get_item(ex.clone(), 0).unwrap(),
                          get_item(ex.clone(), 1).unwrap(),
                      ) {
                          (
                              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(p))),
                              Item::Dispenser(coll::Dispenser::Sized(coll::Sized::List(exp))),
                          ) => test_example(standard_env.clone(), p.clone(), exp.clone()),
                          (i, _) => Some(Error::expected("list", i.into())),
                      }
                  })
                  .collect::<Vec<Error>>()
          } else {
              println!("Empty!");
              Vec::new()
          }
      }

      #[test_case("+" ; "plus")]
      #[test_case("-" ; "minus")]
      #[test_case("=" ; "eq")]
      #[test_case(">" ; "gt")]
      #[test_case(">=" ; "gte")]
      #[test_case("<" ; "lt")]
      #[test_case("<=" ; "lte")]
      #[test_case("*" ; "mult")]
      #[test_case("/" ; "divide")]
      #[test_case("abs")]
      #[test_case("and")]
      #[test_case("any?" ; "is_any")]
      #[test_case("assign")]
      #[test_case("association")]
      #[test_case("association?" ; "is_association")]
      #[test_case("bail")]
      #[test_case("both?" ; "is_both")]
      #[test_case("branch")]
      #[test_case("breaker")]
      #[test_case("bytes")]
      #[test_case("bytes?" ; "is_bytes")]
      #[test_case("ceil")]
      #[test_case("clone")]
      #[test_case("collect")]
      #[test_case("compare")]
      #[test_case("contains?" ; "contains")]
      #[test_case("count")]
      #[test_case("dec")]
      #[test_case("decide")]
      #[test_case("decorate")]
      #[test_case("decorated")]
      #[test_case("dip")]
      #[test_case("dipdown")]
      #[test_case("drop")]
      #[test_case("dropper")]
      #[test_case("each")]
      #[test_case("emit")]
      #[test_case("environment")]
      #[test_case("evaluate")]
      #[test_case("eval_step")]
      #[test_case("even?" ; "is_even")]
      #[test_case("evert")]
      #[test_case("every?" ; "is_every")]
      #[test_case("execute")]
      #[test_case("filter")]
      #[test_case("first")]
      #[test_case("float")]
      #[test_case("functional")]
      #[test_case("future")]
      #[test_case("generate")]
      #[test_case("if")]
      #[test_case("inc")]
      #[test_case("inject")]
      #[test_case("inscribe")]
      #[test_case("join")]
      #[test_case("joiner")]
      #[test_case("keep")]
      #[test_case("let")]
      #[test_case("lingo")]
      #[test_case("list?" ; "is_list")]
      #[test_case("lookup")]
      #[test_case("loop")]
      #[test_case("map")]
      #[test_case("max")]
      #[test_case("min")]
      #[test_case("mod")]
      #[test_case("not")]
      #[test_case("nothing?" ; "is_nothing")]
      #[test_case("number?" ; "is_number")]
      #[test_case("odd?" ; "is_odd")]
      #[test_case("or")]
      #[test_case("pop")]
      #[test_case("put")]
      #[test_case("prepend")]
      #[test_case("primrec")]
      #[test_case("range")]
      #[test_case("reduce")]
      #[test_case("recover")]
      #[test_case("recur")]
      #[test_case("rest")]
      #[test_case("retry")]
      #[test_case("reverse")]
      #[test_case("set")]
      #[test_case("set?" ; "is_set")]
      #[test_case("shield")]
      #[test_case("shielddown")]
      #[test_case("shielddowndown")]
      #[test_case("sink")]
      #[test_case("snapshot")]
      #[test_case("something?" ; "is_something")]
      #[test_case("sqrt")]
      #[test_case("step")]
      #[test_case("string")]
      #[test_case("string?" ; "is_string")]
      #[test_case("swap")]
      #[test_case("swapdown")]
      #[test_case("take")]
      #[test_case("taker")]
      #[test_case("times")]
      #[test_case("type")]
      #[test_case("unassign")]
      #[test_case("until")]
      #[test_case("unwrap")]
      #[test_case("update")]
      #[test_case("value")]
      #[test_case("while")]
      #[test_case("within?" ; "is_within")]
      #[test_case("word?")]
      #[test_case("wrap")]
      #[test_case("xor")]
      #[test_case("zero?" ; "is_zero")]
      #[test_case("zip")]
      fn test_lexicon(word: &str) {
          let e = axiom::standard_env(None, None);

          let r = test_word(e.clone(), Intern::new(word.to_string()));
          assert!(r.is_empty(), "{:?}", r);
      }
  }

  // if let (Item::List(program), Item::List(expected)) = (program, expected) {

  //     } else {
  //         Err(Error::from("Example should be a pair"))
  //     }

  // for ex in d.examples().iter() {
  //             let e = List::try_from(*ex).ok().unwrap();
  //             let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();
  //             let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();

  //             test_example(axiom::standard_env.clone(), w, p,exp)
  //         }.retain(|i| i.is_some()).collect::<Vec<Error>>()
#+end_src
** Pipes (input/output)
Kcats will confine all i/o to pipes. You can put values into pipes and
they emerge elsewhere. Words that act on pipes are the only ones that
can be impure. Everything else is a value.
**** Basic Types
The basic pipe contracts.
#+begin_src rust :tangle src/pipes.rs
  use crate::types::collection as coll;
  use crate::types::error::Error;
  use crate::types::{self, Item};
  use std::sync::Arc;
  use tokio::sync::RwLock;

  use futures::executor;
  pub mod channel;
  pub mod fs;
  pub mod net;
  pub mod standard;
  pub mod time;

  #[derive(Debug, Clone)]
  pub enum In {
      StaticFile(Arc<RwLock<fs::StaticFile>>),
      Socket(Arc<RwLock<net::Socket>>),
      Handoff(channel::Handoff<Item>),
      Standard,
  }

  impl PartialEq for In {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              (In::StaticFile(s1), In::StaticFile(s2)) => Arc::ptr_eq(s1, s2),
              (In::Socket(s1), In::Socket(s2)) => Arc::ptr_eq(s1, s2),
              (In::Handoff(h1), In::Handoff(h2)) => h1 == h2,
              _ => false,
          }
      }
  }

  #[derive(Debug, Clone)]
  pub enum Out {
      StaticFile(Arc<RwLock<fs::StaticFile>>),
      Socket(Arc<RwLock<net::Socket>>),
      ServerSocket(Arc<RwLock<net::ServerSocket>>),
      Handoff(channel::Handoff<Item>),
      Time,
      Standard,
  }

  impl PartialEq for Out {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              (Out::StaticFile(s1), Out::StaticFile(s2)) => Arc::ptr_eq(s1, s2),
              (Out::Socket(s1), Out::Socket(s2)) => Arc::ptr_eq(s1, s2),
              (Out::ServerSocket(s1), Out::ServerSocket(s2)) => Arc::ptr_eq(s1, s2),
              (Out::Handoff(h1), Out::Handoff(h2)) => h1 == h2,
              (Out::Time, Out::Time) => true,
              (Out::Standard, Out::Standard) => true,
              _ => false,
          }
      }
  }

  #[derive(Debug, Clone)]
  pub enum Tunnel {
      StaticFile(Arc<RwLock<fs::StaticFile>>),
      Socket(Arc<RwLock<net::Socket>>),
      Handoff(channel::Handoff<Item>),
      Standard,
  }

  impl PartialEq for Tunnel {
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              (Tunnel::StaticFile(s1), Tunnel::StaticFile(s2)) => Arc::ptr_eq(s1, s2),
              (Tunnel::Socket(s1), Tunnel::Socket(s2)) => Arc::ptr_eq(s1, s2),
              (Tunnel::Handoff(h1), Tunnel::Handoff(h2)) => h1 == h2,
              (Tunnel::Standard, Tunnel::Standard) => true,
              _ => false,
          }
      }
  }

  impl From<Tunnel> for Out {
      fn from(t: Tunnel) -> Self {
          match t {
              Tunnel::StaticFile(f) => Out::StaticFile(f),
              Tunnel::Socket(s) => Out::Socket(s),
              Tunnel::Handoff(h) => Out::Handoff(h),
              Tunnel::Standard => Out::Standard,
          }
      }
  }

  impl From<Tunnel> for In {
      fn from(t: Tunnel) -> Self {
          match t {
              Tunnel::StaticFile(f) => In::StaticFile(f),
              Tunnel::Socket(s) => In::Socket(s),
              Tunnel::Handoff(h) => In::Handoff(h),
              Tunnel::Standard => In::Standard,
          }
      }
  }

  impl In {
      pub fn put(&mut self, i: Item) -> types::Future<Result<(), Error>> {
          match self {
              In::StaticFile(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.put(i).await })
              }
              In::Socket(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.put(i).await })
              }
              In::Handoff(ref mut h) => Box::pin(h.put(i)), //_ => Err(Error::expected("foo")),
              In::Standard => standard::put(i),
          }
      }
  }

  impl Tunnel {
      pub fn put(&mut self, i: Item) -> types::Future<Result<(), Error>> {
          match self {
              Tunnel::StaticFile(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.put(i).await })
              }
              Tunnel::Socket(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.put(i).await })
              }
              Tunnel::Handoff(ref mut h) => Box::pin(h.put(i)),
              Tunnel::Standard => standard::put(i),
          }
      }

      pub fn take(&mut self) -> types::Future<Result<Option<Item>, Error>> {
          match self {
              Tunnel::StaticFile(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.take().await })
              }
              Tunnel::Socket(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.take().await })
              }
              Tunnel::Handoff(ref mut h) => Box::pin(h.take()),
              Tunnel::Standard => standard::take(),
          }
      }
  }

  impl Out {
      pub fn take(&mut self) -> types::Future<Result<Option<Item>, Error>> {
          match self {
              Out::StaticFile(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.take().await })
              }
              Out::Socket(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.take().await })
              }
              Out::ServerSocket(f) => {
                  let f = f.clone();
                  Box::pin(async move { f.write().await.take().await })
              }
              Out::Handoff(ref mut h) => Box::pin(h.take()),
              Out::Time => Box::pin(time::take()),
              Out::Standard => standard::take(),
          }
      }
  }

  impl crate::serialize::Display for In {
      fn representation(&self) -> Item {
          match self {
              In::StaticFile(f) => executor::block_on(async move { f.read().await.representation() }),
              In::Socket(f) => executor::block_on(async move { f.read().await.representation() }),
              In::Handoff(h) => h.representation(),
              In::Standard => standard::representation(),
          }
      }
  }

  impl crate::serialize::Display for Out {
      fn representation(&self) -> Item {
          match self {
              Out::StaticFile(f) => {
                  executor::block_on(async move { f.read().await.representation() })
              }
              Out::Socket(f) => executor::block_on(async move { f.read().await.representation() }),
              Out::ServerSocket(f) => {
                  executor::block_on(async move { f.read().await.representation() })
              }
              Out::Handoff(h) => h.representation(),
              Out::Time => time::representation(),
              Out::Standard => standard::representation(),
          }
      }
  }

  impl crate::serialize::Display for Tunnel {
      fn representation(&self) -> Item {
          match self {
              Tunnel::StaticFile(f) => {
                  executor::block_on(async move { f.read().await.representation() })
              }
              Tunnel::Socket(f) => executor::block_on(async move { f.read().await.representation() }),
              Tunnel::Handoff(h) => h.representation(),
              Tunnel::Standard => standard::representation(),
          }
      }
  }
  /* Pipes can be "closed", from either end to signal that either the
   ,* putter or taker has gone away. Sometimes the type of pipe
   ,* may not really support this concept but an implementation is
   ,* required.  For example, files. When you open a file for writing and
   ,* then "close" it, that doesn't really do anything. Rust doesn't have
   ,* an explicit file close. You have to drop the reference to it, which
   ,* in kcats you can do by popping the pipe off the stack. Rust will
   ,* clean up automatically, other impls might have to reference count.
   ,*
   ,* The contract here is as follows:
   ,* 1. After calling close, put on the pipe returns an error
   ,*
   ,* 2. After calling close, take on the pipe will return still-buffered
   ,* items (if the pipe has a buffer), but once buffer is exhausted it
   ,* will return error.
   ,*
   ,* 2. Errors cannot be put into a pipe (the taker can't distinguish
   ,* between io error and an error value). To work around this, wrap the
   ,* error value in a list to quote it. Putting error into a pipe will
   ,* return an io error.
   ,*
   ,* 3. Once closed pipes cannot be ever be put into again. closed? will always
   ,* return true thereafter.
   ,*
   ,* One use case that has to be handled specially is a file we've fully
   ,* read but later someone else might write more bytes to the end. Does
   ,* the pipe close when we reach EOF? I think we might need to support
   ,* both types (a type that closes when hitting eof and one that
   ,* doesn't). The former is the "normal" use case, which will be the
   ,* default.
   ,*
   ,* These two types are basically static vs dynamic content. Either all
   ,* the content is known now, or it isn't.
   ,*
  ,*/

  fn closed_error(on_take: bool) -> Error {
      Error::create(
          coll::List::from_iter([
              Item::from("close"),
              if on_take { "take" } else { "put" }.into(),
          ]),
          "attempt to use closed pipe",
          None,
      )
  }

  impl From<Tunnel> for Item {
      fn from(t: Tunnel) -> Self {
          Item::Dispenser(coll::Dispenser::Tunnel(t))
      }
  }

  impl From<Out> for Item {
      fn from(t: Out) -> Self {
          Item::Dispenser(coll::Dispenser::Out(t))
      }
  }

  impl From<In> for Item {
      fn from(t: In) -> Self {
          Item::Receptacle(coll::Receptacle::In(t))
      }
  }
#+end_src
**** Files
How to interact with files on disk
#+begin_src rust :tangle src/pipes/fs.rs
  use crate::axiom::ItemResult;
  use crate::types::associative as assoc;
  use crate::types::error::Error;
  use crate::types::*;
  use futures::Stream;
  use std::future;
  use std::pin::Pin;
  use std::ptr;
  use std::sync::Arc;
  use std::task::{Context, Poll};
  use tokio::fs::File;
  use tokio::io::{AsyncRead, ReadBuf};
  use tokio::io::{AsyncReadExt, AsyncWriteExt};
  use tokio::sync::RwLock;

  #[derive(Debug)]
  pub struct StaticFile {
      pub file: File,
      pub path: String,
  }

  impl PartialEq for StaticFile {
      fn eq(&self, other: &Self) -> bool {
          // Check if the 'file' fields of both structs are the same by reference
          ptr::eq(&self.file, &other.file)
      }
  }

  impl StaticFile {
      pub fn put<'a>(
          &'a mut self,
          i: Item,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<(), Error>> + Send + 'a>> {
          let b = Bytes::try_from(i);

          match b {
              Ok(bs) => Box::pin(async move { self.file.write_all(&bs).await.map_err(|e| e.into()) }),
              Err(e) => Box::pin(future::ready(Err(e))),
          }
      }

      pub fn take<'a>(
          &'a mut self,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<Option<Item>, Error>> + Send + 'a>> {
          let mut bs = [0u8; 1024];
          Box::pin(async move {
              let ct = self.file.read(&mut bs).await?;
              if ct == 0 {
                  // EOF, no more takes since it's static
                  Ok(None)
              } else {
                  Ok(Some(bs[0..ct].to_vec().into()))
              }
          })
      }
  }

  impl Stream for StaticFile {
      type Item = Result<Item, Error>;

      fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
          let mut buf = vec![0u8; 1024];
          let mut read_buf = ReadBuf::new(&mut buf);

          match Pin::new(&mut self.file).poll_read(cx, &mut read_buf) {
              Poll::Ready(Ok(())) => {
                  let bytes_read = read_buf.filled().len();
                  if bytes_read == 0 {
                      Poll::Ready(None)
                  } else {
                      Poll::Ready(Some(Ok(read_buf.filled().to_owned().into())))
                  }
              }
              Poll::Ready(Err(e)) => Poll::Ready(Some(Err(e.into()))),
              Poll::Pending => Poll::Pending,
          }
      }
  }

  impl crate::serialize::Display for StaticFile {
      fn representation(&self) -> Item {
          assoc::Association::from_iter([
              ("type".into(), "tunnel".into()),
              (
                  "values".into(),
                  assoc::Association::from_iter([("type".into(), "bytes".into())]).into(),
              ),
              (
                  "to".into(),
                  assoc::Association::from_iter([("file".into(), self.path.clone().into())]).into(),
              ),
          ])
          .into()
      }
  }

  pub fn file_in(i: Item) -> ItemResult {
      let path = String::try_from(i)?;
      let file = std::fs::File::options()
          .read(true)
          .write(true)
          .create_new(true)
          .open(path.clone())?;
      Ok(super::In::StaticFile(Arc::new(RwLock::new(StaticFile {
          file: File::from_std(file),
          path,
      })))
      .into())
  }

  pub fn file_out(i: Item) -> ItemResult {
      let path = String::try_from(i)?;
      let file = std::fs::File::open(path.clone())?;
      Ok(super::Out::StaticFile(Arc::new(RwLock::new(StaticFile {
          file: File::from_std(file),
          path,
      })))
      .into())
  }

  impl From<StaticFile> for Item {
      fn from(f: StaticFile) -> Self {
          super::Out::StaticFile(Arc::new(RwLock::new(f))).into()
      }
  }
#+end_src
**** Network
How to interact with the network (TCP/IP sockets)
#+begin_src rust :tangle src/pipes/net.rs
  use crate::axiom::ItemResult;
  use crate::types::associative as assoc;
  use crate::types::error::Error;
  use crate::types::{self, wrap, Int, Item};
  use futures::future::FutureExt;
  use std::future::{self};
  use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
  use std::pin::Pin;
  use std::ptr;
  use std::str::FromStr;
  use std::sync::Arc;
  use tokio::io::{AsyncReadExt, AsyncWriteExt};
  use tokio::net::{TcpListener, TcpStream};
  use tokio::sync::RwLock;

  #[derive(Debug)]
  pub struct Socket {
      pub socket: TcpStream,
      pub addr: SocketAddr,
  }

  impl PartialEq for Socket {
      fn eq(&self, other: &Self) -> bool {
          // Check if the 'socket' fields of both structs are the same by reference
          ptr::eq(&self.socket, &other.socket)
      }
  }

  impl Socket {
      pub fn put<'a>(
          &'a mut self,
          i: Item,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<(), Error>> + Send + 'a>> {
          println!("Putting {:?}", i);
          let b = types::Bytes::try_from(i);
          match b {
              Ok(bs) => {
                  Box::pin(async move { self.socket.write_all(&bs).await.map_err(|e| e.into()) })
              }
              Err(e) => Box::pin(future::ready(Err(e))),
          }
      }

      pub fn take<'a>(
          &'a mut self,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<Option<Item>, Error>> + Send + 'a>> {
          let mut bs = [0u8; 1024];
          Box::pin(async move {
              let n = self.socket.read(&mut bs).await?;
              if n == 0 {
                  Ok(None)
              } else {
                  Ok(Some(bs[..n].to_vec().into()))
              }
          })
      }
  }

  impl crate::serialize::Display for Socket {
      fn representation(&self) -> Item {
          assoc::Association::from_iter([
              ("type".into(), "tunnel".into()),
              ("realm".into(), "tcp".into()),
              ("address".into(), self.addr.to_string().into()),
          ])
          .into()
      }
  }

  // Server sockets
  #[derive(Debug)]
  pub struct ServerSocket {
      pub socket: TcpListener,
  }

  impl PartialEq for ServerSocket {
      fn eq(&self, other: &Self) -> bool {
          // Check if the 'socket' fields of both structs are the same by reference
          ptr::eq(&self.socket, &other.socket)
      }
  }

  impl ServerSocket {
      pub fn take<'a>(
          &'a mut self,
      ) -> Pin<Box<dyn std::future::Future<Output = Result<Option<Item>, Error>> + Send + 'a>> {
          Box::pin(async move {
              let (socket, addr) = self.socket.accept().await?;

              Ok(Some(
                  super::Tunnel::Socket(Arc::new(RwLock::new(Socket { socket, addr }))).into(),
              ))
          })
      }
  }

  impl crate::serialize::Display for ServerSocket {
      fn representation(&self) -> Item {
          assoc::Association::from_iter([
              ("type".into(), "pipe".into()),
              (
                  "serversocket".into(),
                  "todo: fix serversocket local addr async issue".into(), //Item::String(self.socket.lock().await.local_addr().unwrap().to_string()),
              ),
          ])
          .into()
      }
  }

  fn socket_addr(i: Item, j: Item) -> Result<SocketAddrV4, Error> {
      println!("socket: {:?} {:?}", i, j);
      let addr = Ipv4Addr::from_str(String::try_from(j)?.as_str())?;
      let port = Int::try_from(i)? as u16;
      Ok(SocketAddrV4::new(addr, port))
  }

  pub fn server_socket(i: Item, j: Item) -> types::Future<ItemResult> {
      match socket_addr(i, j) {
          Ok(addr) => {
              Box::pin(TcpListener::bind(addr).map(|l| {
                  Ok(super::Out::ServerSocket(Arc::new(RwLock::new(ServerSocket {
                      socket: l.unwrap(),
                  })))
                  .into())
              }))
          }
          Err(e) => Box::pin(future::ready(Err(e))),
      }
  }

  // pub fn server_socket(env: Environment) -> environment::Future {
  //     let addr = env.pop();

  //     let inner_env = Environment::try_from(tos);
  //     match inner_env {
  //         Ok(inner) => Box::pin(eval_step(inner).map(|inner_next| env.push(Item::Env(inner_next)))),
  //         Err(e) => env.push(Item::Error(e)).into(),
  //     }
  // }

  impl From<std::net::AddrParseError> for Error {
      fn from(err: std::net::AddrParseError) -> Error {
          Error::create(wrap("addrparse".into()), &err.to_string(), None)
      }
  }
#+end_src
**** Time
#+begin_src rust :tangle src/pipes/time.rs
  use crate::types::associative as assoc;
  use crate::types::error::Error;
  use crate::types::*;
  use std::{
      future,
      time::{SystemTime, UNIX_EPOCH},
  };

  pub fn take() -> Future<Result<Option<Item>, Error>> {
      let t = SystemTime::now()
          .duration_since(UNIX_EPOCH)
          .unwrap()
          .as_millis() as Int;
      Box::pin(future::ready(Ok(Some(Item::Int(t)))))
  }

  pub fn representation() -> Item {
      assoc::Association::from_iter([
          ("type".into(), "out".into()),
          ("from".into(), "systemtime".into()),
          (
              "values".into(),
              assoc::Association::from_iter([
                  ("type".into(), "integer".into()),
                  ("units".into(), "milliseconds".into()),
              ])
              .into(),
          ),
      ])
      .into()
  }
#+end_src
**** Standard in/out
#+begin_src rust :tangle src/pipes/standard.rs
  use crate::types::associative as assoc;
  use crate::types::error::Error;
  use crate::types::{self, *};
  use std::future;
  use std::io::{self, Read, Write};

  pub fn take() -> Future<Result<Option<Item>, Error>> {
      let mut buf = [0u8];
      let n = io::stdin().read(&mut buf);
      let f = match n {
          Ok(0) => Ok(None),
          Ok(n) => Ok(Some(buf[..n].to_vec().into())),
          Err(e) => Err(e.into()),
      };
      Box::pin(future::ready(f))
  }

  pub fn put(i: Item) -> types::Future<Result<(), Error>> {
      let bs = Bytes::try_from(i);
      match bs {
          Ok(bs) => {
              let f = io::stdout().write(&bs);
              Box::pin(future::ready(f.map_err(|e| e.into()).map(|_| ())))
          }
          Err(e) => Box::pin(future::ready(Err(e))),
      }
  }

  pub fn representation() -> Item {
      assoc::Association::from_iter([
          ("type".into(), "tunnel".into()),
          ("peer".into(), "standard".into()),
      ])
      .into()
  }
#+end_src
**** Channels
Implement the =handoff= type
#+begin_src rust :tangle src/pipes/channel.rs
  use crate::pipes;
  use crate::types::associative as assoc;
  use crate::types::environment::Environment;
  use crate::types::error::Error;
  use crate::types::{self, Item};
  use flume;
  use std::future;
  use std::ptr;

  #[derive(Debug, Clone)]
  // Use Option because we want to be able to drop senders/receivers to
  // close the channel
  pub struct Handoff<T> {
      pub receiver: Option<flume::Receiver<T>>,
      pub sender: Option<flume::Sender<T>>,
  }

  impl<T> PartialEq for Handoff<T> {
      fn eq(&self, other: &Self) -> bool {
          // Check if the 'file' fields of both structs are the same by reference
          match (&self.receiver, &other.receiver, &self.sender, &other.sender) {
              (Some(sr), Some(or), Some(ss), Some(os)) => ptr::eq(&sr, &or) && ptr::eq(&ss, &os),
              _ => false,
          }
      }
  }

  impl Handoff<Item> {
      pub fn new() -> Handoff<Item> {
          let (sender, receiver) = flume::bounded::<Item>(0);
          Handoff::<Item> {
              sender: Some(sender),
              receiver: Some(receiver),
          }
      }

      pub fn put(&mut self, i: Item) -> types::Future<Result<(), Error>> {
          if let Some(ch) = self.sender.clone() {
              // Can't send and receive in the same channel in same thread
              if !self.receiver.is_none() {
                  //println!("Dropping receiver");
                  self.receiver = None;
              }
              Box::pin(async move {
                  ch.send_async(i)
                      .await
                      .map_err(|_| pipes::closed_error(false))
              })
          } else {
              Box::pin(future::ready(Err(pipes::closed_error(false))))
          }
      }

      pub fn take(&mut self) -> types::Future<Result<Option<Item>, Error>> {
          if let Some(ch) = self.receiver.clone() {
              // Can't send and receive in the same channel in same thread
              if !self.sender.is_none() {
                  //println!("Dropping sender");
                  self.sender = None;
              }
              Box::pin(async move {
                  //println!("Receiving");
                  ch.recv_async().await.map(Some).or_else(|_| Ok(None))
              })
          } else {
              Box::pin(future::ready(Ok(None)))
          }
      }
  }

  impl crate::serialize::Display for Handoff<Item> {
      fn representation(&self) -> Item {
          assoc::Association::from_iter([
              ("type".into(), "pipe".into()),
              ("handoff".into(), "todo: id-or-hash here".into()),
          ])
          .into()
      }
  }

  pub fn handoff(env: Environment) -> types::Future<Environment> {
      env.push(pipes::Tunnel::Handoff(Handoff::new()).into())
          .into()
  }
#+end_src
** Issues
*** INPROGRESS Interactive mode :tools:
run with =kcats -i= for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
**** TODO Only print the changed part of the stack
**** TODO Emacs keybindings to send common stack ops
+ swap / swapdown
+ clear ([] evert drop)
+ clone
+ snapshot?
+ discard
+ sink / float
  
*** DONE Install the lexicon in the proper place
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in =/usr/share/kcats= or =~/.local/share/kcats= or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.

*** CANCELED Add option to read an alternative lexicon file
The builtins can stay inside the binary, but we should have a cmdline
option to start without the usual lexicon. Should probably add a word
'lexicon' to add a parsed object as the lexicon.
*** TODO Package the binary for various platforms
Would be nice to build rpms/debs etc so users can skip the nasty build
process.
*** DONE Optimize memory allocation
**** DONE Lists
#+begin_src kcats
[[a b]] [a] lookup
#+end_src

#+RESULTS:
: b
*** DONE pack and unpack are not inverse
#+begin_src kcats :result code
[1 2 3] unpack pack
#+end_src

#+RESULTS:
: 
: [[2 3 1]]

It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.

Solution: rename to put take
*** DONE true and false are not words?
#+begin_src kcats :results code
[true] unwrap word?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

If you didn't know =true= was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).

It's messy because true/false are the only "words" you can put onto
the stack without wrapping.

There are several ways to deal with this:

+ just leave as is (these look like words but don't act like them)

+ Use something else for boolean values, like 0b 1b or something (ugly, no)

+ Revert to allowing bare words (that aren't actions) to go onto the
  stack unwrapped, so that true/false aren't different

Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.
*** DONE Division by zero panics
*** INPROGRESS Implement pipes :stdlib:
**** DONE Write to a file
#+begin_src kcats
  [[file "/tmp/bar4"]] pipe-in

  ["hello world!"
   "Nice to meet you!"
   "My name is kcats"]

  ["\n" join bytes put]

  step
#+end_src

#+RESULTS:
: [[asked [pipe]] [unwound [["Nice to meet you!" "My name is kcats"] ["\n" join bytes put] step]] [type error] [reason "type mismatch"]] [[type pipe] [file "/tmp/bar4"]]

#+begin_src kcats
  [[file "/tmp/bar101r7"]] pipe-in

  "hello world!"

  bytes put

#+end_src

#+RESULTS:
: [[type pipe] [file "/tmp/bar101r7"]]

#+begin_src kcats
  [[file "/tmp/bar101r7"]] pipe-out

  take

  string

#+end_src

#+RESULTS:
: "hello world!" [[type pipe] [file "/tmp/bar101r7"]]

**** DONE Read from a file
#+begin_src kcats :results code
"" [string join] [[file "/tmp/bar2"]] pipe-out

collect 
#+end_src

#+RESULTS:
#+begin_src kcats

stack: [[[reason "type mismatch"] [asked [pipe]] [type error]] [[file "/tmp/bar2"] [type pipe]] ""]
expression: [swap [string join] dip [closed? not] shield [take swap [string join] dip [closed? not] shield] loop discard]
#+end_src

#+begin_src kcats :results code
dictionary [collect spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[type error] [reason "word is not defined"] [asked [fail]]]
 "Lookup attempted on non association value"
 [spec]
 [[definition [swap [take swap] swap put [dip] join [[closed? not]] dip while discard]]
  [spec [[pipe program] [item]]]]]
#+end_src
**** DONE Close a pipe
#+begin_src kcats :results code
[[file "/tmp/foopytoop"]] pipe-in "foo" bytes put close "bar" bytes put
#+end_src

#+RESULTS:
#+begin_src kcats
[[type pipe] [file "/tmp/foopytoop"]]
#+end_src
**** DONE Serialize pipes with something sane
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
**** DONE Sockets
***** DONE Server Sockets
#+begin_src kcats :results code
[[type ip-port] [address "127.0.0.1"] [port 11211]] pipe-out 
#+end_src

#+RESULTS:
#+begin_src kcats
socket: Int(11211) String("127.0.0.1")
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
#+end_src

#+begin_src kcats :results code
  "127.0.0.1" 12345 serversocket 
#+end_src

#+RESULTS:
#+begin_src kcats
socket: Int(12345) String("127.0.0.1")
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
#+end_src

#+begin_src kcats :results code
[[type ip-port] [address "127.0.0.1"] [port 11211]] pipe-out ;; server socket
take ;; accept connection by taking a socket out of the pipe
"foo\n" bytes put ;; write a message to the socket
take string ;; get a message from the socket
[discard ;; close the socket
 discard] ;; close the server socket
dip
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [string]] [unwound [take "foo\n" bytes put take string [discard discard] dip]] [type error] [reason "type mismatch"]]
#+end_src

***** DONE Sockets

***** INPROGRESS Assemble is broken when reading files
I think it's because =closed?= is broken.

#+begin_src kcats :results code
"" [string join] [[file "bar"]] pipe-out assemble
#+end_src

#+begin_src kcats :results code
"" [string join] [[file "bar"]] pipe-out take discard take discard closed? 
#+end_src

#+RESULTS:
#+begin_src kcats
checking file closed false
Got 3 bytes
checking file closed false
Got 0 bytes
Closing!
checking file closed false
[] [string join] ""
#+end_src

I see the problem. When we clone the pipe, we also clone the =closed=
boolean and we shouldn't be doing that. There should only be one copy
of that. The entire struct should be in an Arc<Mutex> and not just the
file field. And when we modify the boolean, we shouldn't 
**** DONE Convert In/Out traits to enums in pipes modules
Enums seem to work well elsewhere, and since pipes are also a closed
set, we can use them here too.

I don't think there will ever be user-created pipe types as it would
have to be done in rust and not in kcats.

**** TODO Composable transforms
There should be some way to compose transforms in a pipe. For example,
we can have a pipe that when you put bytes in it, it gets written to a
certain file on disk. But what we really want is that we put bytes
into it, and they get compressed with lz4 before being written to
disk.

I suppose pump could take an optional transducer-like thing, and *those*
could be composable. The transformations I'm thinking of generally
aren't going to be i/o, it's pure computation. Actually I guess any
pipe could take an optional transform. Clojure.core.async channels do this.

Maybe the first thing to do is implement transducers?

**** CANCELED Filled pipes
Mostly for testing purposes, takes a list and creates a buffered pipe
that offers list items until the list is exhausted and then returns pipe closed errors.

#+begin_src kcats
[1 2 3] filled take
#+end_src

#+RESULTS:
: 1 [[type pipe] [filled todo: id-or-hash here]]

**** TODO Object pipes
These pipes should send serialized kcats objects and each put/take
should transfer 1 object. Maybe use protocol buffers or similar

This could be done using a network pipe, and an assemble function that
pulls byte chunks and builds objects when there are enough bytes for
one object, and puts them into a handoff pipe.

This should be possible to do entirely in kcats.

**** DONE Time pipe
Each take from the pipe return the current unix time in ms.  Should be
a "singleton" - probably using Box::leak, so that we can insert a copy
of this pipe whenever we want and it's always a reference to the same
object. Might be an Arc for compatibility even though we don't need to
ref count. (But I suspect we don't need the Arc).

#+begin_src kcats
timestamps take
#+end_src

#+RESULTS:
: 1687273991929 [[from systemtime] [values [[type integer] [units milliseconds]]] [type out]]

**** DONE stdin/stdout pipes
Should also be singleton. Should it always be a tunnel or should we
allow separate access to in or out?

#+begin_src kcats
standard "foo" bytes put
#+end_src

#+RESULTS:
: foo[[type tunnel] [peer standard]]

Stdin is not tested, since currently the interpreter reads the program
from stdin. May need to change that (read the program from filesystem
and let the program itself access stdin).
**** TODO Pipe take outcome
There is some inconsistency with what happens when there's nothing
left - empty lists just return nothing on take, but closed pipes
return an error. May need to resolve this inconsistency.

|               | List    | Handoff | Socket  | StaticFile |
|---------------+---------+---------+---------+------------|
| take Items    | Item    | Item    | Bytes   | Bytes      |
| take Past EOF | Nothing | Nothing | Nothing | Nothing    |
| step Past EOF | Exit    | Exit    | Exit    | Exit       |
*** DONE 'Fail' is not defined
We need to be able to throw our own errors (eg lookup tries to do this)

#+begin_src kcats
1 2 [1 "two" +] [fail] recover 3 4 
#+end_src

#+RESULTS:
: converting to error: Error([[type error] [asked [number]] [unwound [+]] [reason "type mismatch"]])
: [[type error] [asked [number]] [unwound [3 4]] [reason "type mismatch"]] 2 1

*** DONE 'dictionary' doesn't allow access to the data inside definitions
The definition is just shown as the word itself and we can't access
spec, definition etc.

#+begin_src kcats :results code
dictionary [swap spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item a] [item b]] [[item b] [item a]]]
#+end_src

*** INPROGRESS Use a single word for all derivation/conversion :stdlib:
Right now there's different words for converting bytes to string
(string) or string to bytes (bytes). Proposing a more composable
mechanism here, where there's a single action word that derives one
data structure from another.

Here we use the association shorthand for =[[type bytes]]=
#+begin_src kcats
"foo" [bytes] derive
#+end_src

#+RESULTS:
: No spec for derive!
: 
: [[] [bytes] "foo"]

Here's a typical invocation
#+begin_src kcats
"foo" [[type bytes]] derive
#+end_src

#+RESULTS:
: No spec for derive!
: 
: [[] [[type bytes]] "foo"]

Here's a derivation with two steps: convert string to bytes, then use
the bytes as entropy to generate an AES encryption key.
#+begin_src kcats
"foo"
[[bytes]
 [[type aes-key]
  [length 128]]]
[derive]
step
#+end_src

#+RESULTS:
: No spec for derive!
: No spec for derive!
: 
: [[] [[type aes-key] [length 128]] [] [bytes] "foo"]

This seems like a pretty straightforward syntax and should eliminate
an explosion of new words that just convert one type to another.

The difficulty is how to implement it. A naive way would just make
=derive= a multimethod and add lots of methods. The problem is the
=decide= based multimethods aren't really intended to have lots of
methods because it's inefficient - all the conditions are checked
until one is true. In this case, we can just do a straight lookup by
destination type (if we have different methods depending on input
type, THEN we can use =decide= internally).

But maybe even that isn't ideal - we could also lookup by =[sourcetype
destinationtype]= pairs. However we don't have explicit source
types. We just have a list that may or may not also act as a set or
association.

It should be possible to implement the =destinationtype= based lookup
pretty easily. Make =derive= a lexicon entry but insert it earlier so
that it will have an actual association object. It'll be refcounted or
possibly even static (if we don't care about leaking these - but that
would fail if we run through many envs in the same process).

Actually we can do this in kcats itself but it requires executing
arbitrary code. The lexicon doesn't really do that - it's just a data
file. 
#+begin_src kcats
[derive]
[[[bytes string] [string]]] association wrap
[float type wrap swap join ;; 1 [string] => [number string]
 lookup execute] join
[definition] swap put
wrap
inscribe

"foo" bytes [string] 
derive 
#+end_src

#+RESULTS:
: No spec for derive!
: 
: stack: [[[reason "type mismatch"] [asked [[[list?] [string?]] [execute] any?]] [type error]] [string]]
: expression: [lookup execute]


Ok here's the basic impl. Afterward, should change =string= to
=++string= to make them non-public, should use =[string] derive=
instead. The issue here is how do we add new conversions? We could
make the conversions a separate word, like =derivations=, but that
sticks out as different - it's a data structure and not an action
word.
#+begin_src kcats
;; add some conversions
derivations [[bytes string] [string]] assign
;; the list of conversions
[[[bytes string] [string]]] association

"foo" bytes [string]


;; determine the current type and look up the conversion
[[type] shield wrap] dipdown [join wrap] dip 
swap lookup execute
#+end_src

#+RESULTS:
: 
: ["foo"]
#+begin_src kcats
dictionary [assign spec] lookup 
#+end_src

#+RESULTS:
: 
: [[[type error] [reason "word is not defined"] [asked [fail]]] "Lookup attempted on non association value" [spec] assign]

#+begin_src kcats 
[[[a b] c]] [[a b]] lookup
#+end_src

#+RESULTS:
: 
: [c]

#+begin_src kcats
[[string [foo]]] [string] lookup
#+end_src
#+RESULTS:
: 
: [[foo]]

Experiment with whether we can easily determine the 'from' type so
that we can dispatch on both 'from' and 'to'.
#+begin_src kcats :results code
[+] unwrap type
#+end_src

#+RESULTS:
#+begin_src kcats

[[[reason "type mismatch"] [type error] [unwound [count 1 = [[+]] unwrap evert first [[[first [type] unwrap =] [first second] [first first] if] [[]]] unwrap branch [[[[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] +]] unwrap evert first swap discard [[[[association] unwrap]]] unwrap swap [[]] unwrap or [[[[nothing?] shield] dip swap [or] shielddown] [] [[take swap [[execute] shielddown] dip swap] dip or] [execute] recur] execute swap discard swap discard]] [asked [list]]] +]
#+end_src

#+begin_src kcats
[] [] [] [discard [default] unwrap] if
#+end_src

#+RESULTS:
: 
: [default]

#+begin_src kcats
[[bar 12]]
[
[[foo] lookup]
[[bar] lookup]
[5]
[6]
]
swap [nothing?] shield
[[take] dip swap execute [nothing?] shield] loop
;;sink discard discard
#+end_src

#+RESULTS:
: 
: [[[bar 12]] [[[foo] lookup] [[bar] lookup] [5] [6]]]

#+begin_src kcats
[[bar 12]]
[[[foo] lookup]
 [[bar] lookup]]
[execute] any?
#+end_src

#+RESULTS:
: 
: [12 [[bar 12]]]

#+begin_src kcats
1 2 or
#+end_src

#+RESULTS:
: 
: [1]

Now that we have a fairly reliable =type= implementation, we can
dispatch on both =to= and =from= types for =derive=.

#+begin_src 

#+end_src
*** DONE Change boolean operators to retain values
=or= and =and= should return the actual value if it is truthy, instead
of =true=. But neither should ever return =[]=, but use =false=
instead.
#+begin_src kcats
2 [] or
#+end_src

#+RESULTS:
: 2

#+begin_src kcats
1 10 inc 1 range take swap [*] step
#+end_src

#+RESULTS:
: 3628800

This does bring up the question of whether the boolean type is really
needed. It may be possible to use =[]= as =false= and anything else as
=true= (=1= for example, or maybe the bare word =true= which then
wouldn't carry any other meaning). Or possible use some other word
than =true=, eg =something=.

Does this make sense when applied to boolean logic?

#+begin_example
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
#+end_example

I think it doesn't make sense.

Maybe yes/no?

#+begin_example
yes or no = yes ?
#+end_example
#+begin_src kcats
5 3 =
#+end_src

#+RESULTS:
: 
: [[]]

#+begin_src kcats
5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide
#+end_src

#+RESULTS:
: 
: ["five" 5]

#+begin_src kcats
[3 5 7] [even?] any? false =
#+end_src

#+RESULTS:
: 
: stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
: expression: [false =]
*** DONE 'recover' is broken
#+begin_src kcats
[+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: [3]

#+begin_src kcats
[[expression [[+] [3] recover]]] environment advance advance
eval-step
advance
advance
advance
advance
advance
eval-step
advance
advance
advance
#+end_src

#+RESULTS:
: Env: [List([List([])]), Word(0x5a56c7a6c3c0 : "unwrap"), List([List([List([Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a73ca0 : "association?", examples: Some([List([List([List([List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a66d90 : "c"), Word(0x5a56c7a73d60 : "d")])]), Word(0x5a56c7a73ca0 : "association?")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), List([Word(0x5a56c7a65c40 : "something?")])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), Word(0x5a56c7a8c8c0 : "shield"), List([Entry(Entry { word: 0x5a56c7a7ddf0 : "take", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a7ddf0 : "take")]), List([List([String("b"), String("c")]), String("a")])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([Entry(Entry { word: 0x5a56c7a73c80 : "++lookup", examples: None, spec: Some([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a56d50 : "item")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x5a56c7a668b0 : "dip", examples: Some([List([List([Int(1), Int(8), List([Word(0x5a56c7a570f0 : "inc")]), Word(0x5a56c7a668b0 : "dip")]), List([Int(2), Int(8)])]), List([List([Int(1), Int(2), List([Word(0x5a56c7a621b0 : "dec")]), Word(0x5a56c7a6c3c0 : "unwrap"), List([Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a668b0 : "dip")]), List([Int(3), Word(0x5a56c7a621b0 : "dec")])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program"), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin }), List([List([List([Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a73ca0 : "association?", examples: Some([List([List([List([List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a66d90 : "c"), Word(0x5a56c7a73d60 : "d")])]), Word(0x5a56c7a73ca0 : "association?")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), List([Word(0x5a56c7a65c40 : "something?")])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), Word(0x5a56c7a8c8c0 : "shield")]), Word(0x5a56c7a79bd0 : "loop"), List([Word(0x5a56c7a65c40 : "something?")]), List([String("Lookup attempted on non association value"), Entry(Entry { word: 0x5a56c7a55850 : "fail", examples: None, spec: Some([List([Word(0x5a56c7a66340 : "string")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: [] })]), List([Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a89c10 : "if"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Env({ stack: [], expression: [[+] [3] recover] })])]), Word(0x5a56c7a6c3c0 : "unwrap"), Entry(Entry { word: 0x5a56c7a7bf60 : "evert", examples: Some([List([List([Int(1), Int(2), Int(3), List([Int(4), Int(5), Int(6)]), Word(0x5a56c7a7bf60 : "evert")]), List([Int(6), Int(5), Int(4), List([Int(3), Int(2), Int(1)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list"), Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a88e20 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x5a56c7a88e20 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a56d50 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] }), Entry(Entry { word: 0x5a56c7ad0140 : "advance", examples: None, spec: Some([List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x5a56c7a8c780 : "environment", examples: None, spec: Some([List([Word(0x5a56c7a572d0 : "association")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })])]), serialize: false, definition: [List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), List([List([List([List([Word(0x5a56c7a73dc0 : "expression")]), Word(0x5a56c7a945e0 : "lookup"), Entry(Entry { word: 0x5a56c7a8c4f0 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x5a56c7a8c4f0 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a54a90 : "number")])]), serialize: false, definition: Builtin }), List([List([Word(0x5a56c7a96e20 : "positive?")]), List([Entry(Entry { word: 0x5a56c7a54660 : "<=", examples: None, spec: Some([List([Word(0x5a56c7a54a90 : "number"), Word(0x5a56c7a54a90 : "number")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([List([Entry(Entry { word: 0x5a56c7a803a0 : "errored?", examples: None, spec: Some([List([Word(0x5a56c7a8c780 : "environment")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a8c8c0 : "shield"), Entry(Entry { word: 0x5a56c7a87e60 : "not", examples: Some([List([List([Int(1), Word(0x5a56c7a62500 : "even?"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56780 : "false"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])]), List([List([Word(0x5a56c7a56b40 : "true"), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56780 : "false")])]), List([List([List([]), Word(0x5a56c7a87e60 : "not")]), List([Word(0x5a56c7a56b40 : "true")])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([Word(0x5a56c7a56970 : "boolean")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x5a56c7a69bc0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x5a56c7a540c0 : "+")]), Word(0x5a56c7a69bc0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x5a56c7a540c0 : "+")]), Int(4), Word(0x5a56c7a66d70 : "swap"), Word(0x5a56c7a69bc0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x5a56c7a66db0 : "program")]), List([Word(0x5a56c7a54830 : "*")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a5e2b0 : "every?")]), List([Entry(Entry { word: 0x5a56c7a73e00 : "eval-step", examples: Some([List([List([List([List([Word(0x5a56c7a73dc0 : "expression"), List([Int(1), Word(0x5a56c7a570f0 : "inc")])])]), Word(0x5a56c7a8c780 : "environment"), Word(0x5a56c7a73e00 : "eval-step"), Word(0x5a56c7a73e00 : "eval-step"), List([Word(0x5a56c7a73d80 : "stack")]), Word(0x5a56c7a945e0 : "lookup")]), List([List([Int(2)])])])]), spec: Some([List([Word(0x5a56c7a66c70 : "list")]), List([Word(0x5a56c7a66c70 : "list")])]), serialize: false, definition: Builtin })]), Word(0x5a56c7a72d80 : "while"), Entry(Entry { word: 0x5a56c7a66d70 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66d70 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")])]), List([List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a669d0 : "b")]), List([Word(0x5a56c7a56d50 : "item"), Word(0x5a56c7a66700 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5a56c7a66740 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x5a56c7a66700 : "a"), Word(0x5a56c7a669d0 : "b"), Word(0x5a56c7a66d90 : "c")]), Word(0x5a56c7a66740 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x5a56c7a56d50 : "item")]), List([])]), serialize: false, definition: Builtin })] })]
: handle is Word(0x5a56c7a5eab0 : "handle") Word(0x5a56c7a5eab0 : "handle")
: expr contains handle? false
: unhandled err!
: 
: stack: [[[type error] [asked [association (unfinished tryfrom impl)]] [reason "type mismatch"]]]
: expression: [[[]] unwrap [[[swap association?] [something?]] [execute] every?] shield [take swap [++lookup] dip [[[swap association?] [something?]] [execute] every?] shield] loop [something?] ["Lookup attempted on non association value" fail] [discard] if count [[[[stack []] [expression [[+] [3] recover]]]]] unwrap evert first swap [[[[expression] lookup count [[positive?] [<=]] [execute] every?] [[errored?] shield not]] [execute] every?] [eval-step] while swap discard advance eval-step advance advance advance advance advance eval-step advance advance advance]
*** DONE Fix handle in nested env
=handle= doesn't work properly in a nested environment. That is
because =eval= has some logic to check for uncaught exceptions, but
the =advance= self-hosted evaluator doesn't.

#+begin_src kcats
1 + handle error?
#+end_src

#+RESULTS:
: Env: [Word(0x5d29b8fb5b00 : "handle"), Entry(Entry { word: 0x5d29b8fc2600 : "error?", examples: None, spec: Some([List([Word(0x5d29b8fb6c00 : "item")]), List([Word(0x5d29b8fb6820 : "boolean")])]), serialize: false, definition: Builtin })]
: handle is Word(0x5d29b8fb5b00 : "handle") Word(0x5d29b8fb5b00 : "handle")
: expr contains handle? true
: Word(0x5d29b8fb5b00 : "handle") vs Word(0x5d29b8fb5b00 : "handle")
: 
: [true 1]

#+begin_src kcats
+ handle type
#+end_src

#+RESULTS:
#+begin_example
Env: [Word(0x577eb3e95b00 : "handle"), Entry(Entry { word: 0x577eb3ea5000 : "type", examples: Some([List([List([List([List([Word(0x577eb3ed46b0 : "foo"), Int(1)])]), Word(0x577eb3ea5000 : "type")]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Int(1)]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Float(1.0)]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([List([])]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([String("foo"), Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([String("foo")]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3ed46b0 : "foo")])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3ed46b0 : "foo")]), List([Word(0x577eb3f20780 : "attr"), String("blah")])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3f20570 : "attr1"), Word(0x577eb3ed46b0 : "foo")]), List([Word(0x577eb3f20640 : "attr2"), String("blah")])]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ed46b0 : "foo"), Int(1)])]), List([List([Word(0x577eb3ed46b0 : "foo")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), List([List([List([List([Word(0x577eb3ea5000 : "type"), Word(0x577eb3f202d0 : "url")]), List([Word(0x577eb3edb6e0 : "value"), String("http://foo.com")])]), Word(0x577eb3ea5000 : "type")]), List([List([Word(0x577eb3f202d0 : "url")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([List([List([Word(0x577eb3ed0c80 : "nothing?")]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3eb3c80 : "association?", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3eb3c80 : "association?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([List([List([Word(0x577eb3ea5000 : "type")]), Word(0x577eb3ed4460 : "lookup")]), List([List([Entry(Entry { word: 0x577eb3ecca20 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x577eb3ecca20 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e94940 : "number")])]), serialize: false, definition: Builtin }), Int(1), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), List([Word(0x577eb3ea5000 : "type")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ebdf40 : "second", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ebdf40 : "second")]), List([Int(5)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ea2e60 : "if")]), List([List([])]), Word(0x577eb3ea2e60 : "if")]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x577eb3ea9ba0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x577eb3e93f70 : "+")]), Word(0x577eb3ea9ba0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x577eb3e93f70 : "+")]), Int(4), Word(0x577eb3ea6df0 : "swap"), Word(0x577eb3ea9ba0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x577eb3ea6a70 : "program")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ee54c0 : "any?")])]), List([List([Entry(Entry { word: 0x577eb3ea22b0 : "list?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Int(5), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea6cf0 : "list")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea4130 : "number?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Int(5), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Float(5.01), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ed46f0 : "word?", examples: Some([List([List([Word(0x577eb3ed46b0 : "foo"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Word(0x577eb3ed46b0 : "foo")]), Word(0x577eb3eac3a0 : "unwrap"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea4170 : "word")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecac30 : "bytes?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ec8d40 : "string?", examples: Some([List([List([String("hi"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String(""), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([String("hi")]), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecc550 : "pipe?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3edd950 : "pipe")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea2600 : "error?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3f08630 : "error")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), Entry(Entry { word: 0x577eb3ede4f0 : "decide", examples: Some([List([List([Int(5), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(5), String("five")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), String("something else")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), List([])])])]), spec: Some([List([List([Word(0x577eb3e97180 : "association"), Word(0x577eb3ede280 : "test-expr-pairs")])]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea6df0 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea6df0 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")])]), List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea67c0 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b"), Word(0x577eb3ea6e10 : "c")]), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([])]), serialize: false, definition: Builtin })] })]
handle is Word(0x577eb3e95b00 : "handle") Word(0x577eb3e95b00 : "handle")
expr contains handle? true
Word(0x577eb3e95b00 : "handle") vs Word(0x577eb3e95b00 : "handle")
Env: [List([List([List([Word(0x577eb3ed0c80 : "nothing?")]), List([List([Entry(Entry { word: 0x577eb3eb5060 : "nothing", examples: None, spec: Some([List([]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: [List([])] })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3eb3c80 : "association?", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3eb3c80 : "association?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([List([List([Word(0x577eb3ea5000 : "type")]), Word(0x577eb3ed4460 : "lookup")]), List([List([Entry(Entry { word: 0x577eb3ecca20 : "count", examples: Some([List([List([List([String("a"), String("b"), String("c")]), Word(0x577eb3ecca20 : "count")]), List([Int(3)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e94940 : "number")])]), serialize: false, definition: Builtin }), Int(1), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), List([Word(0x577eb3ea5000 : "type")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3e95ef0 : "=", examples: Some([List([List([Int(1), Int(2), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([Int(1), Int(1), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), List([]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Int(1)]), List([]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Int(1), List([Word(0x577eb3e96630 : "false")])]), List([Int(1), List([Word(0x577eb3e96630 : "false")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("foo")])]), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("hi"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String("hi"), String("there"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([]), Word(0x577eb3e969f0 : "true"), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([Float(1.0), List([String("foo")])]), List([Float(1.0), List([String("bar")])]), Word(0x577eb3e95ef0 : "=")]), List([List([])])]), List([List([List([List([]), List([]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])])])]), spec: Some([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ebdf40 : "second", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ebdf40 : "second")]), List([Int(5)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), List([Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ecc6d0 : "first", examples: Some([List([List([List([Int(4), Int(5), Int(6)]), Word(0x577eb3ecc6d0 : "first")]), List([Int(4)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e96c00 : "item")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ea2e60 : "if")]), List([List([])]), Word(0x577eb3ea2e60 : "if")]), List([List([Entry(Entry { word: 0x577eb3e97180 : "association", examples: Some([List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")]), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), List([List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3ea6e10 : "c"), Word(0x577eb3eb3d40 : "d")])]), Word(0x577eb3e97180 : "association"), Word(0x577eb3e95ef0 : "=")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e97180 : "association")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([Entry(Entry { word: 0x577eb3ea9ba0 : "execute", examples: Some([List([List([List([Int(1), Int(2), Word(0x577eb3e93f70 : "+")]), Word(0x577eb3ea9ba0 : "execute")]), List([Int(3)])]), List([List([Int(2), List([Word(0x577eb3e93f70 : "+")]), Int(4), Word(0x577eb3ea6df0 : "swap"), Word(0x577eb3ea9ba0 : "execute")]), List([Int(6)])])]), spec: Some([List([Word(0x577eb3ea6a70 : "program")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })]), Word(0x577eb3ee54c0 : "any?")])]), List([List([Entry(Entry { word: 0x577eb3ea22b0 : "list?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([]), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Int(5), Word(0x577eb3ea22b0 : "list?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea6cf0 : "list")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea4130 : "number?", examples: Some([List([List([List([Int(1)]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([List([]), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Int(5), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Float(5.01), Word(0x577eb3ea4130 : "number?")]), List([Word(0x577eb3e969f0 : "true")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3e94940 : "number")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ed46f0 : "word?", examples: Some([List([List([Word(0x577eb3ed46b0 : "foo"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([Word(0x577eb3ed46b0 : "foo")]), Word(0x577eb3eac3a0 : "unwrap"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ed46f0 : "word?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3ea4170 : "word")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecac30 : "bytes?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ecac50 : "bytes", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ecac50 : "bytes")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ec8d40 : "string?", examples: Some([List([List([String("hi"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([String(""), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e969f0 : "true")])]), List([List([List([String("hi")]), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])]), List([List([Word(0x577eb3e969f0 : "true"), Word(0x577eb3ec8d40 : "string?")]), List([Word(0x577eb3e96630 : "false")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Entry(Entry { word: 0x577eb3ea6420 : "string", examples: Some([List([List([Int(1), Word(0x577eb3ea6420 : "string")]), List([String("1")])]), List([List([List([Int(1), Int(2), Int(3)]), Word(0x577eb3ea6420 : "string")]), List([String("[1 2 3]")])]), List([List([List([]), Word(0x577eb3ea6420 : "string")]), List([String("[]")])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3ea6420 : "string")])]), serialize: false, definition: Builtin })]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ecc550 : "pipe?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3edd950 : "pipe")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])]), List([List([Entry(Entry { word: 0x577eb3ea2600 : "error?", examples: None, spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([Word(0x577eb3e96820 : "boolean")])]), serialize: false, definition: Builtin })]), List([List([Word(0x577eb3f08630 : "error")]), Entry(Entry { word: 0x577eb3eac3a0 : "unwrap", examples: Some([List([List([List([Int(1)]), Word(0x577eb3eac3a0 : "unwrap")]), List([Int(1)])])]), spec: Some([List([Word(0x577eb3ea6cf0 : "list")]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin })])])]), Entry(Entry { word: 0x577eb3ede4f0 : "decide", examples: Some([List([List([Int(5), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(5), String("five")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])]), List([List([Word(0x577eb3e969f0 : "true")]), List([String("something else")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), String("something else")])]), List([List([Int(9), List([List([List([Int(3), Word(0x577eb3e95ef0 : "=")]), List([String("three")])]), List([List([Int(5), Word(0x577eb3e95ef0 : "=")]), List([String("five")])]), List([List([Int(7), Word(0x577eb3e95ef0 : "=")]), List([String("seven")])])]), Word(0x577eb3ede4f0 : "decide")]), List([Int(9), List([])])])]), spec: Some([List([List([Word(0x577eb3e97180 : "association"), Word(0x577eb3ede280 : "test-expr-pairs")])]), List([Word(0x577eb3e946e0 : "*")])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea6df0 : "swap", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea6df0 : "swap")]), List([Int(1), Int(3), Int(2)])])]), spec: Some([List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")])]), List([List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea6a50 : "b")]), List([Word(0x577eb3e96c00 : "item"), Word(0x577eb3ea63c0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x577eb3ea67c0 : "discard", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2)])]), List([List([Int(1), Int(2), Int(3), List([Word(0x577eb3ea63c0 : "a"), Word(0x577eb3ea6a50 : "b"), Word(0x577eb3ea6e10 : "c")]), Word(0x577eb3ea67c0 : "discard")]), List([Int(1), Int(2), Int(3)])])]), spec: Some([List([Word(0x577eb3e96c00 : "item")]), List([])]), serialize: false, definition: Builtin })]
handle is Word(0x577eb3e95b00 : "handle") Word(0x577eb3e95b00 : "handle")
expr contains handle? false
unhandled err!

stack: [[[reason "not enough items on stack"] [asked [consume]] [type error]]]
expression: [[[[nothing?] [[nothing] unwrap]] [[association?] [[[[type] lookup] [[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[association] unwrap]] [execute] any?]] [[list?] [[list] unwrap]] [[number?] [[number] unwrap]] [[word?] [[word] unwrap]] [[bytes?] [[bytes] unwrap]] [[string?] [[string] unwrap]] [[pipe?] [[pipe] unwrap]] [[error?] [[error] unwrap]]] decide swap discard]
#+end_example

Looks like the word =error?= is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
=type=, which expects the builtin version of =error?=).

#+begin_src kcats
[[expression [+]]] environment eval-step 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]]]] [expression []]]]

#+begin_src kcats
[[expression [1 +]]] environment advance advance advance 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [expression [+]]]]

#+begin_src kcats
[[expression [[[3]] [+ handle] dip]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [expression [+_handle [[[3]]] unwrap]]]]

#+begin_src kcats
[[expression [+ handle]]] environment eval-step eval-step
#+end_src

#+RESULTS:
: { stack: [], expression: [[[expression [+ handle]]] environment eval-step eval-step] }
: { stack: [[[expression [+ handle]]]], expression: [environment eval-step eval-step] }
: { stack: [[[stack []] [expression [+ handle]]]], expression: [eval-step eval-step] }
: { stack: [], expression: [+ handle] }
: { stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]], expression: [eval-step] }
: { stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], expression: [+ handle] }
: 
: [[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [expression [+ handle]]]]

There is a problem in the design where an error (with no =handle=) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.

A possible solution is to have whatever =eval= we're using halt but
remove the =halt= bit (in the current design it's the =is_handled=
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.

Also for nested envs we need several words to help deal with errors:

+ a word that tells whether the env will halt: that there's an error
  on ToS with halt bit set, and =handle= does not appear in the
  expression. The word can efficiently return =false= if ToS isn't an
  Error.

+ A word that removes the halt bit - as the last thing to do before
  exiting.

So what about the word =advance= that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In =eval= it's pretty obvious if we
halted on error - the expression isn't empty (that's the only other
reason to stop). We could see in =advance= that the expression got
longer, but isn't very obvious in many cases.

Another possibility is letting the expression unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
=recover= is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the expression that will know what to do. But
there may not be, and the end result is a major unwind of the
expression, at least, all the way to the deepest =recover=. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on. 

But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong *and*
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.

Maybe another possibility is unwinding the expression **into** the
error object. In other words, whatever expression items we lop off, we
save them in the error object, in a field named, say, =unwound= or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
expression from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
=rewind= or something, that restores the expression from the error on
ToS and clears the halt bit.

I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the expression item that threw the error so
we would still have it to retry. I'm thinking syntax like this:

#+begin_src kcats
[+] [[1 1] dip retry] recover
#+end_src

In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:

#+begin_src kcats
[[stack [[[type error] [asked [consume]] [unwound [+]]]]
 [expression [[1 1] dip retry]]]]
#+end_src

So we =dip= the numbers underneath the error, then calling =retry= on
an error will extract the =unwound= field (discarding the rest of the
error) and =execute= it. So then we end up with =1 1 +=.

Ok i actually implemented this (and I don't think it was difficult)
but i don't know what I did with it. I know it worked quite well and I
wanted to keep it. Need to do it again.

#+begin_src kcats
  ;; there needs to be 3 numbers here to add/mult but we forgot!
  + * 1 2 3
  handle ;; catch the error here, stack is empty except the error
  [5 6 7] dip ;; put numbers underneath
  retry ;; rerun what failed before
#+end_src

#+RESULTS:
: 
: [3 2 1 65]

Now put it together using the higher-level =recover=

#+begin_src kcats
  [+ *] [[5 6 7] dip retry] recover
#+end_src

#+RESULTS:
: 
: [65]

*** DONE Lots of association-like objects that aren't
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait *and* make the trait object part of the
Item enum.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar { Int(i32), Foo(Box<dyn Foo>), Quux(Quux) }
#+end_src

#+RESULTS:

Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar<'a> { Int(i32), Foo(&'a dyn Foo), Quux(&'a Quux) }
#+end_src

#+RESULTS:


#+begin_src kcats :results code
  dictionary [advance definition] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[[expression] lookup count] shield swap [[expression] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap discard]]
#+end_src

#+begin_src kcats :results code
  [[expression [1 1 +]]] environment eval-step [stack] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[1]]
#+end_src

#+begin_src kcats :results code
[] environment association?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

#+begin_src kcats
dictionary [fail] lookup
#+end_src

#+RESULTS:
: [[spec [[string] [*]]] [definition []]]

*** DONE scoping of dictionary entries
The original design was to have the dictionary be a single atomic data
structure that code could modify basically at will, with words like
=inscribe= (to add words) etc.

However I think a better design would be something like this:

#+begin_src kcats
  [[add1 [1 +]]] [3 add1] augment
#+end_src

Where the word =augment= takes an association (more specifically, a
dictionary) and overlays that on top of the builtin dictionary. Then
those new words become accessible just as if they were built in, then
the 2nd argument (a program) is executed as usual. After execution,
the learned words are no longer accessible.

It would be possible to nest calls to =augment= (where the program has
its own call to =augment=).

As for implementation, it may be possible to do a kcats-only impl, but
I don't think it's going to perform well. This is going to be the
normal mode of execution. Very few programs will run with only the
builtin words. In fact, it may be a good idea to break up the lexicon
into components - have pipes be a separate library that has to be
loaded with =augment=.

There is some overlap in functionality here, between =decide= and
=augment= - both are designed to provide context. Maybe =decide= provides
context on how a given word (whose overall meaning doesn't change)
applies to a given piece of data. And =augment= provides completely new
words, or provides a new meaning. Probably it's not going to be common
to replace meanings - maybe for security reasons. For example, when
running untrusted code, you may want to eliminate certain words (like
those that have side effects like writing to disk or the
network). That brings up the possible feature of not just merging new
items into the dictionary but doing arbitrary combinators, where =join=
is just a common use case. In that case, maybe =augment= isn't the right
word because you might be actually restricting the dictionary. So we
need a more generic term for "changing the language". Garble? babel?
I like =babel= - it captures the fact that we're moving from one
language (the set of builtin words) to lots of different languages. I also like =lingo=.

#+begin_src kcats
  [[clone *] [square] assign] ;; operate on the dictionary - add word 'square'
  [3 square]
  lingo
#+end_src

would print 9.

The idea here is to have local lingo, possibly down to quite small
pieces of code. I'm thinking on the order of 10 words is probably
enough to have certain words added or changed.

Special care will need to be taken, if you want to change the meaning
of the word, but re-use the old meaning as part of the new
meaning. You can't just overwrite the definition with a new one that
contains the word itself, expecting *that* word to refer to the old
meaning. You'll have to capture the old definition and incorporate
it. =update= should help.
**** What to call this word
+ learn (but unlearn after?)
+ specialize
+ extend
+ adapt
+ augment 
+ refine
+ supplement
+ babel
+ lingo <= front runner.
**** Implementation
It seems viable that we could use the stack to hold dictionary changes.

We'd have to retain a copy of the original dictionary to restore later.

An axiom word like =definitions= or something that sets the dictionary
to ToS would help. I think the rest could be pure kcats.

it'd be something like:

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float ;; d p n
  swapdown ;; d n p
  [redefine ;; p
   execute]
  dip ;; d
  redefine
#+end_src

#+RESULTS:
: 81

A few problems remaining above:
- [X] Need to specify the word inside the definition.
- [X] Need to explicitly convert the definition to an association.

But I think this proves the concept.

Probably want to eventually make a rust implementation.

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float
  swapdown
  [redefine] dip dictionary [square] lookup
 
#+end_src

#+begin_src kcats :results code 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  lingo 
#+end_src

#+begin_src kcats
  dictionary [square] [[definition [clone *]]
                       [spec [[number] [number]]]] assign
  [square] lookup
#+end_src

#+RESULTS:
: Warning, failed to insert into dictionary: List([List([Word(0x5dcc4c2878e0 : "definition"), List([Entry(Entry { word: 0x5dcc4c26dea0 : "clone", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5dcc4c26dea0 : "clone")]), List([Int(1), Int(2), Int(3), Int(3)])])]), spec: Some([List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])]), List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")]), List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5dcc4c2579c0 : "*", examples: None, spec: Some([List([Word(0x5dcc4c258ab0 : "number"), Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])]), serialize: false, definition: Builtin })])]), List([Word(0x5dcc4c25a6a0 : "spec"), List([List([Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])])])])
: []

*** DONE Move environment stuff into own module
#+begin_src kcats :results code
  [[expression [1 2 3]]] environment 
#+end_src

#+RESULTS:
#+begin_src kcats
{ stack: [], expression: [[[expression [1 2 3]]] environment] }
{ stack: [[[expression [1 2 3]]]], expression: [environment] }

[[[stack []] [expression [1 2 3]]]]
#+end_src

#+begin_src kcats
1 2 +
#+end_src

#+RESULTS:
: 
: [3]

*** DONE When printing results, don't wrap the stack
Evaling =1 1 += should print =2=, not =[2]=. We don't have to wrap the
input, so why wrap the output.

*** DONE Update pipes to use enums instead of traits
It's worked out well for everything else, and I don't think anyone
else will be implementing these traits.

Looking at this I am not in that big a hurry to change it, with traits
at least I can spread out the impls into different modules. with enums
that'd be awkward.

*** CANCELED Recover clears the stack built up in the try program
#+begin_src kcats :results code
 [2 3 "four" * +] [] recover
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [unwound [* +]] [type error] [asked [number]]]
#+end_src

Apparently this was my design. I am not so sure about it now, that we
have =retry=. If an error occurs in the middle of a program, what do we
do with the stack? If the recovery is meant to be "try something else
instead of the entire program" then restoring the stack makes
sense. However then that breaks use of =retry= because the recovery
can't pick up where the program left off.

Maybe =recover= and =retry= are mutually exclusive.

We could also use =retry= with =handle=:

#+begin_src kcats
2 3 "four" * + handle [discard 4] dip retry
#+end_src

#+RESULTS:
: 14

To make this work you have to know which item is the potential problem.

Specifying alternates seems useful, such that it will keep retrying
until it hits an empty alternates object or the program finishes. Each
time an alternate is tried it is removed from the list.

#+begin_src kcats
[2 3 ["four" 4] alternates * +] retry 
#+end_src

*** DONE List access and update by index
I think re-using =lookup= and =assign= for lists, using their index, makes sense here:
#+begin_src kcats
  [5 10 15 20] [1] lookup
#+end_src
should print 10.

#+begin_src kcats
  [5 10 15 20] [1] 30 assign
#+end_src

#+RESULTS:
: [5 30 15 20]

 would leave =[5 30 15 20]=.

 The problem here is that this is ambiguous:

#+begin_src kcats
  [[a b] [c d]] [0] [d e] assign

  ;; is it (assigned as a hashmap by key)
  ;;[[a b] [c d] [0 [d e]]]

  ;; or is it (assigned as a vector by index)
  ;;[[d e] [c d]]
#+end_src

#+RESULTS:
: [[d e] [c d]]

We could clear up the ambiguity by saying that int keys on a list mean
vector behavior. If you want the other you have to specify =association=
first.

lets check some corner cases - creating nested lists
#+begin_src kcats
  [1 2 3] [1 0 0] "foo" assign
;; should be [1 [[foo]] 3]
#+end_src

#+RESULTS:
: [1 [["foo"]] 3]

What do we do when we're requested to assign beyond the end of the
list? We can extend the list and pad it with =Nothing=, although this
seems maybe going a bit too far to honor the user's request that maybe
doesn't make sense.

#+begin_src kcats
  [1 2 3] [1 2] "foo" assign
#+end_src

#+RESULTS:
: [1 [[] [] "foo"] 3]

Now let's test mixed list/assoc

#+begin_src kcats
  [1 2 3] [1 foo baz 0] "bar" assign
#+end_src

#+RESULTS:
: [1 [[foo [[baz [[0 "bar"]]]]]] 3]

Note that here, the last 0 index inserts as a map key because the
object is already an assoc. The contract is basically that once you're
in assoc-land you stay there.

Now check the changes for =lookup=

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] lookup
#+end_src

#+RESULTS:
: 45

make sure update works too

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] [inc] update
#+end_src

#+RESULTS:
: [1 4 [34 6 46] 99 23]

#+begin_src kcats
true not
#+end_src

#+RESULTS:
: []

*** DONE write 'let'
#+begin_src kcats :results code
  [[a [1 1 1]]
   [b [6 7 *]]]
  [a b +]
  [wrap
   [[[1] [shield
          wrap
          [[[spec [[] [item]]]]
           [definition]] dip
          assign] ;; build a full entry
     update]
    map association join]
   join] dip
  lingo
#+end_src

#+RESULTS:
#+begin_src kcats
43
#+end_src

i am not sure if just taking the top value is correct here.


#+begin_src kcats :results code
  dictionary
  [[a [1 1 1]]
   [b [6 7 *]]]
  [[1] [shield] update] map association join
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [type error] [unwound [lingo]] [asked [program]]] [a b +] [[- [[examples [[[2 1 -] [1]] [[1.1 2.2 -] [-1.1]] [[2.2 1 -] [1.2]]]] [spec [[number number] [number]]]]] [read [[spec [[string] [item]]] [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]] [first [[spec [[list] [item]]] [examples [[[[4 5 6] first] [4]]]]]] [close [[spec [[[pipe p]] [[pipe p]]]]]] [if [[definition [[shield] dipdown branch]] [spec [[[program false-branch] [program true-branch] [program condition]] [*]]] [examples [[[5 [5 =] [3 *] [4 +] if] [15]] [[6 [5 =] [3 *] [4 +] if] [10]]]]]] [assemble [[definition [swap [take swap] swap put [dip] join [[closed? not]] dip while discard]] [spec [[pipe program] [item]]]]] [dip [[examples [[[1 8 [inc] dip] [2 8]] [[1 2 [dec] unwrap [+] dip] [3 dec]]]] [spec [[program [item a]] [[item a] *]]]]] [nothing? [[examples [[[[] nothing?] [true]] [[1 nothing?] [false]] [[false nothing?] [false]]]] [spec [[item] [boolean]]] [definition [[] =]]]] [sqrt [[spec [[number] [number]]]]] [lookup [[examples [[[[[a b] [c d]] [a] lookup] [[b] unwrap]] [[[[a b] [c d]] [e] lookup] [[]]] [[[[outer [[a b] [c d]]]] [outer c] lookup] [[d] unwrap]]]] [spec [[[list keys] list] [item]]] [definition [[[[swap list?] [something?]] [execute] every?] [take swap [++lookup] dip] while [something?] [[[type error] [asked [association]] [reason "Lookup attempted on non-associative value"]] fail] [discard] if]]]] [filled [[spec [[list] [pipe]]] [definition []]]] [assign [[spec [[[item value] [list keys] association] [association]]] [examples [[[[[a b] [c d]] [a] 5 assign] [[[a 5] [c d]] association]] [[[[a b] [c d]] [e] 5 assign] [[[a b] [c d] [e 5]] association]] [[[[a b] [c [[d e]]]] [c d] 5 assign] [[[a b] [c [[d 5]]]] association]] [[[[a b] [c [[d e]]]] [1 0] 5 assign] [[[a b] [c [5]]]]] [[[1 2 3] [1 0 0] "foo" assign] [[1 [["foo"]] 3]]] [[[1 2 3] [1 2] "foo" assign] [[1 [[] [] "foo"] 3]]] [[[1 2 3] [1 foo baz 0] "bar" assign] [[1 [[foo [[baz [[0 "bar"]]]]]] 3]]]]]]] [pipe-out [[spec [[item] [pipe]]] [definition [[[[type [file] unwrap =] [value file-out]] [[type [ip-port] unwrap =] [clone [address] lookup [[port] lookup] dip serversocket]] [[list?] [+kcats.pipe/->filled]]] decide]]]] [association [[spec [[item] [association]]] [examples [[[[[a b] [c d]] association [[c d] [a b]] association =] [true]] [[[[a b] [c d]] [[c d] [a b]] association =] [false]] [[[[a b] [c d]] [[a b] [c d]] association =] [false]]]]]] [shield [[definition [[snapshot] dip inject first]] [examples [[[1 2 3 [=] shield] [1 2 3 false]]]] [spec [[program] [item]]]]] [< [[spec [[number number] [boolean]]]]] [pair [[examples [[[1 2 pair] [[1 2]]] [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]] [spec [[item item] [list]]] [definition [[wrap] dip put]]]] [buffer [[spec [[integer] [pipe]]] [definition []]]] [swapdown [[examples [[[1 2 3 swapdown] [2 1 3]]]] [spec [[[item a] [item b] [item c]] [[item a] [item c] [item b]]]]]] [string [[examples [[[1 string] ["1"]] [[[1 2 3] string] ["[1 2 3]"]] [[[] string] ["[]"]]]] [spec [[item] [string]]]]] [eval-step [[examples [[[[[expression [1 inc]]] environment eval-step eval-step [stack] lookup] [[2]]]]] [spec [[list] [list]]]]] [inject [[examples [[[1 2 3 [4 5 6] [* +] inject] [1 2 3 [26]]]]] [definition [swap evert take dip evert]] [spec [[program list] [list]]]]] [association? [[spec [[item] [boolean]]] [examples [[[[[a b] [c d]] association?] [true]]]]]] [b 42] [serversocket [[spec [[string integer] [pipe]]]]] [every? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [take swap] swap put [dip swap not] join wrap [dip or] join [[] [[[nothing?] shield] dip swap [or] shielddown] [not]] dip [execute] recur swap discard]] [examples [[[[2 4 6] [even?] every?] [true]] [[[2 4 5] [even?] every?] [false]] [[[] [even?] every?] [true]] [[[2 4 6] [] every?] [true]] [[11 [2 4 6] [+ odd?] every?] [true 11]] [[12 [[even?] [positive?] [3 rem 0 =]] [execute] every?] [true 12]]]]]] [both? [[definition [sink pair swap every?]] [examples [[[1 2 [odd?] both?] [false]] [[1 3 [odd?] both?] [true]]]] [spec [[program item item] [boolean]]]]] [filter [[definition [[snapshot [] swap] dipdown [[clone] dip clone wrap swapdown] swap put [join inject first [[put]] [[discard]] branch swapdown dip] join step discard]] [examples [[[[1 2 3] [odd?] filter] [[1 3]]] [[[2 4 6] [odd?] filter] [[]]] [[33 [1 2 3] [+ odd?] filter] [[2] 33]]]] [spec [[program list] [list]]]]] [file-in [[spec [[string] [pipe]]]]] [shielddowndown [[definition [shield [discard discard] dip]] [spec [[[program p] [item consumed] [item consumed]] [[item result]]]] [examples [[[1 2 3 [+ +] shielddowndown] [1 6]]]]]] [snapshot [[examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]]] [[snapshot] [[]]]]] [spec [[] [list]]] [definition [[] evert clone evert unwrap]]]] [* [[spec [[number number] [number]]]]] [dictionary [[spec [[] [list]]]]] [word? [[examples [[[foo word?] [true]] [[[foo] unwrap word?] [true]] [[true word?] [false]]]] [spec [[item] [boolean]]]]] [put [[spec [[item [pipe in]] [[pipe in]]]]]] [max [[spec [[number number] [number]]] [definition []]]] [positive? [[spec [[number] [boolean]]] [definition [0 >]]]] [float [[examples [[[1 2 3 float] [2 3 1]]]] [spec [[[item a] [item b] [item c]] [[item c] [item a] [item b]]]]]] [zip [[examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]]]]] [spec [[[list values] [list keys]] [association]]] [definition [[[]] dipdown [[take wrap] dip put swap [put] dip] step discard]]]] [quot [[definition []] [spec [[number number] [number]]]]] [reverse [[spec [[list] [list]]] [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]] [string? [[examples [[["hi" string?] [true]] [["" string?] [true]] [[["hi"] string?] [false]] [[true string?] [false]]]] [spec [[item] [boolean]]]]] [disassemble [[definition [[swap [put] dip] join [nothing? not] swap while discard]] [spec [[program item [pipe in]] [[pipe in]]]]]] [step [[examples [[[1 [2 3 4] [*] step] [24]] [[1 [] [*] step] [1]]]] [spec [[program list] [*]]]]] [wrap [[examples [[[1 wrap] [[1]]] [[[1 2] wrap] [[[1 2]]]]]] [spec [[item] [list]]]]] [> [[spec [[number number] [boolean]]] [examples [[[2 1 >] [true]] [[1.1 2.2 >] [false]] [[2.2 1 >] [true]]]]]] [zero? [[spec [[number] [boolean]]] [definition [0 =]] [examples [[[0 zero?] [true]] [[0 zero?] [true]] [[-0.00001 zero?] [false]] [[1.1 zero?] [false]]]]]] [addmethod [[spec [[[pair condition] [program combinator] word] []]] [definition [float [wrap dictionary swap lookup] shield [wrap swap put] dipdown float [float [execute] dip] join inject swap inscribe]]]] [lingo [[definition [dictionary sink [clone] dipdown [execute] dip float swapdown [redefine execute] dip redefine]] [examples [[[[[square] [[definition [clone *]] [spec [[number] [number]]]] assign] [9 square] lingo] [81]]]] [spec [[[program enriched-lexicon] [program dictionary-modifier]] [*]]]]] [redefine [[spec [[association] []]]]] [unassign [[spec [[[item key] association] [association]]] [examples [[[[[a b] [c d]] [a] unwrap unassign] [[[c d]] association]] [[[[a b] [c d]] [e] unwrap unassign] [[[a b] [c d]] association]]]]]] [swap [[examples [[[1 2 3 swap] [1 3 2]]]] [spec [[[item a] [item b]] [[item b] [item a]]]]]] [prepend [[spec [[item list] [list]]] [examples [[[[1 2] 3 prepend] [[3 1 2]]]]] [definition [wrap swap join]]]] [spawn [[spec [[program] []]] [definition []]]] [recur [[spec [[[program rec2] [program rec1] [program true-branch] [program pred]] [*]]] [examples [[[3 [1 <=] [] [clone dec] [execute *] recur] [6]]]]]] [closed? [[spec [[pipe] [boolean]]]]] [sink [[spec [[[item a] [item b] [item c]] [[item b] [item c] [item a]]]] [examples [[[1 2 3 sink] [3 1 2]]]]]] [negative? [[spec [[number] [boolean]]] [definition [0 <]]]] [evaluate [[examples [[[[[expression [1 2 3 4 + *]]] environment evaluate [stack] lookup] [[14 1]]]]] [spec [[list] [list]]]]] [not [[examples [[[1 even? not] [true]] [[false not] [true]] [[true not] [false]] [[[] not] [true]]]] [spec [[item] [boolean]]]]] [timeout [[definition []] [spec [[integer] [pipe]]]]] [environment [[examples [[[[[expression [1 2 3]]] environment eval-step [stack] lookup] [[1]]]]] [spec [[association] [list]]]]] [bytes? [[spec [[item] [boolean]]]]] [update [[examples [[[[[a 1] [b 2]] [b] [inc] update] [[[a 1] [b 3]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a c] [inc] update] [[[a [[c 4] [d 5]]] [b 2]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a c] [discard 10 15] update] [[[a [[c 15] [d 5]]] [b 2]] association]] [[[[a 1] [b 2]] [d] [5] update] [[[a 1] [b 2] [d 5]] association]] [[[[a [[c 3] [d 5]]] [b 2]] [a e] [5 6 +] update] [[[a [[c 3] [d 5] [e 11]]] [b 2]] association]]]] [definition [[[lookup] shield] dip shielddown assign]] [spec [[program [list keys] association] [association]]]]] [tunnel [[definition [[[[type [ip-port] unwrap =] [clone [port] lookup [[address] lookup] dip !**java.net.Socket.]]] decide]] [spec [[item] [pipe]]]]] [number? [[spec [[item] [boolean]]] [examples [[[[1] number?] [false]] [[[] number?] [false]] [[5 number?] [true]] [[5.01 number?] [true]]]]]] [loop [[spec [[program [item flag]] [*]]] [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]] [select [[definition []] [spec [[[list pipes]] [item pipe [list pipes]]]]]] [evert [[spec [[list] [list *]]] [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]]]]]]] [advance [[spec [[environment] [environment]]] [definition [[[expression] lookup count] shield swap [[expression] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap discard]]]] [dipdown [[spec [[program [item a] [item b]] [[item a] [item b] *]]] [examples [[[1 2 3 [inc] dipdown] [2 2 3]]]]]] [map [[spec [[program list] [list]]] [examples [[[[1 2 3] [inc] map] [[2 3 4]]] [[1 [1 2 3] [+] map] [[2 3 4] 1]] [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]] [[7 9 [+] [] map] [[+] 9 7]]]] [definition [[snapshot [] swap] dipdown [wrap swap clone float] swap put [[swap join] dip inject first swap [put] dip] join step discard]]]] [primrec [[examples [[[5 [1] [*] primrec] [120]]]] [spec [[[program rec1] [program exit] [number data]] [*]]] [definition [[execute] swap join [[discard] swap join] dip [[zero?]] dipdown [[clone dec]] dip recur]]]] [execute [[spec [[program] [*]]] [examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]]]] [clone [[examples [[[1 2 3 clone] [1 2 3 3]]]] [spec [[[item a]] [[item a] [item a]]]]]] [or [[examples [[[1 odd? 3 even? or] [true]] [[1 2 or] [1]] [[[] 2 or] [2]] [[[] [] or] [false]]]] [spec [[item item] [item]]]]] [= [[spec [[item item] [boolean]]] [examples [[[1 2 =] [[]]] [[1 1 =] [true]] [[[] [] =] [true]] [[[1] [] =] [[]]] [[[1 [false]] [1 [false]] =] [true]] [[[1 ["foo"]] [1 ["foo"]] =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [[]]] [[[] true =] [[]]] [[[1 ["foo"]] [1 ["bar"]] =] [[]]] [[[[] [] association =] [true]]]]]]] [take [[spec [[[pipe out]] [item [pipe out]]]]]] [something? [[definition [nothing? not]] [spec [[item] [boolean]]] [examples [[[1 something?] [true]] [[false something?] [true]] [[[] something?] [false]]]]]] [type [[examples [[[[[foo 1]] type] [[foo] unwrap]] [[1] [[number] unwrap]] [[1] [[number] unwrap]] [[[]] [[nothing] unwrap]] [["foo" bytes] [[bytes] unwrap]] [["foo"] [[string] unwrap]] [[[[type foo]] [[foo] unwrap]]] [[[[type foo] [attr "blah"]] [[foo] unwrap]]] [[[[attr1 foo] [attr2 "blah"]] [[association] unwrap]]] [[[[foo 1]] [[foo] unwrap]]] [[[[type url] [value "http://foo.com"]] type] [[url] unwrap]]]] [spec [[item] [item]]] [definition [[[[nothing?] [[nothing] unwrap]] [[association?] [[[[type] lookup] [[count 1 =] [[first [type] unwrap =] [first second] [first first] if] [[]] if] [[association] unwrap]] [execute] any?]] [[list?] [[list] unwrap]] [[number?] [[number] unwrap]] [[word?] [[word] unwrap]] [[bytes?] [[bytes] unwrap]] [[string?] [[string] unwrap]] [[pipe?] [[pipe] unwrap]] [[error?] [[error] unwrap]]] decide swap discard]]]] [fail [[spec [[association] [*]]]]] [decide [[examples [[[5 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]] [[true] ["something else"]]] decide] [5 "five"]] [[9 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]] [[true] ["something else"]]] decide] [9 "something else"]] [[9 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]]] decide] [9 []]]]] [spec [[[association test-expr-pairs]] [*]]]]] [break [[spec [[environment [program condition]] [environment [program condition]]]] [definition [[[[[expression] lookup something?] [swap execute not]] [execute] every?] [eval-step] while]]]] [unwrap [[spec [[list] [*]]] [examples [[[[1] unwrap] [1]]]]]] [handoff [[spec [[] [pipe]]] [definition []]]] [even? [[spec [[number] [boolean]]]]] [assert [[definition [snapshot [shield] dip swap [discard] [string ["assertion failed "] dip join fail] branch]] [spec [[program] [*]]]]] [rest [[spec [[list] [list]]] [examples [[[[1 2 3] rest] [[2 3]]]]]]] [false [[spec [[] [item]]] [definition [nothing]]]] [pump [[spec [[program [pipe in] [pipe out]] [[pipe in] [pipe out]]]] [definition [wrap [shield] join [[] sink [put] dip swapdown [put] dip [[closed?] any?] dip swap]]]]] [branch [[examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]] [spec [[[program false-branch] [program true-branch] [item condition]] [*]]]]] [rem [[spec [[number number] [number]]] [definition []]]] [/ [[spec [[number number] [number]]]]] [value [[definition [[count 1 =] [first second] [[value] lookup] if]] [examples [[[[[foo 1]] value] [1]] [[[[type url] [value "http://foo.com"]] value] ["http://foo.com"]]]] [spec [[association] [item]]]]] [dec [[spec [[number] [number]]]]] [any? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [take swap] swap put [dip swap] join wrap [dip or] join [[] [[[nothing?] shield] dip swap [or] shielddown] []] dip [execute] recur swap discard]] [examples [[[[2 4 6] [even?] any?] [true]] [[[3 5 7] [even?] any?] [false]] [[[] [even?] any?] [false]] [[[2 4 6] [] any?] [2]] [[11 [3 5 6] [+ odd?] any?] [true 11]] [[-15 [[even?] [positive?] [3 rem 0 =]] [execute] any?] [true -15]]]]]] [and [[examples [[[1 odd? 2 even? and] [true]]]] [spec [[item item] [item]]]]] [pipe-in [[spec [[item] [pipe]]] [definition [[[[type [file] unwrap =] [value file-in]] [[type [stdout] unwrap =] [stdout]]] decide]]]] [nothing [[definition [[]]] [spec [[] [item]]]]] [range [[examples [[[1 5 range] [[1 2 3 4]]]]] [spec [[integer integer] [list]]]]] [take [[spec [[list] [item list]]] [examples [[[["a" "b" "c"] take] [["b" "c"] "a"]]]]]] [count [[examples [[[["a" "b" "c"] count] [3]]]] [spec [[list] [number]]]]] [list? [[examples [[[[1] list?] [true]] [[[] list?] [true]] [[5 list?] [false]]]] [spec [[item] [boolean]]]]] [retry [[spec [[error] [*]]] [examples [[[2 3 "four" * + handle [discard 4] dip retry] [14]]]] [definition [[unwound] lookup execute]]]] [min [[spec [[number number] [number]]] [definition []]]] [spit [[definition [[pipe-in] dip bytes put close discard]] [spec [[item [item target]] []]]]] [ceil [[spec [[number] [integer]]]]] [atom [[definition []] [spec [[item] [pipe]]]]] [join [[examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]] [["ab" "cd" join] ["abcd"]] [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]]] [spec [[item item] [item]]]]] [odd? [[spec [[number] [boolean]]]]] [file-out [[spec [[string] [pipe]]]]] [discard [[spec [[item] []]] [examples [[[1 2 3 discard] [1 2]] [[1 2 3 [a b c] discard] [1 2 3]]]]]] [tos [[examples [[[[[stack [1 2 3]] [expression [[+] step]]] tos] [1]]]] [definition [[stack] lookup first]] [spec [[environment] [item]]]]] [+ [[examples [[[1 2 +] [3]] [[1.1 2.2 +] [3.3]] [[1 2.2 +] [3.2]]]] [spec [[number number] [number]]]]] [second [[spec [[list] [item]]] [examples [[[[4 5 6] second] [5]]]]]] [recover [[examples [[[[+] [discard 1 [+] [discard 2 +] recover] recover] [3]] [5 [1 2 "oh fudge"] [[+] [discard discard] recover] map] [5 [6 7 5]] [[swap] [swap] recover] [swap]]] [definition [[[handle] join] dip [snapshot] dipdown sink inject [first error?] [first swap execute] [evert discard] if]] [spec [[program program] [*]]]]] [inc [[examples [[[1 inc] [2]] [[-1 inc] [0]] [[99 inc] [100]]]] [spec [[number] [number]]]]] [put [[examples [[[[] 1 put] [[1]]] [[[1 2 3] 4 put] [[1 2 3 4]]] [["foo" bytes 32 put string] ["foo "]]]] [spec [[item list] [list]]]]] [true [[spec [[] [word]]]]] [pipe? [[spec [[item] [boolean]]]]] [error? [[spec [[item] [boolean]]]]] [bytes [[spec [[item] [bytes]]]]] [a 1] [while [[examples [[[3 [0 >] [clone dec] while] [3 2 1 0]]]] [spec [[[program body] [program pred]] [*]]] [definition [swap wrap [shield] join clone dipdown join loop]]]] [>= [[spec [[number number] [boolean]]]]] [shielddown [[examples [[[1 2 3 [=] shielddown] [1 2 false]]]] [definition [shield swap discard]] [spec [[program item] [item]]]]] [derivations [[definition [[]]]]] [times [[definition [swap [dec] swap put [dip] join [0 >] swap while discard]] [spec [[[integer howmany] [program body]] [*]]]]] [++lookup [[spec [[item association] [item]]]]] [mod [[spec [[number number] [number]]]]] [<= [[spec [[number number] [boolean]]]]] [toe [[examples [[[[[stack [1 2 3]] [expression [[+] step]]] toe] [[+]]]]] [definition [[expression] lookup first]] [spec [[environment] [item]]]]]]
#+end_src

Need a way of converting an item to an entry that just pushes that item.

#+begin_src kcats :results code
  1 wrap [[[spec [[[] [item]]]]] [definition]] dip assign 
#+end_src

#+RESULTS:
#+begin_src kcats
[[spec [[[] [item]]]] [definition [1]]]
#+end_src

#+begin_src kcats :results code
  dictionary
  [[spec [[] [item]]]
   [definition [23]]]
  [fooptoopy] swap assign
  [fooptoopy] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[spec [[] [item]]] [definition [23]]]
#+end_src

#+begin_src kcats
  [[a [1 1 1]]
   [b [6 7 *]]]
  [a b +] let
#+end_src

*** TODO Error should have actual struct fields :optimization:
It's still implemented as generic Hashmap data field. 

*** TODO Script
**** DONE Cryptographic primitives
***** DONE SHA256
#+begin_src kcats
"foo" bytes hash "fop" bytes hash =
#+end_src

#+RESULTS:
: []

#+begin_src kcats
  ["foo" bytes key] 2 times =
#+end_src

#+RESULTS:
: true

#+begin_src kcats
"foo" bytes key
#+end_src

#+RESULTS:
: [[public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="] [type elliptic-curve-key] [secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="]]

***** DONE Signing
#+begin_src kcats :results code
  "foo" bytes key "we attack at dawn" bytes [sign] shield verify
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

#+begin_src kcats :results code
  "foo" bytes key "we attack at dawn" bytes [sign] shield
  ;; now change the message
  [discard "we attack at sunset" bytes] dip
  verify
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

***** TODO AES Encryption
***** TODO Random
**** DONE Pure functional env
#+begin_src kcats
  [[pipe-in pipe-out channel timeout handoff file-in file-out timestamps standard serversocket animate future spit tunnel ] [wrap unassign] step] [1 2 swap] lingo
#+end_src

#+RESULTS:
: 1 2
**** TODO Infinite loop protection
We need to prevent an attacker presenting =true [clone] loop= as their
identity proof, which would never halt. It may be easiest to just
remove all the looping words from the dictionary, but that seems
overly restrictive, when the point is just to limit the resources an
attacker can consume, and we already have a direct solution for that:

#+begin_src kcats
[[expression [true [clone] loop]]] environment
#+end_src
*** DONE Multithreading
**** Overview
There are a few major components here:
+ Be able to tell whether an environment can advance. It's basically
  "if there's nothing in the expression, it's done, otherwise it can
  run unless it's currently putting/taking from a pipe"
**** Pipes
It's not clear to me what to do about pipes. As soon as we call =take=
(for example) we're going to block the rust thread. In order to use
lightweight "threads" we're going to need a non-blocking check to see
if something can come out (or fit in) the pipe. For things like files
and sockets, it looks like we will need =tokio=.

tokio has Task which can manage this. It looks like tokio has file io
and network io that will automatically yield and allow other tasks to
run.

So then another question is, how to use something like =select= in
kcats. It might be possible to pass in a list of pipes to select and
then return the item that came out (along with the pipe itself i
guess). But this is advanced functionality that probably isn't a high
priority.

I think the basic design here is that each environment is a single
"thread" of execution, and that will map to a tokio Task. Pipe
operations within an env will call the async functions but will
immediately =await=. That should yield to allow other envs to run.

It looks like the =async= will creep all the way up to =axiom::eval=. If
the criteria is that anything we want to be able to pre-empt (if it's
waiting on i/o) needs to be labeled async, then everything up to =eval=
is going to be =async=.

I think that means fns like =f_stack1= etc will need to be async because
the =f= it calls can potentially call i/o. Actually it's probably best
to make new async versions of these so we don't have to make all the
Item fns async too.

We'll also need to think about what to do about dangling
environments - let's say we have the main env, and it spawns env e,
which will feed values back to main. But let's say main is done and
doesn't want any more values from e. Is the entire program done and we
can garbage collect e? My first instinct here is to blow everything
away as soon as main is done. If we don't want to exit we should be
taking from a pipe that won't produce anything until we're ready to
exit. So we're not going to =join= with other environment's tasks.
**** DONE Add tokio as dep
**** DONE Prepare for multithreading
***** DONE Use Arc instead of Rc
Does Arc have =make_mut=?  Yes! So hopefully it will be a drop-in
replacement.
**** DONE Update pipe types for fs and net to use tokio calls
One problem here is that we don't have a trivial way to mix step
functions that are pure vs involving pipes.

If we don't know until runtime what it is, we have to assume async and
there's probably a huge performance hit.

Maybe one way to proceed is to make an =Item= variant =Future=. So if
we're taking from a pipe, we can just put the =Future= on the stack and
continue. Of course, very soon we'll need to access the value and call
=await= on it. 

What then, do we do about =put=? Let's say the pipe is full and the put
needs to wait. We can return the Env but we still need to await sometime.

Maybe in eval-step, we can check if the top item is a Future. If so,
await it. If it returns another Item, replace it. If it returns Unit,
just discard it. Somewhere we'd need a type =Option<Item>= for what the
futures return (None if we're just waiting on a value to put into a
pipe, Item if we're taking)

So will this work in nested envs? I am not sure but I can't think of
why it wouldn't.

If this works then only eval/eval-step will need =async=.
**** DONE Use channel type to implement handoff pipe
***** DONE Use crossbeam channels
mpsc doesn't allow us to clone the receiver (Out) end of the pipe, and
that would seem like a rather sharp corner to users of kcats who
generally aren't too performance sensitive and want simple programs to
"just work".

#+begin_src kcats :results code
  handoff clone
  wrap [5 put "hello" put] join
  [] swap [[expression]] dip assign environment animate take [take] dip
#+end_src

#+RESULTS:
#+begin_src kcats
5 "hello" [[type pipe] [handoff todo: id-or-hash here]]
#+end_src

#+RESULTS:
:

One issue here is that we accidentally made a bidirectional channel. I
don't know if that should be the default mode of operation. When we
create a handoff maybe we should really create two stack items: the in
and out. 

The question is, what should be a tunnel? I am not sure single stack
items really should allow both put and take.

The problem with splitting them is it can exascerbate the already
difficult problem of stack manipulation (if indeed you actually need
to read from a file and then write to the same spot... is that
common?)

The benefit is that a process that's supposed to be reading can't
accidentally write, if it doesn't have the In part of the pipe.

For now I think I'm inclined to leave it as-is and see how it goes.
***** TODO Nonblocking eval-step (for inner envs)
It would be nice if calling eval-step on an inner env and having it
block, wouldn't block the outer env (or at least it would be nice if
it were an option not to wait). Maybe =try_eval_step= which tries to
make progress immediately and if it can't, just returns as-is.

There's probably a way to do this by polling the future. using =select!=
with a short timeout future would do it but there's probably a better
way.
***** TODO Combine implementations for net and fs
They're both using AsyncReadExt and AsyncWriteExt methods. The only
difference between them is how the pipes are created. It would be
easier to make pipes for stdin/stdout this way.  I tried it but the
compiler complained about not being able to make trait objects out of
them. Will revisit later.

**** DONE Implement 'spawn' or equavalent
Can probably think of a better name. What we're doing is taking an
environment that's a local piece of data on the stack and spitting it
out to make it its own autonomous thing.
=animate= seems rather fitting.

#+begin_src kcats
 [[expression [+ 1 1]]] environment animate 
#+end_src

#+RESULTS:
: 
**** DONE Implement 'future' or equivalent
The idea here is to take an expression and run it in its own spawned
env, and when it's done, snapshot the stack and put it into a
pipe and close it. The original env gets the other end of the pipe.

I think the new env should probably inherit the current env's stack.
#+begin_src kcats :results code
  1 2 [+] 
  ;; make a pipe
  handoff swap
  ;; save the stack, including pipe
  [snapshot] dip
  ;; prepare the program for the new env
  ;; end up with [[+ snapshot] dip swap put]
  [snapshot] join wrap [dip swap put discard] join
  ; ;; now we have expr stack
  pair
  [stack expression] swap zip environment
  animate take
#+end_src

#+RESULTS:
#+begin_src kcats
[3] [[type pipe] [handoff todo: id-or-hash here]] 2 1
#+end_src

#+begin_src kcats
  1 [2 +] future take swap discard
#+end_src

#+RESULTS:
: [3] 1
*** TODO retry should have opposite argument order :stdlib:consistency:
Currently it expects an error on ToS and then a program beneath. But
it seems like we'd nearly always have to =dip= the program beneath the
error. I think it would be better if =retry= expected the program to fix
the issue on top, and the error beneath.
*** INPROGRESS Support Kademlia DHT
**** DONE XOR
We have a node id (maybe just the i2p destination address?) and we
want to calculate the distance to another node as the XOR
**** INPROGRESS Simple API server
Construct a socket listener, and serve something from a trivial local
database. Disable exploitable words.

#+begin_src kcats :tangle net.kcats
  ;; create an API service
  ;; 
  ;; Takes from the stack:
  ;; 
  ;; * a Database (can be a regular data structure for read-only apis),
  ;; or a pipe to an actual (sql or other) database that accepts queries for
  ;; read/write ops
  ;;
  ;; * a program that modifies the dictionary that clients can
  ;; access. It should add words to make interaction easier (for
  ;; example, you might provide a word 'customers' that gets the customers
  ;; db table). It should also remove words that the clients should not be able
  ;; to use - for example, they shouldn't be able to create file or network pipes. 
  ;;
  ;; * a server socket pipe to serve from
  ;;
  ;; The client sends a program to run in a fresh environment where he
  ;; can expect to find:
  ;;
  ;; * The database (either a pipe or data structure)
  ;;
  ;; His program runs and then the resulting stack is returned to him.
  ;; 
  ;; socket listener
  [[type ip-port] [port 12121] [address "127.0.0.1"]] pipe-out

  ;; sample local db - list of people and their game high
  ;; scores
  [[[name "joe"] [age 25] [score 1000]]
   [[name "jane"] [age 35] [score 1100]]
   [[name "tommy"] [age 9] [score 870]]
   [[name "carter"] [age 59] [score 670]]]
  [association] map

  [] ;; dictionary modifications 

  ;; API Server code begins here

  dictionary swap execute ;; -> new-dict db sock

  ;; start building the environment
  [[expression [take ;; the request as bytes (todo: know when the request ends) -> req pipe db
                swap ;; we want the pipe on top so we can dip the user's program under it -> pipe req db
                [string ;; translate to a string -> req-str db
                 read ;; the request program into a data structure -> prog db
                 execute ;; the program -> items*
                 snapshot] dip ;; under the pipe so the user's code has no access
                swap ;; -> response pipe
                emit ;; -> response-str pipe
                bytes ;; -> response-bytes pipe
                put ;; the response into the pipe
                discard ;; close the connection
               ]]] environment ;; -> env new-dict db sock 
  [dictionary] float ;; -> new-dict [dictionary] env db sock
  assign  ;; -> env db sock

  ;; now just need to assign the stack, which is [pipe db] 
  float ;; -> sock env db
  ;; loop to accept connections and start new env with the db and a pipe
  ;; to take requests and reply
  [[float ;; -> pipe db env
    pair ;; -> stack env
    [stack] swap ;; -> stack ks env
    assign ;; -> env
    environment
    animate ;; let it fly  
   ] shielddown  ;; shielded so as not to consume the db each time
   discard ;; drop whatever the result is of this iteration, we don't need it
  ]

  step ;; accepts incoming connections until killed
#+end_src
**** TODO Kademlia functions
***** TODO COMMENT Distance
takes two hashes, returns the xor distance between them

helper function that takes an int 0-255 and returns the most
significant bit position, eg 33 is 5

#+begin_src kcats :tangle src/kcats/dht.kcats
  [msb [[spec [[int] [int]]]
        [definition [8 swap [1 >] [2 / [dec] dip] while discard]]
        [examples [[[] []]]]]]
#+end_src

#+begin_src kcats :results code
[[msb [8 swap [1 >] [2 / [dec] dip] while discard]]] [63 msb] let
#+end_src

#+begin_src kcats 
[[msb [+]]] [1 2 msb] let
#+end_src

#+begin_src kcats
  [[msb] [[definition [8 swap [1 >] [2 / [dec] dip] while discard]]
          [spec [[number] [number]]]]
   assign]
  ["foo" hash 0 swap ]
  lingo
#+end_src

#+RESULTS:
: 3

#+begin_src kcats
  "bardddddddd" bytes hash "foodf" bytes hash xor ;; inputs
  ;; function begins here
  -1 swap 0 ;; i bs ct 
  [zero?] 
  [discard take [inc] dipdown]
  while
  float 8 * swap
  ;; calculate the number of leading zeros of the first nonzero byte
  8 swap [1 >] [2 / [dec] dip] while discard
  + ;; add them 
  255 swap - ;; subtract from 255
#+end_src

#+RESULTS:
: 253 #b64 "9xFLZf2AmWe7DRojlnYwLsBsq1Iz7mfo8BYH33X3FQ=="

*** DONE Implement print (opposite of read)
We don't have a way to convert objects to their string serialization
Completed as the word emit
*** TODO read and emit don't have quite the same semantics :consistency:
read will read all the bytes and return however many objects were read.
emit will take an object and return its serialization.

There should be some way of round tripping here, maybe a word =read1= or
something that just reads one object. 
*** TODO Inconsistent stack handling when encountering error :consistency:
Some words pop the arguments off the stack, then if an error is
encountered, throws the error without the args on the stack. Others
leave the args intact. This needs to be consistent.

I would lean towards leaving the args intact so that =retry= is easily applied.
**** TODO 'read' on invalid edn consumes the string argument
It should attempt to parse before popping the item off the stack.
**** TODO Division by zero consumes stack items
=5 0 /= shouldn't consume the =5= and =0= - compare to =1 "2" += behavior
(which leaves items on stack).

*** DONE logical enum hierarchy
**** DONE Collection hierarchy
There are read (peek/first) and write operations (pack/put/conj).

Then there are read/write ops like (take/unpack) that mutate the coll
and also return a value.

An In pipe supports only write. An Out pipe supports only
read-write. Pipes in general do not support peeking.

Collections (lists, maps, sets etc) support all of them.

It's not clear how to support overlapping functionality in an enum.
**** DONE pipe as list-like thing
Are both words =put= and =pack= needed (similarly =take= and =unpack=)? Seems
like the former should be all that's needed. That starts to address
that pack/unpack aren't inverse (they shouldn't be because it's really
put/take, and whether you get the last item back or not depends on the
underlying impl - a stack you would, a queue you wouldn't).

Also take in other langs takes a number arg (how many to take). You
could do this as =[take] 5 times=, but that's less efficient. Could
maybe create a new word like =split= or =unload= or something.

The possibility that these words might block, and you don't know
except by the argument type, is a bit off-putting, and maybe these
should be different words? I don't know, the contract is to "take
thing out of other thing" and sometimes that's instant and sometimes
it isn't. (You can ask if the object is a pipe before taking)

=step= should work on pipes. It continues until the pipe closes. How do
we write step in terms of take? The problem is we don't know when to
stop. We know if a collection is empty, but we need to know if a pipe
is closed. The way pipes work now is that if something goes wrong, it
produces an error from the pipe. That's ok for pipes, where we're ok
with the limitation that you can't tell whether the error was
generated during the take or was the actual data sent. However when
dealing with lists, errors are never generated, they're always the
item in the list. We want step to treat both errors and =nothing= as
actual items and not a flag value for error conditions

OK here's a plan: Result<Option<Item>>.  If the pipe is closed, return
Ok(None), if error return Err. The way we differentiate between Errors
in a list and Errors that just happened, is already implemented: via
the 'handled' field of the Error. So if there's a error in the list,
it'll have handled=true and it won't cause the expression to
unwind. If it's an actual error reading from the underlying data,
it'll have handled=false and unwind. This will also allow us to
support Nothing in lists and pipes, we won't reserve it as a sentinel
value.
**** DONE Step accepts pipes
**** DONE Set close = discard
**** DONE Remove closed? 
***** DONE Write assemble in terms of step
I don't think we actually need assemble anymore, since this is just a
regular =step= (same as reducing any other iterable).
***** DONE Do something with network pipes
I think this does have a notion of closing.
**** DONE make a polymorphic 'join'
:LOGBOOK:
CLOCK: [2023-01-04 Wed 05:48]--[2023-01-04 Wed 07:26] =>  1:38
:END:
The problem is that it's not symmetrical. If you have two different
types, whose semantics do you use? Sometimes it's obvious regardless
of order. Other times I suppose it's ok to use the first one (the
deeper in the stack).

 - list assoc -> list
 - assoc list -> list
 - list string -> list
 - assoc string -> error
 - assoc assoc -> assoc (merge top into 2nd)

   #+begin_src kcats :results code
     [[a b] [c d]] [[e f]] join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a b] [c d] [e f]]
   #+end_src

   #+begin_src kcats :results code
     [[a b] [c d]] association [[a f]] association join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a f] [c d]]
   #+end_src
**** DONE Update spec types to be more abstract
For example, =step= now accepts not only lists but also out-pipes. So
really the spec type for this argument should be =iterable= or
something.

For ideas of what to call these types, how about =in= and =out=? So eg
step takes a program and an out. =put= takes an =in=, =take= takes an =out=. I
am not sure if the =tunnel= concept will be necessary.
*** DONE Support char type
If we don't support char, that breaks the abstraction of a String as a
sort of collection. A collection of what? Characters, not 1-length
strings.

Might have to do something similar with byte, but a byte array can
also be thought of as an array of ints (8 bit unsigned), and we
already have an integer type (even though it holds more bits).
*** TODO implement sleep :stdlib:
helps with debugging multithreading
*** DONE handoff tests
This should block, not error
#+begin_src kcats
handoff take
#+end_src

#+RESULTS:
: [[reason "type mismatch"] [unwound [unpack]] [type error] [asked [list]] [actual [[type pipe] [handoff todo: id-or-hash here]]] [handled true]] [[handoff todo: id-or-hash here] [type pipe]]

#+begin_src kcats
  handoff [1 2 +] future take 
#+end_src

#+RESULTS:
: [3 [[type pipe] [handoff todo: id-or-hash here]]] [[handoff todo: id-or-hash here] [type pipe]] [[handoff todo: id-or-hash here] [type pipe]]

#+begin_src kcats
handoff clone [snapshot] dip swap [1 put 2 put] join [[] [expression]] dip assign environment animate take [take] dip +
#+end_src

#+RESULTS:
: 3 [[type pipe] [handoff todo: id-or-hash here]] [[type pipe] [handoff todo: id-or-hash here]]

Should make a word that creates an inner env with access to a handoff also present in the outer env.
#+begin_src kcats
    [[1 2 3] [put] step close] handoff clone ; p h h
    [wrap swap join [[] [expression]] dip assign environment animate] dip
    0 swap [+] step
  ;;[snapshot] dip swap  join [[] [expression]] dip assign environment animate take [take] dip +
#+end_src

#+RESULTS:
: 6

#+begin_src kcats
    [[1 2 3] [put] step close] handoff clone ; p h h
    [wrap swap join [[] [expression]] dip assign environment animate] dip
    0 swap [+] step
  ;;[snapshot] dip swap  join [[] [expression]] dip assign environment animate take [take] dip +
#+end_src

Read from one file and write to another 
#+begin_src kcats
  [[file "/tmp/bar"]] pipe-in
  [[file "/tmp/foo"]] pipe-out 
  [put] step
#+end_src

#+RESULTS:
: [[type pipe] [file "/tmp/bar"]]

As a library function
#+begin_src kcats :results code
  "/tmp/bar" "/tmp/foo" file-out [file-in] dip
  [put] step close
#+end_src

#+RESULTS:
#+begin_src kcats
Closing In
[[file "/tmp/bar"] [type pipe]]
#+end_src

*** TODO Performance optimizations :optimization:
**** TODO Compile programs
Here is how it could maybe be done. We already have a type StepFn
(which takes an env and returns a new one, in a future).

So let's say we have a program [1 2 +], and we want to convert that
into a StepFn. We could have a function =compose= and another
=self_insert=, and then call compose([self_insert(1), self_insert(2),
plus]), which would return a StepFn.

Let's look at something more complex:

=1 2 3 4 [+ *] dip=

In this case, the program is the composition of the 5 self-inserts and
dip. But what is self-inserted as the 5th item in this case could be
compiled because we know =dip= follows it. How we know in advance a list
can be compiled is difficult.

Let's try this:

=0 1 [2 3 4] [[+] dip] step=

In this case, the program for =step= is easy to spot, and in turn =dip=.

How about this:

=[+ *] [2 3 4] swap join execute=

We can't know the first two programs can be compiled until later on,
unless we look ahead in the expression. Even then we can only know
what arguments end up being passed to join and execute by examining
the words' specs, and even that is not foolproof, as we have wildcard
specs like dip where the stack change is arbitrary.

One major issue with this optimization is that it will stop the
debugger from working properly, unless special care is taken: with the
debugger we can go step by step, but if the function composition is
bundled up, we can only "step over" that function and not "into" it. I
am not sure if it's possible to build this such that we preserve
stepping ability and increase performance substantially.
**** TODO Programs as their own immutable type
Programs executing in a loop are generally not modified (exception -
the =recur= word, which can modify but usually just calls =execute=)- so
when we execute a program with =loop= we don't want to have to clone it
each time through the loop.

Instead we'll do the following: when =loop= places a program into the
expression, instead of joining it, it's just going to put it right on
top as a =program= - we may need to differentiate programs that are
active vs meant to be run later. When =eval-step= runs, it sees an
active program on the top of the expression, so it calls =next= and gets
a reference to the next word (or None if it's at the end, drop the
program). Then we lookup that word. If it's an axiom, we call it. If
it's derived, we place a new program on the top of the expression,
with its PC set to 0. The actual programs are immutable, and behind an
Rc. Each "copy" of the program is just an Rc and a counter. Then all
programs are references except the counter.


example expression:
#+begin_src kcats
  [flip discard] ;;0 
  [float swapdown] [flip discard] ;; 0 1
#+end_src
#+begin_src kcats
  [[+] shield] ;; pc 0
  [[+] shield] ;; pc 1 
  [[snapshot] dip inject first] [[+] shield] ;; pc 0 1
  ;; etc
#+end_src

So when printing out the expression, we could cheat and only show the
remaining program (instead of a stack of partially executed programs).


*** TODO Debugging method for animated envs :tools:
When we =animate= an env, we lose all contact with it if anything goes
wrong. It's supposed to send stuff back via pipes, but if it doesn't,
how do we know what went wrong? 
*** INPROGRESS Generators :stdlib:
**** DONE Basic functionality and generators
There's the concept of "lazy sequence" that I think maps nicely to
pipes - you can keep calling 'take' and it keeps calculating new
values. Everything it needs is contained in the object, it's not like
a network or filesystem pipe where the data is coming from somewhere
external. But it acts like a pipe.

#+begin_src kcats :results code
  0 []
  ;; the producer - infinite seq of integers
  [[inc clone] dip swap put] ;; -> [1] 1
  ;; the filter condition
  [3 mod 0 =] ;; divisible by 3

  ;; filter-xf
  [pop] swap put [[put] [discard] if] join  

  join ;; [generation filtration] [] 0 
  clone [execute] dip ;;generate ;; [3]
  clone [execute] dip ;;generate ;; [3]
  clone [execute] dip ;;generate ;; [3]
  clone [execute] dip ;;generate ;; [3]
#+end_src

The problem above is =generate= will not produce a value until one
passes the filter. I think filter needs to keep calling =generate= on the xf below it?
#+RESULTS:
#+begin_src kcats
[[inc clone] dip swap put pop [3 mod 0 =] [put] [discard] if] [3] 4
#+end_src

#+RESULTS:
: 1 [[unwound [[[[inc clone] dip swap put [pop [3 mod 0 =]] [put] [discard] if]] unwrap]] [type error] [asked [packable]] [actual 1] [reason "type mismatch"] [handled true]]

#+begin_src kcats :results code
  ;; the impl of filter-xf
  [3 mod 0 =]
  [pop] swap put [[put] [discard] if] join  
#+end_src

#+RESULTS:
#+begin_src kcats
[pop [3 mod 0 =] [put] [discard] if]
#+end_src
 
#+begin_src kcats
  0 [inc clone]
  clone [execute] dip swap
  discard clone [execute] dip swap
#+end_src

#+RESULTS:
: 2 [inc clone] 2

#+begin_src kcats
0 [inc] [] [[generate] dip] ]
#+end_src

#+RESULTS:
: [[generate] dip] [] [inc] 1

#+begin_src kcats :results code
  [
  ;;[1 2 3 4 6 9] liberate ;; produce from list
  1 [2 * clone] ;; infinite list
  ;; increment each
  ;;[3 * 3 -] each
  ;; drop the first few
  5 dropper
  ;; limit the list
  10 taker
  ;; collect into list
  collect
  ] shield
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [unwound [positive? [[[2 * clone] 1]] unwrap evert first [[dec discard] [[generate] dip swap []]] unwrap branch [[[positive?] [dec discard] [[generate] dip swap []] if]] unwrap swap [8] unwrap swap [[[positive?] [dec [generate] dip swap] [discard []] if]] unwrap swap clone [[[generate [[3 * 3 -] bail] shielddown]]] unwrap swap put swap [[generate clone] dip swap put swap] loop pop discard [[]] unwrap evert first]] [type error] [asked [number]] [actual [2 * clone]] [handled true]] [2 * clone] 1
#+end_src

#+begin_src kcats
0 [inc clone] generate
#+end_src

#+RESULTS:
: 1 [inc clone] 1

Now express the debugger interface in terms of generated environment states!

#+begin_src kcats :results code
  ;; the steps of execution
  [[expression [0 0 10 1 range [+] step]]] environment
  [[[expression] lookup something?]
   [eval-step clone]
   [[]]
   if] ;; the generator, which needs to emit 'nothing' once the expression is empty
  [[stack] lookup] each
  50 taker
  laster
  generate
#+end_src

#+RESULTS:
#+begin_src kcats
  [[9] 36] [generate [] swap [] [swap discard [generate] dip swap] while discard] [[positive?] [dec [generate] dip swap] [discard []] if] [generate [[[stack] lookup] bail] shielddown] [[[expression] lookup something?] [eval-step clone] [[]] if] [[stack [[9] 36]] [expression [[+] step]]]
#+end_src

implement 'laster' which returns only the last in the seq
#+begin_src kcats
  0 100 1 range liberate
  laster
  generate
#+end_src

#+begin_src kcats
  [1 2 3] traversal ;; a generator for the list
  [inc] each
  collect
#+end_src
#+RESULTS:
: 99 [generate [] swap [] [swap discard [generate] dip swap] while discard] liberate []

Now implement 'keep' which returns only an item that passes the filter
#+begin_src kcats
  0 [inc clone] 
  [odd?] keep
  1 dropper
  10 taker
  [clone *] each
  collect
#+end_src

#+RESULTS:
: [9 25 49 81 121 169 225 289 361 441] [generate [[clone *] bail] shielddown] [[positive?] [dec [generate] dip swap] [discard []] if] [[[positive?] [[generate discard] dip dec] while [generate swap] dip swapdown swap] bail] 0 [clone [[generate] dip [discard generate] while] dip swap] [[[something?] [odd? not]] [execute] every?] [inc clone] 21
#+begin_src kcats
[odd?] [something?] swap pair wrap [every?] join ;; [odd? not]

#+end_src

#+RESULTS:
: [[[something?] [odd?]] every?]

dropper (almost got it, doesn't detect end of parent stream yet)
#+begin_src kcats :results code
  [0 20 1 range liberate
   5 dropper
   10 taker
   [5 *] each
   [odd?] keep
   collect] shield
#+end_src

#+RESULTS:
#+begin_src kcats
[25 35 45 55 65]
#+end_src

Collect fix
#+begin_src kcats
  [1 2 3] liberate

  generate ;; n
  [] swap clone ;; n n r
  [put ;; r
   [generate] dip ;; r n
   swap clone]  ;; n n r 
  loop discard
#+end_src

#+RESULTS:
: [1 2 3] liberate []

#+begin_src kcats
integers 10 taker collect drop generate 
#+end_src

#+RESULTS:
: [] [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 9

**** DONE map
**** DONE filter
**** DONE take
**** DONE drop
#+begin_src kcats
integers 15 taker 10 dropper [+] reduce
#+end_src

#+RESULTS:
: 60 [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 14

**** CANCELED last
**** TODO distinct
depends on sets

The difference between this and just calling =set= is that the result is
still a list, and it preserves the original order, just removes
duplicates. Should be a similar impl to =keep=.
#+begin_src kcats
  [1 1 3] liberate
  [] set ;; state
  [[generate] dive ;; n seen g

   [contains?]
   [put ;; seen g
    [generate] dive] ;; n seen g
   while
  ]
  collect
#+end_src

#+RESULTS:
: [1 1 3] [[generate] dive [contains?] [put [generate] dive] while] [] [take] []

**** TODO partition
**** DONE joiner (aka catenate)
#+begin_src kcats
  [[1 2 3] [4 5 6] [7 8 9]]
  liberate
  [generate [] swap
   []
   [join
    [generate] dip swap] 
   while discard] 
  generate
#+end_src

#+RESULTS:
: [1 2 3 4 5 6 7 8 9] [generate [] swap [] [join [generate] dip swap] while discard] [take] []

**** TODO groupby
#+begin_src kcats :results code
  ["foo" "bar" "baaz" "quux"]
  liberate
  [] association ;; state
  [take swap discard] ;; f state
  [[generate] dipdown ;; f state i
   swapdown ;; f i state
   [execute] shield ;; k f v state
   sink ;; f v k state
   [wrap ;; [v] k state
    [join] unwrap pair ;; [[v] join] k state
    [wrap] dip ;; [[v] join] [k] state
    update] ;; 
   dip ;; f state
   
  ] generate
#+end_src

#+RESULTS:
#+begin_src kcats
  [take swap discard]
  [[generate] dipdown swapdown [execute] shield sink [wrap [join] unwrap pair [wrap] dip update] dip]
  [[o ["foo"]]] [take] ["bar" "baaz" "quux"]
#+end_src

**** CANCELED Map/filter can't access lower stack items
***** Problem
this doesn't work:

#+begin_src kcats :results code
10 [1 2 3] liberate [+] each
#+end_src

#+RESULTS:
#+begin_src kcats
[generate [[+] bail] shielddown] [take] [1 2 3] 10
#+end_src

We should get =[11 12 13]= but it errors out.

The reason is that when + runs, the generators are still on the stack,
in between this mapping function, and the original stack arguments.

We need a way to break out of the generation part of the stack and let
the mapping function access the arguments below it.

I can't immediately think of a good way to do it.

Actually I think that instead of recursively calling generate, and
passing the values back up the stack, there might be a way to build up
the program recursively, and then execute it in one swoop? 

Perhaps we can split each stage into several parts:

+ Generate from the layer below (in which case we obviously need the
  layers below to get the next value)
+ dip underneath the layers to calculate the next value using lower stack items
+ swap the new value to the top of stack
+
***** Debug session
#+begin_src kcats :results code
[[expression [10 [1 2 3] liberate [+] each generate]]] environment
advance advance advance advance eval-step [advance] 5 times eval-step
[advance] 2 times [eval-step] 99 times 
#+end_src

#+begin_src kcats
10 [1 2 3] liberate [+] each generate
#+end_src

#+RESULTS:
: [[asked [number]] [reason "type mismatch"] [unwound [+ [[1 [take] [2 3] 10]] unwrap evert first swap discard [[generate [[+] bail] shielddown]] unwrap swap]] [actual [take]] [type error] [handled true]] 1 [take] [2 3] 10


#+begin_src kcats :results code
  [[expression [[[expression [+]]] environment advance]]] environment advance advance eval-step
#+end_src

#+RESULTS:
#+begin_src kcats
[[expression [[[expression] lookup count] shield swap [[expression] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap discard]] [stack [[[stack []] [expression [+]]]]]]
#+end_src
***** Resolution
After thinking about this some more, my conclusion:

This is supporting multi-arity mapping functions, which did work in
the original map implementation but they are not supported in other
languages. The way you access multiple values there is by closing over
them. So the way you'd do it in kcats is like so:

#+begin_src kcats
  10 [1 2 3] ;; the extra arg and the list
  [-] ;; the multi-arity map fn
  [clone] dipdown ;; clone the 10
  [swap] unwrap prepend ;; prepend the word swap to the fn so that the 10 ends up beneath the list item
  float prepend ;; prepend the 10
  map
#+end_src

#+RESULTS:
: [9 8 7] 10

In theory we could write a helper function called =capture1= or something that does this for us, so you can write

#+begin_src 
10 [1 2 3] [-] capture1 map
#+end_src

#+begin_src kcats
  10 [1 2 3  4 5 6] ;; the extra arg and the list
  [-] ;; the multi-arity map fn

  [swapdown ;; f i
   [swap] unwrap prepend
   swap prepend] shielddown
  [liberate] dip each collect
#+end_src

#+RESULTS:
: [9 8 7] [generate [[10 swap -] bail] shielddown] [take] [] 10

#+begin_src kcats
  [1 2 "oh fudge"]
  [[5 +]
   [discard 5]
   recover]
  map
#+end_src

#+RESULTS:
: [6 7 5]
**** DONE Reduce
#+begin_src kcats :results code
  0 [inc clone] 30 taker [+]
  [generate] dive clone ;; acc acc f
  ;;drop [generate] divedown [] [float execute clone] [] if
  ;; acc f g
  [[generate] divedown ;; i acc f g
   [] [float execute clone] [] if]  ;; acc acc f g
  loop
#+end_src

#+begin_src kcats :results code
  0 [inc clone] 10 taker 
  generate clone ;; acc acc 
  ;;drop [generate] divedown [] [float execute clone] [] if
  ;; acc g
  [[generate] dive ;; i acc g
   [] [+ clone] [] if]  ;; acc acc f g
  loop
#+end_src

#+RESULTS:
#+begin_src kcats
55 [[positive?] [dec [generate] dive] [drop []] if] [inc clone] 10
#+end_src

#+begin_src kcats :results code
  0 [inc clone] 3 taker
  [*]
  ;; build the 'then' branch
  [clone] join ;; -> [+ clone]
  ;; build the loop body
  [[generate] dive []] swap put [[] if] join
  ;; generate the first item under the loop body
  [generate clone] dip
  loop
#+end_src

#+RESULTS:
#+begin_src kcats
6 [[positive?] [dec [generate] dive] [drop []] if] [inc clone] 3
#+end_src

#+begin_src kcats
1 2 3 4 [+] divedown
#+end_src

#+RESULTS:
: 3 4 3

#+begin_src kcats
1 true [ inc clone 5 < ] loop
#+end_src

#+RESULTS:
: 5

#+begin_src kcats
  integers
  1 dropper ;; start with 1
  1000 taker ;; take items
  [3 *] each
  [odd?] keep
  [+ 37 mod] reduce
#+end_src

#+RESULTS:
: 10 [clone [[generate] dip [drop generate] while] dive] [[[something?] [odd? not]] [execute] every?] [generate [[3 *] bail] shielddown] [[positive?] [dec [generate] dive] [drop []] if] [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [inc clone] 1000

#+begin_src kcats
1025 8 mod
#+end_src

#+RESULTS:
: 1

*** DONE Investigate simpler map/filter impls
#+begin_src kcats :results code
7 8 [+] [] [] sink [shielddown dip] decorate [swap] unwrap prepend [swap put] join step
#+end_src

#+RESULTS:
#+begin_src kcats
[+] 8 7
#+end_src

#+begin_src kcats :results code
3 [1 2 3 4 5 6] [discard odd?] [] sink [shield dip] decorate [swap] unwrap prepend [sink [put] [discard] branch] join step
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3 4 5 6] 3
#+end_src

*** INPROGRESS Implement hashset :stdlib:
Once we have this, we can implement stuff like the =distinct= transform
function.

**** INPROGRESS Implement set membership check
Could possibly piggyback on =lookup= here, but the semantics are a
little different (nested sets are not allowed, return value is the
same as the key argument).

Another option is to call it =contains?= and check for membership. The
implementation could accept any Sized type, but it's not obvious how
to handle map types - are we checking just for the key, or key/val
pair? I lean slightly toward just the key, but hard to say. For list
types do we convert or promote to set, or just do a (worst case) full
pass over the elements? Vec[Deque] has a contains method so I'm
inclined to just use that.

***** TODO Substring or subcollection
Included as part of this should be substring and subarray checking. eg
="foobar" "bar" contains?= should return =true=. It's a different behavior
when the member and collection are the same type vs different
types. Should probably error when it's two different collection types,
eg =[1 2 3] [2 3] set contains?= should error.


*** DONE Implement until
like =while= but always runs the body once.

#+begin_src kcats :results code
  64 [50 >] [clone *] ;; until
  swap ;; pred body
  [not] join ;; reverse logic
  [shield] decorate ;; add shield to the pred program -> pred body
  join ;; [body ..  pred]
  true swap ;; run at least once
  loop
#+end_src

#+RESULTS:
#+begin_src kcats
4096
#+end_src

use until in places I wish i'd had it:
laster:
#+begin_src kcats :results code
  [1 2 3 4] liberate
  [] []
  [[nothing?]
   ;; l sl
   [swap ;; sl l
    discard ;; l
    [generate] dip ;; sl l
    swap] ;; l sl 
   until swap
   [[]] dipdown] ;; replace the empty state
  collect
#+end_src

joiner
#+begin_src kcats :results code
  [[1 2 3] [4 5 6] [7 8 9]] liberate
  [] []
  [nothing?]
  [discard ;; r
   [generate] dip ;; r i
   swap ;; i r
   clone ;; i i r
   [join] dip ;; i r2
  ] until  generate
#+end_src
#+RESULTS:
#+begin_src kcats
[1 2 3 4 5 6 7 8 9] [] [take] []
#+end_src

#+begin_src kcats
[1 2 3 4] liberate generate
#+end_src

#+RESULTS:
: 1 [take] [2 3 4]

*** TODO Implement sorting :stdlib:

**** TODO Implement partialord
Each type needs to be comparable to another.

#+begin_src kcats
  [["b" 2]["g" 5]["a", 1]["d" 4] ["c" 3]] association ++sort
#+end_src

#+RESULTS:
: [1 2 3 4 5]

#+begin_src kcats
  [-2 10 -8 -12 8 0 1 20]
  [5 - abs]
  [clone] swap join
  [ pair] join
  map  ++sort 
#+end_src

#+RESULTS:
: Pair is (Int(-2), Int(7))
: Pair is (Int(10), Int(5))
: Pair is (Int(-8), Int(13))
: Pair is (Int(-12), Int(17))
: Pair is (Int(8), Int(3))
: Pair is (Int(0), Int(5))
: Pair is (Int(1), Int(4))
: Pair is (Int(20), Int(15))
: [8 1 10 0 -2 -8 20 -12]

UHOH
#+begin_src kcats
  ["hi" "there" "what" "is" "your" "birthdate" "homeboy"]
  []
  [clone] swap join
  [pair] join
  map  ++sort 
#+end_src

#+RESULTS:
: Pair is (Iterable(Sized(String("hi"))), String("hi"))
: Pair is (Iterable(Sized(String("there"))), String("there"))
: Pair is (Iterable(Sized(String("what"))), String("what"))
: Pair is (Iterable(Sized(String("is"))), String("is"))
: Pair is (Iterable(Sized(String("your"))), String("your"))
: Pair is (Iterable(Sized(String("birthdate"))), String("birthdate"))
: Pair is (Iterable(Sized(String("homeboy"))), String("homeboy"))
: ["birthdate" "hi" "homeboy" "is" "there" "what" "your"]

#+begin_src kcats
8 5 - 
#+end_src

#+RESULTS:
: 3

#+begin_src kcats
1 2 [inc] both
#+end_src

#+RESULTS:
: [[reason "word is not defined"] [unwound [both]] [type error] [asked [both]] [handled true]] [inc] 2 1

**** TODO Make floats hashable
This will allow floats to be added to the =KeyItem= enum. Floats are not
normally hashable, because mathematically identical numbers are not
always represented the same way in memory and wouldn't hash the
same. But for the purposes of kcats, I think this doesn't matter. We
can document that you can't expect (10.0 + 10.0) and (15.0 + 5.0) to
be the same map key.

This will then allow a list that contains floats, to be sorted, or be
able to use float values as a sort-by key.

**** TODO Implement compare
Should expose Rust's comparison function. That will allow a native
sort function, for max flexibility (but not performance).

#+begin_src kcats
  "a" "b" compare
#+end_src

#+RESULTS:
: less

#+begin_src kcats
"a" "a" compare
#+end_src

#+RESULTS:
: equal

#+begin_src kcats
["a" "b"] ["a" "c"] compare
#+end_src

#+RESULTS:
: less

#+begin_src kcats
"foo" bytes [1] compare
#+end_src

#+RESULTS:
: less

#+begin_src kcats
[] [] compare
#+end_src

#+RESULTS:
: [[type error] [unwound []] [actual []] [asked [KeyItem]] [reason "type mismatch"] [handled true]]
