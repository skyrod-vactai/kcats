# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: The kcats Programming Language Lexicon
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:clojure :noweb yes :tangle src/kcats/core.clj :results value silent
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)
* Builtin words documentation
** Base words
The actual functionality of axiom words can't be defined in kcats
itself, but we can define some other properties, such as the spec
(what types the word uses and returns), and some example uses.
#+begin_src kcats :tangle src/kcats/builtins.kcats
  [= [[spec [[item item] [boolean]]]
      [examples [[[1 2 =] [false]]
                 [[1 1 =] [true]]
                 [[[] [] =]  [true]]
                 [[[1] [] =]  [false]]
                 [[[1 [false]] [1 [false]] =] [true]]
                 [[[1.0 ["foo"]] [1.0 ["foo"]] =]  [true]]
                 [["hi" "hi" =] [true]]
                 [["hi" "there" =] [false]]
                 [[[] true =] [false]]
                 [[[1.0 ["foo"]] [1.0 ["bar"]] =]  [false]]
                 [[[] [] association =] [true]]
                 [[[[a b]] [[a b]] association =] [false]]]]]]

  [+ [[spec [[number number] [number]]]
      [examples [[[1 2 +] [3]]
                 [[1.1 2.2 + 3.3 0.001 within?] [true]]
                 [[1 2.2 +] [3.2]]]]]]

  [- [[spec [[number number] [number]]]
      [examples [[[2 1 -] [1]]
                 [[1.1 2.2 - -1.1 0.00001 within?] [true]]
                 [[2.2 1 - 1.2 0.00001 within?] [true]]]]]]

  [* [[spec [[number number] [number]]]
      [examples [[[4 3 *] [12]]
                 [[10 1.5 * 15 0.0001 within?] [true]]
                 [[5 0 *] [0]]
                 [[5 -1 *] [-5]]]]]]

  [/ [[spec [[number number] [number]]]
      [examples [[[12 3 /] [4]]
                 [[15 1.5 /] [10.0]]
                 [[0 1 /] [0]]
                 [[1 0 / handle [reason] lookup] ["division by zero"]]]]]]

  [min [[spec [[number number] [number]]]
        [definition [[<] shield [wrap [wrap] dip] dip sink branch]]
        [examples [[[2 3 min] [2]]
                   [[-5 -3 min] [-5]]
                   [[0.3 0.2 min] [0.2]]]]]]

  [max [[spec [[number number] [number]]]
        [definition [[>] shield [wrap [wrap] dip] dip sink branch]]
        [examples [[[2 3 max] [3]]
                   [[-5 -3 max] [-3]]
                   [[0.3 0.2 max] [0.3]]]]]]

  [quot [[spec [[number number] [number]]]
         [examples [[[16 5 quot] [3]]]]]]

  [rem [[spec [[number number] [number]]]
        [examples [[[17 5 rem] [2]]]]]]

  [mod [[spec [[number number] [number]]]
        [examples [[[17 5 mod] [2]]]]]]

  [< [[spec [[number number] [boolean]]]
      [examples [[[1 2 <] [true]]
                 [[2.2 1.1 <] [false]]
                 [[1 2.2 <] [true]]
                 [[1.1 1.1 <] [false]]]]]]

  [> [[spec [[number number] [boolean]]]
      [examples [[[2 1 >] [true]]
                 [[1.1 2.2 >] [false]]
                 [[2.2 1 >] [true]]
                 [[1.1 1.1 >] [false]]]]]]

  [<= [[spec [[number number] [boolean]]]
       [examples [[[1 2 <=] [true]]
                  [[2.2 1.1 <=] [false]]
                  [[1 2.2 <=] [true]]
                  [[1.1 1.1 <=] [true]]]]]]

  [>= [[spec [[number number] [boolean]]]
       [examples [[[2 1 >=] [true]]
                  [[1.1 2.2 >=] [false]]
                  [[2.2 1 >=] [true]]
                  [[1.1 1.1 >=] [true]]]]]]

  [ceil [[spec [[number] [integer]]]
         [examples [[[1.1 ceil] [2.0]]
                    [[-1.1 ceil] [-1.0]]]]]]

  [sqrt [[spec [[number] [number]]]
         [examples [[[9 sqrt] [3]]
                    [[81 sqrt] [9]]]]]]

  [inc [[spec [[number] [number]]]
        [examples [[[1 inc] [2]]
                   [[-1 inc] [0]]
                   [[99 inc] [100]]]]]]

  [dec [[spec [[number] [number]]]
        [examples [[[2 dec] [1]]
                   [[0 dec] [-1]]
                   [[100 dec] [99]]]]]]

  [abs [[spec [[number] [integer]]]
        [examples [[[2.1 abs] [2.1]]
                   [[-0.2 abs] [0.2]]
                   [[-2 abs] [2]]
                   [[0 abs] [0]]]]]]

  [xor [[spec [[item] [item]]]
        [examples [[[10 12 xor] [6]] ;; 10 = 01010, 12 = 01100, 00110, 6
                   [["foo" bytes "bar" bytes xor] [#b64 "BA4d"]]]]]]

  [odd? [[spec [[number] [boolean]]]
         [examples [[[1 odd?] [true]]
                    [[-1 odd?] [true]]
                    [[4 odd?] [false]]]]]]

  [even? [[spec [[number] [boolean]]]
          [examples [[[2 even?] [true]]
                     [[-2 even?] [true]]
                     [[3 even?] [false]]]]]]

  [zero? [[spec [[number] [boolean]]]
          [examples [[[0 zero?] [true]]
                     [[0.0 zero?] [true]]
                     [[-0.00001 zero?] [false]]
                     [[1.1 zero?] [false]]]]]]

  [drop [[spec [[item] []]]
         [examples [[[1 2 3 drop] [1 2]]
                    [[1 2 3 [a b c] drop] [1 2 3]]]]]]

  [clone [[spec [[[item a]]
                 [[item a] [item a]]]]
          [examples [[[1 2 3 clone] [1 2 3 3]]]]]]

  [swap [[spec [[[item a] [item b]]
                [[item b] [item a]]]]
         [examples [[[1 2 3 swap] [1 3 2]]]]]]

  [swapdown [[spec [[[item a] [item b] [item c]]
                    [[item a] [item c] [item b]]]]
             [examples [[[1 2 3 swapdown] [2 1 3]]]]]]

  [float [[spec [[[item a] [item b] [item c]]
                 [[item c] [item a] [item b]]]]
          [examples [[[1 2 3 float] [2 3 1]]]]]]

  [sink [[spec [[[item a] [item b] [item c]]
                [[item b] [item c] [item a]]]]
         [examples [[[1 2 3 sink] [3 1 2]]]]]]

  [execute [[spec [[program] [*]]]
            [examples [[[[1 2 +] execute] [3]]
                       [[2 [+] 4 swap execute] [6]]]]]]

  [wrap [[spec [[item] [list]]]
         [examples [[[1 wrap] [[1]]]
                    [[[1 2] wrap] [[[1 2]]]]]]]]

  [unwrap [[spec [[list] [*]]]
           [examples [[[[1] unwrap] [1]]
                      [[[1 2 3] unwrap] [1 2 3]]]]]]

  [reverse [[spec [[ordered] [ordered]]]
            [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]]

  [fail [[spec [[association] [*]]]]]

  [dip [[spec [[program [item a]] [[item a] *]]]
        [examples [[[1 8 [inc] dip] [2 8]]
                   [[1 2 [dec] unwrap
                     [+] dip] [3 [dec] unwrap]]]]]]

  [list? [[spec [[item] [boolean]]]
          [examples [[[[1] list?] [true]]
                     [[[] list?] [true]]
                     [[5 list?] [false]]]]]]

  [number? [[spec [[item] [boolean]]]
            [examples [[[[1] number?] [false]]
                       [[[] number?] [false]]
                       [[5 number?] [true]]
                       [[5.01 number?] [true]]]]]]

  [error? [[spec [[item] [boolean]]]]]

  ;; handle is a special word only used to unwind the expression on
  ;; error, if there's no error and we end up reaching this word, we
  ;; ignore it.
  [handle [[spec [[] []]]
           [definition []]]]

  [string [[spec [[item] [string]]]
           [examples [[[1 string] ["1"]]
                      [[[1 2 3] string] ["[1 2 3]"]]
                      [[[] string] ["[]"]]]]]]

  [read [[spec [[string] [item]]]
         [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]]

  [emit [[spec [[item] [string]]]
         [examples [[[[1 [2] 3] emit] ["[1 [2] 3]"]]]]]]

  ; [inscribe [[spec [[list list] []]]
  ;            [examples [[[[add3] [[definition [3 +]]
  ;                                 [spec [[number] [number]]]]
  ;                         inscribe
  ;                         5 add3] [8]]]]]]

  [branch [[spec [[[program false-branch]
                   [program true-branch]
                   [item condition]]
                  [*]]]
           [examples [[[5 true [3 *] [4 +] branch] [15]]
                      [[6 false [3 *] [4 +] branch] [10]]]]]]

  [step [[spec [[program dispenser] [*]]]
         [examples [[[1 [2 3 4] [*] step] [24]]
                    [[1 [] [*] step] [1]]]]]]

  [recur [[spec [[[program rec2]
                  [program rec1]
                  [program true-branch]
                  [program pred]]
                 [*]]]
          [examples [[[3
                       [1 <=] [] [clone dec] [execute *]
                       recur]
                      [6]]]]]]

  [loop [[spec [[program [item flag]] [*]]]
         [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]]

  [take [[spec [[dispenser] [item dispenser]]]
         [examples [[[["a" "b" "c"] take] [["b" "c"] "a"]]
                    [[[1 2 3] take dropdown] [1]]]]]]

  [pop [[spec [[ordered] [item ordered]]]
        [examples [[[["a" "b" "c"] pop] [["a" "b"] "c"]]
                   [[[1 2 3] pop dropdown] [3]]]]]]

  [range [[spec [[integer integer integer] [list]]]
          [examples [[[1 5 1 range] [[1 2 3 4]]]
                     [[3 13 3 range] [[3 6 9 12]]]]]]]

  [integers [[spec [[] [program]]]
             [definition [-1 [inc clone]]]]]

  [evert [[spec [[list] [list *]]]
          [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]]]]]]]

  [true [[spec [[] [word]]]]] ;; self-inserts

  [false [[spec [[] [item]]]
          [definition [nothing]]]] ;; false = nothing = []

  [nothing [[spec [[] [item]]]
            [definition [[]]]]]

  [and [[spec [[item item] [item]]]
        [examples [[[1 odd? 2 even? and] [true]]]]]]

  [or [[spec [[item item] [item]]]
       [examples [[[1 odd? 3 even? or] [true]]
                  [[1 2 or] [1]]
                  [[[] 2 or] [2]]
                  [[[] [] or] [false]]]]]]

  [not [[spec [[item] [boolean]]]
        [examples [[[1 even? not] [true]]
                   [[false not] [true]]
                   [[true not] [false]]
                   [[[] not] [true]]]]]]

  [join [[spec [[sized sized] [sized]]]
         [examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]]
                    [["ab" "cd" join] ["abcd"]]
                    [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]
                    [[[[a b] [c d]] association [[e f] [a g]] join] [[[a g] [c d] [e f]] association]]
                    [[[[e f] [a g]] [[a b] [c d]] association  join] [[[a b] [e f] [c d]] association]]]]]]

  [put [[spec [[item dispenser] [dispenser]]]
        [examples [[[[] 1 put] [[1]]]
                   [[[1 2 3] 4 put] [[1 2 3 4]]]
                   ;; [["foo" \d put] ["food"]] ;; breaks prod, where chars are not valid data
                   [["foo" bytes 32 put string] ["foo "]]]]]]

  [dipdown [[spec [[program
                    [item a]
                    [item b]]
                   [[item a] [item b] *]]]
            [examples [[[1 2 3 [inc] dipdown] [2 2 3]]]]]]

  [count [[spec [[sized]
                 [number]]]
          [examples [[[["a" "b" "c"] count] [3]]]]]]

  [first [[spec [[ordered] [item]]]
          [examples [[[[4 5 6] first] [4]]]]]]

  [second [[spec [[ordered] [item]]]
           [examples [[[[4 5 6] second] [5]]]]]]

  [last [[spec [[ordered] [item]]]
         [examples [[[[3 4 5 6] last] [6]]]]]]

  [bytes [[spec [[item] [bytes]]]
          [examples [[["foo" bytes] [#b64 "Zm9v"]]]]]]

  [bytes? [[spec [[item] [boolean]]]
           [examples [[["foo" bytes?] [false]]
                      [[#b64 "Zm9v" bytes?] [true]]
                      [[[#b64 "Zm9v"] bytes?] [false]]
                      [["foo" bytes bytes?] [true]]]]]]

  [pipe? [[spec [[item] [boolean]]]]]

  [string? [[spec [[item] [boolean]]]
            [examples [[["hi" string?] [true]]
                       [["" string?] [true]]
                       [[["hi"] string?] [false]]
                       [[true string?] [false]]]]]]

  [word? [[spec [[item] [boolean]]]
          [examples [[[[foo] unwrap word?] [true]]
                     [[true word?] [true]]]]]]

  [environment [[spec [[sized] [environment]]]
                [examples [[[[[expression [1 2 3]]] environment eval-step [stack] lookup] [[1]]]]]]]

  [eval-step [[spec [[environment] [environment]]]
              [examples [[[[[expression [1 inc]]] environment
                           eval-step eval-step
                           [stack] lookup]
                          [[2]]]]]]]

  [evaluate [[spec [[environment] [environment]]]
             [examples [[[[[expression [1 2 3 4 + *]]] environment
                          evaluate
                          [stack] lookup]
                         [[14 1]]]]]]]

  [dictionary [[spec [[] [list]]]]]

  [redefine [[spec [[association] []]]]]

  [inspect [[spec [[item] [string]]]]]

  [hash [[spec [[bytes] [bytes]]]
         [examples [[[["foo" bytes hash] 2 times =] [true]]
                    [["foo" bytes hash
                      "fop" bytes hash
                      =]
                     [false]]]]]]

  [key [[spec [[bytes] [bytes]]]
        [examples [[[["foo" bytes key] 2 times =] [true]]]]]]

  [sign [[spec [[[bytes message] [association key]] [bytes]]]]]

  [verify [[spec [[[bytes signature]
                   [bytes message]
                   [association key]]

                  [boolean]]]
           [examples [[["foo" bytes key "we attack at dawn" bytes [sign] shield verify] [true]]]]]]

  [delegated [[spec [[[association pubkey]] [program]]]
              [definition [[[sink ;; css cs pk
                             [[bytes hash] [shield dip] decorated ;; css csh cs pk
                              float ;; cs css csh pk
                              [verify] dip
                              [[]]  ;; the program to run if the child script isn't authorized
                              branch] ;; runs the child script if the sig on its hash is verified  
                             [drop drop ;; the sig and (empty) child script -> pk sig msg
                              sink ;; sig msg pk
                              verify]
                             [clone] dipdown branch]
                            [[]] recover]
                           swap prepend]]]] ;; prepend the pubkey
#+end_src

#+RESULTS:
: [verify [[spec [[[bytes signature] [bytes message] [association key]] [boolean]]] [examples [[["foo" bytes key "we attack at dawn" bytes [sign] shield verify] [true]]]]]] [sign [[spec [[[bytes message] [association key]] [bytes]]]]] [key [[spec [[bytes] [bytes]]] [examples [[[["foo" bytes key] 2 times =] [true]]]]]] [hash [[spec [[bytes] [bytes]]] [examples [[[["foo" bytes hash] 2 times =] [true]] [["foo" bytes hash "fop" bytes hash =] [false]]]]]] [inspect [[spec [[item] [string]]]]] [redefine [[spec [[association] []]]]] [dictionary [[spec [[] [list]]]]] [evaluate [[spec [[list] [list]]] [examples [[[[[expression [1 2 3 4 + *]]] environment evaluate [stack] lookup] [[14 1]]]]]]] [eval-step [[spec [[list] [list]]] [examples [[[[[expression [1 inc]]] environment eval-step eval-step [stack] lookup] [[2]]]]]]] [environment [[spec [[association] [list]]] [examples [[[[[expression [1 2 3]]] environment eval-step [stack] lookup] [[1]]]]]]] [word? [[spec [[item] [boolean]]] [examples [[[[foo] unwrap word?] [true]] [[true word?] [true]]]]]] [string? [[spec [[item] [boolean]]] [examples [[["hi" string?] [true]] [["" string?] [true]] [[["hi"] string?] [false]] [[true string?] [false]]]]]] [pipe? [[spec [[item] [boolean]]]]] [bytes? [[spec [[item] [boolean]]] [examples [[["foo" bytes?] [false]] [[#b64 "Zm9v" bytes?] [true]] [[[#b64 "Zm9v"] bytes?] [false]] [["foo" bytes bytes?] [true]]]]]] [bytes [[spec [[item] [bytes]]] [examples [[["foo" bytes] [#b64 "Zm9v"]]]]]] [second [[spec [[list] [item]]] [examples [[[[4 5 6] second] [5]]]]]] [first [[spec [[list] [item]]] [examples [[[[4 5 6] first] [4]]]]]] [count [[spec [[list] [number]]] [examples [[[["a" "b" "c"] count] [3]]]]]] [dipdown [[spec [[program [item a] [item b]] [[item a] [item b] *]]] [examples [[[1 2 3 [inc] dipdown] [2 2 3]]]]]] [put [[spec [[item item] [item]]] [examples [[[[] 1 put] [[1]]] [[[1 2 3] 4 put] [[1 2 3 4]]] [["foo" bytes 32 put string] ["foo "]]]]]] [join [[spec [[item item] [item]]] [examples [[[["a" "b"] ["c" "d"] join] [["a" "b" "c" "d"]]] [["ab" "cd" join] ["abcd"]] [["ab" bytes "cd" bytes join "abcd" bytes =] [true]]]]]] [not [[spec [[item] [boolean]]] [examples [[[1 even? not] [true]] [[false not] [true]] [[true not] [false]] [[[] not] [true]]]]]] [or [[spec [[item item] [item]]] [examples [[[1 odd? 3 even? or] [true]] [[1 2 or] [1]] [[[] 2 or] [2]] [[[] [] or] [false]]]]]] [and [[spec [[item item] [item]]] [examples [[[1 odd? 2 even? and] [true]]]]]] [nothing [[spec [[] [item]]] [definition [[]]]]] [false [[spec [[] [item]]] [definition [nothing]]]] [true [[spec [[] [word]]]]] [evert [[spec [[list] [list *]]] [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]]]]]]] [range [[spec [[integer integer integer] [list]]] [examples [[[1 5 1 range] [[1 2 3 4]]] [[3 13 3 range] [[3 6 9 12]]]]]]] [take [[spec [[item] [item list]]] [examples [[[["a" "b" "c"] take] [["b" "c"] "a"]] [[[1 2 3] take swap drop] [1]]]]]] [loop [[spec [[program [item flag]] [*]]] [examples [[[10 true [-2 * clone 50 <] loop] [160]]]]]] [recur [[spec [[[program rec2] [program rec1] [program true-branch] [program pred]] [*]]] [examples [[[3 [1 <=] [] [clone dec] [execute *] recur] [6]]]]]] [step [[spec [[program list] [*]]] [examples [[[1 [2 3 4] [*] step] [24]] [[1 [] [*] step] [1]]]]]] [branch [[spec [[[program false-branch] [program true-branch] [item condition]] [*]]] [examples [[[5 true [3 *] [4 +] branch] [15]] [[6 false [3 *] [4 +] branch] [10]]]]]] [emit [[spec [[item] [string]]] [examples [[[[1 [2] 3] emit] ["[1 [2] 3]"]]]]]] [read [[spec [[string] [item]]] [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]] [string [[spec [[item] [string]]] [examples [[[1 string] ["1"]] [[[1 2 3] string] ["[1 2 3]"]] [[[] string] ["[]"]]]]]] [handle [[spec [[] []]] [definition []]]] [error? [[spec [[item] [boolean]]]]] [number? [[spec [[item] [boolean]]] [examples [[[[1] number?] [false]] [[[] number?] [false]] [[5 number?] [true]] [[5.01 number?] [true]]]]]] [list? [[spec [[item] [boolean]]] [examples [[[[1] list?] [true]] [[[] list?] [true]] [[5 list?] [false]]]]]] [dip [[spec [[program [item a]] [[item a] *]]] [examples [[[1 8 [inc] dip] [2 8]] [[1 2 [dec] unwrap [+] dip] [3 [dec] unwrap]]]]]] [fail [[spec [[association] [*]]]]] [reverse [[spec [[list] [list]]] [examples [[[[1 2 3] reverse] [[3 2 1]]]]]]] [rest [[spec [[list] [list]]] [examples [[[[1 2 3] rest] [[2 3]]]]]]] [unwrap [[spec [[list] [*]]] [examples [[[[1] unwrap] [1]]]]]] [wrap [[spec [[item] [list]]] [examples [[[1 wrap] [[1]]] [[[1 2] wrap] [[[1 2]]]]]]]] [execute [[spec [[program] [*]]] [examples [[[[1 2 +] execute] [3]] [[2 [+] 4 swap execute] [6]]]]]] [sink [[spec [[[item a] [item b] [item c]] [[item b] [item c] [item a]]]] [examples [[[1 2 3 sink] [3 1 2]]]]]] [float [[spec [[[item a] [item b] [item c]] [[item c] [item a] [item b]]]] [examples [[[1 2 3 float] [2 3 1]]]]]] [swapdown [[spec [[[item a] [item b] [item c]] [[item a] [item c] [item b]]]] [examples [[[1 2 3 swapdown] [2 1 3]]]]]] [swap [[spec [[[item a] [item b]] [[item b] [item a]]]] [examples [[[1 2 3 swap] [1 3 2]]]]]] [clone [[spec [[[item a]] [[item a] [item a]]]] [examples [[[1 2 3 clone] [1 2 3 3]]]]]] [drop [[spec [[item] []]] [examples [[[1 2 3 drop] [1 2]] [[1 2 3 [a b c] drop] [1 2 3]]]]]] [zero? [[spec [[number] [boolean]]] [examples [[[0 zero?] [true]] [[0 zero?] [true]] [[-0.00001 zero?] [false]] [[1.1 zero?] [false]]]]]] [even? [[spec [[number] [boolean]]] [examples [[[2 even?] [true]] [[-2 even?] [true]] [[3 even?] [false]]]]]] [odd? [[spec [[number] [boolean]]] [examples [[[1 odd?] [true]] [[-1 odd?] [true]] [[4 odd?] [false]]]]]] [xor [[spec [[item] [item]]] [examples [[[10 12 xor] [6]] [["foo" bytes "bar" bytes xor] [#b64 "BA4d"]]]]]] [abs [[spec [[number] [integer]]] [examples [[[2.1 abs] [2.1]] [[-0.2 abs] [0.2]] [[-2 abs] [2]] [[0 abs] [0]]]]]] [dec [[spec [[number] [number]]] [examples [[[2 dec] [1]] [[0 dec] [-1]] [[100 dec] [99]]]]]] [inc [[spec [[number] [number]]] [examples [[[1 inc] [2]] [[-1 inc] [0]] [[99 inc] [100]]]]]] [sqrt [[spec [[number] [number]]] [examples [[[9 sqrt] [3]] [[81 sqrt] [9]]]]]] [ceil [[spec [[number] [integer]]] [examples [[[1.1 ceil] [2]] [[-1.1 ceil] [-1]]]]]] [>= [[spec [[number number] [boolean]]] [examples [[[2 1 >=] [true]] [[1.1 2.2 >=] [false]] [[2.2 1 >=] [true]] [[1.1 1.1 >=] [true]]]]]] [<= [[spec [[number number] [boolean]]] [examples [[[1 2 <=] [true]] [[2.2 1.1 <=] [false]] [[1 2.2 <=] [true]] [[1.1 1.1 <=] [true]]]]]] [> [[spec [[number number] [boolean]]] [examples [[[2 1 >] [true]] [[1.1 2.2 >] [false]] [[2.2 1 >] [true]] [[1.1 1.1 >] [false]]]]]] [< [[spec [[number number] [boolean]]] [examples [[[1 2 <] [true]] [[2.2 1.1 <] [false]] [[1 2.2 <] [true]] [[1.1 1.1 <] [false]]]]]] [mod [[spec [[number number] [number]]] [examples [[[17 5 mod] [2]]]]]] [rem [[spec [[number number] [number]]] [examples [[[17 5 rem] [2]]]]]] [quot [[spec [[number number] [number]]] [examples [[[16 5 quot] [3]]]]]] [max [[spec [[number number] [number]]] [definition [[>] shield [wrap [wrap] dip] dip sink branch]] [examples [[[2 3 max] [3]] [[-5 -3 max] [-3]] [[0.3 0.2 max] [0.3]]]]]] [min [[spec [[number number] [number]]] [definition [[<] shield [wrap [wrap] dip] dip sink branch]] [examples [[[2 3 min] [2]] [[-5 -3 min] [-5]] [[0.3 0.2 min] [0.2]]]]]] [/ [[spec [[number number] [number]]] [examples [[[12 3 /] [4]] [[15 1.5 /] [10]] [[0 1 /] [0]] [[1 0 / handle [reason] lookup] ["division by zero"]]]]]] [* [[spec [[number number] [number]]] [examples [[[4 3 *] [12]] [[10 1.5 * 15 0.0001 within?] [true]] [[5 0 *] [0]] [[5 -1 *] [-5]]]]]] [- [[spec [[number number] [number]]] [examples [[[2 1 -] [1]] [[1.1 2.2 - -1.1 0.00001 within?] [true]] [[2.2 1 - 1.2 0.00001 within?] [true]]]]]] [+ [[spec [[number number] [number]]] [examples [[[1 2 +] [3]] [[1.1 2.2 + 3.3 0.001 within?] [true]] [[1 2.2 +] [3.2]]]]]] [= [[spec [[item item] [boolean]]] [examples [[[1 2 =] [false]] [[1 1 =] [true]] [[[] [] =] [true]] [[[1] [] =] [false]] [[[1 [false]] [1 [false]] =] [true]] [[[1 ["foo"]] [1 ["foo"]] =] [true]] [["hi" "hi" =] [true]] [["hi" "there" =] [false]] [[[] true =] [false]] [[[1 ["foo"]] [1 ["bar"]] =] [false]] [[[] [] association =] [true]] [[[[a b]] [[a b]] association =] [false]]]]]]


** Association words
#+begin_src kcats :tangle src/kcats/builtins.kcats
  [++lookup [[spec [[item sized] [item]]]]]

  [association? [[spec [[item] [boolean]]]
                 [examples [[[[[a b] [c d]] association association?] [true]]
                            [[[[a b] [c d]] association?] [false]]
                            [[1 association?] [false]]
                            [[[] association?] [true]]
                            [[[] association association?] [true]]
                            [[[] [a] 1 assign association?] [true]]
                            [[[] [a] 1 assign association?] [true]]]]]]

  [association [[spec [[item] [association]]]
                [examples [[[[[a b] [c d]] association
                             [[c d] [a b]] association =]
                            [true]]

                           [[[[a b] [c d]]
                             [[c d] [a b]] association =]
                            [false]]

                           [[[[a b] [c d]]
                             [[a b] [c d]] association =]

                            [false]]]]]]

  [assign [[spec [[[item value]
                   [list keys]
                   sized]
                  [association]]]
           [examples [[[[[a b] [c d]] [a] 5 assign]
                       [[[a 5] [c d]] association]]

                      [[[[a b] [c d]] [e] 5 assign]
                       [[[a b] [c d] [e 5]] association]]

                      [[[[a b] [c [[d e]]]] [c d] 5 assign]
                       [[[a b] [c []]] [c] [[d 5]] association assign]]

                      [[[[a b] [c [[d e]]]] [1 1 0] 5 assign]
                       [[[a b] [c [5]]]]]

                      [[[1 2 3] [1 0 0] "foo" assign]
                       [[1 [["foo"]] 3]]]

                      [[[1 2 3] [1 2] "foo" assign]
                       [[1 [[] [] "foo"] 3]]]]]]]

  [unassign [[spec [[[item key] [sized into-association]] [association]]]
             [examples [[[[[a b] [c d]] [a] unassign]
                         [[[c d]] association]]

                        [[[[a b] [c d]] [e] unassign]
                         [[[a b] [c d]] association]]

                        [[[[a [[b c] [d e]]]] [a d] unassign]
                         [[] association [a b] [c] unwrap assign]]

                        [[[0 1 2 [[a b] [c d]]] [3 c] unassign]
                         [[0 1 2] [[a b]] association put]]]]]]

  [decide [[spec [[[list test-expr-pairs]] [*]]]
           [doc "Takes a list of choices (pairs of test, program) and
                  executes the first program whose test passes. if none
                  pass, returns 'nothing'. Stack is reset between
                  testing conditions."]
           [examples [[[5 [[[3 =] ["three"]]
                           [[5 =] ["five"]]
                           [[7 =] ["seven"]]
                           [[true] ["something else"]]]
                        decide]
                       [5 "five"]]

                      [[9 [[[3 =] ["three"]]
                           [[5 =] ["five"]]
                           [[7 =] ["seven"]]
                           [[true] ["something else"]]]
                        decide]

                       [9 "something else"]]
                      [[9 [[[3 =] ["three"]]
                           [[5 =] ["five"]]
                           [[7 =] ["seven"]]]
                        decide]
                       [9 []]]]]]]

  ;; TODO add 'set' type for spec?
  [set [[spec [[item] [item]]]
        [examples [[[[1 2 3 1 2 3] set] [[1 2 3] set]]]]]]

#+end_src

#+RESULTS:
: [decide [[spec [[[association test-expr-pairs]] [*]]] [doc "Takes a list of choices (pairs of test, program) and\n                executes the first program whose test passes. if none\n                pass, returns 'nothing'. Stack is reset between\n                testing conditions."] [examples [[[5 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]] [[true] ["something else"]]] decide] [5 "five"]] [[9 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]] [[true] ["something else"]]] decide] [9 "something else"]] [[9 [[[3 =] ["three"]] [[5 =] ["five"]] [[7 =] ["seven"]]] decide] [9 []]]]]]] [unassign [[spec [[[item key] association] [association]]] [examples [[[[[a b] [c d]] [a] unassign] [[[c d]] association]] [[[[a b] [c d]] [e] unassign] [[[a b] [c d]] association]] [[[[a [[b c] [d e]]]] [a d] unassign] [[] association [a b] c assign]] [[[0 1 2 [[a b] [c d]]] [3 c] unassign] [[0 1 2] [[a b]] association put]]]]]] [assign [[spec [[[item value] [list keys] association] [association]]] [examples [[[[[a b] [c d]] [a] 5 assign] [[[a 5] [c d]] association]] [[[[a b] [c d]] [e] 5 assign] [[[a b] [c d] [e 5]] association]] [[[[a b] [c [[d e]]]] [c d] 5 assign] [[[a b] [c []]] [c] [[d 5]] association assign]] [[[[a b] [c [[d e]]]] [1 1 0] 5 assign] [[[a b] [c [5]]]]] [[[1 2 3] [1 0 0] "foo" assign] [[1 [["foo"]] 3]]] [[[1 2 3] [1 2] "foo" assign] [[1 [[] [] "foo"] 3]]]]]]] [association [[spec [[item] [association]]] [examples [[[[[a b] [c d]] association [[c d] [a b]] association =] [true]] [[[[a b] [c d]] [[c d] [a b]] association =] [false]] [[[[a b] [c d]] [[a b] [c d]] association =] [false]]]]]] [association? [[spec [[item] [boolean]]] [examples [[[[[a b] [c d]] association?] [true]]]]]] [++lookup [[spec [[item association] [item]]]]]

** Sets
#+begin_src kcats :tangle src/kcats/builtins.kcats
  ;; TODO add 'set' type for spec?
  [set [[spec [[item] [item]]]
        [examples [[[[1 2 3 1 2 3] set] [[1 2 3] set]]]]]]

  [set? [[spec [[item] [boolean]]]
         [examples [[[[1 2 3] set set?] [true]]
                    [[[1 2 3] set?] [false]]]]]]
#+end_src
** Pipes
#+begin_src kcats :tangle src/kcats/builtins.kcats
  [atom [[spec [[item] [pipe]]]]]

  [buffer [[spec [[integer] [pipe]]]]]

  [timeout [[spec [[integer] [pipe]]]]]

  [handoff [[spec [[] [pipe]]]]]

  [select [[spec [[[list pipes]] [item pipe [list pipes]]]]]]

  [file-in [[spec [[string] [pipe]]]]]

  [file-out [[spec [[string] [pipe]]]]]

  [timestamps [[spec [[] [pipe]]]]]

  [standard [[spec [[] [pipe]]]]]
  
  [serversocket [[spec [[integer string] [pipe]]]]]

  [animate [[spec [[environment] []]]]]
#+end_src

#+RESULTS:
: [animate [[spec [[environment] []]]]] [serversocket [[spec [[integer string] [pipe]]]]] [handoff [[spec [[] [pipe]]]]] [file-out [[spec [[string] [pipe]]]]] [file-in [[spec [[string] [pipe]]]]] [spawn [[spec [[program] []]]]] [closed? [[spec [[pipe] [boolean]]]]] [close [[spec [[[pipe p]] [[pipe p]]]]]] [put [[spec [[item [pipe in]] [[pipe in]]]]]] [take [[spec [[[pipe out]] [item [pipe out]]]]]] [select [[spec [[[list pipes]] [item pipe [list pipes]]]]]] [handoff [[spec [[] [pipe]]]]] [filled [[spec [[list] [pipe]]]]] [timeout [[spec [[integer] [pipe]]]]] [buffer [[spec [[integer] [pipe]]]]] [atom [[spec [[item] [pipe]]]]]

* Lexicon
** Base standard library
#+begin_src kcats :tangle src/kcats/lexicon.kcats
  [flip [[spec [[[item a] [item b] [item c]]
                [[item c] [item b] [item a]]]]
         [definition [float swapdown]]]]

  [dive [[spec [[program [item a]] [item [item a] *]]]
         [definition [dip swap]]]]

  [divedown [[spec [[program [item a] [item b]] [item [item a] [item b] *]]]
             [definition [dipdown float]]]]

  [dropdown [[spec [[[item a] [item b]] [[item b]]]]
         [definition [swap drop]]]]

  [shield [[spec [[program]
                  [item]]]
           [doc "Runs program keeping top of stack produced but protects existing items from being consumed."]
           [definition [[snapshot] dip inject first]]
           [examples [[[1 2 3 [=] shield] [1 2 3 false]]]]]]

  [shielddown [[spec [[program item]
                      [item]]]
               [definition [shield dropdown]]
               [examples [[[1 2 3 [=] shielddown] [1 2 false]]]]]]

  [shielddeep [[spec [[[program p] [item consumed] [item consumed]]
                          [[item result]]]]
                   [definition [shield [drop drop] dip]]
                   [examples [[[1 2 3 [+ +] shielddeep] [1 6]]]]]]

  [if [[spec [[[program false-branch]
               [program true-branch]
               [program condition]]
              [*]]]
       [definition [[shield] dipdown branch]]
       [examples [[[5 [5 =] [3 *] [4 +] if] [15]]
                  [[6 [5 =] [3 *] [4 +] if] [10]]]]]]

  [rest [[spec [[list] [list]]]
         [definition [take drop]]
         [examples [[[[1 2 3] rest] [[2 3]]]]]]]

  [every? [[spec [[program sized] boolean]]
           [definition [[shielddown] decorate ;; building r1, run pred with unary
                        [take swap] swap put ;; add rest of dip program
                        [dive not] join ;; add the rest of outer dip
                        wrap [dip or] join ;; add rest of r1
                        ;; put the other recur clauses under r1
                        [[]
                         [[[nothing?] shield] dip
                          swap [or] shielddown] ;; the 'if' 
                         [not]] ;; then
                        dip ;; underneath the r1
                        [execute] recur ;; r2 and recur!
                        dropdown]]
           [examples [[[[2 4 6] [even?] every?] [true]]
                      [[[2 4 5] [even?] every?] [false]]
                      [[[] [even?] every?] [true]]
                      [[[2 4 6] [] every?] [true]]
                      [[11 [2 4 6] [+ odd?] every?] [11 true]]
                      [[12 [[even?] [positive?] [3 mod 0 =]] [execute] every?] [12 true]]]]]]

  [any? [[spec [[program sized] boolean]]
         [definition [[shielddown] decorate ;; building r1, run pred with unary
                      [take swap] swap put ;; add rest of dip program
                      [dive] join ;; add the rest of outer dip
                      wrap [dip or] join ;; add rest of r1
                      ;; put the other recur clauses under r1
                      [[]
                       [[[nothing?] shield] dip
                        swap [or] shielddown] ;; the 'if' 
                       []] ;; then
                      dip ;; underneath the r1
                      [execute] recur ;; r2 and recur!
                      dropdown]]
         [examples [[[[2 4 6] [even?] any?] [true]]
                    [[[3 5 7] [even?] any?] [false]]
                    [[[] [even?] any?] [false]]
                    [[[2 4 6] [] any?] [2]]
                    [[11 [3 5 6] [+ odd?] any?] [11 true]]
                    [[-15 [[even?] [positive?] [3 mod 0 =]] [execute] any?] [-15 true]]]]]]

  [primrec [[spec [[[program rec1]
                    [program exit]
                    [number data]]
                   [*]]]
            [definition [[execute] swap join ;; add execute to rec1 to be recurs rec2
                         [[drop] swap join] dip ;; add drop to exit condition
                         [[zero?]] dipdown  ;; put the condition on bottom
                         [[clone dec]] dip ;; add the r1
                         recur]] ;; now its generic recur
            [examples [[[5 [1] [*] primrec] [120]]]]]]

  [prepend [[spec [[item list]
                   [list]]]
            [definition [wrap swap join]]
            [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]]

  [assert [[spec [[program]
                  [*]]]
           [definition [snapshot ;; save stack to print in err message
                        [shield] dive ;; run the assertion under the saved stack
                        [drop] ;; if passes, drop the saved stack, dont need
                        [string ["assertion failed "] dip join fail] ;; else throw err
                        branch]]]]

  [inject [[spec [[program list]
                  [list]]]
           [doc "Inject the quoted program into the list below
                     it (runs the program with the list as its
                     stack).  Does not affect the rest of the stack."]
           [definition [swap evert take dip evert]]
           [examples [[[1 2 3 [4 5 6] [* +] inject] [1 2 3 [26]]]]]]]

  [snapshot [[spec [[] [list]]]
             [doc "Save the whole stack as a list on the stack"]
             [definition [[] evert clone evert unwrap]]
             [examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]]]
                        [[snapshot] [[]]]]]]]

  ;; infinite sequence (generators) functions

  [generate [[spec [[program item] [program item]]]
             [definition [clone [execute] dive]]
             [examples [[[1 [inc clone] generate] [2 [inc clone] 2]]]]]]

  [liberate [[spec [[] [program]]]
             [definition [[take]]]]]

  [collect [[spec [[program] [list]]]
            [definition [generate ;; n
                         [] swap clone ;; n n r
                         [put ;; r
                          [generate] dip ;; r n
                          swap clone]  ;; n n r 
                         loop drop]]
            [examples [[[[[1 2 3 4] [take] collect] shield]
                        [[1 2 3 4]]]
                       [[[0 10 1 range [take]
                          5 dropper
                          [10 *] each
                          collect]
                         shield]
                        [[50 60 70 80 90]]]]]]]

  [bail [[spec [[program] [*]]]
         [definition [[swap] [execute] [drop] if]]
         [examples [[[[] [inc] bail] [[]]]
                    [[1 [inc] bail] [2]]]]]]

  [decorate [[spec [[list program] [program]]]
             [definition [[[wrap] dip put] step]]
             [examples [[[[1 inc] [foo bar] decorate] [[[[1 inc] foo] bar]]]]]]]

  [decorated [[spec [[list program] [*]]]
              [definition [decorate execute]]
              [examples [[[1 2 [+] [bail shield] decorated] [1 2 3]]]]]]

  [each [[spec [[program] [program]]]
         [definition [[generate] swap
                      [bail shielddown] decorate
                      join]]
         [examples [[[[[1 2 3 4] liberate
                       [clone *] each
                       collect]
                      shield]

                     [[1 4 9 16]]]]]]]

  [joiner [[spec [[] [program]]]
           [definition [[generate [] swap
                         []
                         [join
                          [generate] dive] 
                         while drop]]]
           [examples [[[[[[1 2 3] [4 5 6] [7 8 9]] liberate
                         joiner
                         collect]
                        shield]

                       [[[1 2 3 4 5 6 7 8 9]]]]]]]]

  [taker [[spec [[] [program]]]
          [definition [[[positive?] [dec [generate] dive] [[]] if]]]
          [examples [[[[[1 2 3 4 5] liberate
                        3 taker
                        collect]
                       shield]

                      [[1 2 3]]]]]]]

  [dropper [[spec [[] [program]]]
            [definition [[[[positive?]
                           [[generate drop] dip dec]
                           while
                           [generate swap] dip float]
                          bail]]]
            [examples [[[[[1 2 3 4 5] liberate
                          3 dropper
                          collect]
                         shield]

                        [[4 5]]]]]]]
  [keep [[spec [[program] [program]]]
         [definition [[not] join
                      [something?] swap pair wrap [[execute] every?] join ;; pred that also checks for nothing first
                      [clone
                       [[generate] dip ;; pred 1 
                        [drop generate]
                        while]
                       dive]]]
         [examples [[[[[1 2 3 4 5] liberate
                       [odd?] keep
                       collect]
                      shield]

                     [[1 3 5]]]]]]]

  [reduce [[spec [[[program reducing-function] [program generator]] [item]]]
           [definition [[clone] join ;; -> [+ clone] to build the 'then' branch
                        ;; build the loop body
                        [[generate] dive []] swap put [[] if] join
                        ;; generate the first item under the loop body
                        [generate clone] dip
                        loop]]
           [examples [[[[integers 1 dropper 10 taker [+] reduce] shield] [55]]]]]]

  [map [[spec [[program sized] [list]]]
        [definition [[[liberate] dip each collect] shielddeep]] 
        [examples [[[[1 2 3] [inc] map] [[2 3 4]]]

                   ;; multi-arity mapping functions not supported
                   ;; there will only be one item on the stack
                   ;;[[1 [1 2 3] [+] map] [1 [2 3 4]]]
                   ;;[[7 9 [1 2 3] [+ *] map] [7 9 [70 77 84]]]
                   ;;[[7 9 [1 2 3] [drop drop] map] [7 9 [7 7 7]]]
                   ;; do it this way instead
                   [[1 [1 2 3] [1 swap +] map] [1 [2 3 4]]]
                   [[7 9 [1 2 3] [[7 9] dip + *] map] [7 9 [70 77 84]]]

                   [[[1 2 3] [drop 1 inc] map] [[2 2 2]]]
                   [[7 9 [+] [] map] [7 9 [+]]]]]]]

  [filter [[spec [[program list] [list]]]
           [definition [[[liberate] dip keep collect] shielddeep]]
           [examples [[[[1 2 3] [odd?] filter] [[1 3]]]
                      [[[2 4 6] [odd?] filter] [[]]]
                      [[33 [1 2 3] [33 + odd?] filter] [33 [2]]]]]]]

  [nothing? [[spec [[item] [boolean]]]
             [definition [[] =]]
             [examples [[[[] nothing?] [true]]
                        [[1 nothing?] [false]]
                        [[false nothing?] [true]]]]]]

  [something? [[spec [[item] [boolean]]]
               [definition [nothing? not]]
               [examples [[[1 something?] [true]]
                          [[false something?] [false]]
                          [[[] something?] [false]]]]]]

  [while [[spec [[[program body]
                  [program pred]]
                 [*]]]
          [definition [swap [shield] decorate ;; add shield to the pred program
                       clone dipdown ;; run it on the previous ToS
                       join loop]]
          [examples [[[3 [0 >] [clone dec] while] [3 2 1 0]]]]]]

  [until [[spec [[[program body]
                  [program pred]]
                 [*]]]
          [definition [swap ;; pred body
                       [not] join ;; reverse logic
                       [shield] decorate ;; add shield to the pred program -> pred body
                       join ;; [body ..  pred]
                       true swap ;; run at least once
                       loop]]
         [examples [[[2 [even?] [inc] until] [4]]]]]]

  [times [[spec [[[integer howmany]
                  [program body]]
                 [*]]]
          [definition [swap
                       [dec] swap put [dip] join ;; build [dec body dip]
                       [0 >] swap
                       while
                       drop]]
          [examples [[[[5] 3 times] [5 5 5]]
                     [[1 1 [inc swap] 3 times] [3 2]]]]]]

  [pair [[spec [[item item] [list]]]
         [definition [[wrap] dip put]]
         [examples [[[1 2 pair] [[1 2]]]
                    [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]]]]

  [both? [[spec [[program item item] [boolean]]]
          [definition [sink pair swap every?]]
          [examples [[[1 2 [odd?] both?] [false]]
                     [[1 3 [odd?] both?] [true]]]]]]

  [positive? [[spec [[number] [boolean]]]
              [definition [0 >]]]]

  [negative? [[spec [[number] [boolean]]]
              [definition [0 <]]]]

  [within? [[spec [[number number] [boolean]]]
            [definition [[- abs] dip <]]
            [examples [[[1.0 2.0 + 3 0.001 within?] [true]]]]]]

  [recover [[spec [[program program] [*]]]
            [definition [[[handle] join] dip ;; add handle to the end of test
                         [snapshot] dipdown ;; rec test ss
                         sink inject ;; res rec
                         [first error?] ;; err? res rec
                         [first swap execute];; drop the snapshot and run recovery
                         [evert drop] ;; use snapshot as stack
                         if]]
            [examples [[[[+]
                         [drop 1
                          [+] [drop 2 +]
                          recover]
                         recover]
                        [3]]

                       [[[1 2 "oh fudge"]
                         [[5 +]
                          [drop 5]
                          recover]
                         map]
                        [[6 7 5]]]

                       [[[swap] [drop swap] recover]
                        [swap]]]]]]

  [retry [[spec [[error] [*]]]
          [definition [[unwound] lookup
                       execute]]
          [examples [[[2 3 "four" * + handle [drop 4] dip retry] [14]]]]]]

  [close [[spec [[pipe] []]]
          [definition [drop]]]]

  [lingo [[spec [[[program p]
                  [program dictionary-modifier]] [*]]]
          [definition [dictionary ;; fetch the dictionary
                       sink ;; p o d
                       [clone] dipdown ;; p o d d
                       [execute] dip ;; n=new-dict p n d
                       float ;; d p n
                       swapdown ;; d n p
                       [redefine ;; p
                        execute]
                       dip ;; d
                       redefine]]
          [examples [[[[[square] [[definition [clone *]]
                                  [spec [[number] [number]]]] assign]
                       [9 square]
                       lingo]
                      [81]]]]]]

  ;; modifies a dictionary to remove any i/o capable words, for use with lingo
  [functional [[spec [[] [program]]]
               [definition [[[pipe-in pipe-out channel timeout
                              handoff file-in file-out timestamps
                              standard serversocket animate future
                              spit tunnel]
                             [wrap unassign] step]]]
               [examples [[[functional ["foo" file-in] lingo handle type]
                           ["foo" [error] unwrap]]]]]]

  [let [[spec [[[program p]
                [program dictionary-modifier]] [*]]]
        [definition [[wrap
                      [[[1] [shield
                             wrap
                             [[[spec [[] [item]]]] ;; spec of self-insert
                              [definition]] dip
                             assign] ;; build a full entry
                        update]
                       map association join]
                      join] dip
                     lingo]]
        [examples [[[[[a [1 1 1]]
                      [b [6 7 *]]]
                     [a b +] let] [43]]]]]]

  [tos [[spec [[environment] [item]]]
        [definition [[stack] lookup first]]
        [examples [[[[[stack [1 2 3]]
                      [expression [[+] step]]]
                     tos]
                    [1]]]]]]

  [toe [[spec [[environment] [item]]]
        [definition [[expression] lookup first]]
        [examples [[[[[stack [1 2 3]]
                      [expression [[+] step]]]
                     toe]
                    [[+]]]]]]]

  [break [[spec [[environment [program condition]]
                 [environment [program condition]]]]
          [definition [[[[[expression] lookup something?] ;; something still in the expression
                         [swap execute not]] ;; check condition not true yet
                        [execute]
                        every?] ;; break?
                       [eval-step]  ;; evaluate the environment one step
                       while]]]]

  [advance [[spec [[environment] [environment]]]
            [definition [[[expression] lookup count] shield swap ;; count up the expression length, we'll run until it's smaller than this

                         [[expression] lookup count  ;; only stop if expr empty or shorter than we started off
                          [[positive?] [<=]] [execute] every?]
                         [eval-step]  ;; evaluate the environment one step
                         while
                         dropdown ;; drop the expression length item
                        ]]]]

  [pipe-in [[spec [[item] [pipe]]]
            [definition [[[[type [file] unwrap =]
                           [value file-in]]
                          [[type [stdout] unwrap =]
                           [stdout]]]
                         decide]]]]

  [tunnel [[spec [[item] [pipe]]]
           [definition [[[[type [ip-port] unwrap =]
                          [clone
                           [port] lookup
                           [[address] lookup] dip
                           !**java.net.Socket.]]]
                        decide]]]]

  [pipe-out [[spec [[item] [pipe]]]
             [definition [[[[type [file] unwrap =]
                            [value file-out]]
                           [[type [ip-port] unwrap =]
                            [clone
                             [port] lookup
                             [[address] lookup] dip
                             serversocket]]]                        
                          decide]]]]

  [spit [[spec [[item [item target]] []]]
         [definition [[pipe-in] dip bytes put drop]]]]

  ;;[slurp [[spec [[[item target]] [item pipe]]]]]
#+end_src

#+RESULTS:
: 
: [[recover [[spec [[program program] [*]]] [definition [[[handle] join] dip [snapshot] dipdown sink inject [first error?] [first swap execute] [evert drop] if]] [examples [[[[+] [drop 1 [+] [drop 2 +] recover] recover] [3]] [5 [1 2 "oh fudge"] [[+] [drop drop] recover] map] [5 [6 7 5]]]]]] [error? [[spec [[item] [boolean]]] [definition [[[association?] [type [error] unwrap =]] [execute] every? dropdown]]]] [zero? [[spec [[number] [boolean]]] [definition [0 =]] [examples [[[0 zero?] [true]] [[0 zero?] [true]] [[-0.00001 zero?] [false]] [[1.1 zero?] [false]]]]]] [negative? [[spec [[number] [boolean]]] [definition [0 <]]]] [positive? [[spec [[number] [boolean]]] [definition [0 >]]]] [both? [[spec [[program item item] [boolean]]] [definition [sink pair swap every?]] [examples [[[1 2 [odd?] both?] [false]] [[1 3 [odd?] both?] [true]]]]]] [pair [[spec [[item item] [list]]] [definition [[wrap] dip put]] [examples [[[1 2 pair] [[1 2]]] [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]]]]]]] [times [[spec [[[program body] [integer howmany]] [*]]] [definition [[dec] swap put [dip] join [0 >] swap while drop]]]] [while [[spec [[[program body] [program pred]] [*]]] [definition [swap wrap [shield] join clone dipdown join loop]] [examples [[[3 [0 >] [clone dec] while] [3 2 1 0]]]]]] [something? [[spec [[item] [boolean]]] [definition [nothing? not]] [examples [[[1 something?] [true]] [[false something?] [true]] [[[] something?] [false]]]]]] [nothing? [[spec [[item] [boolean]]] [definition [[] =]] [examples [[[[] nothing?] [true]] [[1 nothing?] [false]] [[false nothing?] [false]]]]]] [filter [[spec [[program list] [list]]] [definition [[snapshot [] swap] dipdown [[clone] dip clone wrap swapdown] swap put [join inject first [[put]] [[drop]] branch swapdown dip] join step drop]] [examples [[[[1 2 3] [odd?] filter] [[1 3]]] [[[2 4 6] [odd?] filter] [[]]] [[33 [1 2 3] [+ odd?] filter] [[2] 33]]]]]] [map [[spec [[program list] [list]]] [definition [[snapshot [] swap] dipdown [wrap swap clone float] swap put [[swap join] dip inject first swap [put] dip] join step drop]] [examples [[[[1 2 3] [inc] map] [[2 3 4]]] [[1 [1 2 3] [+] map] [[2 3 4] 1]] [[7 9 [1 2 3] [+ *] map] [[70 77 84] 9 7]] [[7 9 [+] [] map] [[+] 9 7]]]]]] [snapshot [[spec [[] [list]]] [doc "Save the whole stack as a list on the stack"] [definition [[] evert clone evert unwrap]] [examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]]] [[snapshot] [[]]]]]]] [inject [[spec [[program list] [list]]] [doc "Inject the quoted program into the list below\n                   it (runs the program with the list as its\n                   stack).  Does not affect the rest of the stack."] [definition [swap evert take dip evert]] [examples [[[1 2 3 [4 5 6] [* +] inject] [1 2 3 [26]]]]]]] [assert [[spec [[program] [*]]] [definition [snapshot [shield] dip swap [drop] [string ["assertion failed "] dip join fail] branch]]]] [prepend [[spec [[item list] [list]]] [definition [wrap swap join]] [examples [[[[1 2] 3 prepend] [[3 1 2]]]]]]] [primrec [[spec [[[program rec1] [program exit] [number data]] [*]]] [definition [[execute] swap join [[drop] swap join] dip [[zero?]] dipdown [[clone dec]] dip recur]] [examples [[[5 [1] [*] primrec] [120]]]]]] [any? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [take swap] swap put [dip swap] join wrap [dip or] join [false [[[nothing?] shield] dip swap [or] shielddown] []] dip [execute] recur swap drop]] [examples [[[[2 4 6] [even?] any?] [true]] [[[3 5 7] [even?] any?] [false]] [[[] [even?] any?] [false]] [[[2 4 6] [] any?] [2]] [[11 [3 5 6] [+ odd?] any?] [true 11]] [[-15 [[even?] [positive?] [3 rem 0 =]] [execute] any?] [true -15]]]]]] [every? [[spec [[program list] boolean]] [definition [[shielddown] swap prepend [take swap] swap put [dip swap not] join wrap [dip or] join [false [[[nothing?] shield] dip swap [or] shielddown] [not]] dip [execute] recur swap drop]] [examples [[[[2 4 6] [even?] every?] [true]] [[[2 4 5] [even?] every?] [false]] [[[] [even?] every?] [true]] [[[2 4 6] [] every?] [true]] [[11 [2 4 6] [+ odd?] every?] [true 11]] [[12 [[even?] [positive?] [3 rem 0 =]] [execute] every?] [true 12]]]]]] [if [[spec [[[program false-branch] [program true-branch] [program condition]] [*]]] [definition [[shield] dipdown branch]] [examples [[[5 [5 =] [3 *] [4 +] if] [15]] [[6 [5 =] [3 *] [4 +] if] [10]]]]]] [shielddeep [[spec [[[program p] [item consumed] [item consumed]] [[item result]]]] [definition [shield [drop drop] dip]] [examples [[[1 2 3 [+ +] shielddeep] [1 6]]]]]] [shielddown [[spec [[program item] [item]]] [definition [shield swap drop]] [examples [[[1 2 3 [=] shielddown] [1 2 false]]]]]] [shield [[spec [[program] [item]]] [doc "Runs program keeping top of stack produced but protects existing items from being consumed."] [definition [[snapshot] dip inject first]] [examples [[[1 2 3 [=] shield] [1 2 3 false]]]]]]]


** Associative words
#+begin_src kcats :tangle src/kcats/lexicon.kcats
  ;; Associative words
  [update [[spec [[program [list keys] [sized into-association]]
                  [association]]]
           [definition [[[lookup] shield] dip ;; m ks v p
                        shielddown
                        assign]]
           [examples [[[[[a 1] [b 2]] [b] [inc] update]
                       [[[a 1] [b 3]] association]]

                      [[[[a [[c 3] [d 5]]] [b 2]]
                        [a c] [inc] update
                        [a c] lookup]
                       [4]]

                      [[[[a [[c 3] [d 5]]] [b 2]]
                        [a c] [drop 10 15] update
                        [a c] lookup]
                       [15]]

                      [[[[a 1] [b 2]] [d] [5] update]
                       [[[a 1] [b 2] [d 5]] association]]

                      [[[[a [[c 3] [d 5]]] [b 2]]
                        [a e] [5 6 +] update
                        [a e] lookup]
                       [11]]]]]]

  [lookup [[spec [[[list keys] sized] [item]]]
           [definition [[[[swap list?] ;; it's a list
                          ;; [swap something?] ;; it's not empty
                          [something?]] ;; the keylist is not empty
                         [execute]
                         every?]
                        [take swap [++lookup] dip] ;; extract the first key and lookup
                        while

                        [something?]
                        ;; fail if we could not drill down all the way
                        [[[type error]
                          [asked [association]]
                          [reason "Lookup attempted on non-associative value"]]
                         fail]
                        [drop]  ;; get rid of remaining keylist
                        if]]
           [examples [[[[[a b] [c d]] [a] lookup] [[b] unwrap]]
                      [[[[a b] [c d]] [e] lookup] [[]]]
                      [[[[outer [[a b] [c d]]]] [outer c] lookup] [[d] unwrap]]]]]]

  ;; TODO: fix the case where you just want a value [[type foo]] - only
  ;; one item but you want the value, not key
  [type [[spec [[item] [item]]]
         [definition [[[[nothing?] [[nothing] unwrap]]
                       [[word?] [[word] unwrap]]
                       [[number?] [[number] unwrap]]
                       [[string?] [[string] unwrap]]
                       [[bytes?] [[bytes] unwrap]]
                       [[pipe?] [[pipe] unwrap]]
                       [[error?] [[error] unwrap]]
                       [[association?] [[[[type] lookup]
                                         [[count 1 =]
                                          [[first [type] unwrap =]
                                           [first second]
                                           [first first]
                                           if]
                                          [[]]
                                          if]
                                         [[association] unwrap]]
                                        [execute] any?]]
                       [[list?] [[list] unwrap]]]
                      decide dropdown]]
         [examples [[[[[foo 1]] association type] [[foo] unwrap]]
                    [[1 type] [[number] unwrap]]
                    [[1.0 type] [[number] unwrap]]
                    [[[] type] [[nothing] unwrap]]
                    [["foo" bytes type] [[bytes] unwrap]]
                    [["foo" type] [[string] unwrap]]
                    [[[[type foo]] association type] [[foo] unwrap]]
                    [[[[type foo] [attr "blah"]] association type] [[foo] unwrap]]
                    [[[[attr1 foo] [attr2 "blah"]] association type] [[association] unwrap]]
                    [[[[type url] [value "http://foo.com"]] association type] [[url] unwrap]]]]]]

  [value [[spec [[[sized into-association]] [item]]]
          [definition [[count 1 =] ;; if it's a single item
                       [first second] ;; the value is the value of that first item
                       [[value] lookup] ;; otherwise look up the key 'value'
                       if]]
          [examples [[[[[foo 1]] value] [1]]

                     [[[[type url] [value "http://foo.com"]] value]
                      ["http://foo.com"]]]]]]
  [zip [[spec [[[list values] [list keys]] [association]]]
        [definition [[[]] dipdown ;; add empty result below ToS
                     [[take wrap] ;; take the next key, wrap it
                      ;; to make a "pair" (adding
                      ;; value later)
                      dip ;; run that underneath the current value
                      put ;; the value into the "pair" we created earlier
                      swap [put] dip] ;; add the new pair to the results
                     step ;; through all the values
                     drop]] ;; the now-empty list of keys
        [examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]]]]]]]
#+end_src

** Methods
We want a way of adding methods to a word that's already set up as a
simple 'decide' form. This will add the method at the beginning -
adding it at the end is not good because often there's a catchall
condition at the end, and adding beyond that means the new condition
is unreachable. Adding at the beginning is not always what the user
wants either, though. So maybe this could be improved by taking
another argument: a program to combine the item and the existing list
(that defaults to =prepend= here).
#+begin_src kcats :tangle src/kcats/lexicon.kcats
  [addmethod [[spec [[[pair condition] [program combinator] word] []]]
              [definition [float ;; work with the word first to get definition: w c b
                           [wrap dictionary swap lookup] shield ;; leave the word and put def on top: def w c b
                           [wrap swap put] divedown ;; [c b] def w 
                           [  ;; b c decide cs
                           float ;; decide b c cs
                           [execute] dip] ;; run combinator which will work on c cs 
                           join inject ;; join with [c b], the above program to run on the definition
                           swap inscribe]]]] ;; redefine word
#+end_src

** Programmable Runtime
We can make some handy words to help debug programs.

#+begin_src kcats :tangle src/kcats/lexicon.kcats
  [tos [[spec [[environment] [item]]]
        [definition [[stack] lookup first]]
        [examples [[[[[stack [1 2 3]]
                      [expression [[+] step]]]
                     tos]
                    [1]]]]]]

  [toe [[spec [[environment] [item]]]
        [definition [[expression] lookup first]]
        [examples [[[[[stack [1 2 3]]
                      [expression [[+] step]]]
                     toe]
                    [[+]]]]]]]

  [break [[spec [[environment [program condition]]
                 [environment [program condition]]]]
          [definition [[[[[expression] lookup something?] ;; something still in the expression
                         [swap execute not]] ;; check condition not true yet
                        [execute]
                        every?] ;; break?
                       [eval-step]  ;; evaluate the environment one step
                       while]]]]

  [advance [[spec [[environment] [environment]]]
            [definition [[[expression] lookup count] shield swap ;; count up the expression length, we'll run until it's smaller than this

                         [[expression] lookup count  ;; only stop if expr empty or shorter than we started off
                          [[positive?] [<=]] [execute] every?]
                         [eval-step]  ;; evaluate the environment one step
                         while
                         dropdown ;; drop the expression length item
                        ]]]]
#+end_src

*** Other examples
**** Count the number of times each word is executed while running a program.
#+begin_src kcats :results code
[[expression [10 [0 >] [clone dec] while]]]  ;; the sample program to run
environment
evaluate
#+end_src

#+RESULTS:
#+begin_src kcats
[[stack [0 1 2 3 4 5 6 7 8 9 10]] [expression []]]
#+end_src

#+begin_src kcats
10 [0 >] [clone dec] while
#+end_src
#+RESULTS:
: 
: [0 1 2 3 4 5 6 7 8 9 10]

#+begin_src kcats
[swap] unwrap  word?
#+end_src

#+RESULTS:
: 
: [true]

"Increment the counter, or set to 1 if nothing"
#+begin_src kcats
[] [inc] bail 1 or
#+end_src

#+RESULTS:
: 1

#+begin_src kcats :results code
[] ;; empty list to put word counts in
[[expression [3 [0 >] [clone dec] while]]]  ;; the sample program to run
environment 
[[expression] lookup something?] ;; something still in the expression, keep running
[[[expression] lookup first] shield ;; get the item we're about to execute
 swap ;; put it under the environment
 [[word?] ; if it's a word
  [wrap
   [[inc] bail 1 or]
   update] ;; the results, the count for the word about to execute
  [drop] ;; if it's not a word, do nothing
  if] dip
 eval-step] ;; evaluate the environment one step
while 
drop ;; drop the environment and just report the word counts
#+end_src

#+RESULTS:
#+begin_src kcats
[[wrap 1] [step 2] [first 4] [snapshot 4] [execute 1] [put 1] [inject 4] [loop 4] [dec 3] [decorate 1] [swap 5] [unwrap 14] [take 4] [join 1] [> 4] [while 1] [shield 4] [dipdown 1] [evert 16] [clone 8] [dip 9]]
#+end_src

**** TODO spec checking
clojure spec check can be replaced with predicate programs, that will
be run with =shield= before the actual word and if it returns false,
will raise an error. 
**** TODO Trace output
#+begin_src kcats :results code
[] ;; results
[[expression [1 [2 3 4 5] [*] step]]]  ;; the sample program to run
environment

[[expression] lookup something?] ;; break?
[eval-step clone [put] dip]  ;; evaluate the environment one step
while

#+end_src

#+RESULTS:
#+begin_src kcats
[[[stack [120]] [expression []]]
 [[[stack [1]] [expression [[2 3 4 5] [*] step]]]
  [[stack [[2 3 4 5] 1]] [expression [[*] step]]]
  [[stack [[*] [2 3 4 5] 1]] [expression [step]]]
  [[stack [[*] 2 1]] [expression [execute [3 4 5] [*] step]]]
  [[stack [2 1]] [expression [* [3 4 5] [*] step]]]
  [[stack [2]] [expression [[3 4 5] [*] step]]]
  [[stack [[3 4 5] 2]] [expression [[*] step]]]
  [[stack [[*] [3 4 5] 2]] [expression [step]]]
  [[stack [[*] 3 2]] [expression [execute [4 5] [*] step]]]
  [[stack [3 2]] [expression [* [4 5] [*] step]]]
  [[stack [6]] [expression [[4 5] [*] step]]]
  [[stack [[4 5] 6]] [expression [[*] step]]]
  [[stack [[*] [4 5] 6]] [expression [step]]]
  [[stack [[*] 4 6]] [expression [execute [5] [*] step]]]
  [[stack [4 6]] [expression [* [5] [*] step]]]
  [[stack [24]] [expression [[5] [*] step]]]
  [[stack [[5] 24]] [expression [[*] step]]]
  [[stack [[*] [5] 24]] [expression [step]]]
  [[stack [[*] 5 24]] [expression [execute]]]
  [[stack [5 24]] [expression [*]]]
  [[stack [120]] [expression []]]]]
#+end_src


**** DONE Step count limiting
When testing or debugging, limit the number of steps to avoid a
possible infinite loop.
#+begin_src kcats :results code
  200 ;; step count remaining
  [[expression [10 [0 >] [clone dec] while]]]  ;; the sample program to run
  environment

  [[expression] lookup something? ;; something still in the expression
   [positive?] dip and] ;; still step budget remaining
  [eval-step ;; evaluate the environment one step
   [dec] dip] ;; decrease the step budget 
  while

  ;[stack] lookup ;; return the output
#+end_src

#+RESULTS:
#+begin_src kcats
[[expression [take dip evert first [clone dec [0 >] shield] loop]] [stack [[[0 >] 4 5 6 7 8 9 10] 4 5 6 7 8 9 10]]] 0
#+end_src

**** DONE Breakpoint
#+begin_src kcats
[[[[toe [+] unwrap =]
   [tos 3 >]]
  [execute]
  every?] ;; when to stop - when we're about to add and tos already >3
 [0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
 [[[[expression] lookup something?] ;; something still in the expression
   [swap execute not]] ;; don't stop yet
  [execute]
  every?] ;; break?
 [eval-step]  ;; evaluate the environment one step
 while]
#+end_src
**** TODO Step over
#+begin_src kcats
[[0 [1 2 3 4 5] [+] step]  ;; the sample program to run
 environment
 
[[expression] lookup count] shield swap;; count up the expression length, we'll run until it's smaller than this
 
 [[expression] lookup count
  [[positive?] [<=]] [execute] every?] ;; only stop if expr empty or shorter than we started off
 [eval-step]  ;; evaluate the environment one step
 while]
#+end_src

** Pipes
#+begin_src kcats :tangle src/kcats/lexicon.kcats
  [pipe-in [[spec [[item] [pipe]]]
            [definition [[[[type [file] unwrap =]
                           [value file-in]]
                          [[type [stdout] unwrap =]
                           [stdout]]]
                         decide]]]]

  [tunnel [[spec [[item] [pipe]]]
           [definition [[[[type [ip-port] unwrap =]
                          [clone
                           [port] lookup
                           [[address] lookup] dip
                           !**java.net.Socket.]]]
                        decide]]]]

  [pipe-out [[spec [[item] [pipe]]]
             [definition [[[[type [file] unwrap =]
                            [value file-out]]
                           [[type [ip-port] unwrap =]
                            [clone
                             [port] lookup
                             [[address] lookup] dip
                             serversocket]]]                        
                          decide]]]]

  [spit [[spec [[item [item target]] []]]
         [definition [[pipe-in] dip bytes put drop]]]]

  ;;[slurp [[spec [[[item target]] [item pipe]]]]]

  [future [[spec [[program] [pipe]]]
           [definition [handoff swap ;; make a pipe
                        ;; save the stack, including pipe
                        [snapshot] dip
                        ;; prepare the program for the new env
                        ;; end up with [[+ snapshot] dive put]
                        [snapshot] join wrap [dive put drop] join
                        ; ;; now we have expr stack
                        pair
                        [stack expression] swap zip environment
                        animate]]
           [examples [[[1 [2 +] future take dropdown] [1 [3]]]]]]]
#+end_src
* Issues
** DONE Get rid of platform-specific definitions
** DONE fix evaluate
#+begin_src kcats
  [[expression [1 1 +]]] environment evaluate [stack] lookup
#+end_src

#+RESULTS:
: 
: [[2]]
