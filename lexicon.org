# -*- mode: org; -*-
# -*- org-export-babel-evaluate: nil -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="doc-custom.css"/>

#+TITLE: The kcats Programming Language Lexicon
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:kcats :results code :exports both
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)

* Standard library source and documentation
** Comparison
Words that help compare one item to another, with concepts of =equal=, =greater=, =less= etc.

#+begin_src kcats :tangle src/kcats/core/compare-builtins.kcats :mkdirp yes
  [[= [[spec [[item item] [boolean]]]
       [doc "Test two items for equality"]
       [examples [[[1 2 =] [ğŸ”³] "Different Numbers are not equal"]
                  [[1 1 =] [âœ…] "Same numbers are equal"]
                  [[1 1.0 =] [âœ…] "Same value integer and float are equal"]
                  [[[1] ğŸ”³ =]  [ğŸ”³] "Number and Nothing are unequal"]
                  [[[1 [ğŸ”³]] [1 [ğŸ”³]] =] [âœ…] "Same nested list with numbers are equal"]
                  [[[1.0 ["foo"]] [1.0 ["foo"]] =] [âœ…] "Same nested list with string are equal"]
                  [["hi" "hi" =] [âœ…] "Same strings are equal"]
                  [["hi" "there" =] [ğŸ”³] "Different strings are unequal"]
                  [[\h \h =] [âœ…] "Same characters are equal"]
                  [[\h \i =] [ğŸ”³] "Different characters are unequal"]
                  [["hi" encode "hi" encode =] [âœ…] "Same bytes are equal"]
                  [["hi" encode "there" encode =] [ğŸ”³] "Different bytes are unequal"]
                  [[ğŸ”³ âœ… =] [ğŸ”³] "Different booleans unequal"]
                  [[[1.0 ["foo"]] [1.0 ["bar"]] =]  [ğŸ”³] "Nested lists with different strings are unequal"]
                  [[ğŸ”³ ğŸ”³ =] [âœ…] "'Nothing' is equal to itself"]
                  [[ğŸ”³ ğŸ”³ association =] [âœ…] "List/Association empty container types are equal"]
                  [[ğŸ”³ ğŸ”³ set =] [âœ…] "List/Set empty container types are equal"]
                  [[[[a b]] [[a b]] association =] [ğŸ”³] "Nonempty List/Association types are unequal"]
                  [[[1 2 3] set [3 1 2] set =] [âœ…] "Sets constructed from different lists are equal"]
                  [[["foo" =] [ğŸ—‘ï¸ "Needs 2 items"] ğŸ©¹ â–¶ï¸] ["Needs 2 items"] "Less than 2 stack items results in an error"]]]]]

   [compare [[spec [[item item] [word]]]
             [doc "Compare 2nd stack item to 1st, returning word `equal`, `greater`, or `less`"]
             [examples [[["a" "b" compare] [[less] ğŸ«] "string lexicographical order with single character inequality"]
                        [["a" "a" compare] [[equal] ğŸ«] "string lexicographical order with single character equality"]
                        [[1 1 compare] [[equal] ğŸ«] "Same integer compares equal"]
                        [[2 1 compare] [[greater] ğŸ«] "Integer order inequality"]
                        [[1 [foo] ğŸ« compare] [[less] ğŸ«] "Integer/list order inequality"]
                        [[1 "foo" encode compare] [[less] ğŸ«] "Integer/byte order inequality"]
                        [[[foo] ğŸ« "foo" encode compare] [[less] ğŸ«] "Word/string order inequality"]
                        [["foo" encode "foo" compare] [[less] ğŸ«] "String order equaltiy"]
                        [[ğŸ”³ [ğŸ”³] ğŸ« compare] [[equal] ğŸ«] "Unwrapped Nothing value equality"]
                        [[ğŸ”³ [1] rest compare] [[equal] ğŸ«] "Nothing/emptied container equality"]
                        [[["foo" compare] [ğŸ—‘ï¸ "Needs 2 items"] ğŸ©¹ â–¶ï¸] ["Needs 2 items"] "Less than 2 stack items results in an error"]

                        ;; Length comparisons
                        [["ab" "a" compare] [[greater] ğŸ«] "Longer string is greater"]
                        [["" "" compare] [[equal] ğŸ«] "Empty strings are equal"]
                        [["" "a" compare] [[less] ğŸ«] "Empty string is less than non-empty"]

                        ;; List comparisons
                        [[[1 2] [1 2] compare] [[equal] ğŸ«] "Equal lists compare equal"]
                        [[[1 2] [1 3] compare] [[less] ğŸ«] "Lists compared element by element"]
                        [[[1 2 3] [1 2] compare] [[greater] ğŸ«] "Longer list is greater"]
                        [[ğŸ”³ ğŸ”³ compare] [[equal] ğŸ«] "Empty lists are equal"]
                        [[ğŸ”³ [1] compare] [[less] ğŸ«] "Empty list is less than non-empty"]

                        ;; Mixed type edge cases
                        [[ğŸ”³ "" compare] [[greater] ğŸ«] "Empty list vs empty string"]
                        [[[ğŸ”³] ğŸ”³ compare] [[greater] ğŸ«] "Nothing in list vs bare Nothing"]
                        [[[""] ğŸ”³ compare] [[greater] ğŸ«] "List with empty string vs empty list"]

                        ;; Number edge cases
                        [[0 -0 compare] [[equal] ğŸ«] "Zero equals negative zero"]
                        [[42 42.0 compare] [[equal] ğŸ«] "Integer equals float representation"]
                        [[-1 1 compare] [[less] ğŸ«] "Negative less than positive"]

                        ;; Unicode string comparisons
                        [["Ã©" "e" compare] [[greater] ğŸ«] "Accented character comparison"]
                        [["a" "A" compare] [[greater] ğŸ«] "Case-sensitive comparison"]
                        [["ğŸ«" "a" compare] [[greater] ğŸ«] "Emoji vs ASCII"]

                        ;; Nested structure comparisons
                        [[[1 [2]] [1 [2]] compare] [[equal] ğŸ«] "Nested structure equality"]
                        [[[1 [2]] [1 [3]] compare] [[less] ğŸ«] "Nested structure inequality"]
                        [[[ğŸ”³ ğŸ”³] [ğŸ”³ ğŸ”³] compare] [[equal] ğŸ«] "Different arrangements of Nothing and empty list"]]]]]]
  ğŸ”—
  #+end_src

#+begin_src kcats :tangle src/kcats/stdlib/compare.kcats :mkdirp yes
  [[< [[spec [[[item a] [item b]] [boolean]]]
       [doc "Is the 2nd stack item less than the first"]
       [definition [ğŸ”³ both compare [less] ğŸ« =]]
       [examples [[[1 2 <] [âœ…] "Integer is less"]
                  [[2.2 1.1 <] [ğŸ”³] "Float is not less"]
                  [[1 2.2 <] [âœ…] "Integer/float is less"]
                  [[-3 2.2 <] [âœ…] "Negative integer/float is less"]
                  [[0 2.2 <] [âœ…] "Zero Integer/float is less"]
                  [[1.1 1.1 <] [ğŸ”³] "Equal floats is not less"]
                  [[-1.1 -1.1 <] [ğŸ”³] "Negative equal floats is not less"]
                  [["a" "b" <] [âœ…] "String is less than other string"]
                  [[["a" "b"] ["a" "c"] <] [âœ…] "List is less than other list"]]]]]

   [<= [[spec [[[item a] [item b]] [boolean]]]
        [doc "Is the 2nd stack item less than or equal to the first"]
        [definition [> â˜¯ï¸]]
        [examples [[[1 2 <=] [âœ…] "Integer is less/equal"]
                   [[2.2 1.1 <=] [ğŸ”³] "Float is not less/equal"]
                   [[1 2.2 <=] [âœ…] "Integer/float is less/equal"]
                   [[1.1 1.1 <=] [âœ…] "Equal floats is less/equal"]]]]]

   [> [[spec [[[item a] [item b]] [boolean]]]
       [doc "Is the 2nd stack item greater than the first"]
       [definition [ğŸ”³ both compare [greater] ğŸ« =]]
       [examples [[[2 1 >] [âœ…] "Integer is greater"]
                  [[1.1 2.2 >] [ğŸ”³] "Float is not greater"]
                  [[2.2 1 >] [âœ…] "Integer/float is greater"]
                  [[-1 -2.2 >] [âœ…] "Negative integer/float is greater"]
                  [[0 -2.2 >] [âœ…] "Zero Integer/float is greater"]
                  [[1.1 1.1 >] [ğŸ”³] "Equal floats is not greater"]
                  [[-1.1 -1.1 >] [ğŸ”³] "Negative equal floats is not greater"]]]]]

   [>= [[spec [[[item a] [item b]] [boolean]]]
        [doc "Is the 2nd stack item greater than or equal to the first"]
        [definition [< â˜¯ï¸]]
        [examples [[[2 1 >=] [âœ…] "Integer is greater/equal"]
                   [[1.1 2.2 >=] [ğŸ”³] "Float is not greater/equal"]
                   [[2.2 1 >=] [âœ…] "Integer/float is greater/equal"]
                   [[1.1 1.1 >=] [âœ…] "Equal floats is greater/equal"]]]]]

   [between? [[spec [[[number exclusive-upper-bound] [number inclusive-lower-bound] number]]]
              [doc "Is number between inclusive-lower-bound and exclusive-upper-bound?"]
              [definition [[>=] â€¢ğŸ›¡ï¸ ğŸª„ ğŸ”€ [<] ğŸª„ and]]
              [examples [[[9 2 10 between?] [âœ…] "Number is between other numbers"]
                         [[10 2 10 between?] [ğŸ”³] "Number exactly at upper bound, thus is not between"]
                         [[1 2 10 between?] [ğŸ”³] "Number below lower bound is not between"]
                         [[11 2 10 between?] [ğŸ”³] "Number above upper bound is not between"]
                         [["b" "a" "c" between?] [âœ…] "String is between other strings"]]]]]

   [max [[spec [[number number] [number]]]
         [doc "Compares the top two stack items and returns the one that compares `greater`"]
         [definition [[>] ğŸ›¡ï¸ [ğŸ—‘ï¸] [ğŸ”€] âš–ï¸ â–¶ï¸ ğŸ—‘ï¸]]
         [examples [[[2 3 max] [3] "Larger of two positive integers"]
                    [[-5 -3 max] [-3] "Larger of two positive integers"]
                    [[0.3 0.2 max] [0.3] "Larger of two floats <1"]]]]]

   [max-by [[spec [[program [item a] [item b]] [item]]]
            [doc "Runs program on top two stack items, and returns the result that compares `greater`"]
            [definition [[both compare ğŸ] â€¢ğŸ›¡ï¸ â–¶ï¸ [less] =
                         [ğŸ—‘ï¸ â€¢ğŸ—‘ï¸] [ğŸ—‘ï¸] â†”ï¸]]
            [examples [[[[[price 25] [name bar]]
                         [[price 15] [name foo]]
                         [[price] ğŸ”] max-by] [[[price 25] [name bar]]]]]]]]

   [min [[spec [[number number] [number]]]
         [doc "Compares the top two stack items and returns the one that compares `less`"]
         [definition [[<] ğŸ›¡ï¸ [ğŸ—‘ï¸] [ğŸ”€] âš–ï¸ â–¶ï¸ ğŸ—‘ï¸]]
         [examples [[[2 3 min] [2] "Smaller of two positive integers"]
                    [[-5 -3 min] [-5] "Smaller of two negative integers"]
                    [[0.3 0.2 min] [0.2] "Smaller of two floats <1"]]]]]

   [min-by [[spec [[program [item a] [item b]] [item]]]
            [doc "Runs program on top two stack items, and returns the result that compares `less`"]
            [definition [[both compare ğŸ] â€¢ğŸ›¡ï¸ â–¶ï¸ [greater] =
                         [ğŸ—‘ï¸ â€¢ğŸ—‘ï¸] [ğŸ—‘ï¸] â†”ï¸]]
            [examples [[[[[price 25] [name bar]]
                         [[price 15] [name foo]]
                         [[price] ğŸ”] min-by] [[[price 15] [name foo]]]]]]]]]
  ğŸ”—
#+end_src
** Stack Ops
#+begin_src kcats :tangle src/kcats/core/stack-builtins.kcats :mkdirp yes
  [[ğŸ—‘ï¸ [[spec [[item] ğŸ”³]]
       [names ["trash can" "drop"]]
       [doc "Throws away the top stack item"]
       [examples [[[1 2 3 ğŸ—‘ï¸] [1 2] "Drop integer on ToS"]
                  [[1 2 3 [a b c] ğŸ—‘ï¸] [1 2 3] "Drop list on ToS"]

                  ;; Different types of values
                  [[ğŸ”³ ğŸ—‘ï¸] ğŸ”³ "Drop Nothing value"]
                  [["hello" ğŸ—‘ï¸] ğŸ”³ "Drop string"]
                  [[42.5 ğŸ—‘ï¸] ğŸ”³ "Drop float"]
                  [[âœ… ğŸ—‘ï¸] ğŸ”³ "Drop boolean"]

                  ;; Nested structures
                  [[[1 [2 3] 4] ğŸ—‘ï¸] ğŸ”³ "Drop complex nested structure"]
                  [[[[ğŸ”³]] ğŸ—‘ï¸] ğŸ”³ "Drop deeply nested empty lists"]

                  ;; Multiple operations
                  [[1 2 3 ğŸ—‘ï¸ ğŸ—‘ï¸] [1] "Drop multiple times"]
                  [[1 2 3 ğŸ—‘ï¸ 4 ğŸ—‘ï¸] [1 2] "Interleaved drops with pushes"]

                  ;; Edge cases
                  [[ğŸ”³ ğŸ—‘ï¸] ğŸ”³ "Drop empty list"]
                  [["" ğŸ—‘ï¸] ğŸ”³ "Drop empty string"]
                  [[1 2 [ğŸ—‘ï¸] ğŸ—‘ï¸] [1 2] "Drop list containing trash symbol"]

                  ;; Error cases
                  [[[ğŸ—‘ï¸] [ğŸ—‘ï¸ "Nothing to drop"] ğŸ©¹ â–¶ï¸] ["Nothing to drop"] "Empty stack results in error"]
                  [[[1 ğŸ—‘ï¸ ğŸ—‘ï¸] [ğŸ—‘ï¸ "Nothing to drop"] ğŸ©¹ â–¶ï¸] ["Nothing to drop"] "Multiple drops on nonempty stack"]]]]]

   [ğŸ‘¥ [[spec [[[item a]]
               [[item a] [item a]]]]
        [names ["twins" "busts in silhouette" "copy"]]
        [doc "Copy the top stack item"]
        [examples [[[1 2 3 ğŸ‘¥] [1 2 3 3] "Copy integer on ToS"]
                   [["foo" "bar" "baz" ğŸ‘¥] ["foo" "bar" "baz" "baz"] "Copy string on ToS"]
                   [[[ğŸ‘¥] [ğŸ—‘ï¸ "Nothing to clone"] ğŸ©¹ â–¶ï¸] ["Nothing to clone"] "Empty stack results in error"]

                   ;; Different types of values
                   [[ğŸ”³ ğŸ‘¥] [ğŸ”³ ğŸ”³] "Copy Nothing value"]
                   [[âœ… ğŸ‘¥] [âœ… âœ…] "Copy boolean"]
                   [[42.5 ğŸ‘¥] [42.5 42.5] "Copy float"]
                   [[ğŸ”³ ğŸ‘¥] [ğŸ”³ ğŸ”³] "Copy empty list"]

                   ;; Nested structures
                   [[[1 2 3] ğŸ‘¥] [[1 2 3] [1 2 3]] "Copy list"]
                   [[[1 [2 [3]]] ğŸ‘¥] [[1 [2 [3]]] [1 [2 [3]]]] "Copy nested structure"]
                   [[[ğŸ‘¥] ğŸ‘¥] [[ğŸ‘¥] [ğŸ‘¥]] "Copy list containing clone symbol"]

                   ;; Multiple operations
                   [[1 ğŸ‘¥ ğŸ‘¥] [1 1 1] "Multiple consecutive clones"]
                   [[1 2 ğŸ‘¥ 3 ğŸ‘¥] [1 2 2 3 3] "Interleaved clones with pushes"]
                   [[1 ğŸ‘¥ ğŸ—‘ï¸] [1] "Copy then trash"]
                   [[1 2 ğŸ‘¥ ğŸ‘¥ ğŸ—‘ï¸] [1 2 2] "Multiple clones then trash"]

                   ;; Edge cases
                   [["" ğŸ‘¥] ["" ""] "Copy empty string"]
                   [[[ğŸ”³ ğŸ”³] ğŸ‘¥] [[ğŸ”³ ğŸ”³] [ğŸ”³ ğŸ”³]] "Copy complex structure with Nothing"]
                   [[[[ğŸ”³]] ğŸ‘¥] [[[ğŸ”³]] [[ğŸ”³]]] "Copy nested empty lists"]

                   ;; Error cases
                   [[[ğŸ‘¥ ğŸ‘¥] [ğŸ—‘ï¸ "Nothing to clone"] ğŸ©¹ â–¶ï¸] ["Nothing to clone"] "Copy on empty stack"]
                   [[1 ğŸ—‘ï¸ [ğŸ‘¥] [ğŸ—‘ï¸ "Nothing to clone"] ğŸ©¹ â–¶ï¸] ["Nothing to clone" ] "Copy after emptying stack"]]]]]

   [ğŸ“¸ [[spec [ğŸ”³ [list]]]
        [names ["camera" "snapshot"]]
        [doc "Copy the whole stack as a list, onto the top of the stack"]
        [examples [[[1 2 3 ğŸ“¸] [1 2 3 [3 2 1]] "Copy the stack to ToS"]
                   [[ğŸ“¸] [ğŸ”³] "Copy stack to ToS when stack is empty"]]]]]

   [ğŸ§¦ [[spec [[list] [list *]]]
        [names ["socks" "evert"]]
        [doc "Turn inside-out: Takes a list on ToS, makes it the new
             stack, and takes what had previously been the rest of the
             stack, and makes it a list on top of the new stack. Used
             for context switching."]
        [examples [[[1 2 3 [4 5 6] ğŸ§¦] [6 5 4 [3 2 1]] "Swap a list of integers with the rest of the stack"]
                   [[1 [2] 3 [4 foo "bar"] ğŸ§¦] ["bar" [foo] ğŸ« 4 [3 [2] 1]] "Swap a list of items with the rest of the stack"]
                   [[[4 5 6] ğŸ§¦] [6 5 4 ğŸ”³] "Swap a list of integers with an empty stack"]
                   [[["a" "b" "c"] ğŸ§¦] ["c" "b" "a" ğŸ”³] "Swap a list of strings with an empty stack"]
                   [[[1 2 3 4 ğŸ§¦] [ğŸ—‘ï¸ "List is required"] ğŸ©¹ â–¶ï¸] ["List is required"] "Non-list item result in an error"]
                   [[[ğŸ§¦] [ğŸ—‘ï¸ "Nothing to evert"] ğŸ©¹ â–¶ï¸] ["Nothing to evert"] "Empty stack results in error"]

                   ;; Empty and single-item cases
                   [[ğŸ”³ ğŸ§¦] [ğŸ”³] "Evert empty list"]
                   [[[1] ğŸ§¦] [1 ğŸ”³] "Evert single-item list"]
                   [[2 [1] ğŸ§¦] [1 [2]] "Evert single-item list with one item below"]

                   ;; Nested structures
                   [[[1 [2 3] 4] ğŸ§¦] [4 [2 3] 1 ğŸ”³] "Evert list containing nested list"]
                   [[[1 ğŸ”³ 2] ğŸ§¦] [2 ğŸ”³ 1 ğŸ”³] "Evert list containing empty list"]
                   [[1 2 [[3 4] 5] ğŸ§¦] [5 [3 4] [2 1]] "Evert nested list with items below"]

                   ;; Mixed types
                   [[[âœ… ğŸ”³ "hello" 42] ğŸ§¦] [42 "hello" ğŸ”³ âœ… ğŸ”³] "Evert list of mixed types"]
                   [[ğŸ”³ ["a" 1 âœ…] ğŸ§¦] [âœ… 1 "a" [ğŸ”³]] "Evert with Nothing below"]

                   ;; Multiple operations
                   [[1 [2 3] ğŸ§¦ [4 5] ğŸ§¦] [5 4 [[1] 2 3]] "Sequential everts"]
                   [[1 [2 3] ğŸ§¦ ğŸ‘¥] [3 2 [1] [1]] "Evert then clone"]
                   [[1 2 [3 4] ğŸ§¦ ğŸ—‘ï¸] [4 3] "Evert then trash"]

                   ;; Complex structures
                   [[[1 [2 [3]] [4 [5]]] ğŸ§¦] [[4 [5]] [2 [3]] 1 ğŸ”³] "Evert deeply nested structure"]
                   [[1 2 [ğŸ”³ ğŸ”³ [foo]] ğŸ§¦] [[foo] ğŸ”³ ğŸ”³ [2 1]] "Evert list containing Nothing and empty list"]

                   ;; Error cases
                   [[1 2 3 [ğŸ§¦] [ğŸ—‘ï¸ "List is required"] ğŸ©¹ â–¶ï¸] [1 2 3 "List is required"] "Try to evert non-list ToS"]
                   [["hello" [ğŸ§¦] [ğŸ—‘ï¸ "List is required"] ğŸ©¹ â–¶ï¸] ["hello" "List is required"] "Try to evert string"]
                   [[1 2 3 [4 5] ğŸ§¦ ğŸ§¦] [1 2 3 [4 5]] "Evert undoes itself"]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/stack.kcats :mkdirp yes
  [â€¢ğŸ‘¥  [[spec [[[item a] [item b]]
                [[item a] [item b] [item b]]]]
         [names ["twins with dot"]]
         [doc "Copy, one stack position down (copy the 2nd item and place it between the original and the top item)"]
         [definition [[ğŸ‘¥] ğŸª„]]
         [examples [[[1 2 3 â€¢ğŸ‘¥] [1 2 2 3] "Clone the 2nd item on the stack"]]]]]


  [â€¢â€¢ğŸ‘¥ [[spec [[[item a] [item b] [item c]]
                [[item a] [item b] [item c] [item c]]]]
         [names ["twins with dots"]]
         [doc "Copy, two stack positions down (copy the 3rd item)"]
         [definition [[ğŸ‘¥] â€¢ğŸª„]]
         [examples [[[1 2 3 4 â€¢â€¢ğŸ‘¥] [1 2 2 3 4] "Clone the 3rd item on the stack"]]]]]

  [over [[spec [[[item a] [item b]]
                [[item b] [item a] [item b]]]]
         [doc "Copy the 2nd stack item, placing the copy on top"]
         [definition [â€¢ğŸ‘¥ ğŸ”€]]
         [examples [[[1 2 3 over] [1 2 3 2] "Copy the 2nd item to ToS"]]]]]

  [under [[spec [[[item a] [item b]]
                 [[item a] [item b] [item a]]]]
          [doc "Copy the top stack item, placing the copy beneath the 2nd item"]
          [definition [ğŸ‘¥ â€¢ğŸ”€]]
          [examples [[[1 2 3 under] [1 3 2 3] "Copy the ToS to the 2nd item"]]]]]

  [â€¢ğŸ—‘ï¸ [[spec [[[item a] [item b]] [[item b]]]]
       [names ["trash can with dot" "dropdown"]]
       [doc "Drop the second stack item"]
       [definition [ğŸ”€ ğŸ—‘ï¸]]
       [examples [[[1 2 3 â€¢ğŸ—‘ï¸] [1 3] "Drop the 2nd item"]]]]]

  [â€¢â€¢ğŸ—‘ï¸ [[spec [[[item a] [item b] [item c]] [[item a] [item b]]]]
        [names ["trash can with dots" "dropdeep"]]
        [doc "Drop the third stack item"]
        [definition [ğŸ›Ÿ ğŸ—‘ï¸]]
        [examples [[[1 2 3 â€¢â€¢ğŸ—‘ï¸] [2 3] "Drop the 3rd item"]]]]]

  [restore [[spec [[list] [*]]]
            [doc "Replace the entire stack with the list on top of stack"]
            [definition [ğŸ§¦ ğŸ—‘ï¸]]
            [examples [[["x" "y" [1 2 3] restore] [3 2 1] "Replace stack with list"]
                       [[ğŸ”³ restore] ğŸ”³ "Replace stack with empty list"]]]]]
#+end_src
*** Motion
These words change the order of items on the stack.

#+begin_src kcats :tangle src/kcats/core/motion-builtins.kcats :mkdirp yes
  [[ğŸ”€ [[spec [[[item a] [item b]]
               [[item b] [item a]]]]
        [names ["crossing arrows" "swap"]]
        [doc "Swap the top two stack items"]
        [examples [[[1 2 3 ğŸ”€] [1 3 2] "Swap top two items"]
                   ;; Basic types
                   [[ğŸ”³ âœ… ğŸ”€] [âœ… ğŸ”³] "Swap boolean values"]
                   [[42 "hello" ğŸ”€] ["hello" 42] "Swap number and string"]
                   [[ğŸ”³ "" ğŸ”€] ["" ğŸ”³] "Swap Nothing and empty string"]
                   [["a" "b" ğŸ”€] ["b" "a"] "Swap strings"]

                   ;; Lists and nested structures
                   [[[1 2] [3 4] ğŸ”€] [[3 4] [1 2]] "Swap lists"]
                   [[[1 [2]] [3 [4]] ğŸ”€] [[3 [4]] [1 [2]]] "Swap nested lists"]
                   [[[[ğŸ”³]] ğŸ”³ ğŸ”€] [ğŸ”³ [[ğŸ”³]]] "Swap deeply nested empty list with empty list"]

                   ;; Multiple operations
                   [[1 2 3 ğŸ”€ ğŸ”€] [1 2 3] "Double swap"]
                   [[1 2 ğŸ”€ 3 ğŸ”€] [2 3 1] "Interleaved swaps"]
                   [[1 2 ğŸ”€ ğŸ—‘ï¸] [2] "Swap then trash"]

                   ;; With identical items
                   [[42 42 ğŸ”€] [42 42] "Swap identical numbers"]
                   [[ğŸ”³ ğŸ”³ ğŸ”€] [ğŸ”³ ğŸ”³] "Swap identical empty lists"]
                   [[[1 2] [1 2] ğŸ”€] [[1 2] [1 2]] "Swap identical complex lists"]

                   ;; Error cases
                   [[[ğŸ”€] [ğŸ—‘ï¸ "Need 2 items to swap"] ğŸ©¹ â–¶ï¸] ["Need 2 items to swap"] "Empty stack"]
                   [[[1 ğŸ”€] [ğŸ—‘ï¸ "Need 2 items to swap"] ğŸ©¹ â–¶ï¸] ["Need 2 items to swap"] "Only one item on stack"]]]]]

   [â€¢ğŸ”€ [[spec [[[item a] [item b] [item c]]
                [[item a] [item c] [item b]]]]
         [names ["crossing arrows with dot" "swapdown"]]
         [doc "Swap the second and third stack items"]
         [examples [[[1 2 3 â€¢ğŸ”€] [2 1 3] "Swap 2nd and 3rd items"]]]]]

   [â€¢â€¢ğŸ”€ [[spec [[[item a] [item b] [item c] [item d]]
                 [[item a] [item b] [item d] [item c]]]]
          [names ["crossing arrows with dots" "swapdeep"]]
          [doc "Swap the third and fourth stack items"]
          [examples [[[1 2 3 4 â€¢â€¢ğŸ”€] [2 1 3 4] "Swap 3rd and 4th items"]]]]]

   [ğŸ›Ÿ [[spec [[[item a] [item b] [item c]]
               [[item c] [item a] [item b]]]]
        [names ["ring buoy" "float"]]
        [doc "Floats the third stack item to the top"]     
        [examples [[[1 2 3 ğŸ›Ÿ] [2 3 1] "Move 3rd item to ToS"]]]]]

   [âš“ [[spec [[[item a] [item b] [item c]]
               [[item b] [item c] [item a]]]]
        [names ["anchor" "sink"]]
        [doc "Sinks the top stack item to the third position"]
        [examples [[[1 2 3 âš“] [3 1 2] "Move ToS to 3rd item"]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/motion.kcats :mkdirp yes
  [flip [[spec [[[item a] [item b] [item c]]
                [[item c] [item b] [item a]]]]
         [doc "Swaps the first and third stack items"]
         [definition [ğŸ›Ÿ â€¢ğŸ”€]]
         [examples [[[1 2 3 flip] [3 2 1] "Swap ToS and 3rd item"]]]]]
#+end_src
** Program execution
#+begin_src kcats :tangle src/kcats/core/execute-builtins.kcats :mkdirp yes
  ;; Input spec is item because builtins can be executed directly too
  [[â–¶ï¸ [[spec [[item] [*]]]
       [names ["play arrow" "right-pointing triangle" "execute"]]
       [doc "Execute a program on top of stack"]
       [examples [[[[1 2 +] â–¶ï¸] [3] "Execute a program"]
                  [[1 2 ğŸ”³ â–¶ï¸] [1 2] "Execute an empty program"]

                  ;; Nested execution
                  [[1 2 [[+] â–¶ï¸] â–¶ï¸] [3] "Nested execution"]
                  [[[1 [2 ğŸ‘¥] â–¶ï¸ 3] â–¶ï¸] [1 2 2 3] "Execute nested program with clone"]

                  ;; Multiple executions
                  [[[1] â–¶ï¸ [2] â–¶ï¸] [1 2] "Sequential execution"]
                  [[[[1] â–¶ï¸ [2 +] â–¶ï¸] â–¶ï¸] [3] "Nested sequential execution"]

                  ;; Empty and Nothing cases
                  [[ğŸ”³ â–¶ï¸] ğŸ”³ "Execute empty program"]
                  [[ğŸ”³ â–¶ï¸] ğŸ”³ "Execute Nothing"]
                  [[[ğŸ”³ [1] â–¶ï¸] â–¶ï¸] [ğŸ”³ 1] "Execute Nothing then program"]

                  ;; Complex programs
                  [[[1 [2 +] â–¶ï¸ [3 +] â–¶ï¸] â–¶ï¸] [6] "Chained arithmetic operations"]
                  [[[1 2 +] [3 4 *] ğŸ”€ â–¶ï¸] [[3 4 *] 3] "Execute programs after swapping"]

                  ;; Error handling
                  [[[â–¶ï¸] [ğŸ—‘ï¸ "Nothing to execute"] ğŸ©¹ â–¶ï¸] ["Nothing to execute"] "Try to execute with nothing on stack"]
                  [[[1 â–¶ï¸] [ğŸ—‘ï¸ "Type error"] ğŸ©¹ â–¶ï¸] ["Type error"] "Try to execute a non program"]]]]]

   [â†”ï¸ [[spec [[[program no-branch]
               [program yes-branch]
               [item condition]]
              [*]]]
       [names ["left-right arrow" "branch"]]
       [doc "Logical branch: if the top of stack is an affirmative value, execute the second item, otherwise the third item"]
       [examples [[[5 âœ… [ğŸ—‘ï¸ 3 *] [4 +] â†”ï¸] [15] "Branch on true condition"]
                  [[5 "hi" [ğŸ—‘ï¸ 3 *] [4 +] â†”ï¸] [15] "Branch on truthy condition"]
                  [[6 ğŸ”³ [3 *] [4 +] â†”ï¸] [10] "Branch on false condition"]
                  [[6 "" [3 *] [4 +] â†”ï¸] [10] "Branch on falsey condition"]
                  [[6 "hi" ğŸ”³ [4 +] â†”ï¸] [6 "hi"] "Branch with empty 'yes' program"]
                  [[6 "" ğŸ”³ ğŸ”³ â†”ï¸] [6] "Branch with empty 'no' program"]]]]]

   [ğŸª„ [[spec [[program [item a]] [[item a] *]]]
        [names ["magic wand" "dip"]]
        [doc "Make top stack item disappear while program runs, then reappear on top of stack."]
        [examples [[[1 8 [inc] ğŸª„] [2 8] "Dipping a program under ToS"]
                   [[1 2 [dec] ğŸ«
                     [+] ğŸª„] [3 [dec] ğŸ«] "A bare word on stack is left intact and not executed"]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/execute.kcats :mkdirp yes
  [ğŸª† [[spec [[[program combinator]
               [program exit]
               [program body]
               [program pred]]
              [[program recurrence]]]]
       [names ["nesting dolls" "russian dolls" "recurrence"]]
       
       [doc "Construct a recursive program.  Takes 4 component programs
             as input: predicate, body, exit, and combinator. The
             recursive program, when executed will: run predicate, if
             result is false, the exit program runs and the recursive
             program is finished. If true, the body program runs, a copy
             of the whole recursive program is put on the stack, and the
             combinator is run."]

       [definition [[âœ‚ï¸4ï¸âƒ£
                     [âœ‚ï¸3ï¸âƒ£ 4ï¸âƒ£ 3ï¸âƒ£ 2ï¸âƒ£ 1ï¸âƒ£ ğŸª† âœ‚ï¸1ï¸âƒ£]
                     2ï¸âƒ£ â†”ï¸] ğŸ’]]
       [examples [[[5
                    [2 >] ğŸ›¡ï¸
                    [ğŸ—‘ï¸ ğŸ‘¥ dec] ğŸ”³ [â–¶ï¸ *]
                    ğŸª† â–¶ï¸]
                   [120]
                   "Recur with reduction"]]]]] 

  [ğŸŒ€ [[spec [[[program body] [item flag]] [[program loop]]]]
       [names ["swirl" "loop"]]
       
       [doc "Create a loop program with binary exit condition. Takes a
              program and a boolean value, if the value is affirmative,
              run the program and repeat. If negative, drop the value
              and the loop is finished."]
       
       [definition [ğŸ”³ ğŸ”€ ğŸ”³ [â–¶ï¸] ğŸª†]]
       [examples [[[10 âœ… [ğŸ—‘ï¸ -2 * ğŸ‘¥ 50 <] ğŸŒ€ â–¶ï¸] [160] "Looping"]
                  [[10 ğŸ”³ [ğŸ—‘ï¸ -2 * ğŸ‘¥ 50 <] ğŸŒ€ â–¶ï¸] [10] "Looping with false initial condition is no-op"]]]]]


  [decide [[spec [[[list test-expr-pairs]] [*]]]
           [doc "Takes a list of choices (pairs of test, program) and executes the first
                 choice whose test passes. If none pass, it's a no-op. Stack is reset
                 between testing conditions."]
           [definition [ğŸ“¤
                        [ğŸ« ;; break up the pair
                         ğŸ”€ 
                         ğŸ›¡ï¸
                         ;; ğŸª† 
                         flip [1ï¸âƒ£ decide] ğŸ’ âš–ï¸ â–¶ï¸]
                        [ğŸ—‘ï¸] ;; the empty container
                        â†”ï¸]]
           [examples [[[5 [[[3 =] [ğŸ—‘ï¸ "three"]]
                           [[5 =] [ğŸ—‘ï¸ "five"]]
                           [[7 =] [ğŸ—‘ï¸ "seven"]]
                           [[âœ…] [ğŸ—‘ï¸ "something else"]]]
                        decide]
                       [5 "five"] "Decide with matching condition"]

                      [[9 [[[3 =] [ğŸ—‘ï¸ "three"]]
                           [[5 =] [ğŸ—‘ï¸ "five"]]
                           [[7 =] [ğŸ—‘ï¸ "seven"]]
                           [[âœ…] [ğŸ—‘ï¸ "something else"]]]
                        decide]

                       [9 "something else"] "Decide with matching default condition"]

                      [[9 [[[3 =] [ğŸ—‘ï¸ "three"]]
                           [[5 =] [ğŸ—‘ï¸ "five"]]
                           [[7 =] [ğŸ—‘ï¸ "seven"]]]
                        decide]
                       [9] "Decide with no matching condition"]]]]]

  ;; TODO: implement as axiom (which would depend on 'restore' which should also be axiom?)
  [ğŸ›¡ï¸ [[spec [[program] [program]]]
      [names ["shield"]]

      [doc "Run a program, protecting existing stack items from being
            consumed. Places the resulting top stack item on top of the
            original stack."]

      [definition [ğŸ’‰ [ğŸ“¸ âœ‚ï¸1ï¸âƒ£ first] ğŸ’]]
      [examples [[[1 2 3 [=] ğŸ›¡ï¸ â–¶ï¸] [1 2 3 ğŸ”³] "Execute a program shielding the stack from consumption"]]]]]

  [â€¢ğŸ›¡ï¸ [[spec [[program] [program]]]
       [names ["shield with dot" "shielddown"]]
       [doc "Run a program, protecting all but the top stack item from being consumed."]
       [definition [ğŸ’‰ [ğŸ“¸ âœ‚ï¸1ï¸âƒ£ â€¢ğŸ—‘ï¸ first] ğŸ’]]
       [examples [[[1 2 3 [=] â€¢ğŸ›¡ï¸ â–¶ï¸] [1 2 ğŸ”³] "Execute a program consuming only the original ToS"]]]]]

  [â€¢â€¢ğŸ›¡ï¸ [[spec [[program] [program]]]
        [names ["shield with dots" "shielddeep"]]
        [doc "Run a program, protecting all but the top two stack items from being consumed."]
        [definition [ğŸ’‰ [ğŸ“¸ âœ‚ï¸1ï¸âƒ£ â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸ first] ğŸ’]]
        [examples [[[1 2 3 [+ +] â€¢â€¢ğŸ›¡ï¸ â–¶ï¸] [1 6] "Execute a program consuming only the original top 2 items"]]]]]

  [âš–ï¸ [[spec [[[program no-branch]
              [program yes-branch]
              [program condition]]
             [program]]]
      [names ["scales" "if"]]
      
      [doc "Create a logical branch program from 3 component
            programs. When executed, runs condition program. If its
            result is affirmative, runs yes-branch, otherwise runs
            no-branch"]
      
      [definition [[âœ‚ï¸3ï¸âƒ£ ;; the condition
                    2ï¸âƒ£ 1ï¸âƒ£ â†”ï¸] ğŸ’]]
      [examples [[[5 [ğŸ‘¥ 5 =] [ğŸ—‘ï¸ 3 *] [4 +] âš–ï¸ â–¶ï¸] [15] "Conditional with true predicate"]
                 [[6 [ğŸ‘¥ 5 =] [ğŸ—‘ï¸ 3 *] [4 +] âš–ï¸ â–¶ï¸] [10] "Conditional with false predicate"]]]]]

  [when [[spec [[[program yes-branch]
                 [program condition]]
                [program]]]

         [doc "Creates a logical branch program from 2 component
               programs.  When executed, runs condition program. If its
               result is affirmative, runs yes-branch, otherwise
               no-op."]

         [definition [ğŸ”³ âš–ï¸]]
         [examples [[[3 [ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc] when â–¶ï¸] [4] "Conditional with no false branch and true predicate"]
                    [[3 [ğŸ‘¥ even?] [ğŸ—‘ï¸ inc] when â–¶ï¸] [3] "Conditional with no false branch and false predicate"]]]]]

  [dipped [[spec [program program]]
           [doc "Creates a version of program that runs with ğŸª„."]
           [definition [[1ï¸âƒ£ ğŸª„] ğŸ’]]]]

  [â€¢ğŸª„ [[spec [[program
                [item a]
                [item b]]
               [[item a] [item b] *]]]
        [names ["magic wand with dot" "dipdown"]]
        [doc "Run a program, hiding the top two items and then making
              them reappear after the program is finished"]
        [definition [dipped dipped â–¶ï¸]]
        [examples [[[1 2 3 [inc] â€¢ğŸª„] [2 2 3] "Dip program under top two items"]]]]]

  [â€¢â€¢ğŸª„ [[spec [[program
                 [item a]
                 [item b]
                 [item c]]
                [[item a] [item b] [item c] *]]]
         [names ["magic wand with dots" "dipdeep"]]
         [doc "Run a program, hiding the top three items and then making
               them reappear after the program is finished"]
         [definition [dipped dipped dipped â–¶ï¸]]
         [examples [[[1 2 3 4 [inc] â€¢â€¢ğŸª„] [2 2 3 4] "Dip program under top 3 items"]]]]]

  [ğŸªœ [[spec [[program] [program]]]
       [names ["ladder" "step"]]
       
       [doc "Create a stepping program from a body program. When run,
             iterates over a list and executes the body once per
             item. The rest of the list is hidden while the body runs."]

       [definition [[[ğŸ“¤ ğŸ”€ 
                      1ï¸âƒ£ ğŸ‘¥ â€¢ğŸª„
                      ğŸªœ â–¶ï¸]
                     ğŸ”³ â†”ï¸]
                    ğŸ’]]
       [examples [[[1 [2 3 4] [*] ğŸªœ â–¶ï¸] [24] "Step through numbers doing arithmetic"]
                  [[[1 2 3] [inc] ğŸªœ â–¶ï¸] [2 3 4] "Step through items"]
                  [[1 ğŸ”³ [*] ğŸªœ â–¶ï¸] [1] "Stepping through empty list is no-op"]

                  ;; Simple transformations
                  [[[1 2 3] [ğŸ‘¥] ğŸªœ â–¶ï¸] [1 1 2 2 3 3] "Double each item"]
                  [[[1 2 3] [ğŸ—‘ï¸] ğŸªœ â–¶ï¸] ğŸ”³ "Delete all items"]
                  [[[1 2 3] ğŸ”³ ğŸªœ â–¶ï¸] [1 2 3] "No-op body"]
                  [[[1 2 3] [ğŸ—‘ï¸ ğŸ”³] ğŸªœ â–¶ï¸] [ğŸ”³ ğŸ”³ ğŸ”³] "Replace each item with Nothing"]

                  ;; Different input types
                  [[["a" "b" "c"] [encode] ğŸªœ â–¶ï¸] ["a" encode "b" encode "c" encode] "Convert each string to bytes"]
                  [[[ğŸ”³ âœ… ğŸ”³] [â˜¯ï¸] ğŸªœ â–¶ï¸] [âœ… ğŸ”³ âœ…] "Step through list of booleans"]

                  ;; Empty and single item cases
                  [[[1] [ğŸ‘¥] ğŸªœ â–¶ï¸] [1 1] "Step through single-item list"]
                  [[[ğŸ”³] [ğŸ‘¥] ğŸªœ â–¶ï¸] [ğŸ”³ ğŸ”³] "Step through list containing empty list"]

                  ;; Nested lists
                  [[[1 [2 3] 4] [ğŸ—‘ï¸] ğŸªœ â–¶ï¸] ğŸ”³ "Step through list with nested structure"]
                  [[[[1] [2] [3]] [first] ğŸªœ â–¶ï¸] [1 2 3] "Extract first item from each sublist"]

                  ;; Stack manipulation within body
                  [[[1 2 3] [42 ğŸ”€] ğŸªœ â–¶ï¸] [42 1 42 2 42 3] "Step and swap each item with constant"]
                  [[[1 2 3] [ğŸ‘¥ ğŸ”€] ğŸªœ â–¶ï¸] [1 1 2 2 3 3] "Clone and swap each item"]
                  [[[1 2 3] [ğŸ—‘ï¸ 99] ğŸªœ â–¶ï¸] [99 99 99] "Remove and replace each item"]

                  ;; Error cases
                  [[[1 2 3] [ğŸ”€] [ğŸªœ â–¶ï¸] [ğŸ—‘ï¸ "Error in body"] ğŸ©¹ â–¶ï¸] [[1 2 3] [ğŸ”€] "Error in body"] "Step body program causes error"]
                  [[ğŸ”³ [1 0 /] ğŸªœ â–¶ï¸] ğŸ”³ "Empty list with erroring body"]]]]]

  [ğŸ‹ [[spec [[program [item a]] [item [item a] *]]]
       [names ["whale" "dive"]]
       [doc "Run a program 'below' the ToS (with the ToS hidden from the
             program), and then surfacing the result up to the top of
             the stack"]
       [definition [ğŸª„ ğŸ”€]]
       [examples [[[4 5 6 [+] ğŸ‹] [6 9] "Dip program and move result to ToS"]]]]]

  [â€¢ğŸ‹ [[spec [[program [item a] [item b]]
               [item [item a] [item b] *]]]
        [names ["whale with dot" "divedown"]]
        [doc "Run a program beneath the top two items, and then floating
              the result back to the ToS."]
        [definition [â€¢ğŸª„ ğŸ›Ÿ]]
        [examples [[[5 6 7 8 [+] â€¢ğŸ‹] [7 8 11] "Dip under top 2 items and move result to ToS"]]]]]

  [â€¢â€¢ğŸ‹ [[spec [[program [item a] [item b] [item c]]
                [item [item a] [item b] [item c] *]]]
         [names ["whale with dots" "divedeep"]]
         [doc "Run a program beneath the top three items, and then
               floating the result back to the ToS."]
         [definition [ğŸ [â€¢ğŸ‹] ğŸ”— ğŸª„ ğŸ”€]]
         [examples [[[4 5 6 7 8 [+] â€¢â€¢ğŸ‹] [6 7 8 9] "Dip under top 3 items and move result to ToS"]]]]]

  [ğŸ’‰ [[spec [[program] [program]]]
       [names ["syringe" "needle" "injection"]]
       [doc "Creates an program that when executed, injects the given
             program into the list below it (runs the program with the
             list as its stack).  Does not affect the rest of the
             stack. Used for context switching."]
       [definition [dipped [ğŸ§¦ âœ‚ï¸1ï¸âƒ£ ğŸ§¦] ğŸ’]]
       [examples [[[1 2 3 [4 5 6] [* +] ğŸ’‰ â–¶ï¸] [1 2 3 [26]] "Inject program into list as if it's the stack"]]]]]

  [â³ [[spec [[[program body]
               [program pred]]
              [*]]]
       [names ["hourglass" "while"]]
       
       [doc "Create a 'while' loop: run predicate program. If it
             produces logical true, run the body and repeat, otherwise
             stop."]

       [definition [ğŸ”³ [â–¶ï¸] ğŸª†]]
       [examples [[[3 [0 >] ğŸ›¡ï¸ [ğŸ—‘ï¸ ğŸ‘¥ dec] â³ â–¶ï¸] [3 2 1 0] "While loop"]]]]]

  [until [[spec [[[program body]
                  [program pred]]
                 [*]]]
          
          [doc "Create an 'until' loop: Run body once, then
                predicate. if predicate produces logical true,
                stop. Otherwise repeat. Body inside loop does not
                receive the result of the predicate, so no need to call
                ğŸ—‘ï¸."]

          [definition [[ğŸ­] ğŸª„ ;; reverse logic of pred
                       ğŸ‘¥ ;; the body: pre-loop and loop body
                       [[ğŸ—‘ï¸ âœ‚ï¸1ï¸âƒ£] ;; body can drop pred result that's always []
                        ğŸ’ â³] ğŸª„ ;; make a whileloop
                       ğŸ”€ ğŸ”—]] ;; run pre-loop then loop
          [examples [[[2 [even?] ğŸ›¡ï¸ [inc] until â–¶ï¸] [4] "Until loop"]]]]]

  [times [[spec [[[integer howmany]
                  [program body]]
                 [program]]]

          [doc "Create a repeater program. Given an integer n and a body
                program, return another program that runs the body n
                times. Non-positive values of n result in a no-op
                program."]

          [definition [[1ï¸âƒ£ [positive?] ğŸ›¡ï¸
                        [ğŸ—‘ï¸ dec [2ï¸âƒ£ ğŸ‘¥ ğŸª„] ğŸª„ times â–¶ï¸]
                        [ğŸ—‘ï¸] âš–ï¸
                        â–¶ï¸]
                       ğŸ’]]
          [examples [[[[5] 3 times â–¶ï¸] [5 5 5] "Create an item a specific number of times"]
                     [[[5] 0 times â–¶ï¸] ğŸ”³ "0 times is a no-op"]
                     [[[5] -3 times â–¶ï¸] ğŸ”³ "negative times is a no-op"]
                     [[1 1 [inc ğŸ”€] 3 times â–¶ï¸] [3 2] "Run a program a specific number of times"]]]]]

  [primrec [[spec [[[program rec1]
                    [program exit]
                    [number n]]
                   [*]]]

            [doc "Create a countdown recurrence: given a combinator
                  program, an exit program and a positive integer n,
                  create a recurrence where each iteration decrements n
                  and runs the combinator."]

            [definition [[â–¶ï¸ âœ‚ï¸1ï¸âƒ£] ğŸ’  ;; add execute to rec1 to be recurs rec2
                         [[ğŸ—‘ï¸ âœ‚ï¸1ï¸âƒ£] ğŸ’] ğŸª„  ;; add drop to exit condition
                         [zero? â˜¯ï¸] ğŸ›¡ï¸ âš“ ;; put the condition check on bottom
                         [ğŸ—‘ï¸ ğŸ‘¥ dec] âš“  ;; add the r1
                         ğŸª†]]  ;; now its generic recur
            [examples [[[5 [1] [*] primrec â–¶ï¸] [120] "Simple countup loop"]]]]]

  [bail [[spec [[program] [*]]]
         
         [doc "Short circuit primitive. If the top of stack is
               affirmative, run the program, otherwise no-op."]

         [definition [[ğŸ”³] â†”ï¸]]
         [examples [[[ğŸ”³ [inc] bail] [ğŸ”³] "Can bail on invalid input"]
                    [[1 [inc] bail] [2] "Valid input doesn't bail"]]]]]

  [bailer [[spec [[list] [program]]]

           [doc "Short circuit a chain of programs. Takes a list of
                 programs to run, returns a new program. That program
                 only runs each component program, if there is an
                 affirmative value on the top of the stack right before
                 it's due to run."]

           [definition [[and] â€¢ğŸ›¡ï¸ [ğŸ“¤ ğŸª„] â³]]
           [examples [[[1
                        [[ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc] [ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc]]
                        bailer â–¶ï¸]
                       [2 ğŸ”³]
                       "Short circuit when an empty value is produced"]]]]]
#+end_src
** Collections
#+begin_src kcats :tangle src/kcats/core/collections-builtins.kcats :mkdirp yes
  [[ğŸ”— [[spec [[sized sized] [sized]]]
        [names ["link" "join"]]
        [doc "Join two containers together"]
        [examples [[[["a" "b"] ["c" "d"] ğŸ”—] [["a" "b" "c" "d"]] "Join two collections of strings"]
                   [["ab" "cd" ğŸ”—] ["abcd"] "Join two strings"]
                   [["ab" encode "cd" encode ğŸ”— "abcd" encode =] [âœ…] "Two joined byte seqs are equal to the combined literal"]
                   [[[[a b] [c d]] association [[e f] [a g]] ğŸ”—] [[[a g] [c d] [e f]] association] "Joining list+assoc -> assoc, 2nd arg keys take priority"]
                   [[[[e f] [a g]] [[a b] [c d]] association  ğŸ”—] [[[a b] [e f] [c d]] association] "Joining assoc+list -> assoc, 2nd arg keys take priority"]
                   [[[a b c d] set [a e] ğŸ”—] [[a b c d e] set] "Join set with list -> set"]
                   [[[a e] [a b c d] set ğŸ”—] [[a b c d e] set] "Join list with set -> set"]
                   [["" "" ğŸ”—] [""] "Join two empty strings -> empty string"]
                   [["" [foo bar baz] ğŸ”—] [[foo bar baz]] "Join empty string + list -> list (identity)"]
                   [["a" [\b \c 100 101] ğŸ”—] ["abcde"] "Join a string with a list of chars -> string"]
                   [[[\b \c 100 101] "a" ğŸ”—] ["bcdea"] "Join a list of chars with string -> string"]
                   [["" [\b \c 100 101] ğŸ”—] [[\b \c 100 101]] "Join an empty string with list of chars -> list of chars"]
                   [["abc" [\d 101 "not-char" -1.1] ğŸ”—] [[\a \b \c \d 101 "not-char" -1.1]] "Join a string with (non-char) list -> list"]
                   [["abc" ğŸ”³ ğŸ”—] ["abc"] "Join a string with empty list -> string"]
                   [["" ğŸ”³ ğŸ”—] [""] "Join empty string with empty list -> string"]
                   [[[1 2 3] set [4 4 4] ğŸ”—] [[1 2 3 4] set] "Join set with list -> set"]]]]]

   [ğŸ“¤ [[spec [[dispenser] [item dispenser]]]
        [names ["outbox" "take"]]
        
        [doc "Take an item from a container, leaving the item on top and
             then the modified container."]

        [examples [[[["a" "b" "c"] ğŸ“¤] [["b" "c"] "a"] "Take a string from a list"]
                   [[[1 2 3] ğŸ“¤] [[2 3] 1] "Take a number from a list"]
                   [[[[a "foo"] [b "foo"] [c "foo"]] ğŸ“¤ â€¢ğŸ—‘ï¸ second] ["foo"] "Take an entry from association is nondeterministic"]
                   [[[1 3 5 7 9] set ğŸ“¤ â€¢ğŸ—‘ï¸ odd?] [âœ…] "Take item from set is nondeterministic"]]]]]

   [ğŸ“® [[spec [[item receptacle] [receptacle]]]
        [names ["postbox" "put"]]
        [doc "Put an item into a container, leaving the modified container on top"]
        [examples [[[ğŸ”³ 1 ğŸ“®] [[1]] "Put integer into empty list"]
                   [[[1 2 3] 4 ğŸ“®] [[1 2 3 4]] "Put integer into list"]
                   [["foo" \d ğŸ“®] ["food"] "Put character into string"]
                   [["foo" encode 32 ğŸ“® string] ["foo "] "Put byte into byte array"]]]]]

   [ğŸ“ [[spec [[sized]
               [number]]]
        [names ["ruler" "count"]]
        [doc "Get the number of items in a container"]
        [examples [[[["a" "b" "cd"] ğŸ“] [3] "Count list of strings"]
                   [["abcd" ğŸ“] [4] "Count chars in string"]
                   [["abcd" encode ğŸ“] [4] "Count bytes in byte array"]
                   [[[[a b] [c d]] association ğŸ“] [2] "Count entries in association"]]]]]

   [second [[spec [[ordered] [item]]]
            [doc "Get the second item in a container"]
            [examples [[[[4 5 6] second] [5] "Get second item of list"]
                       [["foo" second [\o]] "Get second item of string"]
                       [[ğŸ”³ second] [ğŸ”³] "Get second item of empty list -> Nothing"]]]]]

   [last [[spec [[ordered] [item]]]
          [doc "Get the last item in a container"]
          [examples [[[[3 4 5 6] last] [6] "Get last item of list"]
                     [["foo" last] [\o] "Get last item of string"]
                     [[ğŸ”³ last] [ğŸ”³] "Get last item of empty list -> Nothing"]]]]]

   [pop [[spec [[ordered] [item ordered]]]
         [doc "Take the last item from a container, leaving the item on top and the modified container beneath."]
         [examples [[[["a" "b" "c"] pop] [["a" "b"] "c"] "Pop last string from list"]
                    [[[1 2 3] pop] [[1 2] 3] "Pop last number from list"]]]]]

   [ğŸ [[spec [[item] [list]]]
        [names ["wrapped present" "gift" "wrap"]]
        [doc "Wrap an item in a list container."]
        [examples [[[1 ğŸ] [[1]] "Wrap a number"]
                   [[[1 2] ğŸ] [[[1 2]]] "Wrap a list"]
                   [[[] ğŸ] [[[]]] "Wrap an empty list"]]]]]

   [ğŸ« [[spec [[list] [*]]]
        [names ["chocolate bar" "unwrap"]]
        [doc "Unwrap a container, placing all the items inside onto the stack, in order."]
        [examples [[[[1] ğŸ«] [1] "Unwrap a list of one item"]
                   [["foo" ["bar" "baz"] ğŸ«] ["foo" "bar" "baz"] "Unwrap a list of strings with existing stack items"]
                   [["foo" ğŸ”³ ğŸ«] ["foo"] "Unwrap an empty list is a no-op"]
                   [[[1 2 3] ğŸ«] [1 2 3] "Unwrap a list of multiple items"]]]]]

   [reverse [[spec [[ordered] [ordered]]]
             [doc "Reverse the order of items in a container."]
             [examples [[[[1 2 3] reverse] [[3 2 1]] "Reverse a list"]
                        [["123" reverse] ["321"] "Reverse a string"]
                        [[["foo" "bar" "baz"] reverse] [["baz" "bar" "foo"]] "Reverse a list of string"]]]]]

   [remove [[spec [[item [sized container]] [[sized container]]]]
            [doc "Remove an item from a container. If there are multiple occurences, removes first occurrence only."]
            [examples [[[[a b c] [b] ğŸ« remove] [[a c]] "Remove item from a list (inefficient)"]
                       [[[a b c b d] [b] ğŸ« remove] [[a c b d]] "Remove item from a list that occurs more than once"]
                       [[[a b c] set [b] ğŸ« remove] [[a c] set] "Remove item from a set"]]]]]

   [slice [[spec [[[integer start] [integer end] ordered] [ordered]]]
           
           [doc "Slices a container by taking indices from start
                (inclusive) to end (exclusive), returning a new
                container. Negative indices mean 'from the end'. Returns
                error if indices are out of bounds."]

           [examples [[["foobar" 0 3 slice] ["foo"] "Slice a string with valid indices"]
                      [[["foobar" 0 7 slice] [ğŸ—‘ï¸ "outofbounds"] ğŸ©¹ â–¶ï¸] ["outofbounds"] "Slice a string with index past end -> error"]
                      [[["foobar" -4 1 slice] [ğŸ—‘ï¸ "outofbounds"] ğŸ©¹ â–¶ï¸] ["outofbounds"] "Slice a string with index before beginning (or start > end) -> error"]
                      [["foobarbazquux" 0 -4 slice] ["foobarbaz"] "Slice a string from start to distance from end"]
                      [["foobarbazquux" -7 0 slice] ["bazquux"] "Slice a string from distance from end to end"]
                      [["foobarbazquux" -7 -4 slice] ["baz"] "Slice a string from distance from end to distance from end"]
                      
                      [["foobar" encode 0 3 slice] ["foo" encode] "Slice a byte array with valid indices"]
                      [[[a b c d e] 0 3 slice] [[a b c]] "Slice a list with valid indices"]]]]]

   [cut [[spec [[integer sized] [list]]]
         [doc "Divide a container at a given index, leaving 2 containers on stack (beginning on top)"]
         [definition [[[[ğŸ“] ğŸ›¡ï¸ ğŸ‹ slice]
                       [0 ğŸ”€ slice]]
                      [â–¶ï¸] ğŸšœ â–¶ï¸ 
                      [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸª„ ğŸ«]]
         [examples [[["abcdefghijklmnopqrstuvwxyz" 5 cut] ["fghijklmnopqrstuvwxyz" "abcde"] "Cut string at index"]
                    [["abcde" 0 cut] ["abcde" ""] "Cut string before start"]
                    [["abcde" 5 cut] ["" "abcde"] "Cut string after end"]
                    [[[a b c d e] 3 cut] [[d e] [a b c]] "Cut list at index"]]]]]

   [empty [[spec [[sized] [sized]]]
           [doc "Empty out the given container"]
           [examples [[["foo" empty] [""] "Create empty container from string"]
                      [["foo" encode empty] ["" encode] "Create empty container from byte array"]
                      [[[1 2 3] empty] [ğŸ”³] "Create empty container from list"]
                      [[[[a b] [c d]] association empty] [ğŸ”³ association] "Create empty container from association"]
                      [[[1 2 3] set empty] [ğŸ”³ set] "Create empty container from set"]]]]]

   [range [[spec [[[integer start]
                   [integer end]
                   [integer step]]

                  [list]]]
           [doc "Create a range of numbers from `start` (inclusive) to `end` (noninclusive) increasing by `step`"]
           [examples [[[1 5 1 range] [[1 2 3 4]] "Create integer range with step of 1"]
                      [[3 13 3 range] [[3 6 9 12]] "Create integer range with step greater than 1"]
                      [[-10 -4 2 range] [[-10 -8 -6]] "Create negative integer range"]
                      [[10 4 -2 range] [[10 8 6]] "Create decreasing integer range"]]]]]

   [empty? [[spec [[item] [boolean]]]
            [doc "Is item on ToS an empty container?"]
            [examples [[[ğŸ”³ empty?] [âœ…] "Empty list is empty"]
                       [[1 empty?] [ğŸ”³] "Number is not empty"]
                       [["" empty?] [âœ…] "Empty string is empty"]
                       [[[foo] empty?] [ğŸ”³] "Non-empty list is not empty"]]]]]

   [list? [[spec [[item] [boolean]]]
           [doc "Is item on ToS a list?"]
           [examples [[[[1] list?] [âœ…] "A list is a list"]
                      [[ğŸ”³ list?] [âœ…] "An empty list is a list"]
                      [[5 list?] [ğŸ”³] "A number is not a list"]
                      [["foo" list?] [ğŸ”³] "A string is not a list"]
                      [[[[foo bar] [baz quux]] association list?] [ğŸ”³] "An association is not a list"]
                      [[ğŸ”³ association list?] [ğŸ”³] "An empty association is not a list"]]]]]

   [ğŸ’ [[spec [[[list template]] [list]]]
        [names ["backpack" "knapsack" "pack"]]
        
        [doc "Fill in a template, with items from the stack. Use 1ï¸âƒ£, 2ï¸âƒ£ etc
             to insert the first, second etc items from the stack. You
             can also splice a container item into the template, with
             âœ‚ï¸1ï¸âƒ£, âœ‚ï¸2ï¸âƒ£ etc. The number of stack items consumed is whatever
             is the highest index placeholder. So a 'backpack' of [1ï¸âƒ£ 4ï¸âƒ£]
             consumes 4 items even though 2ï¸âƒ£ and 3ï¸âƒ£ are not used."]

        [examples [[["x" [foo] [bar] ğŸ«
                     [2ï¸âƒ£ [ 1ï¸âƒ£ x âœ‚ï¸2ï¸âƒ£] c d 1 2 3] ğŸ’]
                    ["x" [[foo] [bar x foo] c d 1 2 3]]
                    "Packing values from the stack, into a template"]]]]]

   [â›ï¸ [[spec [[[sized pattern] [sized data]] [associative list]]]
       [names ["pick" "unpack"]]
       
       [doc "Unpack values from a nested structure (aka
             destructuring). Takes a pattern and data to match
             against. The pattern is a nested structure containing
             placeholders that can be either an index (1ï¸âƒ£, 2ï¸âƒ£ etc) or a
             named value (named values start with ğŸ·ï¸, eg
             `ğŸ·ï¸foo`). Traverses pattern and data simultaneously, looking
             for matches. To match against an association, the pattern
             must also be an association (see `assocify` which
             recursively converts lists of pairs to associations). The
             underscore word `_` represents a wildcard, which will match
             any value at that location. Returns two values: an
             association of named values, and a list of indexed
             values. The indexed values will stop at the highest index
             used in the pattern, any skipped indices will be assigned a ğŸ”³ value."]
       
       [examples [[[[a b c d e]
                    [a b 1ï¸âƒ£ d 2ï¸âƒ£] â›ï¸]

                   [[c e] []]

                   "Unpack values by index"]

                  [[[a b c d e]
                    [a b 1ï¸âƒ£ _ 2ï¸âƒ£] â›ï¸]

                   [[c e] []]

                   "Unpack values by index with wildcard"]

                  [[[a b c d e]
                    [a 1ï¸âƒ£ âœ‚ï¸2ï¸âƒ£] â›ï¸]

                   [[b [c d e]] []]

                   "Unpacking values by index with catch-all at end"]
                  
                  [[[anything
                     [foo [this is a] 12]
                     [5 [this is b] 5]
                     []
                     thisisc]
                    [_ [_ ğŸ·ï¸a 12]
                     [5 ğŸ·ï¸b 5]
                     []
                     ğŸ·ï¸c] 
                    â›ï¸]

                   [[]
                    [[a [this is a]]
                     [b [this is b]]
                     [c thisisc]] association]

                   "Unpack nested values by name"]

                  [[[[a [[b 12]
                         [c 15]]]
                     [d [[e []]
                         [f [5 4 3 2 1]]]]] assocify
                    [[a ğŸ·ï¸a]
                     [d [[f [_ _ ğŸ·ï¸b _ _]]]]] assocify
                    â›ï¸]
                   [[]
                    [[a [[b 12]
                         [c 15]]]
                     [b 3]] assocify]]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats kcats :tangle src/kcats/stdlib/collections.kcats :mkdirp yes
  ;; DEPRECATE - this is redundant, all logical operators can take the item directly
  [something? [[spec [[item] [boolean]]] 
               [definition [empty? â˜¯ï¸]]
               [examples [[[1 something?] [âœ…] "A number is something"]
                          [[ğŸ”³ something?] [ğŸ”³] "Empty list is not something"]
                          [["" something?] [ğŸ”³] "Empty string is not something"]]]]]

  [â€¢ğŸ“® [[spec [[[item target] [item skip] receptacle] [[item skip] receptacle]]]
        [doc "Puts target into a container skipping over an intervening item"]
        [definition [â€¢ğŸ”€ ğŸ“® ğŸ”€]]
        [examples [[[["a" "b" "c"] "foo" "d" â€¢ğŸ“®] [["a" "b" "c" "d"] "foo"]]]]]]

  [â€¢â€¢ğŸ“® [[spec [[[item target] [item skip1] [item skip2] receptacle]
                [[item skip1] [item skip2]  receptacle]]]
         [doc "Puts target into a container skipping over two intervening items"]
         [definition [âš“ [ğŸ“®] â€¢ğŸª„]]
         [examples [[[["a" "b" "c"] "foo" "bar" "d" â€¢â€¢ğŸ“®] [["a" "b" "c" "d"] "foo" "bar"]]]]]]

  [first [[spec [[ordered] [item]]]
          [definition [ğŸ“¤ â€¢ğŸ—‘ï¸]]
          [examples [[[[4 5 6] first] [4] "Get the first item of a list"]
                     [["foo" first] [\f] "The first item of a string is the first character"]
                     [[ğŸ”³ first] [ğŸ”³] "The first item of an empty list is Nothing"]]]]]

  [any [[spec [[sized] [item]]]
        [definition [ğŸ“¤ â€¢ğŸ—‘ï¸]]
        [examples [[[[4 5 6] any] [4] "Get any item of a list (gets first)"]
                   [["foo" any] [\f] "Any item of a string is the first character"]
                   [[ğŸ”³ any] [ğŸ”³] "Any of an empty list is Nothing"]]]]]

  [rest [[spec [[sized] [sized]]]
         [definition [ğŸ“¤ ğŸ—‘ï¸]]
         [examples [[[[1 2 3] rest] [[2 3]] "Take rest of list"]
                    [["foo" rest] ["oo"] "Take rest of string"]]]]]

  [butlast [[spec [[sized] [sized]]]
            [definition [pop ğŸ—‘ï¸]]
            [examples [[[[1 2 3] butlast] [[1 2]] "Take all but last of list"]]]]]

  [prepend [[spec [[item sized]
                   [sized]]]
            [definition [ğŸ ğŸ”€ ğŸ”—]]
            [examples [[[[1 2] 3 prepend] [[3 1 2]] "Prepend to list"]
                       [["oo" \f prepend] ["foo"] "Prepend to string"]]]]]

  [ğŸ’¯ [[spec [[program sized] [program]]]
       [doc "The '100' (percent) denotes creating a consensus program from a predicate program. The returned program will check whether all the items in the container match the predicate program. Each item is placed on the stack (with remaining items hidden), and the predicate program is run. If it returns logical true, repeat with the next item, otherwise stop and return logical false."]
       [definition [â€¢ğŸ›¡ï¸ ;; protect the rest of stack
                    [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
                     [ğŸ”³ âœ… ğŸ”³] ;; empty list, return âœ…
                     â†”ï¸] ğŸ’
                    [ğŸ—‘ï¸ ğŸ—‘ï¸]
                    [â€¢ğŸ—‘ï¸]
                    [â–¶ï¸] ğŸª†]]
       [examples [[[[2 4 6] [even?] ğŸ’¯ â–¶ï¸] [âœ…] "Every number matches predicate"]
                  [[[2 4 5] [even?] ğŸ’¯ â–¶ï¸] [ğŸ”³] "Not every number matches predicate"]
                  [[ğŸ”³ [ğŸ”³] ğŸ’¯ â–¶ï¸] [âœ…] "Every item in empty list matches any predicate"]
                  [[[2 4 6] ğŸ”³ ğŸ’¯ â–¶ï¸] [âœ…] "Every item in list matches empty predicate"]
                  [[11 [2 4 6] [+ odd?] â€¢ğŸ›¡ï¸ ğŸ’¯ â–¶ï¸] [11 âœ…] "Can shield stack from predicate"]
                  [[12 [[even?] [positive?] [3 mod 0 =]] [â–¶ï¸] â€¢ğŸ›¡ï¸ ğŸ’¯ â–¶ï¸] [12 âœ…] "Can check list of predicates with execute predicate"]]]]]

  [ğŸ“£ [[spec [[program sized] boolean]]
       [doc "The megaphone denotes creating a existence program from a predicate program. (The megaphone represents amplifying from a single element to the whole). The returned program will check whether any of the items in the container match the predicate program. Each item is placed on the stack (with remaining items hidden), and the predicate program is run. If it returns logical false, repeat with the next item, otherwise stop and return logical true."]
       [definition [[[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥ â˜¯ï¸] ;; more items
                     [ğŸ”³ ğŸ”³ ğŸ”³] ;; empty list, return ğŸ”³
                     â†”ï¸] ğŸ’
                    [ğŸ—‘ï¸ ğŸ—‘ï¸]
                    [â€¢ğŸ—‘ï¸]
                    [â–¶ï¸] ğŸª†]]
       [examples [[[[2 4 6] [even?] ğŸ“£ â–¶ï¸] [âœ…] "Any number matches predicate"]
                  [[[3 5 7] [even?] ğŸ“£ â–¶ï¸] [ğŸ”³] "No number matches predicate"]
                  [[ğŸ”³ [âœ…] ğŸ“£ â–¶ï¸] [ğŸ”³] "No item in empty list matches any predicate"]
                  [[[ğŸ”³ 2 4 6] ğŸ”³ ğŸ“£ â–¶ï¸] [2] "Empty predicate returns first truthy item"]
                  [[11 [3 5 6] [+ odd?] â€¢ğŸ›¡ï¸ ğŸ“£ â–¶ï¸] [11 âœ…] "Stack is shielded from predicate"]
                  [[-15 [[even?] [positive?] [3 mod 0 =]] [ğŸ›¡ï¸ â–¶ï¸] ğŸ“£ â–¶ï¸] [-15 âœ…] "Can check list of predicates with execute predicate"]]]]]

  [ğŸ­ [[spec [[program] [program]]]
       [doc "The performing arts masks denote logically complementing a program: create a new program that returns the logical opposite of what the original program did."]
       [definition [[1ï¸âƒ£ â–¶ï¸ â˜¯ï¸] ğŸ’]]
       [examples [[[4 [odd?] ğŸ­ [ğŸ—‘ï¸ "even"] ["odd"] âš–ï¸ â–¶ï¸]
                   ["even"]]]]]]

  [ğŸšœ [[spec [[[program transform]] [program]]]
       [doc "The tractor denotes creating an item-by-item transformation. The returned program will run the transform on each item in the container on ToS. Each item is placed on the stack with remaining items hidden, and the transform program is run. Its stack effects are erased for the next item."]
       [definition [[[ğŸ”€ 1ï¸âƒ£ â€¢ğŸ›¡ï¸ ğŸª„ ğŸ”€ ğŸ“®] ğŸªœ
                     ğŸ”³ âš“ ;; put empty results below list
                     â–¶ï¸]
                    ğŸ’]]
       [examples [[[[1 2 3] [inc] ğŸšœ â–¶ï¸] [[2 3 4]] "Pass each item through a program"]

                  [[1 [1 2 3] [+] ğŸšœ â–¶ï¸] [1 [2 3 4]] "Program has access to rest of stack"]
                  [[7 9 [1 2 3] [+ *] ğŸšœ â–¶ï¸] [7 9 [70 77 84]] "Stack is shielded from mapping program"]
                  [[7 9 [1 2 3] [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸšœ â–¶ï¸] [7 9 [7 7 7]] "Result of program can be lower stack items"]

                  [[7 9 [+] ğŸ”³ ğŸšœ â–¶ï¸] [7 9 [+]] "Empty program is a no-op"]
                  [[[+] ğŸšœ [7 9 [1 2 3]] ğŸª„ â–¶ï¸] [7 9 [10 11 12]] "Create a map program and use later"]]]]]

  [ğŸ§² [[spec [[[program predicate] sized] [list]]]
       [doc "The magnet denotes a filtering. The returned program will filter a list on ToS and leave only those items for which the predicate returns logical true."]
       [definition [ğŸ›¡ï¸ ;; run the predicate with no stack effect
                    [1ï¸âƒ£ â€¢ğŸ”€ ğŸ‹] ğŸ’  ;; dive the predicate under the result
                    [ğŸ—‘ï¸ ğŸ”€ ğŸ“®] [â€¢ğŸ—‘ï¸] âš–ï¸ ;; if match, drop the pred result and put the original item in result list
                    ;; if not, just drop the original
                    ğŸªœ 
                    [1ï¸âƒ£ ğŸ”³ âš“ â–¶ï¸] ğŸ’]]  ;; place the empty result container beneath
       [examples [[[[1 2 3] [odd?] ğŸ§² â–¶ï¸] [[1 3]] "Filter a list with predicate"]
                  [[[2 4 6] [odd?] ğŸ§² â–¶ï¸] [ğŸ”³] "Filter with predicate that matches no items"]
                  [[33 [1 2 3] [+ odd?] ğŸ§² â–¶ï¸] [33 [2]] "Filter predicate uses existing stack items"]]]]]

  [sort [[spec [[program sized] [list]]]
         [definition [[ğŸ‘¥ âœ‚ï¸1ï¸âƒ£ pair] ğŸ’
                      ğŸšœ â–¶ï¸ sort-indexed]]
         [examples [[[[1 3 2] ğŸ”³ sort] [[1 2 3]] "Sort a list of numbers"]
                    [[["Carol" "Alice" "bob"] ğŸ”³ sort] [["Alice" "Bob" "Carol"]] "Sort a list of strings"]
                    [[["Charlie" "Alice" "bob"] [ğŸ“] sort] [["Bob" "Alice" "Charlie"]] "Sort list of strings by length"]]]]]

  [repetition [[spec [[[integer howmany]
                       item]
                      [list]]]
               [definition [ğŸ”³ âš“ [ğŸ [ğŸ“®] ğŸ”—] ğŸª„ times]]
               [examples [[["hi" 3 repetition â–¶ï¸] [["hi" "hi" "hi"]] "Create a list of repeated items"]]]]]

  [indexed [[spec [[list] [list]]]
            [definition [[ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 0 ğŸ”€ 1 range ğŸ”€ zip]]
            [examples [[[[a b c] indexed] [[[0 a] [1 b] [2 c]]] "Index a list"]]]]]

  [indexer [[spec [ğŸ”³ [program]]]
            [definition [0 [[â–¶ï¸] ğŸ‹
                            [[pair] â€¢ğŸ›¡ï¸ â–¶ï¸ [inc] ğŸª„] bail]
                         ğŸ”³ [ğŸ—‘ï¸ ğŸ”³] [ğŸ”€] ğŸª†]]
            [examples [[[[a b c] [indexer collect] assemble] [[[0 a] [1 b] [2 c]]] "Index a generator"]]]]]

  [indexof [[spec [[item list] [item]]]
            [definition [[[second ğŸ [1ï¸âƒ£] = â˜¯ï¸] skipper
                          [indexer] â€¢ğŸª„
                          â–¶ï¸ first] ğŸ’ 
                         assemble]]
            [examples [[[[a b c] [c] ğŸ« indexof] [2] "Get the index of first matching item"]
                       [[[a b c] [d] ğŸ« indexof] [ğŸ”³] "No matching item -> Nothing"]
                       [[[a b c d c e] [c] ğŸ« indexof] [2] "Multiple matches returns index of first match"]]]]]

  [interpose [[spec [[item ordered] [ordered]]]
              [definition [ğŸ”³ flip
                           [ğŸ”€ pair ğŸ”— [pop] ğŸ›¡ï¸ â–¶ï¸] ğŸªœ â–¶ï¸ 
                           ğŸ—‘ï¸ pop ğŸ—‘ï¸]]
              [examples [[[[foo bar baz] "hi" interpose] [[foo "hi" bar "hi" baz]] "Interpose string between words"]
                         [[ğŸ”³ "hi" interpose] [ğŸ”³] "Empty list is a no-op"]
                         [[[foo] "hi" interpose] [[foo]] "Single item list is a no-op"]]]]]

  [starts? [[spec [[[ordered prefix] [ordered target]] [boolean]]]
            [definition [[[zip [ğŸ« =] ğŸ’¯ â–¶ï¸] ;; the items at matching indexes are equal
                          [[ğŸ“] both >=]] ;; the prefix is shorter than the target
                         [â–¶ï¸] â€¢ğŸ›¡ï¸ ğŸ’¯ â–¶ï¸
                         â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸]] ;; drop the originals
            [examples [[["abcd" "ab" starts?] [âœ…] "String starts with matching string"]
                       [["abcd" "" starts?] [âœ…] "String starts with empty string"]
                       [["" "ab" starts?] [ğŸ”³] "Empty string doesn't start with a string"]
                       [["abcd" "bb" starts?] [ğŸ”³] "String doesn't start with non-matching string"]
                       [[[1 2 3 4] [1 2] starts?] [âœ…] "List starts with matching list"]]]]]

  [ends? [[spec [[ordered ordered] [boolean]]]
          [definition [[reverse] both starts?]]
          [examples [[["abcd" "cd" ends?] [âœ…] "String ends with matching string"]
                     [["abcd" "" ends?] [âœ…] "String ends with empty string"]
                     [["abcd" "bb" ends?] [ğŸ”³] "String doesn't end with non-matching string"]
                     [[[1 2 3 4] [3 4] ends?] [âœ…] "List ends with matching list"]]]]]

  [pair [[spec [[item item] [list]]]
         [definition [[ğŸ] ğŸª„ ğŸ“®]]
         [examples [[[1 2 pair] [[1 2]] "Pair up two numbers into a list"]
                    [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]] "Pair up two lists into a new list"]]]]]

  [pair? [[spec [[item] [boolean]]]
          [definition [[ğŸ“ 2 =]
                       [[actual 0 0] ğŸ” [sized] ğŸ« =]
                       [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³]
                       [ğŸ”³] âš–ï¸ ğŸ©¹ â–¶ï¸] ]
          [examples [[["ab" pair?] [âœ…] "2-character string is a pair"]
                     [[[a b] pair?] [âœ…] "2-item list is a pair"]
                     [["abc" pair?] [ğŸ”³] "3-character string is not a pair"]
                     [[ğŸ”³ pair?] [ğŸ”³] "Nothing is not a pair"]
                     [[7 pair?] [ğŸ”³] "Number is not a pair"]]]]]

  [triplet [[spec [[item item] [list]]]
            [definition [[pair] ğŸª„ ğŸ“®]]
            [examples [[[1 2 3 triplet] [[1 2 3]] "Make a 3-item list from 3 stack items"]
                       [[["hi"] ["there" "foo"] ["bar"] triplet] [[["hi"] ["there" "foo"] ["bar"]]] "Make a 3-item list from smaller lists"]]]]]

  [both? [[spec [[program item item] [boolean]]]
          [definition [âš“ pair ğŸ”€ ğŸ’¯ â–¶ï¸]]
          [examples [[[1 2 [odd?] both?] [ğŸ”³] "Test two items for predicate when not all match"]
                     [[1 3 [odd?] both?] [âœ…] "Test two items for predicate when all match"]]]]]

  [both [[spec [[program [item a] [item b]] [item item]]]
         [definition [[pair] ğŸª„ ğŸªœ â–¶ï¸]]
         [examples [[[1 2 [inc] both] [2 3] "Run program on two stack items"]]]]]

  [walk [[spec [[[program item-transform] list] [list]]]
         [definition [[âœ‚ï¸1ï¸âƒ£] ğŸ’ ;; the negative branch
                      [list?] ğŸ›¡ï¸ ;; pred
                      [ğŸ—‘ï¸ ğŸ”³ ğŸ”€] ğŸ›Ÿ ;; affirmative branch
                      [[âœ‚ï¸1ï¸âƒ£ ğŸ”—] ğŸ’ ğŸªœ â–¶ï¸ ğŸ] ;; recur into each subitem and wrap
                      ğŸª† [âœ‚ï¸1ï¸âƒ£ ğŸ«] ğŸ’]] ;; unwrap at the end
         [examples [[[[1 2 [3 [4 5] 6]] [inc ğŸ] walk â–¶ï¸] [[2 3 [4 [5 6] 7]]] "Walk a nested list"]
                    [[[1 2 [3 [4 5] 6]] [ğŸ‘¥ inc pair] walk â–¶ï¸] [[1 2 2 3 [3 4 [4 5 5 6] 6 7]]] "Walk a nested list and splice results"]]]]]

  [flatten [[spec [[list] [list]]]
            [definition [ğŸ”³ ğŸ”€ [list?] ğŸ›¡ï¸ [ğŸ—‘ï¸] [ğŸ“®] [ğŸªœ â–¶ï¸] ğŸª† â–¶ï¸]]
            [examples [[[[a b [c [d e] f] g] flatten] [[a b c d e f g]] "Flatten a nested list"]]]]]

  [pad [[spec [[[item padding] [integer newsize] sized] [sized]]]
        [definition [[[[ğŸ“] ğŸ›¡ï¸ â–¶ï¸] ğŸ‹
                      [[abs] ğŸª„ -] ğŸ›¡ï¸ â–¶ï¸ ;; negative means pad on left
                      â€¢ğŸ—‘ï¸] ğŸª„
                     ğŸ”€ repetition â–¶ï¸
                     ğŸ”€
                     [positive?] [ğŸ—‘ï¸] [ğŸ”€] âš–ï¸ â–¶ï¸ 
                     ğŸ”—]]
        [examples [[[[1 2 3] -5 0 pad] [[0 0 1 2 3]] "Pad a list at start with negative argument, to given size"]
                   [[[1 2 3] 5 0 pad] [[1 2 3 0 0]] "Pad a list at end with positive argument, to given size"]
                   [[[1 2 3 4 5 6] -5 0 pad] [[1 2 3 4 5 6]] "Padding a list to smaller than original size, is a no-op"]]]]]

  [ğŸ·ï¸â›ï¸ [[spec [[[sized pattern] [sized data]] [associative]]]
         [definition [â›ï¸ â€¢ğŸ—‘ï¸]]]]

  [#ï¸âƒ£â›ï¸ [[spec [[[sized pattern] [sized data]] [*]]]
         [doc "Picks values from a nested structure and places them on the
       stack. Use 1ï¸âƒ£, 2ï¸âƒ£ etc for the first, second etc items to place on
       the stack (with 1ï¸âƒ£ being on top)."]
         [definition [â›ï¸ ğŸ—‘ï¸ reverse ğŸ«]]]]

  [ğŸ§¤ [[spec [[[[list patterns]] [program]]]]

       [doc "Creates a matcher program. Takes a list of pattern/program
             pairs. Returns a program that will match data below
             it. When that program runs, the first pattern that matches
             the data, its corresponding program will be executed. If
             no patterns match, then an error will be raised."]

       [definition [[ğŸ« ;; break up pair 
                     [[2ï¸âƒ£
                       [â›ï¸ ğŸ—‘ï¸ âœ… or] ;; use dummy value if no placeholders
                       [ğŸ—‘ï¸ []] ğŸ©¹ â–¶ï¸] ;; recover from failed destructure to try next
                      [[âœ… =] ğŸ›¡ï¸
                       [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop dummy value 
                       [â€¢ğŸ—‘ï¸ ğŸ«] ;; unwrap the destructured elements onto the stack
                       âš–ï¸ â–¶ï¸ âœ‚ï¸1ï¸âƒ£]] ğŸ’] ;; rebuild pair with new condition and program
                    ğŸšœ â–¶ï¸
                    ;; now add a clause to fail if no match
                    [[âœ…] [ğŸ—‘ï¸ [ğŸ§¤] "No patterns match" [reason asked actual] label fail]] ğŸ“®
                    [1ï¸âƒ£ decide] ğŸ’]]
       [examples [[[[foo bar [5 6]]
                    [[[foo nomatch [1ï¸âƒ£ 2ï¸âƒ£]] ["shouldn't match"]]
                     [[nomatch bar [1ï¸âƒ£ quux]] ["also shouldn't match"]]
                     [[foo _ [1ï¸âƒ£ 2ï¸âƒ£]] [+]]] ğŸ§¤ â–¶ï¸]
                   [11] "Simple pattern matching"]

                  [[[foo]
                    [[[bar] ["shouldn't match"]]
                     [[nomatch bar [1ï¸âƒ£ quux]] ["also shouldn't match"]]
                     [[foo] ["match"]]] ğŸ§¤ â–¶ï¸]
                   [[foo] "match"] "Matching with no placeholders (equality test)"]
                  
                  [[[foo bar [5 6]]
                    [[[foo nomatch [1ï¸âƒ£ 2ï¸âƒ£]] ["shouldn't match"]]
                     [[nomatch bar [1ï¸âƒ£ quux]] ["also shouldn't match"]]] ğŸ§¤
                    [ğŸ—‘ï¸ ğŸ—‘ï¸ "no match"] ğŸ©¹ â–¶ï¸]
                   ["no match"] "Error when no patterns match"]]]]]

  [ğŸª— [[spec [[[program reducer] dispenser] [item]]]
       [definition [[ğŸ“¤ ğŸ”€] ğŸª„ ;; get the first item as the initial value
                        ğŸªœ]]
       [examples [[[[1 2 3 4] [+] ğŸª— â–¶ï¸] [10]]]]]]

  [ğŸšœğŸ”— [[spec [[[program transform]] [program]]] [doc "Like ğŸšœ, but the
         expectation is that the `transform` program will return a sized
         container, and the final result will ğŸ”— the containers
         together. Like `flatMap` in other languages."]
         [definition [ğŸšœ â–¶ï¸ [ğŸ”—] ğŸª—]]]]
#+end_src

*** Associations
#+begin_src kcats :tangle src/kcats/core/associations-builtins.kcats :mkdirp yes
  [[get [[spec [[item sized] [item]]]
         [examples [[[[[a 3] [c 2]] [a] ğŸ« get] [3] "Get a key from an association"]
                    [[[10 11 12 13] 1 get] [11] "Get an item by index from a list"]
                    [["foobar" 3 get] [\b] "Get a character by index from a string"]
                    [["foobar" encode 3 get] [98] "Get an integer by index from a byte array"]
                    [[[[a 3] [c 2]] [b] ğŸ« get] [ğŸ”³] "Get a nonexistent key -> Nothing"]]]]]

   [assign [[spec [[[item value]
                    [list keys]
                    sized]
                   [association]]]
            [examples [[[[[a b] [c d]] [a] 5 assign]
                        [[[a 5] [c d]] association] "Assign a new value to an existing key"]

                       [[[[a b] [c d]] [e] 5 assign]
                        [[[a b] [c d] [e 5]] association] "Assign a new value to a new key"]

                       [[[[a b] [c [[d e]]]] [c d] 5 assign]
                        [[[a b] [c ğŸ”³]] [c] [[d 5]] association assign] "Assign a new nested key, promoting to nested association"]

                       [[[[a b] [c [[d e]]]] [1 1 0] 5 assign]
                        [[[a b] [c [5]]]] "Assign a new index in a nested list"]

                       [[[1 2 3] [1 0 0] "foo" assign]
                        [[1 [["foo"]] 3]] "Assign a new index in a nested list"]

                       [[[[a [1 2 3]]] [a 0] 10 assign]
                        [[[a [10 2 3]]] association] "Assign a nested key in a mixed structure of association and list"]

                       [[[1 2 3] [1 2] "foo" assign]
                        [[1 [ğŸ”³ ğŸ”³ "foo"] 3]] "Assign an index creating placeholders for missing list items"]]]]]

   [unassign [[spec [[[item key] [sized into-association]] [association]]]
              [examples [[[[[a b] [c d]] [a] unassign]
                          [[[c d]] association] "Unassign a key from an association, promoting from list"]

                         [[[[a b] [c d]] [e] unassign]
                          [[[a b] [c d]] association] "Unassign a key that doesn't exist, only promotes"]

                         [[[[a b] [c d]] [e f] unassign]
                          [[[a b] [c d]] association] "Unassign multiple keys that don't exist only promotes"]

                         [[[[a b] [c [[d e] [f g]]]] [c x] unassign]
                          [[[a b]] [c] [[d e] [f g]] association assign] "Unassign multiple keys where last doesn't exist, only promotes"]

                         [[[[a [[b c] [d e]]]] [a d] unassign]
                          [ğŸ”³ association [a b] [c] ğŸ« assign] "Unassign associative keylist from nested structure, promoted to association"]

                         [[[0 1 2 [[a b] [c d]]] [3 c] unassign]
                          [[0 1 2] [[a b]] association ğŸ“®] "Unassign mixed keylist from nested structure, inner only is promoted to association"]]]]]

   [association? [[spec [[item] [boolean]]]
                  [examples [[[[[a b] [c d]] association association?] [âœ…] "Association is an association"]
                             [[[[a b] [c d]] association?] [ğŸ”³] "A list is not an association, even if it's possible to promote"]
                             [[1 association?] [ğŸ”³] "A number is not an association"]
                             [[ğŸ”³ association?] [ğŸ”³] "An empty list is not an association"]
                             [[ğŸ”³ association association?] [âœ…] "An empty association is an association"]
                             [[ğŸ”³ [a] 1 assign association?] [âœ…] "A list promoted to association by assignment, is an association"]]]]]

   [association [[spec [[item] [association]]]
                 [examples [[[[[a b] [c d]] association
                              [[c d] [a b]] association =]
                             [âœ…] "A list can be promoted to association"]

                            [[[[a b] [c d]]
                              [[c d] [a b]] association =]
                             [ğŸ”³] "An association and list are not the same, even if keys/vals are the same"]

                            [[[[a b] [c d]]
                              [[a b] [c d]] association =] [ğŸ”³] "An association is not the same as the list it was promoted from"]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/associations.kcats :mkdirp yes
    ;; Associative words
    [update [[spec [[program [list keys] [sized into-association]]
                    [association]]]
             [definition  [â€¢ğŸ›¡ï¸ 
                           [ğŸ”] ğŸ›¡ï¸ ğŸª„
                           ğŸ›Ÿ [ğŸ›Ÿ] ğŸª„ 
                           [â–¶ï¸] â€¢ğŸª„ ğŸ›Ÿ assign]]
             [examples [[[[[a 1] [b 2]] [b] [inc] update]
                         [[[a 1] [b 3]] association] "Update a value in an association"]

                        [[[[a [[c 3] [d 5]]] [b 2]]
                          [a c] [inc] update
                          [a c] ğŸ”]
                         [4] "Update a value in a nested association"]

                        [[[[a [1 3 5 7]] [b 2]]
                          [a 2] [inc] update]
                         [[[a [1 3 6 7]] [b 2]] association] "Update a value in a mixed association/list structure"]

                        [["hi"
                          [[a [[c 3] [d 5]]] [b 2]]
                          [a c] [ğŸ—‘ï¸ ğŸ—‘ï¸ 10 15] update
                          [a c] ğŸ”]
                         ["hi" 15] "Update function can't destroy stack items"]

                        [[[[a 1] [b 2]] [d] [5] update]
                         [[[a 1] [b 2] [d 5]] association] "Update creates new key when it doesn't exist"]

                        [[[[a [[c 3] [d 5]]] [b 2]]
                          [a e] [5 6 +] update
                          [a e] ğŸ”]
                         [11] "Update function can ignore previous value"]]]]]

    [ğŸ” [[spec [[[list keys] sized] [item]]]
             [definition [ğŸ”³ ;; keylist not empty
                          [ğŸ“¤ ğŸ”€ [get] ğŸª„] ;; extract the first key and ğŸ”
                          â³ â–¶ï¸]]
             [examples [[[[[a b] [c d]] association [a] ğŸ”] [[b] ğŸ«] "Lookup the value of a key in an association"]
                        [[[[a b] [c d]] [a] ğŸ”] [[b] ğŸ«] "Lookup the value of a key, promoting a list to association"]
                        [[[[a b] [c d]] [e] ğŸ”] [ğŸ”³] "Looking up a key that doesn't exist returns Nothing"]
                        [[[[outer [[a b] [c d]]]] [outer c] ğŸ”] [[d] ğŸ«] "Lookup in a nested structure, with promotion"]]]]]

    ;; TODO: fix the case where you just want a value [[type foo]] - only
    ;; one item but you want the value, not key
    [type [[spec [[item] [item]]]
           [definition [[[[empty?] [[nothing]]]
                         [[word?] [[word]]]
                         [[number?] [[number]]]
                         [[string?] [[string]]]
                         [[bytes?] [[bytes]]]
                         [[pipe?] [[pipe]]]
                         [[error?] [[error]]]
                         [[environment?] [[environment]]]
                         [[set?] [[set]]]
                         [[association?] [ğŸ—‘ï¸ [[[ğŸ“ 1 =] [ğŸ—‘ï¸
                                                        [any first [type] ğŸ« =] ğŸ›¡ï¸
                                                        [ğŸ—‘ï¸ any second]
                                                        [any first]
                                                        âš–ï¸ â–¶ï¸]]
                                             [[[type] ğŸ”] [â€¢ğŸ—‘ï¸]]
                                             [[âœ…] [[association] ğŸ« â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸]]] decide
                                          ğŸ ğŸ”³ ğŸ”³ ğŸ›Ÿ]]
                         [[list?] [[list]]]
                         [[âœ…] [[item]]]]
                        decide ğŸ« â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸]]
           [examples [[[[[foo 1]] association type] [[foo] ğŸ«] "An association with one key assumes it is its type"]
                      [[1 type] [[number] ğŸ«] "Integers are of type number"]
                      [[1.0 type] [[number] ğŸ«] "Floats are of type number"]
                      [[ğŸ”³ type] [[nothing] ğŸ«] "Empty list is of type nothing"]
                      [["foo" encode type] [[bytes] ğŸ«] "A byte array is of type bytes"]
                      [["foo" type] [[string] ğŸ«] "A string is of type string"]
                      [[[1 2 3] set type] [[set] ğŸ«] "A set is of type set"]
                      [[ğŸ”³ environment type] [[environment] ğŸ«] "An environment is of type environment"]
                      [[[[type foo]] association type] [[foo] ğŸ«] "An association with a single type key, the value is its type"]
                      [[[[type foo] [attr "blah"]] association type] [[foo] ğŸ«] "An association with a single type key, the value is its type"]
                      [[[[attr1 foo] [attr2 "blah"]] association type] [[association] ğŸ«] "An association with multiple keys and no type key, is of type association"]
                      [[[[type url] [value "http://foo.com"]] association type] [[url] ğŸ«] "An association with type/value keys, uses the type key for its type"]]]]]

    [value [[spec [[[sized into-association]] [item]]]
            [definition [[ğŸ“ 1 =] ğŸ›¡ï¸ ;; if it's a single item
                         [ğŸ—‘ï¸ first second] ;; the value is the value of that first item
                         [[value] ğŸ”] ;; otherwise look up the key 'value'
                         âš–ï¸ â–¶ï¸]]
            [examples [[[[[foo 1]] value] [1] "The value of a single-entry association is the value of the key-value pair"]

                       [[[[type url] [value "http://foo.com"]] value]
                        ["http://foo.com"] "The value of an object is the value key"]]]]]

    [zip [[spec [[[dispenser values] [dispenser keys]] [list]]]
          [definition [ğŸ”³ âš“ ;; save accumulator below args
                       [ğŸ”³ both?] ğŸ›¡ï¸ ;; stop when either list is empty
                       [ğŸ—‘ï¸ [ğŸ“¤] both â€¢ğŸ”€ pair ;; take from each list and pair them up
                        âš“ [ğŸ“®] â€¢ğŸª„] ;; put them into the accumulator
                       â³ â–¶ï¸
                       ğŸ—‘ï¸ ğŸ—‘ï¸]] ;; drop the empty containers
          [examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]] "Zip two lists together into a single list of pairs"]
                     [[[a b c d] [1 2 3] zip] [[[a 1] [b 2] [c 3]]] "Zip two lists of unequal size pads with Nothing values"]]]]]

    [label [[spec [[[sized labels]] [association]]]
            [definition [ğŸ”³ ğŸ”€ ;; labels acc
                         [ğŸ ğŸ›Ÿ assign] ğŸªœ â–¶ï¸]]
            [examples [[["Alice" 23 "123 Main St" [address age name] label]
                        [[[address "123 Main St"]
                          [age 23]
                          [name "Alice"]] association]
                        "Label values on the stack as an association"]]]]]

    [assocify [[spec [[list] [item]]]
               [doc "Recursively converts association-shaped lists into
               actual associations, leaving non-convertiable values
               as-is. Useful for literal lists that are intended as
               nested associations."]
               [definition [[list?] ğŸ›¡ï¸
                            [ğŸ—‘ï¸]
                            []
                            [ğŸšœ [association] [ğŸ—‘ï¸] ğŸ©¹ ğŸ”— â–¶ï¸]
                            ğŸª† â–¶ï¸]]
               [examples [[[[1 2] assocify] [[1 2]] "assocify a non-assoc-shaped list is a no-op"]
                          [[[[a b]] assocify] [[[a b]] association] "assocify an assoc-shaped list converts to association"]
                          [[[foo [[a b]] bar] assocify] [[[a b]] association [foo 1ï¸âƒ£ bar] ğŸ’] "assocify an non-assoc-shaped list converts inner values to association where appropriate"]]]]]

    [ğŸ¤¹ [[spec [program
                [list [keylist]]
                association]]
         [names ["juggle" "juggler"]]
         
         [doc "Extracts the values from an association using keylist,
               places them on the stack. Runs program, protecting the association"]
         
         [definition [[association] â€¢ğŸª„
                      [reverse [ğŸ ğŸ”] ğŸšœ â–¶ï¸] ğŸª„ ;; lookup the keys
                      [[ğŸ«] ğŸª„ â–¶ï¸] â€¢â€¢ğŸ›¡ï¸ â–¶ï¸]]
         [examples [[[[[foo 1]
                       [bar 2]
                       [baz 3]
                       [quux 4]]
                      [foo bar baz] [+ +] ğŸ¤¹]

                     [[[foo 1]
                       [bar 2]
                       [baz 3]
                       [quux 4]] association 6]]

                   [[[[foo 1]
                       [bar 2]
                       [baz 3]
                       [quux 4]]
                      [foo bar baz] [+ +] ğŸ¤¹ [quux] label ğŸ”—]

                     [[[foo 1]
                       [bar 2]
                       [baz 3]
                       [quux 6]] association]]]]]]
#+end_src

*** Sets
#+begin_src kcats :tangle src/kcats/core/sets-builtins.kcats :mkdirp yes
  ;; TODO add 'set' type for spec?
  [[set [[spec [[item] [item]]]
         [examples [[[[1 2 3 1 2 3] set] [[1 2 3] set] "Promote a list to a set"]
                    [["hello" set] ["helo" set] "Promote a string to a set"]]]]]

   [set? [[spec [[item] [boolean]]]
          [examples [[[[1 2 3] set set?] [âœ…] "A set is a set"]
                     [[[1 2 3] set?] [ğŸ”³] "A list is not a set"]]]]]

   [contains? [[spec [[item [item container]] [boolean]]]
               [examples [[[[1 2 3] 3 contains?] [âœ…] "List contains a number"]
                          [[[1 2 3 3 5] set 3 contains?] [âœ…] "A set contains a number"]
                          [[[1 2 3] 4 contains?] [ğŸ”³] "A list doesn't contain a number"]
                          [[5 3 contains?] [ğŸ”³] "A number is atomic and doesn't contain anything"]
                          [[[foo] ğŸ« \o contains?] [ğŸ”³] "A word is atomic and doesn't contain anything"]
                          [["food" "foo" contains?] [âœ…] "A string contains a sub-string"]
                          [[[a b c d] [b c] contains?] [ğŸ”³] "A list doesn't contain a sub-list (due to ambiguity with what 'contains' means with lists)"]
                          [[[a [b c] d] [b c] contains?] [âœ…] "A list contains another list"]
                          [[[a [b c] d] set [b c] contains?] [âœ…] "A set contains a list"]
                          [["food" \o contains?] [âœ…] "A string contains a character"]]]]]

   [intersection [[spec [[sized sized] [sized]]]
                  [examples [[[[1 2 3] [2 3 4] intersection] [[2 3] set] "Intersection of two lists expressed as set"]]]]]

   [difference [[spec [[sized sized] [sized]]]
                [examples [[[[1 2 3] [2 3 4] difference] [[1] set] "Difference of two lists expressed as set"]]]]]]
  ğŸ”—
#+end_src

*** Generators
#+begin_src kcats :tangle src/kcats/stdlib/generators.kcats :mkdirp yes
  ;; infinite sequence (generators) functions

  [[generator [[spec [[program] [program]]]
               [definition [ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª†]]]]

   [liberator [[spec [ğŸ”³ [program]]]
               [definition [[ğŸ“¤] generator]]]]

   [extractor [[spec [program program]]
               [doc "Turns a wrapped generator into a regular one."]
               [definition [[[â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤]
                            []
                            [[]]
                            [ğŸ”€] ğŸª†]]
               [examples []]]]

   [reap [[spec [[[program generator]] [item]]]
          [doc "Generates a value from a wrapped generator (stacked generator inside a list)"]
          [definition [ğŸ”³ ğŸ”€ ğŸ’‰ â–¶ï¸ first]] ;; the now-empty dispenser
          [examples [[[[integers generator 5 taker collect] reap] [[0 1 2 3 4]]]]]]]

   [assemble [[spec [[program dispenser] [list]]]
              [definition [[liberator âœ‚ï¸1ï¸âƒ£] ğŸ’
                           [ğŸ] ğŸª„ ğŸ’‰ â–¶ï¸ first]]
              [examples [[[[1 2 3 4 5]
                           [[odd?] keep
                            collect] assemble]
                          [[1 3 5]]]]]]]

   [produce [[spec [[[list wrapped-generator]] [list item]]]
             [definition [[â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤]]
             [examples [[[integers generator
                          [ğŸ‘¥ *] each
                          10 dropper
                          ğŸ”³ ğŸ§¦ 
                          produce â€¢ğŸ—‘ï¸] [100]]]]]]

   [ğŸ§¹ [[spec [[[item receptacle] program] [program]]]
        
        [doc "The broom denotes a gathering - the returned program will
        repeatedly call the given program to generate items, and put
        them into the receptacle."]

        [definition [[[â–¶ï¸] ğŸ‹] [ğŸ“®] â³]]
        [examples [[[[\a \b \c \d] liberator "" ğŸ§¹ â–¶ï¸]
                    [ğŸ”³ "abcd"] "Sweep into an empty string"]
                   [[0 10 1 range liberator
                     5 dropper
                     [10 *] each
                     ğŸ”³ ğŸ§¹ â–¶ï¸]
                    [ğŸ”³ [50 60 70 80 90]] "Generate a sequence and put it into the given container"]]]]]

   [drain [[spec [[sized program] [program]]]
           [doc "Returns a program that drains the generator below it,
                 and doesn't save anything in memory. Should be used
                 only for generators that have side effects, when you
                 want to drive the side effects forward, without
                 producing any values."]
           [definition [[â–¶ï¸] [ğŸ—‘ï¸] â³]]
           [examples []]]]

   [collect [[spec [[program] [list]]]
             [definition [ğŸ”³ ğŸ§¹ â–¶ï¸]]
             [examples [[[[[1 2 3 4] liberator collect] ğŸ›¡ï¸ â–¶ï¸]
                         [[1 2 3 4]]]
                        [[[0 10 1 range liberator
                           5 dropper
                           [10 *] each
                           collect]
                          ğŸ›¡ï¸ â–¶ï¸]
                         [[50 60 70 80 90]] "Collect from a generator into an empty list"]]]]]

   [each [[spec [[program] [program]]]
          [definition [â€¢ğŸ›¡ï¸ ;; prevent mapping program from overwriting stack
                       [â–¶ï¸ 1ï¸âƒ£ bail] ğŸ’ ;; only execute the mapping program if parent produces value
                       ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª†]] 
          [examples [[[[1 2 3 4] liberator
                       [ğŸ‘¥ *] each
                       collect]

                      [ğŸ”³ [1 4 9 16]] "Generate a sequence transforming each value"]]]]]

   [taker [[spec [[[integer howmany]] [program]]]
           [definition [[positive?] ğŸ›¡ï¸ ;; counter still positive?
                        [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ;; run the parent generator
                         ğŸ”³ [ğŸ”³ ğŸ”³] â†”ï¸] ;; add padding to drop later
                        [ğŸ”³] âš–ï¸ ;; otherwise return nothing
                        [[dec] ğŸª„] ;; decrement counter
                        [ğŸ—‘ï¸ ğŸ”³] ;; discard the counter but keep parent, all done
                        [ğŸ”€] ğŸª†]]
           [examples [[[[1 2 3 4 5] [3 taker collect] assemble]
                       [[1 2 3]] "Taker takes given number of items from the parent"]

                      [[[1 2 3 4 5] [6 taker collect] assemble]
                       [[1 2 3 4 5]] "Taker stops when parent ends before given number of items"]

                      [[[1 2 3 4 5 6] liberator
                        3 taker collect
                        [2 taker collect] ğŸ‹
                        pair restore] ;; just keep the top 2 items
                       [[4 5] [1 2 3]] "Taker leaves parent intact so it can be reused"]]]]]

   [catcher [[spec [ğŸ”³ [program]]]
             [definition [[[â–¶ï¸] ğŸ‹ ;; get value from parent
                           [ğŸ”€ [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸] bail ;; only check pred iff we get a value, preserve pred
                           ğŸ”³
                           [ğŸ”³ ğŸ”³ ğŸ”³] â†”ï¸] ;; place some dummy values to drop if we didn't get a value
                          [ğŸ—‘ï¸ ğŸ”€] ;; iff pred matches drop the pred result 
                          [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] ;; otherwise drop all the stuff we no longer need
                          âš–ï¸ ğŸ”³
                          [[ğŸ”³] ğŸ”³] [ğŸ”€] ğŸª†]]
             [examples [[[[1 2 3 -4 5]
                          [[positive?] catcher collect]
                          assemble]

                         [[1 2 3]]]

                        [[[1 2 3 4 5]
                          [[positive?] catcher collect]
                          assemble]

                         [[1 2 3 4 5]]]]]]]

   [dropper [[spec [ğŸ”³ [program]]]
             [definition [[positive?] ğŸ›¡ï¸ ;; condition
                          [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ;; call parent 
                           ğŸ”³ ;; if we get something, we're done
                           [ğŸ—‘ï¸ ğŸ”³ ğŸ”³] ;; otherwise signal stop with empty generator
                           â†”ï¸]
                          [ğŸ—‘ï¸ â–¶ï¸ ğŸ”³] âš–ï¸ ;; if counter reaches zero we're done dropping 
                          [ğŸ—‘ï¸ dec] â³
                          ğŸ”³ [ğŸ”³] [ğŸ—‘ï¸] ğŸª†]]
             [examples [[[[1 2 3 4 5] [3 dropper collect]
                          assemble]
                         [[4 5]]]
                        [[[1 2 3 4 5] [6 dropper collect]
                          assemble]
                         [ğŸ”³]]]]]]

   [skipper [[spec [ğŸ”³ [program]]]
             [definition [[[â–¶ï¸] ğŸ‹] ;; get the item from parent
                          [ğŸ”€ [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸] ;; run the pred on it, keep the pred
                          [ğŸ—‘ï¸ ğŸ”³ ğŸ”³] âš–ï¸ ;; when parent is empty, leave negative on the stack
                          [ğŸ—‘ï¸ â€¢ğŸ—‘ï¸] â³ ;; keep consuming items while they match pred
                          ğŸ”³ [ğŸ”³] [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸª†]]
             [examples [[[[1 2 -3 4 5]
                          [[positive?] skipper collect]
                          assemble]

                         [[-3 4 5]]]]]]]

   [keep [[spec [[program] [program]]]
          [definition [[â–¶ï¸  ;; exec the generator below to get value v
                        [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
                        [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
                        â†”ï¸] ğŸ’
                       [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
                       â³ ;; repeat until generator below is finished
                       ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª†]]
          [examples [[[[1 2 3 4 5] liberator
                       [odd?] keep
                       collect]

                      [ğŸ”³ [1 3 5]]]]]]]

   [group [[spec [[[program group-by]] [association]]]
           [definition [ğŸ›¡ï¸
                        [1ï¸âƒ£ â–¶ï¸ ;; k v state
                         ğŸ ğŸ”€   ;;  v k state
                         ğŸ [ğŸ“®] ğŸ”— update] ğŸ’
                        ğŸ”³ association ;; state f
                        ğŸ”€ cram]]
           [examples [[[[1 2 3 4] liberator [odd?] group]
                       [ğŸ”³ [[âœ… [1 3]] [ğŸ”³ [2 4]]] association]]]]]]

   [splitter [[spec [[sized] [program sized sized]]]
              [definition [[[ğŸ‘¥ [ğŸ“® 1ï¸âƒ£] ğŸª„  ;; add new value to input buffer
                             [â˜¯ï¸] ;; the input was empty
                             [ends?] ğŸ›¡ï¸ ;; the input buffer ends in the delimiter
                             pair ;; user both these as conditions
                             [â–¶ï¸] ğŸ“£ 
                             [ğŸ—‘ï¸ ;; the bool
                              ğŸ“ ;; the delim 
                              0 ğŸ”€ - 0 ğŸ”€ slice] ;; chop the length of the divider 
                             [ğŸ—‘ï¸ ğŸ”³]
                             âš–ï¸ â–¶ï¸] ğŸª„ ;; under the output
                            ğŸ”€ ;; put possible new output on top
                            [ğŸ‘¥ empty [ğŸ“®] ğŸª„ ğŸ”€] ğŸ”³ â†”ï¸]
                           over empty ;; starting empty container for parse
                           [ğŸ’] ğŸª„]]
              [examples [[["abcabc" ["b" splitter parse collect] assemble]
                          [["a" "ca" "c"]]]
                         [[[1 2 3 4 2 5] [[2] splitter parse collect] assemble]
                          [[[1] [3 4] [5]]]]]]]]

   [joiner [[spec [[[program generator] [program]]]]
            [doc "A catenating generator: takes a generator that
            produces lists, and returns a generator that yields the
            items in the first list, the items in the 2nd etc."]
            [definition [[] ;; initial state
                         [] [ğŸ“¤] [â–¶ï¸ ğŸ“¤] âš–ï¸  
                         [] [] [ğŸ”€] ğŸª†]]
            [examples [[[[[1 2 3] [4 5 6] [7 8 9]] liberator joiner collect]
                        [ğŸ”³ [1 2 3 4 5 6 7 8 9]]]]]]]

   [parse [[spec [[[item input-container] [[program partial-parser]]]
                  [[program parsed-item-generator]]]]

           [doc "A stream parser. On the stack should be: 1) an input
                 buffer that receives chunks of input from upstream
                 (usually an empty string or byte array or list
                 depending on what type of data is being produced), 2)
                 program that takes 3 args: parsed object output buffer
                 (on top), a new input item, and an unparsed input
                 buffer. The function should return new input and
                 output buffers. If there is enough input to create a
                 new output, the program should do so, otherwise it only
                 needs to combine the new input with the existing input
                 buffer. An empty input should signal an end-of-stream
                 condition and it's up to the program how to interpret
                 that. Returns a generator of parsed items."]

           [definition [ğŸ”³ ;; state - parsed object output buffer (on top), unparsed input 
                        ğŸ”³ ;; there's output?
                        [ğŸ”³]  ;; leave an empty value to be consumed by outer â³ exiting
                        [ğŸ”³ [â–¶ï¸] â€¢â€¢ğŸ‹] ;; exec parent generator 
                        âš–ï¸ 
                        [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸] ;; exec a copy of parser program: output input parser
                        â³ 
                        [ğŸ“¤] [[ğŸ”³] ğŸ”€] ;; leave empty generator if we hit end of stream
                        [ğŸ”€] ğŸª†]]
           [examples [[[[[[104 101 108 108 111]              ;; "hello" (all ASCII)
                          [228 189 160 229 165 189]          ;; "ä½ å¥½" (two complete Chinese chars)
                          [104 105 226]                      ;; "hi" + start of "â‚¬"
                          [130 172]                          ;; completion of "â‚¬"
                          [240 159 145]                      ;; start of "ğŸ‘‘"
                          [145]                              ;; completion of "ğŸ‘‘"
                          [97 98 99 240]                     ;; "abc" + start of "ğŸŒˆ"
                          [159 140 136]]                     ;; completion of "ğŸŒˆ"

                         liberator
                         [#b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸] each ;; convert lists of ints to byte arrays
                         [parse-utf8] #b64 ""
                         parse joiner "" ğŸ§¹ â–¶ï¸] reap]
                       ["helloä½ å¥½hiâ‚¬ğŸ‘‘abcğŸŒˆ"]]

                      [[[["[foo] [bar] [ba"
                          "z] [quux"
                          "] [[this] "
                          "[that]]"
                          "[foo" "]"] liberator
                         [parse-edn] "" parse joiner collect]
                        reap]
                       [[[foo] [bar] [baz] [quux] [[this] [that]]
                         [foo]]]]]]]]

   [combinations [[spec [ğŸ”³ [program]]]
                  [definition [[ğŸ“] ğŸ›¡ï¸ -1 ;; l idx i
                               [[[ğŸ”€ ğŸ“ =] ğŸ‹] [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ“¤ 0 ğŸ”€] when
                                [[ğŸ ğŸ”] ğŸ‹ [pair] bail] ğŸ›¡ï¸ [inc] â€¢ğŸª„]]]
                  [examples [[[[1 2 3] [combinations] assemble] [[[1 2] [1 3] [2 3]]]]]]]]

   [frequencies [[spec [ğŸ”³ [association]]]
                 [definition [ğŸ”³ association
                              [ğŸ [ğŸ”³ [inc] [1] âš–ï¸ â–¶ï¸ ] update]
                              cram]]
                 [examples [[["Hello there!" [frequencies] assemble]
                             [[[\space 1]
                               [\! 1]
                               [\H 1]
                               [\e 3]
                               [\h 1]
                               [\l 2]
                               [\o 1]
                               [\r 1]
                               [\t 1]] association]]]]]]

   [fold [[spec [[[program reducing-function] [program generator]] [item]]]
          [definition [[â–¶ï¸] ğŸª„ ;; generate the first item below the reducer
                       cram]]
          [examples [[[[integers generator
                        1 dropper
                        10 taker
                        [+] fold] reap] [55]]]]]]

   [cram [[spec [[[program reducing-function]
                  [item initial-value]
                  [program generator]] [item]]]
          [definition [[[â–¶ï¸] â€¢ğŸ‹] ;; check that we generated another item
                       [ğŸ”€ [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸ âš“ â€¢ğŸ—‘ï¸ â€¢â€¢ğŸ—‘ï¸] ;; if so, run the reducer shielded and drop component items
                       ğŸ”³ ;; otherwise stop
                       [â–¶ï¸] ğŸª†
                       â–¶ï¸ ğŸ—‘ï¸]]
          [examples [[[[integers generator
                        1 dropper
                        10 taker
                        0 [+] cram]
                       reap] [55]]]]]]

   [integers [[spec [ğŸ”³ [program]]]
              [definition [-1 [inc ğŸ‘¥]]]]]

   [partition [[spec [[[number partition-size] [program generator]] [program]]]
               [definition [[flip [ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 1ï¸âƒ£ >=] ğŸ’
                            [ğŸ—‘ï¸ â€¢ğŸ”€ ğŸ“® [ğŸ] ğŸª„]
                            [ğŸ”€ ğŸ“® ğŸ”€]
                            âš–ï¸ ğŸ”³ parse]]
               [examples [[[[1 2 3 4 5 6 7] [2 partition collect] assemble]
                           [[[1 2] [3 4] [5 6] [7]]]]]]]]

   [evaluator [[spec [[environment [program input-generator]] [program]]]
               [definition [[[â–¶ï¸] ğŸ‹]
                            [[program] ğŸ”€ assign evaluate]
                            [ğŸ—‘ï¸ []]
                            [over] ğŸª†]]
               [examples []]]]]
  ğŸ”—
#+end_src

** Dictionary modules
#+begin_src kcats :tangle src/kcats/core/dictionary-builtins.kcats :mkdirp yes
  [[dictionary [[spec [ğŸ”³ [list]]]]]

   [cache [[spec [[item bytes] [bytes]]]]]

   [decache [[spec [[item] [bytes]]]]]

   [hashbytes [[spec [[bytes] [bytes]]]
               [examples [[[["foo" encode hashbytes] 2 times â–¶ï¸ =] [âœ…]]
                          [["foo" encode hashbytes
                            "fop" encode hashbytes
                            =]
                           [ğŸ”³]]]]]]

   [resolve [[spec [[word] [word]]]
             [examples [[[[+] ğŸ« resolve] [[core/+] ğŸ«]]]]]]

   [namespace [[spec [[bytes word] [word]]]
               [examples [[[[foo] ğŸ« #b64 "quux" namespace] [[quux/foo] ğŸ«]]]]]]

   [unnamespace [[spec [[word] [bytes word]]]
                 [examples [[[[quux/foo] ğŸ« unnamespace] [[foo #b64 "quux"] ğŸ«]]]]]]

   [dictmerge [[spec [[[dictionary module] [dictionary original] [bytes hash]] [dictionary]]]]]

   [lingo [[spec [[dictionary] [association]]]]]]
  ğŸ”— 
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/dictionary.kcats :mkdirp yes
  [updates [[spec [[[sized word-updates]] [[program single-update]]]]
            [definition [[[ğŸ“¤]
                          [[0] [ğŸ] update ;; wrap the word name to get a path to update
                           [update] ğŸ”—] each
                          joiner generate] â€¢ğŸ›¡ï¸]]]]

  [entry [[spec [[[program definition]] [[association full-entry]]]]
          [definition [[definition] label]]]]

  [words [[spec [ğŸ”³ [association]]]
          [definition [dictionary [words] ğŸ”]]]]

  [lingo [[spec [ğŸ”³ [association]]]
          [definition [dictionary [lingo] ğŸ”]]]]

  [module [[spec [[[item wrapped-module-alias-or-hash]] [program]]]
           [doc "reads a cached module from disk and puts it on the stack as a program"]
           [definition [decache string read]]
           [examples [
            ;;[["123" encode [crypto] module [hash] confine]
            ;; [#b64 "_1vRbfFezlcTCUfQCjC1FKukWLoOAeBuvxNXUDbFKSk"]]
            ]]]]

  [inscribe [[spec [[[bytes raw-module] dictionary] [dictionary]]]
             [definition [[[hashbytes] ;; calculate module hash
                           [string read [words] ğŸ”€ update]] ;; install the module in the dictionary
                          [â–¶ï¸] ğŸšœ â–¶ï¸ ;; fork 
                          â€¢ğŸ—‘ï¸ ğŸ« â€¢ğŸ”€ â€¢â€¢ğŸ‘¥ ;; keep the hash in case caller wants to 'use'
                          dictmerge]]]]

  [draft [[spec [[[sized definitions]] [[program dictionary-updater]]]]
          [definition [[[1] [entry] update] ğŸšœ â–¶ï¸ ;; create full entries for each definition
                      [1ï¸âƒ£ ğŸ”—] ğŸ’]]]]  ;; add 'join' to join the entries with the existing dictionary

  [let [[spec [[program [sized entries]] [*]]]
        [definition [[draft ;; build full entries
                      dictionary ğŸ”€ 
                      [emit encode hashbytes] ğŸ›¡ï¸ â–¶ï¸ ;; get the hash of the entries
                      [[[words] ğŸ”€ update] ğŸ›¡ï¸ â–¶ï¸ â€¢ğŸ—‘ï¸] ğŸª„ ;; update the dictionary
                      âš“ [dictmerge] â€¢â€¢ğŸ›¡ï¸ â–¶ï¸] ğŸª„ ;; merge it 
                     ğŸ›Ÿ ğŸ [ğŸ“®] ğŸ”—
                     â€¢ğŸ”€ [modules] ğŸ”€ update
                     [dictionary program] label environment
                     ;; TODO try using confine here
                     [1ï¸âƒ£ capture evaluate [stack] ğŸ” restore] ğŸ’]] 
        [examples [[[[[times5 [5 *]]
                      [doubledec [dec dec]]]
                     [3 times5 doubledec] let â–¶ï¸] [13]]
                   [[[[ğŸ”€ [5]]]
                     ["a" "b" "c" ğŸ”€]
                     let â–¶ï¸]
                    ["a" "b" "c" 5]]
                   [[[[foo ["outer"]]]
                     ["inner"] let
                     [foo] label
                     [foo] let â–¶ï¸] ["inner"]]]]]]

  [definition [[spec [[list] [program]]]
               [definition [[âœ‚ï¸1ï¸âƒ£ definition] ğŸ’ dictionary lingo ğŸ”€ ğŸ”]]
               [examples [[[1 2 3 [ğŸ”€] definition â–¶ï¸] [1 3 2] "Fetch the definition of a builtin word and use it"]
                          [[1 2 3 [flip] definition â–¶ï¸] [3 2 1] "Fetch the definition of a word and use it"]]]]]
#+end_src
** Math
#+begin_src kcats :tangle src/kcats/core/math-builtins.kcats :mkdirp yes
  [[* [[spec [[number number] [number]]]
       [examples [[[4 3 *] [12]]
                  [[10 1.5 * 15 0.0001 within?] [âœ…]]
                  [[5 0 *] [0]]
                  [[5 -1 *] [-5]]]]]]

   [+ [[spec [[number number] [number]]]
       [examples [[[1 2 +] [3]]
                  [[1.1 2.2 + 3.3 0.001 within?] [âœ…]]
                  [[1 2.2 +] [3.2]]]]]]

   [- [[spec [[number number] [number]]]
       [examples [[[2 1 -] [1]]
                  [[1.1 2.2 - -1.1 0.00001 within?] [âœ…]]
                  [[2.2 1 - 1.2 0.00001 within?] [âœ…]]]]]]

   [/ [[spec [[number number] [number]]]
       [examples [[[12 3 /] [4]]
                  [[15 1.5 /] [10.0]]
                  [[0 1 /] [0]]
                  [[1 0 / handle [reason] ğŸ”] [1 0 "division by zero"]]]]]]

   [abs [[spec [[number] [integer]]]
         [examples [[[2.1 abs] [2.1]]
                    [[-0.2 abs] [0.2]]
                    [[-2 abs] [2]]
                    [[0 abs] [0]]]]]]

   [ceiling [[spec [[number] [number]]]
             [examples [[[2.1 ceiling] [3]]]]]]

   [dec [[spec [[number] [number]]]
         [examples [[[2 dec] [1]]
                    [[0 dec] [-1]]
                    [[100 dec] [99]]]]]]

   [even? [[spec [[number] [boolean]]]
           [examples [[[2 even?] [âœ…]]
                      [[-2 even?] [âœ…]]
                      [[3 even?] [ğŸ”³]]]]]]

   [exp [[spec [[number number] [number]]]
         [examples [[[2 5 exp] [32]]
                    [[2 2.5 exp 5.656854 0.00001 within?] [âœ…]]]]]]

   [floor [[spec [[number] [number]]]
           [examples [[[2.1 floor] [2]]]]]]

   [inc [[spec [[number] [number]]]
         [examples [[[1 inc] [2]]
                    [[-1 inc] [0]]]]]]

   [integer? [[spec [[item] [boolean]]]
              [examples [[[[1] integer?] [ğŸ”³]]
                         [[ğŸ”³ integer?] [ğŸ”³]]
                         [[5 integer?] [âœ…]]
                         [[-5 integer?] [âœ…]]
                         [[0 integer?] [âœ…]]
                         [[5.01 integer?] [ğŸ”³]]
                         [[5.00 integer?] [ğŸ”³]]]]]]
   [number [[spec [[item] [number]]]
            [examples [[["12" number] [12]]
                       [["-11.1" number] [-11.1]]
                       [["a" first number] [97]]]]]]

   [log [[spec [[number number] [number]]]
         [examples [[[32 2 log] [5]]]]]]

   [mod [[spec [[number number] [number]]]
         [examples [[[17 5 mod] [2]]]]]]

   [number? [[spec [[item] [boolean]]]
             [examples [[[[1] number?] [ğŸ”³]]
                        [[ğŸ”³ number?] [ğŸ”³]]
                        [[5 number?] [âœ…]]
                        [[5.01 number?] [âœ…]]]]]]

   [odd? [[spec [[number] [boolean]]]
          [examples [[[1 odd?] [âœ…]]
                     [[-1 odd?] [âœ…]]
                     [[4 odd?] [ğŸ”³]]]]]]

   [quot [[spec [[number number] [number]]]
          [examples [[[16 5 quot] [3]]]]]]

   ;; TODO implement in rust
   ;[rem [[spec [[number number] [number]]]
   ;      [examples [[[17 5 rem] [2]]]]]]

   [round [[spec [[number] [number]]]
           [examples [[[2.1 round] [2]]]]]]

   [sqrt [[spec [[number] [number]]]
          [examples [[[9 sqrt] [3]]
                     [[81 sqrt] [9]]
                     [[10.0 sqrt 3.16227 0.00001 within?] [âœ…]]]]]]
   
   [zero? [[spec [[number] [boolean]]]
           [examples [[[0 zero?] [âœ…]]
                      [[0.0 zero?] [âœ…]]
                      [[-0.00001 zero?] [ğŸ”³]]
                      [[1.1 zero?] [ğŸ”³]]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/math.kcats :mkdirp yes
  [positive? [[spec [[number] [boolean]]]
              [definition [0 >]]]]

  [negative? [[spec [[number] [boolean]]]
              [definition [0 <]]]]

  [within? [[spec [[number number] [boolean]]]
            [definition [[- abs] ğŸª„ <]]
            [examples [[[1.0 2.0 + 3 0.001 within?] [âœ…]]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/fib.kcats :mkdirp yes
  [[fibonacci [[definition [1 0 ;; starting state
                            [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ;; add and preserve the first addend
                             ğŸ”€ ğŸ‘¥]]]]]] ;; make the result the new state item
  ğŸ”— 
#+end_src



** Serialization
#+begin_src kcats :tangle src/kcats/core/serialize-builtins.kcats :mkdirp yes
  [[autoformat [[spec [[string] [string]]]
                [examples [[["[[foo bar] [baz [[quux floop] [toop zoop]]]]" autoformat]
                            ["[[foo bar]\n [baz [[quux floop]\n       [toop zoop]]]]"]]]]]]

   [emit [[spec [[item] [string]]]
          [examples [[[[1 [2] 3] emit] ["1 [2] 3"]]]]]]

   [parse-edn [[spec [[[list current-output-sequence] [string input] [string input-buffer]]
                      [[list updated-output-sequence] [string remaining-input]]]]
               [examples [[["" "[foo] [ba" ğŸ”³ parse-edn] [" [ba" [[foo]]]]]]]]

   [read [[spec [[string] [item]]]
          [examples [[["[1 [2] 3]" read] [[[1 [2] 3]]]]]]]]]
  ğŸ”—
#+end_src
** Boolean logic
#+begin_src kcats :tangle src/kcats/core/boolean-builtins.kcats :mkdirp yes
  [[âœ… [[spec [ğŸ”³ [word]]]]] ;; self-inserts

   [and [[spec [[item item] [item]]]
         [examples [[[1 odd? 2 even? and] [âœ…]]
                    [[2 3 and] [3]]
                    [[ğŸ”³ 3 and] [ğŸ”³]]
                    [["" 3 and] [ğŸ”³]]]]]]

   [or [[spec [[item item] [item]]]
        [examples [[[1 odd? 3 even? or] [âœ…]]
                   [[1 2 or] [1]]
                   [[ğŸ”³ 2 or] [2]]
                   [[ğŸ”³ ğŸ”³ or] [ğŸ”³]]]]]]

   [â˜¯ï¸ [[spec [[item] [boolean]]]
       [examples [[[1 even? â˜¯ï¸] [âœ…]]
                  [[ğŸ”³ â˜¯ï¸] [âœ…]]
                  [[âœ… â˜¯ï¸] [ğŸ”³]]
                  [[ğŸ”³ â˜¯ï¸] [âœ…]]]]]]]
  ğŸ”—
#+end_src
** Byte encoding and decoding
#+begin_src kcats :tangle src/kcats/core/encode-builtins.kcats :mkdirp yes
  [[character [[spec [[item] [character]]]
               [examples [[[97 character] [\a]]
                          [[128526 character] [\ğŸ˜]]]]]]

   [encodeitem [[spec [[item] [bytes]]]
                [examples [[["foo" encodeitem] [#b64 "Zm9v"]]
                           [["" encodeitem] [#b64 ""]]
                           [[12 encodeitem] [#b64 "AAAAAAAAAAw"]]
                           [[12.3 encodeitem] [#b64 "QCiZmZmZmZo"]]]]]]

   [decodejson [[spec [[string] [item]]]
                [examples [[["12" decodejson] [12]]
                           [["12.01" decodejson] [12.01]]
                           [["\"foo\"" decodejson] ["foo"]]
                           [["{\"foo\": 12, \"bar\": \"baz\"}" decodejson] [[["foo" 12] ["bar" "baz"]] association]]
                           [["[1,\"foo\"]" decodejson] [[1 "foo"]]]]]]]

   [encodejson [[spec [[item] [string]]]
                [examples [[[12 encodejson] ["12"]]
                           [[12.01 encodejson] ["12.01"]]
                           [["foo" encodejson] ["\"foo\""]]
                           [[[["foo" 12] ["bar" "baz"]] association encodejson decodejson] [[["foo" 12] ["bar" "baz"]] association]]
                           [[[1 "foo"] encodejson] ["[1,\"foo\"]"]]]]]]

   [bytes? [[spec [[item] [boolean]]]
            [examples [[["foo" bytes?] [ğŸ”³]]
                       [[#b64 "Zm9v" bytes?] [âœ…]]
                       [[[#b64 "Zm9v"] bytes?] [ğŸ”³]]
                       [["foo" encode bytes?] [âœ…]]]]]]

   [xor [[spec [[item] [item]]]
         [examples [[[10 12 xor] [6]] ;; 10 = 01010, 12 = 01100, 00110, 6
                    [["foo" encode "bar" encode xor] [#b64 "BA4d"]]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/encode.kcats :mkdirp yes
  [[decodeb64string [[spec [[string] [bytes]]]
                     [definition [ğŸ "#b64 \"{}\"" format read first]]
                     [examples []]]]

   [encode [[spec [[item] [bytes]]]
            [definition [[[[âœ…] [ğŸ—‘ï¸ encodeitem]]]
                         decide]]
            [examples [[[12 encode] [#b64 "AAAAAAAAAAw"]]
                       [["foo" encode] [#b64 "Zm9v"]]
                       [["foo" encode encode] [#b64 "Zm9v"]]
                       [["" encode] [#b64 ""]]]]]]

   [radix [[spec [[integer integer] [list]]]
           [definition [[ğŸ—‘ï¸ 1ï¸âƒ£ [/] ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ 
                         [*] â€¢ğŸ›¡ï¸ â–¶ï¸
                         â€¢ğŸ”€ -
                         ğŸ”€ [prepend] ğŸª„] ğŸ’
                        [ğŸ”³ ğŸ”€ [positive?] ğŸ›¡ï¸] ğŸª„
                        â³ â–¶ï¸ ğŸ—‘ï¸]]
           [examples [[[7 2 radix] [[1 1 1]]]
                      [[9 3 radix] [[1 0 0]]]
                      [[255 16 radix] [[15 15]]]]]]]

   [bits [[spec [[item] [sized]]]
          [definition [encode [[2 radix -8 0 pad] each [ğŸ”—] fold] assemble]]
          [examples [[["foo" bits] [[0 1 1 0 0 1 1 0 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 1]]]]]]]]
  ğŸ”—
#+end_src
** Strings
#+begin_src kcats :tangle src/kcats/core/strings-builtins.kcats :mkdirp yes
  [[format [[spec [[string list] [string]]]
            [examples [[[["abc" "def"] "foo {} bar {} baz" format] ["foo abc bar def baz"]]]]]]

   [inspect [[spec [[item] [string]]]]]

   [parse-utf8 [[spec [[[sized current-output] [bytes input] [bytes input-buffer]]
                       [[string updated-output-sequence] [bytes remaining-input]]]]
                [doc "Parses bytes into strings - returns list of strings"]
                [examples [[["hi" encode [226] encode "" parse-utf8] [#b64 "4g" ["hi"]]]
                           [["hell" encode \o encode "" parse-utf8] [#b64 "" ["hello"]]]]]]]

   [string [[spec [[item] [string]]]
            [examples [[[1 string] ["1"]]
                       [[[97 98 99] string] ["abc"]]
                       [[ğŸ”³ string] [""]]]]]]

   [string? [[spec [[item] [boolean]]]
             [examples [[["hi" string?] [âœ…]]
                        [["" string?] [âœ…]]
                        [[["hi"] string?] [ğŸ”³]]
                        [[âœ… string?] [ğŸ”³]]]]]]

   [word [[spec [[item] [word]]]
          [examples [[["foo" word] [[foo] ğŸ«]]]]]]

   ;; Don't really belong here but good enough for now
   [word? [[spec [[item] [boolean]]]
           [examples [[[[foo] ğŸ« word?] [âœ…]]
                      [[âœ… word?] [âœ…]]
                      [[1 word?] [ğŸ”³]]
                      [["âœ…" word?] [ğŸ”³]]]]]]]
  ğŸ”—
#+end_src
** Error handling
#+begin_src kcats :tangle src/kcats/core/errors-builtins.kcats :mkdirp yes
  [[error? [[spec [[item] [boolean]]]]]

   ;; handle is a special word only used to unwind the program on
   ;; error, if there's no error and we end up reaching this word, we
   ;; ignore it.
   [handle [[spec [ğŸ”³ ğŸ”³]]
            [definition ğŸ”³]]]

   [fail [[spec [[sized] [*]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/errors.kcats :mkdirp yes
  [[assert [[spec [[program]
                   [*]]]
            [definition [ğŸ“¸ ;; save stack to print in err message
                         [ğŸ›¡ï¸] ğŸ‹ ;; run the assertion under the saved stack
                         [ğŸ—‘ï¸] ;; if passes, drop the saved stack, dont need
                         [string ["assertion failed "] ğŸª„ ğŸ”— fail]]]]] ;; else throw err

   [ğŸ©¹ [[spec [[[program error-handler] [program to-attempt]] [program]]]
        [doc "The bandage denotes a recovery, it takes an error-handler
              program, and a program to attempt that may cause an
              error. If the to-attempt program succeeds, the
              error-handler is dropped. Iff the to-attempt program fails
              with an error, the error-handler is invoked on a snapshot
              of the stack when the to-attempt program began."]
        [definition [[ğŸ“¸ [âœ‚ï¸2ï¸âƒ£ handle] ğŸ’‰ â–¶ï¸
                      [first error?] ğŸ›¡ï¸
                      [ğŸ—‘ï¸ first âœ‚ï¸1ï¸âƒ£]
                      [ğŸ§¦ ğŸ—‘ï¸]
                      âš–ï¸ â–¶ï¸] ğŸ’]]
        [examples [[[[+]
                     [ğŸ—‘ï¸ 1
                      [+] [ğŸ—‘ï¸ 2 +]
                      ğŸ©¹ â–¶ï¸]
                     ğŸ©¹ â–¶ï¸]
                    [3] "Simple recovery"]

                   [[[1 2 "oh fudge"]
                     [5 +]
                     [ğŸ—‘ï¸ 5]
                     ğŸ©¹ ğŸšœ â–¶ï¸]
                    [[6 7 5]] "Recover as part of mapping function"]]]]]

   [retry [[spec [[error] [*]]]
           [definition [[unwound] ğŸ” â–¶ï¸]]
           [examples [[[2 3 "four" * + handle [ğŸ—‘ï¸ 4] ğŸª„ retry] [14]]]]]]]
  ğŸ”—
#+end_src
** Methods
We want a way of adding methods to a word that's already set up as a
simple 'decide' form. This will add the method at the beginning -
adding it at the end is not good because often there's a catchall
condition at the end, and adding beyond that means the new condition
is unreachable. Adding at the beginning is not always what the user
wants either, though. So maybe this could be improved by taking
another argument: a program to combine the item and the existing list
(that defaults to =prepend= here).
#+begin_src kcats :tangle src/kcats/stdlib/methods.kcats :mkdirp yes
  [[addmethod [[spec [[[program method] [program condition] [program definition]]
                      [[program newdefinition]]]]
               [definition [[[2ï¸âƒ£ 1ï¸âƒ£] prepend] ğŸ’
                            [0] ğŸ”€ update]]
               [examples [[[[[[[ğŸ“ 3 >] ["foo" ğŸ“®]]
                              [[â˜¯ï¸] ["bar" ğŸ“®]]] decide]
                            [ğŸ“ 1 =] [rest] addmethod]

                           [[[[[ğŸ“ 1 =] [rest]]
                              [[ğŸ“ 3 >] ["foo" ğŸ“®]]
                              [[â˜¯ï¸] ["bar" ğŸ“®]]]
                             decide]]]]]]]

   [method? [[spec [[program] [boolean]]]
             [definition [[[first [[pair?]
                                   [[list?] every?]] every?]
                           [second [decide] unwrap =]]
                          every?]]]]]
  ğŸ”—
#+end_src
** Database
#+begin_src kcats :tangle src/kcats/stdlib/database.kcats :mkdirp yes
  [[[list selection] [list constraints]]
   [string]]

  [[fork [[â–¶ï¸] ğŸšœ]]
   [triangle [[ğŸ”³ [[ğŸ“¤] ğŸª„ ğŸ”€ [[ğŸ“®] ğŸ›¡ï¸ âš“ ğŸ”€ pair] bail] collect] â€¢ğŸ›¡ï¸]]
   [indexed-as-property [ğŸ”€ indexed
                         [ğŸ« âš“ assign] ğŸšœ â€¢ğŸ—‘ï¸]]
   [join-all [[first empty] ğŸ›¡ï¸ ğŸ”€ [ğŸ”—] ğŸªœ]]
   [selectkeys [set [1ï¸âƒ£ [first] ğŸ‹ contains?] ğŸ’ ğŸ§²]]
   [invert [[reverse] ğŸšœ association]]

   ;; datalog variables
   [variable? [[[word?]
                [string last \? =]] [â–¶ï¸] ğŸ’¯]]
   [variable= [[[pair [variable?] ğŸ’¯] [=]] [â–¶ï¸] ğŸ’¯]] 

   ;; datalog constraints
   [slots [[entity attribute value]]]
   [slot-combos [slots [slots [pair] ğŸšœ] ğŸšœ join-all]]
   [constraint [ğŸ« slots reverse label]] 

   ;; links between datalog constraints
   [links [slot-combos
           [[ğŸ] ğŸšœ ğŸ« â€¢ğŸ”€ 
            [[[ğŸ”] ğŸ’‰] both] pairwise 
            variable=]
           ğŸ§²    
           [ğŸ« pair âš“ pair
            [[index] ğŸ”] ğŸšœ ğŸ”€ zip]
           ğŸšœ]]
   [all-links [ğŸ”³ âš“
               [[[[index] ğŸ”] ğŸ›¡ï¸] both ;; lookup the indices of both constraints
                [â€¢ğŸ”€] ğŸª„ âš“ ;; move the indices under the constraints
                [links] â€¢ğŸ›¡ï¸
                ğŸ”€ [â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸ ğŸ”—] ğŸª„] 

               ğŸªœ ğŸ—‘ï¸]]
   [format-link [[ğŸ”—] ğŸ’‰ ğŸ« [string] ğŸšœ
                 "c{0}.{1} = c{2}.{3}" format]] 

   ;; formatting pieces of query data into text
   [anded-together [" AND " interpose join-all]]

   ;; where clause data processing
   [where-data [[[index] ğŸ”] ğŸ›¡ï¸ ğŸ”€ 
                [[[second variable? â˜¯ï¸]
                  [first [index] ğŸ« = â˜¯ï¸]] [â–¶ï¸] ğŸ’¯] ğŸ§² 
                [ğŸ”€ prepend] ğŸšœ â€¢ğŸ—‘ï¸]]
   [format-where [[string] ğŸšœ 
                  "c{0}.{1} = :c{0}{1}" format]]
   [make-where [first [where] ğŸ” anded-together]]
   [format-join [[[[on] ğŸ”]
                  [[where] ğŸ”]
                  [[index] ğŸ” string]] [â–¶ï¸] ğŸšœ
                 [ğŸ”— anded-together] ğŸ’‰ 
                 "JOIN EAV c{1} ON {0}" format]]
   [make-query [rest [[on]
                      [[format-link] ğŸšœ] update
                      [format-join] ğŸ›¡ï¸ [ğŸ”—] ğŸ”€ assign] ğŸšœ]]

   ;; SQL parameters for rusqlite
   [param-name [[string] ğŸšœ ":c{0}{1}" format]]
   [extract-params [ğŸ”³ association ğŸ”€ [[params] ğŸ” ğŸ”—] ğŸªœ]]


   ;; SELECT clause
   [wordval? [second word?]]
   [invert [[reverse] ğŸšœ association]]
   [validate [[[second â˜¯ï¸]
               [first "All selected query variables must appear somewhere in constraints"
                [reason variable] label fail]
               when] ğŸšœ]]
   [select-data [ğŸ”€
                 [[slots selectkeys invert] ğŸ›¡ï¸
                  [wordval?] ğŸ§² ğŸ”— association] ğŸšœ
                 ğŸ”€
                 [[[[index 1ï¸âƒ£] selectkeys] ğŸ’ ;; make the program to cut down 
                   ğŸšœ 
                   [ğŸ“ 2 =] ğŸ§² first [second] ğŸšœ
                   [first number?] [reverse] when] ;; items are in random order due to coming from association, fix the order
                  ğŸšœ]
                 ğŸ›¡ï¸ â€¢â€¢ğŸ—‘ï¸ zip
                 validate]]

   ;; query 
   [extract-data [[[[ğŸ« all-links]
                    [first where-data   ; [ğŸ”—] ğŸ’‰ ğŸ«
                     ;; build the query param ğŸšœ
                     [[ğŸ”³ ğŸ”€
                       [[param-name] ğŸ›¡ï¸ [last] ğŸª„ ğŸ ğŸ”€ assign]
                       ğŸªœ]
                      ;; build the actual query where clauses
                      [[format-where] ğŸšœ]]
                     fork]]
                   fork] ğŸ›¡ï¸
                  ;; combine extracted items

                  [first] ğŸª„ ;; keep the original constraint to add properties to
                  ğŸ« ğŸ« [where params on] label ğŸ”—]]
   [format-select [[ğŸ« ğŸ”€
                    string butlast ;; remove the ? from the variable name for result column
                    ğŸ“®
                    [string] ğŸšœ %
                    "c{1}.{0} as {2}" format] ğŸšœ ", " interpose join-all]]]

  ;; This is the program we need to modify that is `query`

  [ğŸ”€
   ;; expand all combinations of constraints
   [constraint] ğŸšœ
   ;;ğŸ”³ prepend ;; an empty constraint to represent the orignal EAV table we're joining with
   [index] indexed-as-property
   triangle
   ;; for each pair of constraints, build the "ON" clause data for the JOIN
   [extract-data] ğŸšœ
   [[extract-params]
    [make-query]
    [make-where]
    [ğŸ”€ select-data]] fork 
   â€¢ğŸ—‘ï¸ ;; don't need original anymore
   ğŸ« ğŸ›Ÿ
   [[ğŸ”—] ğŸ”] ğŸšœ  
   format-select 
   [" " interpose join-all] ğŸª„ triplet reverse
   "SELECT {0} from EAV as c0 {1} WHERE {2}" format
   ğŸ”€ â€¢â€¢ğŸ—‘ï¸]

  let
  [definition spec] label
  [query] ğŸ”€ assign
#+end_src
** Pipes
#+begin_src kcats :tangle src/kcats/core/pipes-builtins.kcats :mkdirp yes
  [[pipe? [[spec [[item] [boolean]]]
           [examples [[[timestamps pipe?] [âœ…]]
                      [[standard pipe?] [âœ…]]
                      [[[1 2 3] pipe?] [ğŸ”³]]
                      [[5 pipe?] [ğŸ”³]]]]]]

   [animate [[spec [[environment] ğŸ”³]]]]

   [attend [[spec [[list] [list]]]]]

   [file-in [[spec [[string] [pipe]]]]]

   [file-out [[spec [[string] [pipe]]]]]

   [handoff [[spec [ğŸ”³ [pipe]]]]]

   [receiver [[spec [[pipe] [pipe]]]]]

   [select [[spec [[[list pipes]] [item pipe [list pipes]]]]]]

   [sender [[spec [[pipe] [pipe]]]]]

   [serversocket [[spec [[integer string] [pipe]]]]]

   [socket [[spec [[integer string] [pipe]]]]]

   [standard [[spec [ğŸ”³ [pipe]]]]]

   [timer [[spec [[integer] [pipe]]]]]

   [timestamps [[spec [ğŸ”³ [pipe]]]]]

   [database [[spec [[[sized params] string] ğŸ”³]]]]

   [persist [[spec [[sized] ğŸ”³]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/pipes.kcats :mkdirp yes
  [[pipe-in [[spec [[item] [pipe]]]
             [definition [association
                          [[[type [file] ğŸ« =]
                            [ğŸ—‘ï¸ value file-in]]
                           [[type [stdout] ğŸ« =]
                            [ğŸ—‘ï¸ stdout]]]
                          decide]]]]

   [tunnel [[spec [[item] [pipe]]]
            [definition [association
                         [[[type [ip-host] ğŸ« =]
                           [ğŸ—‘ï¸ ğŸ‘¥
                            [port] ğŸ”
                            [[address] ğŸ”] ğŸª„
                            serversocket]]
                          [[type [ip-client] ğŸ« =]
                           [ğŸ—‘ï¸ ğŸ‘¥
                            [port] ğŸ”
                            [[address] ğŸ”] ğŸª„
                            socket]]]
                         decide]]]]

   [pipe-out [[spec [[item] [pipe]]]
              [definition [association
                           [[[type [file] ğŸ« =] 
                             [ğŸ—‘ï¸ value file-out]]
                            [[type [ip-host] ğŸ« =]
                             [ğŸ—‘ï¸ ğŸ‘¥
                              [port] ğŸ”
                              [[address] ğŸ”] ğŸª„
                              serversocket]]]
                           decide]]]]

   [spit [[spec [[item [item target]] ğŸ”³]]
          [definition [[pipe-in] ğŸª„ encode ğŸ“® ğŸ—‘ï¸]]]]

   [slurp [[spec [[pipe] [item]]]
           [definition [liberator [ğŸ”—] fold string â€¢ğŸ—‘ï¸]]]]

   [print [[spec [[string] ğŸ”³]]
           [definition [[standard] ğŸª„ "\n" ğŸ”— encodeitem ğŸ“® ğŸ—‘ï¸]]]]

   ;;[slurp [[spec [[[item target]] [item pipe]]]]]

   [sleep [[spec [[integer] ğŸ”³]]
           [definition [timer ğŸ“¤ ğŸ—‘ï¸ ğŸ—‘ï¸]]]]

   [future [[spec [[program] [pipe]]]
            [definition [handoff ğŸ”€
                         [[âœ‚ï¸1ï¸âƒ£ ğŸ“¸] ;; return entire stack
                          ğŸ‹ ğŸ“® ğŸ—‘ï¸] ğŸ’
                         dictionary ğŸ”€ spawn animate]]
            [examples [[[1 [2 +] future ğŸ“¤ â€¢ğŸ—‘ï¸] [1 [3]]]]]]]

   [close [[spec [[pipe] ğŸ”³]]
           [definition [ğŸ—‘ï¸]]]]]
  ğŸ”—
#+end_src

** Crypto
#+begin_src kcats :tangle src/kcats/core/crypto-builtins.kcats :mkdirp yes
  [[random [[spec [[integer] [bytes]]]]]

   [key [[spec [[bytes] [bytes]]]
         [examples [[[["foo" encode key] 2 times =] [âœ…]]]]]]

   [sign [[spec [[[bytes message] [association key]] [bytes]]]]]

   [verify [[spec [[[bytes signature]
                    [bytes message]
                    [sized key]]

                   [boolean]]]
            [examples [[["foo" encode key "we attack at dawn" encode [sign] ğŸ›¡ï¸ verify]
                        [âœ…]]
                       [[words [first] ğŸšœ â–¶ï¸] [[]]]]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/crypto.kcats :mkdirp yes
  [[delegated [[spec [[[association pubkey]] [program]]]
               [definition [[[âš“ ;; css cs pk
                              [[hash] [ğŸ›¡ï¸ ğŸª„] decorated ;; css csh cs pk
                               ğŸ›Ÿ ;; cs css csh pk
                               [verify] ğŸª„
                               [ğŸ”³]  ;; the program to run if the child script isn't authorized
                               â†”ï¸] ;; runs the child script if the sig on its hash is verified
                              [ğŸ—‘ï¸ ğŸ—‘ï¸ ;; the sig and (empty) child script -> pk sig msg
                               âš“ ;; sig msg pk
                               verify]
                              [ğŸ‘¥] â€¢ğŸª„ â†”ï¸]
                             [ğŸ”³] ğŸ©¹]
                            ğŸ”€ prepend]]]] ;; prepend the pubkey

   [hash [[spec [[item] [bytes]]]
          [definition [[[[bytes?] [ğŸ—‘ï¸ hashbytes]]
                        [[âœ…] [ğŸ—‘ï¸ encode hash]]]
                       decide]]]]]
  ğŸ”—
#+end_src

** Time and date
#+begin_src kcats :tangle src/kcats/stdlib/time.kcats :mkdirp yes
  [[milliseconds [[spec [[integer] [integer]]]
                  [definition ğŸ”³]]]

   [seconds [[spec [[integer] [integer]]]
             [definition [1000 *]]]]

   [minutes [[spec [[integer] [integer]]]
             [definition [seconds 60 *]]]]

   [hours [[spec [[integer] [integer]]]
           [definition [minutes 60 *]]]]

   [days [[spec [[integer] [integer]]]
          [definition [hours 24 *]]]]]
  ğŸ”—
#+end_src
** Nested Environments
#+begin_src kcats :tangle src/kcats/core/environment-builtins.kcats :mkdirp yes 
  [[depend [[spec [[[list hash-bool-pairs] program] [*]]]
            [definition [dictionary âš“
                         [using] ğŸª„
                         confine]]]]

   [environment [[spec [[sized] [environment]]]
                 [examples [[[[[program [1 2 3]]] environment eval-step [stack] ğŸ”] [[1]]]]]]]

   [environment? [[spec [[item] [boolean]]]
                  [examples [[[[[program [1 inc]]] environment environment?] [âœ…]]
                             [[[[program [1 inc]]] environment?] [ğŸ”³]]]]]]

   [eval-step [[spec [[environment] [environment]]]
               [examples [[[[[program [1 inc]]] environment
                            eval-step eval-step
                            [stack] ğŸ”]
                           [[2]]]]]]]

   [evaluate [[spec [[item] [environment]]]
              [examples [[[[[program [1 2 3 4 + *]]] environment
                           evaluate
                           [stack] ğŸ”]
                          [[14 1]]]]]]]

   [finished? [[spec [[environment] [boolean]]]
               [examples [[[[[program [1 2 3 4 + *]]] environment
                            finished?]
                           [ğŸ”³]]
                          [[[[program [1 2 3 4 + *]]] environment
                            evaluate
                            finished?]
                           [âœ…]]]]]]]
  ğŸ”— 
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/environment.kcats :mkdirp yes
  [capture [[spec [[environment] [environment]]]
            [doc "Capture the outer stack and assign it to the inner env's stack"]
            [definition [[stack]
                         [ğŸ“¸] â€¢ğŸ‹
                         assign]]]]

  [confine [[spec [[[program module] dictionary] [*]]]
            [definition [spawn evaluate [stack] ğŸ” restore]]]]

  [fork [[spec [[program] [environment]]]
          [definition [[ğŸ“¸] ğŸª„ dictionary ;; d s p
                       [dictionary program stack] label
                       environment]]
          [examples [[[1 2 3 [ğŸ”€ ğŸ‘¥] fork]
                      [1 2 3 [[program [ğŸ”€ ğŸ‘¥]] [stack [3 2 1]]] environment]]]]]]

  [spawn [[spec [[program dictionary] [environment]]]
          [definition [[ğŸ“¸] â€¢ğŸª„ ;; p d s
                       [program dictionary stack] label
                       environment]]
          [examples [[[1 2 3 dictionary [ğŸ”€ ğŸ‘¥] spawn]
                      [1 2 3 [[program [ğŸ”€ ğŸ‘¥]] [stack [3 2 1]]] environment]]]]]]

  [stage [[spec [[program] [environment]]]
          [definition [[program] label environment]]]]

  [top [[spec [[sized] [item]]]
        [definition [[program] ğŸ” first]]
        [examples [[[[[stack [1 2 3]]
                      [program [[+] ğŸªœ]]]
                     top]
                    [[+]]]]]]]

  [tos [[spec [[sized] [item]]]
        [definition [[stack] ğŸ” first]]
        [examples [[[[[stack [1 2 3]]
                      [program [[+] ğŸªœ]]]
                     tos]
                    [1]]]]]]

  [localize [[spec [[[program [list modules]] [*]]]]
             [definition [[[1ï¸âƒ£ ğŸ”—] ğŸ’ [modules] ğŸ”€ update] ğŸª„ ;; d p
                          confine]]]]

  [use [[spec [[program [list module-hashes]] [*]]]
        [definition [[[âœ… pair] ğŸšœ â–¶ï¸ ;; mark all modules as localized
                      dictionary ğŸ”€ using] ğŸª„
                     confine]]
        [examples [[[[#b64 "DzKwIM_7C7bQOxEBEwS2HShK-QF_n_dVMleH2iFfcRw"
                      #b64 "IXce0iyf1NJA-aART0yr1FsjJvpm5l92asEWl0X3Eew"
                      #b64 "mUBaz5wtBlKaV5UqwpiRJKjq50l96qUBpC7OgMhfTPo"]
                     [foo bar mUBaz5wtBlKaV5UqwpiRJKjq50l96qUBpC7OgMhfTPo/baz]
                     use]
                    ["this is foo" "this is bar" "this is baz"]]]]]]
   
  [using [[spec [[[list hash-bool-pairs] dictionary] [dictionary]]]
          [definition [[ğŸ« [[decache] ğŸ›¡ï¸ â–¶ï¸ â€¢ğŸ”€ inscribe] ğŸª„ â€¢ğŸ”€ 
                        [ğŸ—‘ï¸ [[1ï¸âƒ£] ğŸ« ğŸ“®] ğŸ’ [modules] ğŸ”€ update] ;; use the newly loaded module if checked
                        [ğŸ—‘ï¸] â†”ï¸ â€¢ğŸ—‘ï¸] ğŸªœ â–¶ï¸]]
          [examples [[[dictionary
                       [[#b64 "DzKwIM_7C7bQOxEBEwS2HShK-QF_n_dVMleH2iFfcRw" âœ…]
                        [#b64 "IXce0iyf1NJA-aART0yr1FsjJvpm5l92asEWl0X3Eew" âœ…]
                        [#b64 "mUBaz5wtBlKaV5UqwpiRJKjq50l96qUBpC7OgMhfTPo" []]]
                       using [foo bar mUBaz5wtBlKaV5UqwpiRJKjq50l96qUBpC7OgMhfTPo/baz] confine]
                      ["this is foo" "this is bar" "this is baz"]]]]]]
#+end_src

#+begin_src kcats
  dictionary #b64 "DzKwIM_7C7bQOxEBEwS2HShK-QF_n_dVMleH2iFfcRw" âœ… pair ğŸ using 
#+end_src

#+RESULTS:
#+begin_src kcats
[[modules [#b64 "core" #b64 "DzKwIM_7C7bQOxEBEwS2HShK-QF_n_dVMleH2iFfcRw"]]
 [words 283_entries]]
#+end_src

#+begin_src kcats
  dictionary [[errors âœ… ]]
  [ğŸ« [[decache] ğŸ›¡ï¸ â–¶ï¸ â€¢ğŸ”€ inscribe] ğŸª„ â€¢ğŸ”€ 
   [ğŸ—‘ï¸ [[1ï¸âƒ£] ğŸ« ğŸ“®] ğŸ’ dump [modules] ğŸ”€ update] ;; use the newly loaded module if checked
   [ğŸ—‘ï¸]
   â†”ï¸] ğŸªœ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[[errors] ğŸ« ğŸ“®] [[modules [#b64 "core"]]
                 [words 282_entries]]]
[[modules [#b64 "core"]]
 [words 282_entries]]
#+end_src

#+begin_src kcats
    [#b64 "DzKwIM_7C7bQOxEBEwS2HShK-QF_n_dVMleH2iFfcRw" 
     #b64 "IXce0iyf1NJA-aART0yr1FsjJvpm5l92asEWl0X3Eew" 
     #b64 "mUBaz5wtBlKaV5UqwpiRJKjq50l96qUBpC7OgMhfTPo"
     #b64 "z3itY2DdvwLrSCZ56Gf6GF3OXtTucsxja6-71RgKvnA"]
    [foo bar verify]
    [[âœ… pair] ğŸšœ â–¶ï¸ dictionary ğŸ”€ using] ğŸª„ confine  
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [consume]]
 [handled ğŸ”³]
 [reason "not enough items on stack"]
 [trace ["this is bar" bar]]
 [type error]
 [unwound [verify]]]
"this is bar" "this is foo"
#+end_src

*** Debugging

#+begin_src kcats :tangle src/kcats/stdlib/debug.kcats :mkdirp yes
  [[break [[spec [[[program condition] environment]
                  [[program condition] environment]]]
           [definition [[[[ğŸ”€ something?] ;; still running
                          [â–¶ï¸ â˜¯ï¸]] ;; check condition not true yet
                         [â–¶ï¸]
                         every?] ;; break?
                        [[eval-step] ğŸª„]  ;; evaluate the environment one step
                        â³]]]]

   [breakpoint [[spec [ğŸ”³ ğŸ”³]]
                [definition ğŸ”³]]]

   [sprint [[spec [[environment]
                   [environment]]]
            [definition [[[program 0] ğŸ” ğŸ [breakpoint] =] break
                         ğŸ—‘ï¸ ;; the condition
                         ğŸ”³ [eval-step] when]]]] ;; advance past the breakpoint word if the program isn't complete


   [advance [[spec [[environment] [environment]]]
             [definition [ğŸ‘¥ [program] ğŸ” ğŸ“ ğŸ”€ ;; count up the program length, we'll run until it's smaller than this
                          [[program] ğŸ” ğŸ“ ;; only stop if env's program empty or shorter than we started off
                           [[positive?] [<=]] [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ â–¶ï¸] ğŸ›¡ï¸ 
                          [ğŸ—‘ï¸ eval-step] ;; evaluate the environment one step
                          â³ â–¶ï¸
                          â€¢ğŸ—‘ï¸]]]] ;; drop the program length item

   [stepper [[spec [ğŸ”³ [program]]]
             [definition [[eval-step ğŸ‘¥]]]]]

   [tracer [[spec [[program] [[program generator]]]]
            [definition [stage stepper]]]]

   [trace [[spec [[program] [[program generator-of-states]]]]

           [doc "Returns a generator that produces all the states an
           environment goes through when running the given program. Each
           state shows just the stack and remaining program (the
           dictionary should be the same each time and isn't
           included). Uses the current environment's dictionary. Use
           `collect` after to get the actual list."]
           
           [definition [tracer generator [[dictionary] unassign] each]]
           [examples [[[[1 2 +] trace collect] [[[[program [2 +]]
                                                  [stack [1]]]
                                                 [[program [+]]
                                                  [stack [2 1]]]
                                                 [[program ğŸ”³]
                                                  [stack [3]]]]]]]]]]
   
   [dump [[spec [ğŸ”³ ğŸ”³]]
          [definition [ğŸ“¸ ğŸ emit autoformat print]]]]

   [heatmap [[spec [[program] [association]]]
             [definition [[tracer
                           ;; what item is being â–¶ï¸d
                           [[program] ğŸ” [first]
                            ;; don't emit ğŸ”³ or the execution stops, use 0 instead
                            bail 0 or]
                           each 
                           [word?] keep ;; count only words, which filters out the 0's from above
                           frequencies] â€¢ğŸ›¡ï¸]]]]]

  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/debug-step.kcats :mkdirp yes
  [[evaluating? [[program] ğŸ” [evaluate] starts?]]
   [with-innermost [[ğŸ”³ ğŸ”€
                     [[evaluating?]
                      [[stack 0] ğŸ‘¥ [ğŸ”] ğŸª„ ğŸ”€ [ğŸ”—] ğŸª„ ] ;; append the next part of the path to the accumulator
                      â³ ğŸ”€] ğŸ›¡ï¸ â€¢â€¢ğŸ—‘ï¸]
                    ğŸª„ ;; under the stepping prog
                    [update] â€¢ğŸ›¡ï¸ flip ğŸ—‘ï¸

                    ;; find which envs are finished and remove
                    ;; 'evaluate' from parent
                    [0 -2 slice ğŸ‘¥] [collect] â€¢â€¢ğŸ›¡ï¸ 
                    [[[[[evaluating?]
                        [[stack 0] ğŸ” finished?]]
                       [â–¶ï¸] ğŸ’¯]
                      [[program] [rest] update]
                      when]
                     [update] â€¢ğŸ›¡ï¸ flip ğŸ—‘ï¸ ğŸ—‘ï¸]
                    ğŸªœ]]]
  ğŸ”—
#+end_src
** Test modules
#+begin_src kcats :tangle src/kcats/stdlib/foo.kcats :mkdirp yes
  [[foo [[definition ["this is foo"]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/bar.kcats :mkdirp yes
  [[bar [[definition ["this is bar"]]]]]
  ğŸ”—
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/baz.kcats :mkdirp yes
  [[baz [[definition ["this is baz"]]]]]
  ğŸ”—
#+end_src
* Issues
** DONE Get rid of platform-specific definitions
** DONE fix evaluate
#+begin_src kcats
  [[program [1 1 +]]] environment evaluate [stack] ğŸ”
#+end_src

#+RESULTS:
:
: [[2]]
** TODO merkle tree functions
#+begin_src kcats
"foo" "bar" join hash "foobar" hash =
#+end_src

#+RESULTS:
#+begin_src kcats
yes
#+end_src

First let's figure out how to represent a tree:

#+begin_src kcats
  ;[5 [[3 [[1c ğŸ”³]
  ;        [2c ğŸ”³]]]
  ;    [4 [[3c ğŸ”³]]]]]
  [[hash ğŸ”³]
   [children [second]]
   [data [first]]
   [node [ğŸ”³ pair]]
   [empty-node [#b64 "" hash node]]
   [child [[children] ğŸª„ get]]
   [addchild [[pop] ğŸª„ ğŸ“® ğŸ“®]]
   [rawpath [1 [interpose] ğŸ›¡ï¸ ğŸ”€ prepend â€¢ğŸ—‘ï¸]]
   [siblings [ğŸ”³ node âš“ [addchild] ğŸª„ addchild]]
   ;[path [ğŸ”³ [ğŸ“¤ ğŸ”€ [child] ğŸª„ path] [drop] âš–ï¸]]
   [path [dec 2 radix rawpath]]
   [parent [butlast butlast]]
   [rehash [[children [data] ğŸšœ] ğŸ›¡ï¸
            [first] ğŸ›¡ï¸ empty ğŸ”€ [join] ğŸªœ
            hash wrap [0] ğŸ”€ update]]
   ;; lopsidedtree n
   [balance ğŸ”³]
   ;; node tree cur-ct
   [add [[ğŸ‘¥ path [pop zero?] [parent] when] â€¢ğŸª„  ;; node tree path ct
         â€¢ğŸ”€ ;; node path tree ct
         ğŸ”³]]
   [add [[odd?]
         ;; insert an unbalanced node (empty sibling)
         [empty-node siblings [path parent]]
         ;; otherwise replace the empty sibling
         ğŸ”³
        ]]]
  ; ["" drop
  ;  ;[0 ğŸ”³] 1 node addchild 2 node 3 node addchild addchild
  ;  ;[1 0]  1 [interpose] shield ğŸ”€ ğŸ“® â€¢ğŸ—‘ï¸ ğŸ”
  ;  "foo"  hash node "bar"  hash node siblings
  ;  ;; update the root node
  ;  rehash
  ;  ; now add a new sibling
  ;  "baz"  hash node siblings
  ;  rehash
  ;  3 path [pop zero?] [butlast butlast] ğŸ”³ âš–ï¸
  ;  ;dump
  ;  ["quux" hash node siblings rehash ] update
  ; ]
  [["foo" "bar" "baz" "quux"] [node] ğŸšœ ğŸ”³
  let
#+end_src

#+RESULTS:
#+begin_src kcats
[["foo" ğŸ”³]
 ["bar" ğŸ”³]
 ["baz" ğŸ”³]
 ["quux" ğŸ”³]]
#+end_src

+ 1234
  + 12
    + 1
    + 2
  + 34
    + 3
    + 4

 + 5
 + 6
#+RESULTS:
#+begin_src kcats
  ["foobarbaz" [["foobar" [["foo" ğŸ”³]
                           ["bar" ğŸ”³]]]
                ["bazquux" [["baz" ğŸ”³]
                            ["quux" ğŸ”³]]]]]
  ["" ğŸ”³]
#+end_src

interpose impl
#+begin_src kcats
[1 3 4] [foo] unwrap interpose
#+end_src

#+RESULTS:
#+begin_src kcats
[1 foo 3 foo 4]
#+end_src

#+begin_src kcats
[0 [[1 ğŸ”³]
    [2 [[3 ğŸ”³]]]]]
  [1 0] 1 [interpose] ğŸ›¡ï¸ ğŸ”€ prepend 0 ğŸ“® â€¢ğŸ—‘ï¸ [inc] update
#+end_src

#+RESULTS:
#+begin_src kcats
[0 [[1 ğŸ”³]
    [2 [[4 ğŸ”³]]]]]
#+end_src

We need a function that, given a number n, gives the path in the
merkle tree. eg, 8 would be 1 1 1. Is it just =n-1= in binary?
6 would be 1 0 1. Ok so just write a function to expand binary digits:

#+begin_src kcats
8 dec 2 radix
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 1]
#+end_src

#+begin_src kcats
["foobarbaz" [["foobar" [["foo" ğŸ”³]
                         ["bar" ğŸ”³]]]
              ["baz" ğŸ”³]]] [1 1] [ğŸ—‘ï¸ ğŸ—‘ï¸ "hi" "there"] update
#+end_src

#+RESULTS:
#+begin_src kcats
["foobarbaz" [["foobar" [["foo" ğŸ”³]
                         ["bar" ğŸ”³]]]
              "there"]]
#+end_src

#+begin_src kcats
  [[hash ğŸ”³]
   [children [second]]
   [data [first]]
   [node [ğŸ”³ pair]]
   [child [[children] ğŸª„ get]]
   [addchild [[pop] ğŸª„ ğŸ“® ğŸ“®]]
   [siblings [ğŸ”³ node âš“ [addchild] ğŸª„ addchild]]
   ;[path [ğŸ”³ [ğŸ“¤ ğŸ”€ [child] ğŸª„ path] [ğŸ—‘ï¸] âš–ï¸]]
   [path [dec 2 radix nodepath]]
   [rehash [[children [data] ğŸšœ] ğŸ›¡ï¸ [first] ğŸ›¡ï¸ empty ğŸ”€ [join] ğŸªœ hash wrap [0] ğŸ”€ update]]]
  [["foobarbaz" [["foobar" [["foo" ğŸ”³]
                            ["bar" ğŸ”³]]]
                 ["baz" ğŸ”³]]]
   [1 1]

   ["bazquux" [["baz" ğŸ”³]
               ["quux" ğŸ”³]]]
   assign]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
["foobarbaz" [["foobar" [["foo" ğŸ”³]
                         ["bar" ğŸ”³]]]
              ["bazquux" [["baz" ğŸ”³]
                          ["quux" ğŸ”³]]]]]
#+end_src

#+begin_src kcats
  [["bazquux" [["baz" ğŸ”³]
               ["quux" ğŸ”³]]]
   [1 1]
   ["foobarbaz" [["foobar" [["foo" ğŸ”³]
                            ["bar" ğŸ”³]]]
                 ["baz" ğŸ”³]]]]
  reverse unwrap assign
#+end_src

#+RESULTS:
#+begin_src kcats
["foobarbaz" [["foobar" [["foo" ğŸ”³]
                         ["bar" ğŸ”³]]]
              ["bazquux" [["baz" ğŸ”³]
                          ["quux" ğŸ”³]]]]]
#+end_src

#+begin_src kcats

  [
   [children [second]]
   [data [first]]
   [node [ğŸ”³ pair]]
   [addchild [[pop] ğŸª„ ğŸ“® ğŸ“®]]
   [siblings [ğŸ”³ node âš“ [addchild] ğŸª„ addchild]]
   [nodepath [1 [interpose] ğŸ›¡ï¸ ğŸ”€ prepend â€¢ğŸ—‘ï¸]]
   [padded [[[[ğŸ“] ğŸ›¡ï¸] ğŸ‹ -] ğŸª„
            ğŸ”€ repetition
            ğŸ”€ join]]
   [path [[dec 2 radix] ğŸª„ 2 log ceiling 0 padded nodepath]] ;; item-ct index
   [depth ğŸ”³]

   [rehash [[children [data] ğŸšœ] ğŸ›¡ï¸
            [first] ğŸ›¡ï¸ empty ğŸ”€
            [join] ğŸªœ
            hash
            wrap [0] ğŸ”€ update]]
   [joiner [[2 2 partition
             [[ğŸ“ 1 =] [ğŸ”³ ğŸ“®] when
              unwrap siblings] each]
            assemble [rehash] ğŸšœ]]
   [merkle [[hash node] ğŸšœ
            [ğŸ“ 1 >] [joiner] â³]]]
  [["a" "b" "c" "d" "e"]
   ğŸ“
   5 ;; 2nd item
   ğŸ”€ path ]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 1 0 1 0]
#+end_src

#+RESULTS:
#+begin_src kcats
[[#b64 "FO3l6Ol62TcjJ3KPUJm5VgSjlZPKw704o0OtdiBSE+c=" [[#b64 "5aAf7hTg7VxIcU8iGA8lrYNltT+XefedxKPX6Tlj+Uo="
                                                        [[#b64 "ypeBEsobvcr6wjGzmiPcTaeG7/gUfE5yuYB3ha/uSLs=" ğŸ”³]
                                                         [#b64 "PiPoFgA5WUoziU9lZOGxNIu9egCI1CxKy3PurtWcAJ0=" ğŸ”³]]]
                                                       [#b64 "v/4LNNuha8b6wXwIusVdZ2ze1aSt5B/iyZJKXd6PPls=" [[#b64 "Ln0sA6lQeuJl7PW1NWiFpTOTogKdJBOUmXJloaJa78Y="
                                                                                                              ğŸ”³]
                                                                                                             [#b64 "GKw+c0PwFokMUQ6T+TUmEWnZ4/VlQ2Qpgw+vCTT0+OQ=" ğŸ”³]]]]]]
#+end_src

#+begin_src kcats
  [1 1 1] 5 0 [[[ğŸ“] ğŸ›¡ï¸] ğŸ‹ -] ğŸª„
          ğŸ”€ repetition
          ğŸ”€ join
#+end_src

#+RESULTS:
#+begin_src kcats
[0 0 1 1 1]
#+end_src
** CANCELED Make taker/dropper more flexible
Goal: implement drop and drop-while with the same logic

Canceled - the commonality between drop and drop-while are too small to be worth trying to factor out.

#+begin_src kcats
  [1 2 3 4 5] [ğŸ“¤]
  3
  [[[positive?]
    [[generate ğŸ—‘ï¸] ğŸª„ dec]
    while
    [generate ğŸ”€] ğŸª„ ğŸ›Ÿ]
   bail]
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[4 5]
[[[positive?] [[generate ğŸ—‘ï¸]
               ğŸª„ dec]
  while [generate ğŸ”€]
  ğŸª„ ğŸ›Ÿ]
 bail]
0 [ğŸ“¤] ğŸ”³
#+end_src


This is what drop-while looks like
#+begin_src kcats
  ğŸ”³ [ğŸ“¤]
  [positive?]
  ğŸ”³ ;; the state (whether threshold reached)
  [ğŸ”³ ;; condition - whether we've finished dropping or not 
   [[generate] â€¢ğŸ‹] ;; true - pass everything else through
   [[[generate] â€¢ğŸ‹] ;; prime init
    [[[ğŸ‘¥] â€¢ğŸ‹ execute] bail] ;; bring pred up and exec it
    [ğŸ—‘ï¸] ;; if pred passes drop the value
    prime ;; after this should have value on top
    [ğŸ—‘ï¸ true] ğŸª„ ;; set flag
   ] ;; false - generate, check pred, repeat
   âš–ï¸]
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ [ğŸ”³ [[generate] â€¢ğŸ‹]
    [[[generate] â€¢ğŸ‹]
     [[[ğŸ‘¥] â€¢ğŸ‹ execute] bail]
     [ğŸ—‘ï¸] prime [ğŸ—‘ï¸ yes]
     ğŸª„]
    âš–ï¸]
yes [positive?] [ğŸ“¤] ğŸ”³
#+end_src
** Generate training data
*** Text templates
+ What simple program is equivalent to $usage? Answer: $equivalent
+ What does this program demonstrate about $word: $usage? Answer: $description
*** kcats formatters
**** Specs
#+begin_src kcats
  dictionary lingo [ğŸª† spec] ğŸ”
  [list?] ğŸ›¡ï¸
  [ğŸ—‘ï¸ "{} '{}'" format]
  [ğŸ "{}" format] âš–ï¸
  ğŸšœ ğŸšœ â–¶ï¸
   [", " interpose [ğŸ”—] ğŸª— â–¶ï¸ ] ğŸšœ â–¶ï¸ 
   "Takes: {}. Returns: {}" format
#+end_src

#+RESULTS:
#+begin_src kcats
"Takes: program 'combinator', program 'exit', program 'body', program 'pred'. Returns: *"
#+end_src
**** Examples

*** Elisp automated generation

** Rewrite decide with recur
#+begin_src kcats
    8 [[[3 =] [ğŸ—‘ï¸ "three"]]
       [[5 =] [ğŸ—‘ï¸ "five"]]
       [[7 =] [ğŸ—‘ï¸ "seven"]]
       [[âœ…] [ğŸ—‘ï¸ "something else"]]]
    [ğŸ“¤ ğŸ« ğŸ”€ ğŸ›¡ï¸ flip [[[]] âš–ï¸ â–¶ï¸] ğŸ‹ ğŸ‘¥ â˜¯ï¸]
    [ğŸ—‘ï¸ ğŸ—‘ï¸]
    [â€¢ğŸ—‘ï¸] [â–¶ï¸] ğŸª† â–¶ï¸
  ;ğŸª†
  ;â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
["something else" ğŸ”³ 8]
"something else" 8
#+end_src

Should =decide= 
** Write multimethods?
Isa based dispatch and hierarchies? maybe a bit much to go after now.
#+begin_src kcats
  [[3 [ğŸ—‘ï¸ "three"]]
   [5 [ğŸ—‘ï¸ "five"]]
   [7 [ğŸ—‘ï¸ "seven"]]
   [[âœ…] [ğŸ—‘ï¸ "something else"]]]
#+end_src
** Implement a named-arg calling convention
Let's say we have a bunch of values we need to work with
interchangeably, say more than 4 or 5. There's too much stack
fiddling. Let's say we want to work with named values for bit - we
have our map of named values, and a function we want to call that uses
a few of them (and perhaps will put its result back in the map). We
could do something like this:

#+begin_src kcats
  [[name "Foo"]
   [address "123 Fake st"]
   [email "foo@bar.com"]
   [member-since 3000]
   [age 40]
   [discounts 0.1]]
  ;; we want to increase discount iff age >= 50 or has been a member for more than 10 yrs

  ;; first extract the values we want
  [age member-since discounts]
  [2025 ğŸ”€ - 10 >] [ğŸ—‘ï¸ ğŸ—‘ï¸ 0.1 +] [ğŸ—‘ï¸] âš–ï¸
  ;[discounts]

  [association] â€¢ğŸª„
  [reverse [ğŸ ğŸ”] ğŸšœ â–¶ï¸] ğŸª„
  [[ğŸ«] ğŸª„ â–¶ï¸] â€¢â€¢ğŸ›¡ï¸ â–¶ï¸  
  [discounts] label ğŸ”—
  ;ğŸ—‘ï¸ ; type
#+end_src

#+RESULTS:
#+begin_src kcats
[[address "123 Fake st"]
 [age 40]
 [discounts 0.2]
 [email "foo@bar.com"]
 [member-since 3000]
 [name "Foo"]]
#+end_src

So one question is should the names be in stack order (first = top) or
execution order (last = top)? Seems like stack order is best here
because it's like spec etc.

lets use =ğŸ¤¹= (juggler) for this action. 

