# -*- mode: org; -*-
# -*- org-export-babel-evaluate: nil -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="doc-custom.css"/>

#+TITLE: The kcats Programming Language Lexicon
#+AUTHOR: Skyrod Vactai
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:kcats :results code :exports both
#+TODO: TODO(t) INPROGRESS(i) | DONE(d) CANCELED(c)

* Standard library source and documentation
** Comparison
Words that help compare one item to another, with concepts of =equal=, =greater=, =less= etc.

#+begin_src kcats :tangle src/kcats/core/compare-builtins.kcats :mkdirp yes
  [= [[spec [[item item] [boolean]]] 
      [examples [[[1 2 =] [🔳] "Different Numbers are not equal"]
                 [[1 1 =] [✔️] "Same numbers are equal"]
                 [[1 1.0 =] [✔️] "Same value integer and float are equal"]
                 [[[1] 🔳 =]  [🔳] "Number and Nothing are unequal"]
                 [[[1 [🔳]] [1 [🔳]] =] [✔️] "Same nested list with numbers are equal"]
                 [[[1.0 ["foo"]] [1.0 ["foo"]] =] [✔️] "Same nested list with string are equal"]
                 [["hi" "hi" =] [✔️] "Same strings are equal"]
                 [["hi" "there" =] [🔳] "Different strings are unequal"]
                 [[\h \h =] [✔️] "Same characters are equal"]
                 [[\h \i =] [🔳] "Different characters are unequal"]
                 [["hi" encode "hi" encode =] [✔️] "Same bytes are equal"]
                 [["hi" encode "there" encode =] [🔳] "Different bytes are unequal"]
                 [[🔳 ✔️ =] [🔳] "Different booleans unequal"]
                 [[[1.0 ["foo"]] [1.0 ["bar"]] =]  [🔳] "Nested lists with different strings are unequal"]
                 [[🔳 🔳 =] [✔️] "'Nothing' is equal to itself"]
                 [[🔳 🔳 association =] [✔️] "List/Association empty container types are equal"]
                 [[🔳 🔳 set =] [✔️] "List/Set empty container types are equal"]
                 [[[[a b]] [[a b]] association =] [🔳] "Nonempty List/Association types are unequal"]
                 [[[1 2 3] set [3 1 2] set =] [✔️] "Sets constructed from different lists are equal"]
                 [[["foo" =] [🗑️ "Needs 2 items"] 🩹 ▶️] ["Needs 2 items"] "Less than 2 stack items results in an error"]]]]]

  [compare [[spec [[item item] [word]]]
            [examples [[["a" "b" compare] [[less] unwrap] "string lexicographical order with single character inequality"]
                       [["a" "a" compare] [[equal] unwrap] "string lexicographical order with single character equality"]
                       [[1 1 compare] [[equal] unwrap] "Same integer compares equal"]
                       [[2 1 compare] [[greater] unwrap] "Integer order inequality"]
                       [[1 [foo] unwrap compare] [[less] unwrap] "Integer/list order inequality"]
                       [[1 "foo" encode compare] [[less] unwrap] "Integer/byte order inequality"]
                       [[[foo] unwrap "foo" encode compare] [[less] unwrap] "Word/string order inequality"]
                       [["foo" encode "foo" compare] [[less] unwrap] "String order equaltiy"]
                       [[🔳 [🔳] unwrap compare] [[equal] unwrap] "Unwrapped Nothing value equality"]
                       [[🔳 [1] rest compare] [[equal] unwrap] "Nothing/emptied container equality"]
                       [[["foo" compare] [🗑️ "Needs 2 items"] 🩹 ▶️] ["Needs 2 items"] "Less than 2 stack items results in an error"]]]]]

  ;; TODO these should be in terms of compare and not limited to numbers
  [< [[spec [[number number] [boolean]]]
      [examples [[[1 2 <] [✔️] "Integer is less"]
                 [[2.2 1.1 <] [🔳] "Float is not less"]
                 [[1 2.2 <] [✔️] "Integer/float is less"]
                 [[1.1 1.1 <] [🔳] "Equal floats is not less"]
                 [[["foo" "bar" <] [🗑️ "Number arguments only"] 🩹 ▶️] ["Number arguments only"] "Non-numeric inputs results in an error"]]]]]

  [> [[spec [[number number] [boolean]]]
      [examples [[[2 1 >] [✔️] "Integer is greater"]
                 [[1.1 2.2 >] [🔳] "Float is not greater"]
                 [[2.2 1 >] [✔️] "Integer/float is greater"]
                 [[1.1 1.1 >] [🔳] "Equal floats is not greater"]
                 [[["foo" "bar" >] [🗑️ "Number arguments only"] 🩹 ▶️] ["Number arguments only"] "Non-numeric inputs results in an error"]]]]]

  [<= [[spec [[number number] [boolean]]]
       [examples [[[1 2 <=] [✔️] "Integer is less/equal"]
                  [[2.2 1.1 <=] [🔳] "Float is not less/equal"]
                  [[1 2.2 <=] [✔️] "Integer/float is less/equal"]
                  [[1.1 1.1 <=] [✔️] "Equal floats is less/equal"]
                  [[["foo" "bar" <=] [🗑️ "Number arguments only"] 🩹 ▶️] ["Number arguments only"] "Non-numeric inputs results in an error"]]]]]

  [>= [[spec [[number number] [boolean]]]
       [examples [[[2 1 >=] [✔️] "Integer is greater/equal"]
                  [[1.1 2.2 >=] [🔳] "Float is not greater/equal"]
                  [[2.2 1 >=] [✔️] "Integer/float is greater/equal"]
                  [[1.1 1.1 >=] [✔️] "Equal floats is greater/equal"]
                  [[["foo" "bar" >=] [🗑️ "Number arguments only"] 🩹 ▶️] ["Number arguments only"] "Non-numeric inputs results in an error"]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/compare.kcats :mkdirp yes
  [min [[spec [[number number] [number]]]
        [definition [[<] 🛡️ [🗑️] [🔀] ⚖️ ▶️ 🗑️]]
        [examples [[[2 3 min] [2] "Smaller of two positive integers"]
                   [[-5 -3 min] [-5] "Smaller of two negative integers"]
                   [[0.3 0.2 min] [0.2] "Smaller of two floats <1"]]]]]

  [max [[spec [[number number] [number]]]
        [definition [[>] 🛡️ [🗑️] [🔀] ⚖️ ▶️ 🗑️]]
        [examples [[[2 3 max] [3] "Larger of two positive integers"]
                   [[-5 -3 max] [-3] "Larger of two positive integers"]
                   [[0.3 0.2 max] [0.3] "Larger of two floats <1"]]]]]
#+end_src
** Stack Ops
#+begin_src kcats :tangle src/kcats/core/stack-builtins.kcats :mkdirp yes
  [🗑️ [[spec [[item] []]]
       [examples [[[1 2 3 🗑️] [1 2] "Drop integer on ToS"]
                 [[1 2 3 [a b c] 🗑️] [1 2 3] "Drop list on ToS"]]]]]

  [👥 [[spec [[[item a]]
              [[item a] [item a]]]]
       [examples [[[1 2 3 👥] [1 2 3 3] "Clone integer on ToS"]
                     [["foo" "bar" "baz" 👥] ["foo" "bar" "baz" "baz"] "Clone string on ToS"]]]]]

  [evert [[spec [[list] [list *]]]
          [doc "Takes a list on ToS, makes it the new stack, and takes what had
                previously been the rest of the stack, and makes it a list on top
                of the new stack. Used for context switching."]
          [examples [[[1 2 3 [4 5 6] evert] [6 5 4 [3 2 1]] "Swap a list of integers with the rest of the stack"]
                    [[[4 5 6] evert] [6 5 4 []] "Swap a list of integers with an empty stack"]
                    [[[1 2 3 4 evert] [🗑️ "List is required"] 🩹 ▶️] ["List is required"] "Non-list item result in an error"]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/stack.kcats :mkdirp yes
  [•👥  [[spec [[[item a] [item b]]
                [[item a] [item b] [item b]]]]
         [definition [[👥] 🪄]]
         [examples [[[1 2 3 •👥] [1 2 2 3] "Clone the 2nd item on the stack"]]]]]

  [••👥 [[spec [[[item a] [item b] [item c]]
                [[item a] [item b] [item c] [item c]]]]
         [definition [[•👥] 🪄]]
         [examples [[[1 2 3 4 ••👥] [1 2 2 3 4] "Clone the 3rd item on the stack"]]]]]

  [over [[spec [[[item a] [item b]]
                [[item b] [item a] [item b]]]]
         [definition [•👥 🔀]]
         [examples [[[1 2 3 over] [1 2 3 2] "Copy the 2nd item to ToS"]]]]]

  [under [[spec [[[item a] [item b]]
                 [[item a] [item b] [item a]]]]
          [definition [👥 sink]]
          [examples [[[1 2 3 under] [1 3 2 3] "Copy the ToS to the 2nd item"]]]]]

  [•🗑️ [[spec [[[item a] [item b]] [[item b]]]]
        [definition [🔀 🗑️]]
        [examples [[[1 2 3 •🗑️] [1 3] "Drop the 2nd item"]]]]]

  [••🗑️ [[spec [[[item a] [item b] [item c]] [[item a] [item b]]]]
         [definition [float 🗑️]]
         [examples [[[1 2 3 ••🗑️] [2 3] "Drop the 3rd item"]]]]]

  [snapshot [[spec [[] [list]]]
             [doc "Save the whole stack as a list on the stack"]
             [definition [🔳 evert 👥 evert unwrap]]
             [examples [[[1 2 3 snapshot] [1 2 3 [3 2 1]] "Copy the stack to ToS"]
                        [[snapshot] [🔳] "Copy stack to ToS when stack is empty"]]]]]

  [restore [[spec [[list] [*]]]
            [definition [evert 🗑️]]
            [examples [[["x" "y" [1 2 3] restore] [3 2 1] "Replace stack with list"]
                       [[🔳 restore] 🔳 "Replace stack with empty list"]]]]]
#+end_src
*** Motion
These words change the order of items on the stack.

#+begin_src kcats :tangle src/kcats/core/motion-builtins.kcats :mkdirp yes
  [🔀 [[spec [[[item a] [item b]]
              [[item b] [item a]]]]
       [examples [[[1 2 3 🔀] [1 3 2] "Swap top two items"]]]]]

  [•🔀 [[spec [[[item a] [item b] [item c]]
               [[item a] [item c] [item b]]]]
        [examples [[[1 2 3 •🔀] [2 1 3] "Swap 2nd and 3rd items"]]]]]

  [float [[spec [[[item a] [item b] [item c]]
                 [[item c] [item a] [item b]]]]
          [examples [[[1 2 3 float] [2 3 1] "Move 3rd item to ToS"]]]]]

  [sink [[spec [[[item a] [item b] [item c]]
                [[item b] [item c] [item a]]]]
         [examples [[[1 2 3 sink] [3 1 2] "Move ToS to 3rd item"]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/motion.kcats :mkdirp yes
  [flip [[spec [[[item a] [item b] [item c]]
                 [[item c] [item b] [item a]]]]
          [definition [float •🔀]]
          [examples [[[1 2 3 flip] [3 2 1] "Swap ToS and 3rd item"]]]]]
#+end_src
** Program execution
#+begin_src kcats :tangle src/kcats/core/execute-builtins.kcats :mkdirp yes
  [▶️ [[spec [[program] [*]]]
            [examples [[[[1 2 +] ▶️] [3] "Execute a program"]
                       [[1 2 🔳 ▶️] [1 2] "Execute an empty program"]
                       [[1 2 [[+] ▶️] ▶️] [3] "Nested execution"]]]]]

  [↔️ [[spec [[[program no-branch]
                   [program yes-branch]
                   [item condition]]
                  [*]]]
           [examples [[[5 ✔️ [🗑️ 3 *] [4 +] ↔️] [15] "Branch on true condition"]
                      [[6 🔳 [3 *] [4 +] ↔️] [10] "Branch on false condition"]]]]]

  [🪄 [[spec [[program [item a]] [[item a] *]]]
        [examples [[[1 8 [inc] 🪄] [2 8] "Dipping a program under ToS"]
                   [[1 2 [dec] unwrap
                     [+] 🪄] [3 [dec] unwrap] "A bare word on stack is left intact and not executed"]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/execute.kcats :mkdirp yes
  [loop [[spec [[program [item flag]] [*]]]
         [definition [[[1️⃣ ▶️ ;; execute the body
                        1️⃣ loop ▶️] ;; then wrap the body as a loop and execute that
                       🔳 ;; do nothing if condition is false
                       ↔️]
                      🎒]]
         [examples [[[10 ✔️ [🗑️ -2 * 👥 50 <] loop ▶️] [160] "Looping"]
                    [[10 🔳 [🗑️ -2 * 👥 50 <] loop ▶️] [10] "Looping with false initial condition is no-op"]]]]]

  [recur [[spec [[[program combinator]
                  [program exit]
                  [program body]
                  [program pred]]
                 [*]]]
          [doc "Constructs a recursive program, without having to give it a name. Takes 4 component programs as input: predicate, body, exit,
                and combinator; and returns a recursive program. This program will run predicate, if false the exit program
                runs and the recursive program is finished. If true, the body program runs, the whole recursive program is put on
                the stack and the combinator is run."]
          [definition [[✂️3️⃣ [4️⃣ 3️⃣ 2️⃣ 1️⃣ recur ▶️] ✂️1️⃣] [🎒]
                       ••🛡️ ▶️ ••🗑️ 🔀 ⚖️]]
          [examples [[[5
                       [2 >] 🛡️
                       [🗑️ 👥 dec] 🔳 [▶️ *]
                       recur ▶️]
                      [120]
                      "Recur with reduction"]]]]]


  [decide [[spec [[[list test-expr-pairs]] [*]]]
           [doc "Takes a list of choices (pairs of test, program) and executes the first
                 choice whose test passes. If none pass, it's a no-op. Stack is reset
                 between testing conditions."]
           [definition [📤
                        [unwrap ;; break up the pair
                         🔀 
                         🛡️
                         ;; recur 
                         flip [1️⃣ decide] 🎒 ⚖️ ▶️]
                        [🗑️] ;; the empty container
                        ↔️]]
           [examples [[[5 [[[3 =] [🗑️ "three"]]
                           [[5 =] [🗑️ "five"]]
                           [[7 =] [🗑️ "seven"]]
                           [[✔️] [🗑️ "something else"]]]
                        decide]
                       [5 "five"] "Decide with matching condition"]

                      [[9 [[[3 =] [🗑️ "three"]]
                           [[5 =] [🗑️ "five"]]
                           [[7 =] [🗑️ "seven"]]
                           [[✔️] [🗑️ "something else"]]]
                        decide]

                       [9 "something else"] "Decide with matching default condition"]

                      [[9 [[[3 =] [🗑️ "three"]]
                           [[5 =] [🗑️ "five"]]
                           [[7 =] [🗑️ "seven"]]]
                        decide]
                       [9] "Decide with no matching condition"]]]]]

  ;; TODO: implement as axiom (which would depend on 'restore' which should also be axiom?)
  [🛡️ [[spec [[program] [program]]]
           [doc "Runs program keeping top of stack produced but protects existing items from being consumed."]
           [definition [💉 [snapshot ✂️1️⃣ first] 🎒]]
           [examples [[[1 2 3 [=] 🛡️ ▶️] [1 2 3 🔳] "Execute a program shielding the stack from consumption"]]]]]

  [•🛡️ [[spec [[program] [program]]]
               [definition [💉 [snapshot ✂️1️⃣ •🗑️ first] 🎒]]
               [examples [[[1 2 3 [=] •🛡️ ▶️] [1 2 🔳] "Execute a program consuming only the original ToS"]]]]]

  [••🛡️ [[spec [[program] [program]]]
               [definition [💉 [snapshot ✂️1️⃣ •🗑️ •🗑️ first] 🎒]]
               [examples [[[1 2 3 [+ +] ••🛡️ ▶️] [1 6] "Execute a program consuming only the original top 2 items"]]]]]

  [⚖️ [[spec [[[program no-branch]
               [program yes-branch]
               [program condition]]
              [program]]]
       [definition [[✂️3️⃣ ;; the condition
                     2️⃣ 1️⃣ ↔️] 🎒]]
       [examples [[[5 [👥 5 =] [🗑️ 3 *] [4 +] ⚖️ ▶️] [15] "Conditional with true predicate"]
                  [[6 [👥 5 =] [🗑️ 3 *] [4 +] ⚖️ ▶️] [10] "Conditional with false predicate"]]]]]

  [when [[spec [[[program yes-branch]
                 [program condition]]
                [program]]]
         [definition [🔳 ⚖️]]
         [examples [[[3 [👥 odd?] [🗑️ inc] when ▶️] [4] "Conditional with no false branch and true predicate"]
                    [[3 [👥 even?] [🗑️ inc] when ▶️] [3] "Conditional with no false branch and false predicate"]]]]]

  [dipped [[spec [program program]]
           [definition [wrap [🪄] 🔗]]]]

  [•🪄 [[spec [[program
                [item a]
                [item b]]
               [[item a] [item b] *]]]
        [definition [dipped dipped ▶️]]
        [examples [[[1 2 3 [inc] •🪄] [2 2 3] "Dip program under top two items"]]]]]

  [••🪄 [[spec [[program
                 [item a]
                 [item b]
                 [item c]]
                [[item a] [item b] [item c] *]]]
         [definition [dipped dipped dipped ▶️]]
         [examples [[[1 2 3 4 [inc] ••🪄] [2 2 3 4] "Dip program under top 3 items"]]]]]

  [🪜 [[spec [program program]]
         [definition [[[📤 🔀 
                        1️⃣ 👥 •🪄
                        🪜 ▶️]
                       🔳 ↔️]
                      🎒]]
         [examples [[[1 [2 3 4] [*] 🪜 ▶️] [24] "Step through numbers doing arithmetic"]
                    [[1 🔳 [*] 🪜 ▶️] [1] "Stepping through empty list is no-op"]]]]]

  [dive [[spec [[program [item a]] [item [item a] *]]]
         [definition [🪄 🔀]]
         [examples [[[4 5 6 [+] dive] [6 9] "Dip program and move result to ToS"]]]]]

  [divedown [[spec [[program [item a] [item b]]
                    [item [item a] [item b] *]]]
             [definition [•🪄 float]]
             [examples [[[5 6 7 8 [+] divedown] [7 8 11] "Dip under top 2 items and move result to ToS"]]]]]

  [divedeep [[spec [[program [item a] [item b] [item c]]
                    [item [item a] [item b] [item c] *]]]
             [definition [wrap [divedown] 🔗 🪄 🔀]]
             [examples [[[4 5 6 7 8 [+] divedeep] [6 7 8 9] "Dip under top 3 items and move result to ToS"]]]]]

  [💉 [[spec [program program]]
           [doc "Transform the program into one where it injects the  quoted program into the list below
                       it (runs the program with the list as its
                       stack).  Does not affect the rest of the stack."]
           [definition [dipped [evert ✂️1️⃣ evert] 🎒]]
           [examples [[[1 2 3 [4 5 6] [* +] 💉 ▶️] [1 2 3 [26]] "Inject program into list as if it's the stack"]]]]]

  [while [[spec [[[program body]
                  [program pred]]
                 [*]]]
          [definition [🔳 [▶️] recur] ]
          [examples [[[3 [0 >] 🛡️ [🗑️ 👥 dec] while ▶️] [3 2 1 0] "While loop"]]]]]

  [until [[spec [[[program body]
                  [program pred]]
                 [*]]]
          [definition [🔀 ;; pred body
                       [☯️] 🔗 ;; reverse logic
                       [🛡️] decorate ;; add shield to the pred program -> pred body
                       🔗 ;; [body ..  pred]
                       yes 🔀 ;; run at least once
                       loop]]
          [examples [[[2 [even?] [inc] until] [4] "Until loop"]]]]]

  [times [[spec [[[integer howmany]
                  [program body]]
                 [program]]]
          [definition [[1️⃣ [positive?] 🛡️
                        [🗑️ dec [2️⃣ 👥 🪄] 🪄 times ▶️]
                        [🗑️] ⚖️
                        ▶️]
                       🎒]]
          [examples [[[[5] 3 times ▶️] [5 5 5] "Can create an item multiple times"]
                     [[[5] 0 times ▶️] 🔳 "0 times is a no-op"]
                     [[1 1 [inc 🔀] 3 times ▶️] [3 2] "Can run a program multiple times"]]]]]

  [primrec [[spec [[[program rec1]
                    [program exit]
                    [number repetitions]]
                   [*]]]
            [definition [[▶️] 🔀 🔗 ;; add execute to rec1 to be recurs rec2
                         [[🗑️] 🔀 🔗] 🪄 ;; add drop to exit condition
                         [[zero?]] •🪄  ;; put the condition on bottom
                         [[👥 dec]] 🪄 ;; add the r1
                         recur]] ;; now its generic recur
            [examples [[[5 [1] [*] primrec ▶️] [120] "Simple countup loop"]]]]]

  [bail [[spec [[program] [*]]]
         [definition [[🔳] ↔️]]
         [examples [[[🔳 [inc] bail] [🔳] "Can bail on invalid input"]
                    [[1 [inc] bail] [2] "Valid input doesn't bail"]]]]]
#+end_src
** Collections
#+begin_src kcats :tangle src/kcats/core/collections-builtins.kcats :mkdirp yes
  [🔗 [[spec [[sized sized] [sized]]]
         [examples [[[["a" "b"] ["c" "d"] 🔗] [["a" "b" "c" "d"]] "Join two collections of strings"]
                    [["ab" "cd" 🔗] ["abcd"] "Join two strings"]
                    [["ab" encode "cd" encode 🔗 "abcd" encode =] [✔️] "Two joined byte seqs are equal to the combined literal"]
                    [[[[a b] [c d]] association [[e f] [a g]] 🔗] [[[a g] [c d] [e f]] association] "Joining list+assoc -> assoc, 2nd arg keys take priority"]
                    [[[[e f] [a g]] [[a b] [c d]] association  🔗] [[[a b] [e f] [c d]] association] "Joining assoc+list -> assoc, 2nd arg keys take priority"]
                    [[[a b c d] set [a e] 🔗] [[a b c d e] set] "Join set with list -> set"]
                    [[[a e] [a b c d] set 🔗] [[a b c d e] set] "Join list with set -> set"]
                    [["" "" 🔗] [""] "Join two empty strings -> empty string"]
                    [["" [1 2 3] 🔗] [[1 2 3]] "Join empty string + list -> list (identity)"]
                    [["a" [\b \c] 🔗] ["abc"] "Join a string with a list of chars -> string"]
                    [[[\b \c] "a" 🔗] ["bca"] "Join a list of chars with string -> string"]
                    [["" [\b \c] 🔗] ["bc"] "Join an empty string with list of chars -> string"]
                    [["abc" [\d \e 12] 🔗] [[\a \b \c \d \e 12]] "Join a string with list -> list"]
                    [["abc" 🔳 🔗] ["abc"] "Join a string with empty list -> string"]
                    [["" 🔳 🔗] [""] "Join empty string with empty list -> string"]
                    [[[1 2 3] set [4 4 4] 🔗] [[1 2 3 4] set] "Join set with list -> set"]]]]]

  [put [[spec [[item receptacle] [receptacle]]]
        [examples [[[🔳 1 put] [[1]] "Put integer into empty list"]
                   [[[1 2 3] 4 put] [[1 2 3 4]] "Put integer into list"]
                   [["foo" \d put] ["food"] "Put character into string"]
                   [["foo" encode 32 put string] ["foo "] "Put byte into byte array"]]]]]

  [count [[spec [[sized]
                 [number]]]
          [examples [[[["a" "b" "cd"] count] [3] "Count list of strings"]
                     [["abcd" count] [4] "Count chars in string"]
                     [["abcd" encode count] [4] "Count bytes in byte array"]
                     [[[[a b] [c d]] association count] [2] "Count entries in association"]]]]]

  [second [[spec [[ordered] [item]]]
           [examples [[[[4 5 6] second] [5] "Get second item of list"]
                      [["foo" second [\o]] "Get second item of string"]
                      [[🔳 second] [🔳] "Get second item of empty list -> Nothing"]]]]]

  [last [[spec [[ordered] [item]]]
         [examples [[[[3 4 5 6] last] [6] "Get last item of list"]
                    [["foo" last [\o]] "Get last item of string"]
                    [[🔳 last] [🔳] "Get last item of empty list -> Nothing"]]]]]

  [📤 [[spec [[dispenser] [item dispenser]]]
         [examples [[[["a" "b" "c"] 📤] [["b" "c"] "a"] "Take a string from a list"]
                    [[[1 2 3] 📤] [[2 3] 1] "Take a number from a list"]
                    [[[[a "foo"] [b "foo"] [c "foo"]] 📤 •🗑️ second] ["foo"] "Take an entry from association is nondeterministic"]
                    [[[1 3 5 7 9] set 📤 •🗑️ odd?] [✔️] "Take item from set is nondeterministic"]]]]]

  [pop [[spec [[ordered] [item ordered]]]
        [examples [[[["a" "b" "c"] pop] [["a" "b"] "c"] "Pop last string from list"]
                   [[[1 2 3] pop] [[1 2] 3] "Pop last number from list"]]]]]

  [wrap [[spec [[item] [list]]]
         [examples [[[1 wrap] [[1]] "Wrap a number"]
                    [[[1 2] wrap] [[[1 2]]] "Wrap a list"]]]]]

  [unwrap [[spec [[list] [*]]]
           [examples [[[[1] unwrap] [1] "Unwrap a list of one item"]
                      [[🔳 unwrap] 🔳 "Unwrap an empty list is a no-op"]
                      [[[1 2 3] unwrap] [1 2 3] "Unwrap a list of multiple items"]]]]]

  [reverse [[spec [[ordered] [ordered]]]
            [examples [[[[1 2 3] reverse] [[3 2 1]] "Reverse a list"]
                       [["123" reverse] ["321"] "Reverse a string"]]]]]

  [slice [[spec [[integer integer ordered] [ordered]]]
          [examples [[["foobar" 0 3 slice] ["foo"] "Slice a string with valid indices"]
                     [["foobar" 0 7 slice] [🔳] "Slice a string with index past end -> Nothing"]
                     [["foobar" encode 0 3 slice] ["foo" encode] "Slice a byte array with valid indices"]
                     [[[a b c d e] 0 3 slice] [[a b c]] "Slice a list with valid indices"]]]]]

  [cut [[spec [[integer sized] [list]]]
        [definition [[[[[count] dive] 🛡️ slice]
                      [0 🔀 slice]]
                     [▶️] map
                     [🗑️ 🗑️] 🪄 unwrap]]
        [examples [[["abcdefghijklmnopqrstuvwxyz" 5 cut] ["fghijklmnopqrstuvwxyz" "abcde"] "Cut string at index"]]]]]

  [empty [[spec [[sized] [sized]]]
          [examples [[["foo" empty] [""] "Create empty container from string"]
                     [["foo" encode empty] ["" encode] "Create empty container from byte array"]
                     [[[1 2 3] empty] [🔳] "Create empty container from list"]
                     [[[[a b] [c d]] association empty] [🔳 association] "Create empty container from association"]
                     [[[1 2 3] set empty] [🔳 set] "Create empty container from set"]]]]]

  [range [[spec [[integer integer integer] [list]]]
          [examples [[[1 5 1 range] [[1 2 3 4]] "Create integer range with step of 1"]
                     [[3 13 3 range] [[3 6 9 12]] "Create integer range with step greater than 1"]]]]]

  [empty? [[spec [[item] [boolean]]]
           [examples [[[🔳 empty?] [✔️] "Empty list is empty"]
                      [[1 empty?] [🔳] "Number is not empty"]
                      [["" empty?] [✔️] "Empty string is empty"]
                      [[[foo] empty?] [🔳] "Non-empty list is not empty"]]]]]

  [pad [[spec [[[item padding] [integer newsize] sized] [sized]]]
        [definition [[[[count] 🛡️] dive -] 🪄
                     🔀 repeat
                     🔀 🔗]]
        [examples [[[[1 2 3] 5 0 pad] [[0 0 1 2 3]] "Pad a list at front, to given size"]
                   [[[1 2 3 4 5 6] 5 0 pad] [[1 2 3 4 5 6]] "Padding a list to smaller than original size is a no-op"]]]]]

  [list? [[spec [[item] [boolean]]]
          [examples [[[[1] list?] [✔️] "A list is a list"]
                     [[🔳 list?] [✔️] "An empty list is a list"]
                     [[5 list?] [🔳] "A number is not a list"]
                     [["foo" list?] [🔳] "A string is not a list"]
                     [[🔳 association list?] [🔳] "An empty association is not a list"]]]]]

  [sort-indexed [[spec [[sized] [sized]]]
                 [examples [[[[[1 1] [3 3] [2 2]] sort-indexed] [[1 2 3]] "Sorting a list of key-value pairs by key"]]]]]

  [🎒 [[spec [[[list template]] [list]]]
         [examples [[["x" [foo] [bar] unwrap
                      [2️⃣ [1️⃣ x ✂️2️⃣] c d 1 2 3] 🎒]
                     ["x" [[foo] [bar x foo] c d 1 2 3]]
                     "Packing values from the stack, into a template"]]]]]
#+end_src

#+begin_src kcats kcats :tangle src/kcats/core/collections.kcats :mkdirp yes
  [something? [[spec [[item] [boolean]]] 
               [definition [empty? ☯️]]
               [examples [[[1 something?] [✔️] "A number is something"]
                          [[🔳 something?] [🔳] "Empty list is not something"]
                          [["" something?] [🔳] "Empty string is not something"]]]]]

  [first [[spec [[ordered] [item]]]
          [definition [📤 •🗑️]]
          [examples [[[[4 5 6] first] [4] "Get the first item of a list"]
                     [["foo" first] [\f] "The first item of a string is the first character"]
                     [[🔳 first] [🔳] "The first item of an empty list is Nothing"]]]]]

  [rest [[spec [[sized] [sized]]]
         [definition [📤 🗑️]]
         [examples [[[[1 2 3] rest] [[2 3]] "Take rest of list"]
                    [["foo" rest] ["oo"] "Take rest of string"]]]]]

  [butlast [[spec [[sized] [sized]]]
            [definition [pop 🗑️]]
            [examples [[[[1 2 3] butlast] [[1 2]] "Take all but last of list"]]]]]

  [prepend [[spec [[item sized]
                   [sized]]]
            [definition [wrap 🔀 🔗]]
            [examples [[[[1 2] 3 prepend] [[3 1 2]] "Prepend to list"]
                       [["oo" \f prepend] ["foo"] "Prepend to string"]]]]]

  [every? [[spec [[program sized] [boolean]]]
           [definition [[[📤 🔀 1️⃣ 🐋 👥] ;; more items
                         [[] ✔️ []] ;; empty list, return ✔️
                         ↔️] 🎒
                        [🗑️ 🗑️]
                        [•🗑️]
                        [▶️] 🪆]]
           [examples [[[[2 4 6] [even?] every? ▶️] [✔️] "Every number matches predicate"]
                      [[[2 4 5] [even?] every? ▶️] [🔳] "Not every number matches predicate"]
                      [[🔳 [🔳] every? ▶️] [✔️] "Every item in empty list matches any predicate"]
                      [[[2 4 6] 🔳 every? ▶️] [✔️] "Every item in list matches empty predicate"]
                      [[11 [2 4 6] [+ odd?] •🛡️ every? ▶️] [11 ✔️] "Can shield stack from predicate"]
                      [[12 [[even?] [positive?] [3 mod 0 =]] [▶️] •🛡️ every? ▶️] [12 ✔️] "Can check list of predicates with execute predicate"]]]]]

  [any? [[spec [[program sized] boolean]]
         [definition [[🔀]
                      [[📤] 🪄 👥 [float [•🛡️] dive] dive
                       🔳
                       [•🗑️ •🗑️]
                       [🗑️ any?] ⚖️]
                      [🗑️ 🗑️ 🔳] ⚖️]]
         [examples [[[[2 4 6] [even?] any?] [✔️] "Any number matches predicate"]
                    [[[3 5 7] [even?] any?] [🔳] "No number matches predicate"]
                    [[🔳 [✔️] any?] [🔳] "No item in empty list matches any predicate"]
                    [[[🔳 2 4 6] 🔳 any?] [2] "Empty predicate returns first truthy item"]
                    [[11 [3 5 6] [+ odd?] any?] [11 ✔️] "Stack is shielded from predicate"]
                    [[-15 [[even?] [positive?] [3 mod 0 =]] [▶️] any?] [-15 ✔️] "Can check list of predicates with execute predicate"]]]]]

  [map [[spec [[program] [program]]]
        [definition [[[🔀 1️⃣ •🛡️ 🪄 🔀 put] 🪜
                      🔳 sink ;; put empty results below list
                      ▶️]
                     🎒]]
        [examples [[[[1 2 3] [inc] map ▶️] [[2 3 4]] "Pass each item through a program"]

                   [[1 [1 2 3] [+] map ▶️] [1 [2 3 4]] "Program has access to rest of stack"]
                   [[7 9 [1 2 3] [+ *] map ▶️] [7 9 [70 77 84]] "Stack is shielded from mapping program"]
                   [[7 9 [1 2 3] [🗑️ 🗑️] map ▶️] [7 9 [7 7 7]] "Result of program can be lower stack items"]

                   [[7 9 [+] 🔳 map ▶️] [7 9 [+]] "Empty program is a no-op"]
                   [[[+] map [7 9 [1 2 3]] 🪄 ▶️] [7 9 [10 11 12]] "Create a map program and use later"]]]]]

  [filter [[spec [[program sized] [list]]]
           [definition [🛡️ ;; run the predicate with no stack effect
                        [🗑️ put] [🗑️] ⚖️ ;; if match, drop the pred result and put the original item in result list
                        ;; if not, just drop the original
                        🪜 
                        [1️⃣ 🔳 sink ▶️] 🎒]]  ;; place the empty result container beneath
           [examples [[[[1 2 3] [odd?] filter ▶️] [[1 3]] "Filter a list with predicate"]
                      [[[2 4 6] [odd?] filter ▶️] [🔳] "Filter with predicate that matches no items"]
                      [[33 [1 2 3] [33 + odd?] filter ▶️] [33 [2]] "Filter predicate uses existing stack items"]]]]]

  [sort [[spec [[program sized] [list]]]
         [definition [[👥 ✂️1️⃣ pair] 🎒
                      map ▶️ sort-indexed]]
         [examples [[[[1 3 2] 🔳 sort] [[1 2 3]] "Sort a list of numbers"]
                    [[["Carol" "Alice" "bob"] 🔳 sort] [["Alice" "Bob" "Carol"]] "Sort a list of strings"]
                    [[["Charlie" "Alice" "bob"] [count] sort] [["Bob" "Alice" "Charlie"]] "Sort list of strings by length"]]]]]

  [repeat [[spec [[[integer howmany]
                   item]
                  [list]]]
           [definition [🔳 sink [wrap [put] 🔗] 🪄 times]]
           [examples [[["hi" 3 repeat] [["hi" "hi" "hi"]] "Create a list of repeated items"]]]]]

  [indexed [[spec [[list] [list]]]
            [definition [[count] 🛡️ [0] 🪄 1 range 🔀 zip]]
            [examples [[[[a b c] indexed] [[[0 a] [1 b] [2 c]]] "Index a list"]]]]]

  [indexer [[spec [🔳 [program]]]
            [definition [0 [[generate] dive [[pair] •🛡️ [inc] 🪄] bail]]]
            [examples [[[[a b c] [indexer] assemble] [[[0 a] [1 b] [2 c]]] "Index a generator"]]]]]

  [indexof [[spec [[item list] [item]]]
            [definition [[indexer] 🪄
                         ;; use wrap so we can find index of words,
                         ;; otherwise the word gets ▶️d
                         [second wrap =] 🔀 wrap put [[•🔀] 🪄] 💉
                         keep generate first]]
            [examples [[[[[a b c] [📤] [c] unwrap indexof] 🛡️] [2] "Get the index of first matching item"]
                       [[[[a b c] [📤] [d] unwrap indexof] 🛡️] [🔳] "No matching item -> Nothing"]
                       [[[[a b c d c e] [📤] [c] unwrap indexof] 🛡️] [2] "Multiple matches returns index of first match"]]]]]

  [interpose [[spec [[item ordered] [ordered]]]
              [definition [🔳 flip
                           [🔀 pair 🔗 [pop] 🛡️] 🪜
                           🗑️ pop 🗑️]]
              [examples [[[[foo bar baz] "hi" interpose] [[foo "hi" bar "hi" baz]] "Interpose string between words"]
                         [[🔳 "hi" interpose] [🔳] "Empty list is a no-op"]
                         [[[foo] "hi" interpose] [[foo]] "Single item list is a no-op"]]]]]

  [starts? [[spec [[[ordered prefix] [ordered target]] [boolean]]]
            [definition [[[zip [unwrap =] every?] ;; the items at matching indexes are equal
                          [[count] both >=]] ;; the prefix is shorter than the target
                         [▶️] every? 
                         •🗑️ •🗑️]] ;; drop the originals
            [examples [[["abcd" "ab" starts?] [✔️] "String starts with matching string"]
                       [["abcd" "" starts?] [✔️] "String starts with empty string"]
                       [["" "ab" starts?] [🔳] "Empty string doesn't start with a string"]
                       [["abcd" "bb" starts?] [🔳] "String doesn't start with non-matching string"]
                       [[[1 2 3 4] [1 2] starts?] [✔️] "List starts with matching list"]]]]]

  [ends? [[spec [[ordered ordered] [boolean]]]
          [definition [[reverse] both starts?]]
          [examples [[["abcd" "cd" ends?] [✔️] "String ends with matching string"]
                     [["abcd" "" ends?] [✔️] "String ends with empty string"]
                     [["abcd" "bb" ends?] [🔳] "String doesn't end with non-matching string"]
                     [[[1 2 3 4] [3 4] ends?] [✔️] "List ends with matching list"]]]]]

  [pair [[spec [[item item] [list]]]
         [definition [[wrap] 🪄 put]]
         [examples [[[1 2 pair] [[1 2]] "Pair up two numbers into a list"]
                    [[["hi"] ["there" "foo"] pair] [[["hi"] ["there" "foo"]]] "Pair up two lists into a new list"]]]]]

  [pair? [[spec [[item] [boolean]]]
          [definition [[count 2 =] [🗑️ 🗑️ 🔳] 🩹]]
          [examples [[["ab" pair?] [✔️] "2-character string is a pair"]
                     [[[a b] pair?] [✔️] "2-item list is a pair"]
                     [["abc" pair?] [🔳] "3-character string is not a pair"]
                     [[🔳 pair?] [🔳] "Nothing is not a pair"]
                     [[7 pair?] [🔳] "Number is not a pair"]]]]]

  [triplet [[spec [[item item] [list]]]
            [definition [[pair] 🪄 put]]
            [examples [[[1 2 3 triplet] [[1 2 3]] "Make a 3-item list from 3 stack items"]
                       [[["hi"] ["there" "foo"] ["bar"] triplet] [[["hi"] ["there" "foo"] ["bar"]]] "Make a 3-item list from smaller lists"]]]]]

  [both? [[spec [[program item item] [boolean]]]
          [definition [sink pair 🔀 every?]]
          [examples [[[1 2 [odd?] both?] [🔳] "Test two items for predicate when not all match"]
                     [[1 3 [odd?] both?] [✔️] "Test two items for predicate when all match"]]]]]

  [both [[spec [[program [item a] [item b]] [item item]]]
         [definition [[pair] 🪄 🪜]]
         [examples [[[1 2 [inc] both] [2 3] "Run program on two stack items"]]]]]

  [walk [[spec [[[program item-transform] list] [list]]]
         [definition  [[🗑️ ✂️1️⃣] 🎒 ;; drop the result of the predicate which we won't want
                       [list? not] 🛡️ 🔀
                       [🔳 🔀]
                       [[🔗] 🔗 🪜 ▶️ wrap]
                       recur [unwrap] 🔗]]
         [examples [[[[1 2 [3 [4 5] 6]] [inc wrap] walk ▶️] [[2 3 [4 [5 6] 7]]] "Walk a nested list"]
                    [[[1 2 [3 [4 5] 6]] [👥 inc pair] walk ▶️] [[1 2 2 3 [3 4 [4 5 5 6] 6 7]]] "Walk a nested list and splice results"]]]]]

  [flatten [[spec [[list] [list]]]
            [definition [🔳 🔀 [list? ☯️] 🛡️ [🗑️ put] 🔳 [🪜 ▶️] recur]]
            [examples [[[[a b [c [d e] f] g] flatten ▶️] [[a b c d e f g]] "Flatten a nested list"]]]]]
#+end_src
*** Associations
#+begin_src kcats :tangle src/kcats/core/associations-builtins.kcats :mkdirp yes
  [get [[spec [[item sized] [item]]]
        [examples [[[[[a 3] [c 2]] [a] unwrap get] [3] "Get a key from an association"]
                   [[[10 11 12 13] 1 get] [11] "Get an item by index from a list"]
                   [["foobar" 3 get] [\b] "Get a character by index from a string"]
                   [["foobar" encode 3 get] [98] "Get an integer by index from a byte array"]
                   [[[[a 3] [c 2]] [b] unwrap get] [🔳] "Get a nonexistent key -> Nothing"]]]]]

  [assign [[spec [[[item value]
                   [list keys]
                   sized]
                  [association]]]
           [examples [[[[[a b] [c d]] [a] 5 assign]
                       [[[a 5] [c d]] association] "Assign a new value to an existing key"]

                      [[[[a b] [c d]] [e] 5 assign]
                       [[[a b] [c d] [e 5]] association] "Assign a new value to a new key"]

                      [[[[a b] [c [[d e]]]] [c d] 5 assign]
                       [[[a b] [c 🔳]] [c] [[d 5]] association assign] "Assign a new nested key, promoting to nested association"]

                      [[[[a b] [c [[d e]]]] [1 1 0] 5 assign]
                       [[[a b] [c [5]]]] "Assign a new index in a nested list"]

                      [[[1 2 3] [1 0 0] "foo" assign]
                       [[1 [["foo"]] 3]] "Assign a new index in a nested list"]

                      [[[[a [1 2 3]]] [a 0] 10 assign]
                       [[[a [10 2 3]]] association] "Assign a nested key in a mixed structure of association and list"]

                      [[[1 2 3] [1 2] "foo" assign]
                       [[1 [🔳 🔳 "foo"] 3]] "Assign an index creating placeholders for missing list items"]]]]]

  [unassign [[spec [[[item key] [sized into-association]] [association]]]
             [examples [[[[[a b] [c d]] [a] unassign]
                         [[[c d]] association] "Unassign a key from an association, promoting from list"]

                        [[[[a b] [c d]] [e] unassign]
                         [[[a b] [c d]] association] "Unassign a key that doesn't exist, only promotes"]

                        [[[[a b] [c d]] [e f] unassign]
                         [[[a b] [c d]] association] "Unassign multiple keys that don't exist only promotes"]

                        [[[[a b] [c [[d e] [f g]]]] [c x] unassign]
                         [[[a b]] [c] [[d e] [f g]] association assign] "Unassign multiple keys where last doesn't exist, only promotes"]

                        [[[[a [[b c] [d e]]]] [a d] unassign]
                         [🔳 association [a b] [c] unwrap assign] "Unassign associative keylist from nested structure, promoted to association"]

                        [[[0 1 2 [[a b] [c d]]] [3 c] unassign]
                         [[0 1 2] [[a b]] association put] "Unassign mixed keylist from nested structure, inner only is promoted to association"]]]]]

  [association? [[spec [[item] [boolean]]]
                 [examples [[[[[a b] [c d]] association association?] [✔️] "Association is an association"]
                            [[[[a b] [c d]] association?] [🔳] "A list is not an association, even if it's possible to promote"]
                            [[1 association?] [🔳] "A number is not an association"]
                            [[🔳 association?] [🔳] "An empty list is not an association"]
                            [[🔳 association association?] [✔️] "An empty association is an association"]
                            [[🔳 [a] 1 assign association?] [✔️] "A list promoted to association by assignment, is an association"]]]]]

  [association [[spec [[item] [association]]]
                [examples [[[[[a b] [c d]] association
                             [[c d] [a b]] association =]
                            [✔️] "A list can be promoted to association"]

                           [[[[a b] [c d]]
                             [[c d] [a b]] association =]
                            [🔳] "An association and list are not the same, even if keys/vals are the same"]

                           [[[[a b] [c d]]
                             [[a b] [c d]] association =] [🔳] "An association is not the same as the list it was promoted from"]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/associations.kcats :mkdirp yes
  ;; Associative words
  [update [[spec [[program [list keys] [sized into-association]]
                  [association]]]
           [definition [•🛡️
                        [lookup] 🛡️ 🪄
                        ▶️ assign]]
           [examples [[[[[a 1] [b 2]] [b] [inc] update]
                       [[[a 1] [b 3]] association] "Update a value in an association"]

                      [[[[a [[c 3] [d 5]]] [b 2]]
                        [a c] [inc] update
                        [a c] lookup]
                       [4] "Update a value in a nested association"]

                      [[[[a [1 3 5 7]] [b 2]]
                        [a 2] [inc] update]
                       [[[a [1 3 6 7]] [b 2]] association] "Update a value in a mixed association/list structure"]

                      [["hi"
                        [[a [[c 3] [d 5]]] [b 2]]
                        [a c] [🗑️ 🗑️ 10 15] update
                        [a c] lookup]
                       ["hi" 15] "Update function can't destroy stack items"]

                      [[[[a 1] [b 2]] [d] [5] update]
                       [[[a 1] [b 2] [d 5]] association] "Update creates new key when it doesn't exist"]

                      [[[[a [[c 3] [d 5]]] [b 2]]
                        [a e] [5 6 +] update
                        [a e] lookup]
                       [11] "Update function can ignore previous value"]]]]]

  [lookup [[spec [[[list keys] sized] [item]]]
           [definition [🔳 ;; keylist not empty
                        [📤 🔀 [get] 🪄] ;; extract the first key and lookup
                        while ▶️]]
           [examples [[[[[a b] [c d]] association [a] lookup] [[b] unwrap] "Lookup the value of a key in an association"]
                      [[[[a b] [c d]] [a] lookup] [[b] unwrap] "Lookup the value of a key, promoting a list to association"]
                      [[[[a b] [c d]] [e] lookup] [🔳] "Looking up a key that doesn't exist returns Nothing"]
                      [[[[outer [[a b] [c d]]]] [outer c] lookup] [[d] unwrap] "Lookup in a nested structure, with promotion"]]]]]

  ;; TODO: fix the case where you just want a value [[type foo]] - only
  ;; one item but you want the value, not key
  [type [[spec [[item] [item]]]
         [definition [[[[empty?] [[nothing] unwrap]]
                       [[word?] [[word] unwrap]]
                       [[number?] [[number] unwrap]]
                       [[string?] [[string] unwrap]]
                       [[bytes?] [[bytes] unwrap]]
                       [[pipe?] [[pipe] unwrap]]
                       [[error?] [[error] unwrap]]
                       [[environment?] [[environment] unwrap]]
                       [[set?] [[set] unwrap]]
                       [[association?] [[[[type] lookup]
                                         [[count 1 =]
                                          [[first [type] unwrap =]
                                           [first second]
                                           [first first]
                                           ⚖️]
                                          [🔳]
                                          ⚖️]
                                         [[association] unwrap]]
                                        [▶️] any?]]
                       [[list?] [[list] unwrap]]]
                      decide •🗑️]]
         [examples [[[[[foo 1]] association type] [[foo] unwrap] "An association with one key assumes it is its type"]
                    [[1 type] [[number] unwrap] "Integers are of type number"]
                    [[1.0 type] [[number] unwrap] "Floats are of type number"]
                    [[🔳 type] [[nothing] unwrap] "Empty list is of type nothing"]
                    [["foo" encode type] [[bytes] unwrap] "A byte array is of type bytes"]
                    [["foo" type] [[string] unwrap] "A string is of type string"]
                    [[[1 2 3] set type] [[set] unwrap] "A set is of type set"]
                    [[🔳 environment type] [[environment] unwrap] "An environment is of type environment"]
                    [[[[type foo]] association type] [[foo] unwrap] "An association with a single type key, the value is its type"]
                    [[[[type foo] [attr "blah"]] association type] [[foo] unwrap] "An association with a single type key, the value is its type"]
                    [[[[attr1 foo] [attr2 "blah"]] association type] [[association] unwrap] "An association with multiple keys and no type key, is of type association"]
                    [[[[type url] [value "http://foo.com"]] association type] [[url] unwrap] "An association with type/value keys, uses the type key for its type"]]]]]

  [value [[spec [[[sized into-association]] [item]]]
          [definition [[count 1 =] ;; if it's a single item
                       [first second] ;; the value is the value of that first item
                       [[value] lookup] ;; otherwise look up the key 'value'
                       ⚖️]]
          [examples [[[[[foo 1]] value] [1] "The value of a single-entry association is the value of the key-value pair"]

                     [[[[type url] [value "http://foo.com"]] value]
                      ["http://foo.com"] "The value of an object is the value key"]]]]]

  [zip [[spec [[[dispenser values] [dispenser keys]] [list]]]
        [definition [🔳 sink ;; save accumulator below args
                     [[something?] both?] ;; stop when either list is empty
                     [[📤] both •🔀 pair ;; take from each list and pair them up
                      sink [put] •🪄] ;; put them into the accumulator
                     while
                     🗑️ 🗑️]] ;; drop the empty containers
        [examples [[[[a b c] [1 2 3] zip] [[[a 1] [b 2] [c 3]]] "Zip two lists together into a single list of pairs"]
                   [[[a b c d] [1 2 3] zip] [[[a 1] [b 2] [c 3]]] "Zip two lists of unequal size pads with Nothing values"]]]]]

  [label [[spec [[[sized labels]] [association]]]
          [definition [🔳 🔀 ;; labels acc
                       [wrap float assign] 🪜 ▶️]]
          [examples [[["Alice" 23 "123 Main St" [address age name] label]
                      [[[address "123 Main St"]
                        [age 23]
                        [name "Alice"]] association]
                      "Label values on the stack as an association"]]]]]
#+end_src

*** Sets
#+begin_src kcats :tangle src/kcats/core/sets-builtins.kcats :mkdirp yes
  ;; TODO add 'set' type for spec?
  [set [[spec [[item] [item]]]
        [examples [[[[1 2 3 1 2 3] set] [[1 2 3] set] "Promote a list to a set"]
                   [["hello" set] ["helo" set] "Promote a string to a set"]]]]]

  [set? [[spec [[item] [boolean]]]
         [examples [[[[1 2 3] set set?] [✔️] "A set is a set"]
                    [[[1 2 3] set?] [🔳] "A list is not a set"]]]]]

  [contains? [[spec [[item [item container]] [boolean]]]
              [examples [[[[1 2 3] 3 contains?] [✔️] "List contains a number"]
                         [[[1 2 3 3 5] set 3 contains?] [✔️] "A set contains a number"]
                         [[[1 2 3] 4 contains?] [🔳] "A list doesn't contain a number"]
                         [[5 3 contains?] [🔳] "A number is atomic and doesn't contain anything"]
                         [[[foo] unwrap \o contains?] [🔳] "A word is atomic and doesn't contain anything"]
                         [["food" "foo" contains?] [✔️] "A string contains a sub-string"]
                         [[[a b c d] [b c] contains?] [🔳] "A list doesn't contain a sub-list (due to ambiguity with what 'contains' means with lists)"]
                         [[[a [b c] d] [b c] contains?] [✔️] "A list contains another list"]
                         [[[a [b c] d] set [b c] contains?] [✔️] "A set contains a list"]
                         [["food" \o contains?] [✔️] "A string contains a character"]]]]]

  [intersection [[spec [[sized sized] [sized]]]
                 [examples [[[[1 2 3] [2 3 4] intersection] [[2 3] set] "Intersection of two lists expressed as set"]]]]]

#+end_src

*** Generators
#+begin_src kcats :tangle src/kcats/stdlib/generators.kcats :mkdirp yes
  ;; infinite sequence (generators) functions

  [[liberate [[spec [🔳 [program]]]
              [definition [[📤] 🔳 🔳 [🔀] 🪆]]]]

   ;; DEPRECATED
   [prime [[spec [[[program body]
                   [program pred]
                   [program init]]
                  [*]]]
           [definition [[👥 [▶️] 🪄] divedown 🔗 while]]
           [examples [[[0 [1 2 3 4] [📤] 🔳 [🔀 [+] 🪄] prime 🗑️ 🗑️] [10]
                       "Prime ▶️s init before each time through the loop"]]]]]


   [🧹 [[spec [[sized program] [program]]]
          [definition [[[1️⃣ 🐋] 🎒] 🪄 🔀
                       [📮 •🗑️] 🔳 [▶️] 🪆]]
          [examples [[[[\a \b \c \d] liberate "" 🧹 ▶️]
                      ["abcd"] "Sweep into an empty string"]
                     [[0 10 1 range liberate
                       5 dropper
                       [10 *] each
                       🔳 🧹 ▶️]
                      [[50 60 70 80 90]] "Generate a sequence and put it into the given container"]]]]]

   [collect [[spec [[program] [list]]]
             [definition [🔳 🧹 ▶️]]
             [examples [[[[[1 2 3 4] liberate collect] 🛡️]
                         [[1 2 3 4]]]
                        [[[0 10 1 range liberate
                           5 dropper
                           [10 *] each
                           collect]
                          🛡️]
                         [[50 60 70 80 90]] "Collect from a generator into an empty list"]]]]]

   [each [[spec [[program] [program]]]
          [definition [•🛡️ [✂️2️⃣ 1️⃣ bail] 🎒
                       [•🗑️] [🔳] [🔀] 🪆]] ;; execute the generator below. If we get a value,
                                             ;; execute the provided program on that value,
                                             ;; dropping the parent generator
          [examples [[[[1 2 3 4]
                       [[👥 *] each]
                       assemble]

                      [[1 4 9 16]] "Generate a sequence transforming each value"]]]]]

   [joiner [[spec [[] [program]]]
            [definition [[generate 🔳 🔀
                          🔳
                          [🔗
                           [generate] dive]
                          while 🗑️]]]
            [examples [[[[[1 2 3] [4 5 6] [7 8 9]]
                         [joiner]
                         assemble]

                        [[[1 2 3 4 5 6 7 8 9]]]]]]]]

   [taker [[spec [[] [program]]]
           [definition [[[[positive?] 🛡️ ;; counter still positive?
                          [🗑️ 1️⃣ 🐋]  ;; run the parent generator
                          [[]] ⚖️ ▶️] 🎒] 🐋 ;; otherwise return nothing
                        [[dec •🗑️] 🪄] ;; dec counter, discard parent generator 
                        [🗑️ []] ;; discard the counter, all done
                        [🔀] 🪆]]
           [examples [[[[1 2 3 4 5] liberate
                        3 taker
                        collect]

                       [[1 2 3] [4 5]]]]]]]

   [catcher [[spec [[] [program]]]
             [definition [[[generate] dive
                           [[[👥] dive ▶️] bail ☯️]
                           [🗑️ 🔳]
                           when]]]
             [examples [[[[1 2 3 -4 5]
                          [[positive?] catcher]
                          assemble]

                         [[1 2 3]]]]]]]

   [dropper [[spec [[] [program]]]
             [definition [[[[positive?]
                            [[generate 🗑️] 🪄 dec]
                            while
                            [generate 🔀] 🪄 float]
                           bail]]]
             [examples [[[[1 2 3 4 5]
                          [3 dropper]
                          assemble]

                         [[4 5]]]]]]]

   [skipper [[spec [[] [program]]]
             [definition [🔳 ;; the state (whether threshold reached)
                          [🔳 ;; condition - whether we've finished dropping or not
                           [[generate] divedown] ;; true - pass everything else through
                           ;; false - generate, check pred, repeat
                           [[[generate] divedown] ;; prime init
                            [[[👥] divedown ▶️] bail] ;; bring pred up and exec it
                            [🗑️] ;; if pred passes drop the value
                            prime ;; after this should have value on top
                            [🗑️ true] 🪄]
                           ⚖️]]]
             [examples [[[[1 2 -3 4 5]
                          [[positive?] skipper]
                          assemble]

                         [[-3 4 5]]]]]]]

   [keep [[spec [[program] [program]]]
          [definition [[[▶️ ;; ▶️ the generator below to get value v
                         [1️⃣ 🛡️ ▶️ ☯️] ;; check if v does NOT match given pred, 
                         [🔳 🔳] ;; if generator below is finished, return 2 empty values 
                         ↔️]
                        [🗑️ 🗑️] ;; drop both the value v and the result of pred
                        ⏳ ▶️] ;; repeat until generator below is finished
                       🎒
                       🔳 [🔳] [🔀] 🪆]]
          [examples [[[[1 2 3 4 5]
                       [[odd?] keep]
                       assemble]

                      [[1 3 5]]]]]]]

   [group [[spec [[[program group-by]] [association]]]
           [definition [[1️⃣ 🛡️ ;; k v state
                         wrap 🔀  ;;  v k state
                         wrap [put] 🔗 update] 🎒
                        🔳 association ;; state f
                        🔀 cram]]
           [examples [[[[[1 2 3 4] liberate [odd?] group] 🛡️]
                       [[[✔️ [1 3]] [🔳 [2 4]]] association]]]]]]

   [split [[spec [[sized] [program sized sized]]]
           [definition [[empty] [divedown 🛡️] decorated
                        [[[generate] divedown [👥 [put] 🪄] bail]
                         [[🔳 [🗑️ 🔀 ends? ☯️]] [▶️] every?]
                         [🗑️] prime
                         🗑️
                         [🔀 ends?]
                         [[[count] 🛡️] dive
                          [[count] 🛡️] dive 🔀 - [0] 🪄 slice]
                         when
                         [empty] 🛡️ 🔀]]]
           [examples [[["abcabc" ["b" split] assemble]
                       [["a" "ca" "c"]]]
                      [[[1 2 3 4 2 5] [[2] split] assemble]
                       [[[1] [3 4] [5]]]]]]]]

   [parse [[spec [[[program partial-parser] [[program parser]]]]]
           [doc "A stream parser. On the stack should be a program that takes 2 args:
                 unparsed input sequence, and parsed object output sequence. The function should
                 return a new input and output sequence, with the input no larger, and
                 output no smaller than before. The function can also no-op if there isn't
                 enough input to parse a complete object."]
           [definition [[🔳 🔳 ;; state - parsed object output and unparsed input
                         [[🔀 ☯️] ;; if there's nothing in the output, 
                          [[[generate] divedown] ;;generate input from parent
                           [[🔳 [🔀 ☯️]] [▶️] every?] ;; as long as the parent generates
                                                              ;; and there's no output
                           [🔗 ✂️1️⃣] prime
                           ;; we may have bailed out of the loop either because the parent is done,
                           ;; or there's output. If there was output, join the remaining input to
                           ;; what was already there
                           🔳 [🔗 ✂️1️⃣] when] ;; generate until either we have output,
                                               ;; or the parent returned nothing
                          when
                          [📤] dive]] ;; Generate a parsed output item
                        🎒 ▶️]]
           [examples [[[[[[104 101 108 108 111]              ;; "hello" (all ASCII)
                          [228 189 160 229 165 189]          ;; "你好" (two complete Chinese chars)
                          [104 105 226]                      ;; "hi" + start of "€"
                          [130 172]                          ;; completion of "€"
                          [240 159 145]                      ;; start of "👑"
                          [145]                              ;; completion of "👑"
                          [97 98 99 240]                     ;; "abc" + start of "🌈"
                          [159 140 136]]                     ;; completion of "🌈"

                         [#b64 "" 🔀 [put] 🪜] map ;; convert lists of ints to byte arrays

                         [📤] [parse-utf8]
                         parse "" into] 🛡️]
                       ["hello你好hi€👑abc🌈"]]

                      [[[["[foo] [bar] [ba"
                          "z] [quux"
                          "] [[this] "
                          "[that]]"
                          "[foo" "]"] [📤]
                         [parse-edn] parse collect]
                        🛡️]
                       [[[foo] [bar] [baz] [quux] [[this] [that]]
                         [foo]]]]]]]]

   [combinations [[spec [[] [program]]]
                  [definition [[count] 🛡️ -1 ;; l idx i
                               [[[🔀 count =] dive] [🗑️ 🗑️ 📤 0 🔀] when
                                [[wrap lookup] dive [pair] bail] 🛡️ [inc] •🪄]]]
                  [examples [[[[1 2 3] [combinations] assemble] [[[1 2] [1 3] [2 3]]]]]]]]

   [frequencies [[spec [[] [association]]]
                 [definition [🔳 association
                              [wrap [🔳 [inc] [1] ⚖️] update]
                              cram]]
                 [examples [[[["Hello there!" [📤] frequencies] 🛡️]
                             [[[\space 1]
                               [\! 1]
                               [\H 1]
                               [\e 3]
                               [\h 1]
                               [\l 2]
                               [\o 1]
                               [\r 1]
                               [\t 1]] association]]]]]]

   [fold [[spec [[[program reducing-function] [program generator]] [item]]]
          [definition [[[generate] dive 🔳 [✂️1️⃣ 👥] when] 🎒
                       ;; generate the first item under the loop body
                       [generate 👥] 🪄
                       loop]]
          [examples [[[[integers 1 dropper 10 taker [+] fold] 🛡️] [55]]]]]]

   [cram [[spec [[[program reducing-function]
                  [item initial-value]
                  [program generator]] [item]]]
          [definition [[[generate] dive]
                       🔳
                       float prime 🗑️]]
          [examples [[[[integers 1 dropper 10 taker 0 [+] cram] 🛡️] [55]]]]]]



   [integers [[spec [[] [program]]]
              [definition [-1 [inc 👥]]]]]]
  🔗
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/more-generators.kcats :mkdirp yes
    ;; partition
    [🔳 [program]] ;; the spec
    ;; construct the dynamic definition for partition

    [[take-chunk [[taker collect
                   •🗑️ •🗑️] ; drop the used-up taker generator
                  🔗 divedeep]]
     [shift [[[count <=]
              [🔀 0 slice]
              [🔳] ⚖️] 🛡️ 🔀]]]
    [🔳
     [over wrap take-chunk [🔗 shift] bail]
     [[over] dive wrap take-chunk 🔀 🗑️ shift]
     ⚖️] let 
    ;; add an empty list for the partition state
    [🔳] 🔀 put ;; the definition

    [[[[1 2 3 4 5 6 7] [2 2 partition] assemble]
      [[[1 2] [3 4] [5 6] [7]]]]] ;; examples

    [examples definition spec] label [partition] 🔀 assign
    [[pairwise [[spec [[program] [*]]]
                [definition [[🔳 evert ;; capture stack
                              [2 2 partition] assemble] 🪄 ;; pair up stack items
                             💉 ;; run the program on the pairs
                             [joiner] assemble ;; unpair the items
                             unwrap 🔳 🔀 evert 🗑️]] ;; restore as the stack
                [examples [[[1 2 3 4 5 [🔀] pairwise] [1 4 5 2 3]]
                           [[1 2 3 4 5 [float] pairwise] [2 3 4 5 1]]
                           [[1 2 3 4 5 [[[+] 💉] both] pairwise] [1 5 9]]]]]]]
    🔗
#+end_src

** Dictionary modules
#+begin_src kcats :tangle src/kcats/core/dictionary-builtins.kcats :mkdirp yes
  [dictionary [[spec [🔳 [list]]]]]

  [cache [[spec [[item bytes] [bytes]]]]]

  [decache [[spec [[item] [bytes]]]]]

  [hashbytes [[spec [[bytes] [bytes]]]
              [examples [[[["foo" encode hashbytes] 2 times =] [✔️]]
                         [["foo" encode hashbytes
                           "fop" encode hashbytes
                           =]
                          [🔳]]]]]]

  [resolve [[spec [[word] [word]]]]]

  [dictmerge [[spec [[[dictionary module] [dictionary original] [bytes hash]] [dictionary]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/dictionary.kcats :mkdirp yes
  [updates [[spec [[[sized word-updates]] [[program single-update]]]]
            [definition [[[📤]
                          [[0] [wrap] update ;; wrap the word name to get a path to update
                           [update] 🔗] each
                          joiner generate] •🛡️]]]]

  [entry [[spec [[[program definition]] [[association full-entry]]]]
          [definition [[definition] label]]]]

  [words [[spec [🔳 [association]]]
          [definition [dictionary [words] lookup]]]]

  [module [[spec [[[item wrapped-module-alias-or-hash]] [program]]]
           [doc "reads a cached module from disk and puts it on the stack as a program"]
           [definition [decache string read]]
           [examples [
            [["123" encode [crypto] stdmod [hash] confine]
             [#b64 "_1vRbfFezlcTCUfQCjC1FKukWLoOAeBuvxNXUDbFKSk"]]]]]]

  [inscribe [[spec [[[bytes raw-module] dictionary] [dictionary]]]
             [definition [[[hashbytes] ;; calculate module hash
                           [string read ▶️]] ;; install the module in the dictionary
                          [▶️] map ;; fork 
                          •🗑️ unwrap •🔀 dictmerge]]]]

  [draft [[spec [[[sized definitions]] [[program dictionary-updater]]]]
          [definition [[[1] [entry] update] map ;; create full entries for each definition
                       wrap [🔗] 🔗]]]]  ;; add 'join' to join the entries with the existing dictionary

  [let [[spec [[program [sized entries]] [*]]]
        [definition [[draft dictionary 🔀 [emit encode hashbytes] 🛡️
                      [[[words] 🔀 update] 🛡️ •🗑️] 🪄
                      sink [dictmerge] ••🛡️] 🪄
                     float wrap [put] 🔗
                     •🔀 [modules] 🔀 update
                     [dictionary program] label environment
                     ;; TODO try using confine here
                     [1️⃣ capture evaluate [stack] lookup restore] 🎒]] 
        [examples [[[[[times5 [5 *]]
                      [doubledec [dec dec]]]
                     [3 times5 doubledec] let ▶️] [13]]
                   [[[[🔀 [5]]]
                     ["a" "b" "c" 🔀]
                     let ▶️]
                    ["a" "b" "c" 5]]
                   [[[[foo ["outer"]]]
                     ["inner"] let
                     [foo] label
                     [foo] let ▶️] ["inner"]]]]]]

  [definition [[spec [[list] [program]]]
               [definition [[words ✂️1️⃣ definition] 🎒 dictionary 🔀 lookup]]
               [examples [[[1 2 3 [flip] definition ▶️] [3 2 1] "Fetch the definition of a word and use it"]]]]]
#+end_src
** Math
#+begin_src kcats :tangle src/kcats/core/math-builtins.kcats :mkdirp yes
  [+ [[spec [[number number] [number]]]
      [examples [[[1 2 +] [3]]
                 [[1.1 2.2 + 3.3 0.001 within?] [✔️]]
                 [[1 2.2 +] [3.2]]]]]]

  [- [[spec [[number number] [number]]]
      [examples [[[2 1 -] [1]]
                 [[1.1 2.2 - -1.1 0.00001 within?] [✔️]]
                 [[2.2 1 - 1.2 0.00001 within?] [✔️]]]]]]

  [* [[spec [[number number] [number]]]
      [examples [[[4 3 *] [12]]
                 [[10 1.5 * 15 0.0001 within?] [✔️]]
                 [[5 0 *] [0]]
                 [[5 -1 *] [-5]]]]]]

  [/ [[spec [[number number] [number]]]
      [examples [[[12 3 /] [4]]
                 [[15 1.5 /] [10.0]]
                 [[0 1 /] [0]]
                 [[1 0 / handle [reason] lookup] [1 0 "division by zero"]]]]]]

  [quot [[spec [[number number] [number]]]
         [examples [[[16 5 quot] [3]]]]]]

  [rem [[spec [[number number] [number]]]
        [examples [[[17 5 rem] [2]]]]]]

  [mod [[spec [[number number] [number]]]
        [examples [[[17 5 mod] [2]]]]]]

  [exp [[spec [[number number] [number]]]
        [examples [[[2 5 exp] [32]]]]]]

  [log [[spec [[number number] [number]]]
        [examples [[[32 2 log] [5]]]]]]

  [floor [[spec [[number] [number]]]
          [examples [[[2.1 floor] [2]]]]]]

  [ceiling [[spec [[number] [number]]]
            [examples [[[2.1 ceiling] [3]]]]]]

  [round [[spec [[number] [number]]]
          [examples [[[2.1 round] [2]]]]]]

  [sqrt [[spec [[number] [number]]]
         [examples [[[9 sqrt] [3]]
                    [[81 sqrt] [9]]]]]]

  [inc [[spec [[number] [number]]]
        [examples [[[1 inc] [2]]
                   [[-1 inc] [0]]
                   [[99 inc] [100]]]]]]

  [dec [[spec [[number] [number]]]
        [examples [[[2 dec] [1]]
                   [[0 dec] [-1]]
                   [[100 dec] [99]]]]]]

  [abs [[spec [[number] [integer]]]
        [examples [[[2.1 abs] [2.1]]
                   [[-0.2 abs] [0.2]]
                   [[-2 abs] [2]]
                   [[0 abs] [0]]]]]]

  [odd? [[spec [[number] [boolean]]]
         [examples [[[1 odd?] [✔️]]
                    [[-1 odd?] [✔️]]
                    [[4 odd?] [🔳]]]]]]

  [even? [[spec [[number] [boolean]]]
          [examples [[[2 even?] [✔️]]
                     [[-2 even?] [✔️]]
                     [[3 even?] [🔳]]]]]]

  [zero? [[spec [[number] [boolean]]]
          [examples [[[0 zero?] [✔️]]
                     [[0.0 zero?] [✔️]]
                     [[-0.00001 zero?] [🔳]]
                     [[1.1 zero?] [🔳]]]]]]

  [number? [[spec [[item] [boolean]]]
            [examples [[[[1] number?] [🔳]]
                       [[🔳 number?] [🔳]]
                       [[5 number?] [✔️]]
                       [[5.01 number?] [✔️]]]]]]

  [number [[spec [[item] [number]]]
           [examples [[["12" number] [12]]
                      [["-11.1" number] [-11.1]]
                      [["a" first number] [97]]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/math.kcats :mkdirp yes
  [positive? [[spec [[number] [boolean]]]
              [definition [0 >]]]]

  [negative? [[spec [[number] [boolean]]]
              [definition [0 <]]]]

  [within? [[spec [[number number] [boolean]]]
            [definition [[- abs] 🪄 <]]
            [examples [[[1.0 2.0 + 3 0.001 within?] [✔️]]]]]]
#+end_src
** Serialization
#+begin_src kcats :tangle src/kcats/core/serialize-builtins.kcats :mkdirp yes
  [read [[spec [[string] [item]]]
         [examples [[["[1 [2] 3]" read] [[1 [2] 3]]]]]]]

  [emit [[spec [[item] [string]]]
         [examples [[[[1 [2] 3] emit] ["1 [2] 3"]]]]]]

  [parse-edn [[spec [[[string input-to-parse] [list current-output-sequence]]
                     [[string remaining-input] [list updated-output-sequence]]]]
              [examples [[[🔳 "[foo] [ba" parse-edn] [[[foo]] " [ba"]]]]]]

  [autoformat [[spec [[string] [string]]]
               [examples [[["[[foo bar] [baz [[quux floop] [toop zoop]]]]" autoformat]
                           ["[[foo bar]\n [baz [[quux floop]\n       [toop zoop]]]]"]]]]]]
#+end_src
** Boolean logic
#+begin_src kcats :tangle src/kcats/core/boolean-builtins.kcats :mkdirp yes
  [✔️ [[spec [🔳 [word]]]]] ;; self-inserts

  [and [[spec [[item item] [item]]]
        [examples [[[1 odd? 2 even? and] [✔️]]
                   [[2 3 and] [3]]
                   [[🔳 3 and] [🔳]]
                   [["" 3 and] [🔳]]]]]]

  [or [[spec [[item item] [item]]]
       [examples [[[1 odd? 3 even? or] [✔️]]
                  [[1 2 or] [1]]
                  [[🔳 2 or] [2]]
                  [[🔳 🔳 or] [🔳]]]]]]

  [☯️ [[spec [[item] [boolean]]]
      [examples [[[1 even? ☯️] [✔️]]
                 [[🔳 ☯️] [✔️]]
                 [[✔️ ☯️] [🔳]]
                 [[🔳 ☯️] [✔️]]]]]]
#+end_src
** Byte encoding and decoding
#+begin_src kcats :tangle src/kcats/core/encode-builtins.kcats :mkdirp yes
  [encodestring [[spec [[string] [bytes]]]
                 [examples [
                  [["foo" encodestring] [#b64 "Zm9v"]]
                  [["" encodestring] [#b64 ""]]]]]]

  [encodenumber [[spec [[number] [bytes]]]
                 [examples [[[12 encodenumber] [#b64 "AAAAAAAAAAw"]]
                            [[12.3 encodenumber] [#b64 "QCiZmZmZmZo"]]]]]]

  [decodejson [[spec [[string] [item]]]
               [examples [[["12" decodejson] [12]]
                          [["12.01" decodejson] [12.01]]
                          [["\"foo\"" decodejson] ["foo"]]
                          [["{\"foo\": 12, \"bar\": \"baz\"}" decodejson] [[["foo" 12] ["bar" "baz"]] association]]
                          [["[1,\"foo\"]" decodejson] [[1 "foo"]]]]]]]

  [encodejson [[spec [[item] [string]]]
               [examples [[[12 encodejson] ["12"]]
                          [[12.01 encodejson] ["12.01"]]
                          [["foo" encodejson] ["\"foo\""]]
                          [[[["foo" 12] ["bar" "baz"]] association encodejson decodejson] [[["foo" 12] ["bar" "baz"]] association]]
                          [[[1 "foo"] encodejson] ["[1,\"foo\"]"]]]]]]

  [bytes? [[spec [[item] [boolean]]]
           [examples [[["foo" bytes?] [🔳]]
                      [[#b64 "Zm9v" bytes?] [✔️]]
                      [[[#b64 "Zm9v"] bytes?] [🔳]]
                      [["foo" encode bytes?] [✔️]]]]]]

  [xor [[spec [[item] [item]]]
        [examples [[[10 12 xor] [6]] ;; 10 = 01010, 12 = 01100, 00110, 6
                    [["foo" encode "bar" encode xor] [#b64 "BA4d"]]]]]]

  [bits [[spec [[item] [sized]]]
         [definition [encode [[2 radix 8 0 pad] each joiner] assemble unwrap]]
         [examples [[["foo" bits] [[0 1 1 0 0 1 1 0 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 1]]]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/encode.kcats :mkdirp yes
  [[encode [[spec [[item] [bytes]]]
            [definition [[[[bytes?] [🗑️]]
                          [[string?] [🗑️ encodestring]]
                          [[number?] [🗑️ encodenumber]]
                          [[true] [🗑️ emit encode]]]
                         decide]]
            [examples [[[12 encode] [#b64 "AAAAAAAAAAw"]]
                       [["foo" encode] [#b64 "Zm9v"]]
                       [["foo" encode encode] [#b64 "Zm9v"]]
                       [["" encode] [#b64 ""]]]]]]

   [radix [[spec [[integer integer] [list]]]
           [definition [[[/] 🛡️ 🔀
                         [*] •🛡️
                         •🔀 -
                         🔀 [prepend] 🪄]
                        🔀 prepend
                        [🔳 🔀 [positive?]] 🪄
                        while 🗑️]]
           [examples [[[7 2 radix] [[1 1 1]]]
                      [[9 3 radix] [[1 0 0]]]
                      [[255 16 radix] [[15 15]]]]]]]]
  🔗
#+end_src
** Strings
#+begin_src kcats :tangle src/kcats/core/strings-builtins.kcats :mkdirp yes
  [string [[spec [[item] [string]]]
           [examples [[[1 string] ["1"]]
                      [[[1 2 3] string] ["[1 2 3]"]]
                      [[🔳 string] [""]]]]]]

  [format [[spec [[list string] [string]]]
           [examples [[["foo {} bar {} baz" ["abc" "def"] format] ["foo abc bar def baz"]]]]]]

  [parse-utf8 [[spec [[[bytes input] [sized current-output]]
                      [[bytes remaining-input] [string updated-output-sequence]]]]
               [examples [[["" #b64 "aGni" parse-utf8] ["hi" #b64 "4g"]]
                          [["" #b64 "aGVsbG8" parse-utf8] ["hello" #b64 ""]]]]]]

  [string? [[spec [[item] [boolean]]]
            [examples [[["hi" string?] [✔️]]
                       [["" string?] [✔️]]
                       [[["hi"] string?] [🔳]]
                       [[✔️ string?] [🔳]]]]]]

  ;; Don't really belong here but good enough for now
  [word? [[spec [[item] [boolean]]]
          [examples [[[[foo] unwrap word?] [✔️]]
                     [[✔️ word?] [✔️]]
                     [[1 word?] [🔳]]
                     [["✔️" word?] [🔳]]]]]]

  [word [[spec [[item] [word]]]
         [examples [[["foo" word] [[foo] unwrap]]]]]]

  [inspect [[spec [[item] [string]]]]]
#+end_src
** Emoji aliases
These are emoji aliases for some commonly used standard
functions. They are totally optional, in that you can always use the
english function name instead.

There are no specs or examples for these, because the functions they
alias handle all that. Where the connection between the icon and the
function isn't obvious, the doc explains.
#+begin_src kcats :tangle src/kcats/core/emoji.kcats :mkdirp yes

    ;  [☯️ [[definition [not]]]]

    ;  [▶️ [[definition [execute]]]]

      [🌀 [[definition [loop]]]]

  ;   [↔️ [[definition [branch]]]]

    ;  [⚖️ [[definition [if]]
        ;  [doc ":scales: Goes one way or another depending on the conditions"]]]

      ;[🪄 [[definition [dip]]
      ;     [doc ":magic_wand: makes an item disappear for the duration of the program, then reappear"]]]

      [•🪄 [[definition [dipdown]]]]

      [••🪄 [[definition [dipdeep]]]]

      [🐋 [[definition [dive]]
           [doc ":whale: dives down, runs program, brings result to surface"]]]

      [•🐋 [[definition [divedown]]]]

      [••🐋 [[definition [divedeep]]]]

      [⏳ [[definition [while]]]]

     ; [🛡️ [[definition [shield]]]]

      ;[•🛡️ [[definition [shielddown]]]]

      ;[••🛡️ [[definition [shielddeep]]]]

      ;[🔀 [[definition [swap]]]]

      ;[•🔀 [[definition [swapdown]]]]

      ;[••🔀 [[definition [swapdeep]]]]

      [🚜 [[definition [map]]
           [doc ":tractor: Uses a given attachment to perform the same action on each row of a field"]]]

      [🧲 [[definition [filter]]
           [doc ":magnet: Separates one kind of material from the rest"]]]

      [🪆 [[definition [recur]]
           [doc ":nesting_dolls: Each successive doll gets smaller, similar to how recursion breaks problems down into smaller bits"]]]

      ;[👥 [[definition [clone]]]]

      ;[•👥 [[definition [clonedown]]]]

      ;[••👥 [[definition [clonedeep]]]]

      ;[🗑️ [[definition [drop]]]]

      ;[•🗑️ [[definition [dropdown]]]]

      [••🗑️ [[definition [dropdeep]]]]

      ;[📤 [[definition [take]]]]

      [📮 [[definition [put]]]]

      ; [🔗 [[definition [join]]]]

      ; [🪜 [[definition [step]]]]

      [🎁 [[definition [wrap]]]]

      [🍫 [[definition [unwrap]]]]

      [🛟 [[definition [float]]]]

      [⚓ [[definition [sink]]]]

      [🎀 [[definition [decorate]]]]

      [💯 [[definition [every?]]]]

      [📣 [[definition [any?]]
           [doc ":mega: If any sound is made, amplifies it to full sound. Similar to how 'any?' will make the truthy result i any of the components are truthy"]]]

     ; [💉 [[definition [inject]]]]

     ; [🎒 [[definition [pack]]]]

      [📸 [[definition [[snapshot]]]]]

      [🩹 [[definition [recover]]]]
#+end_src
** Error handling
#+begin_src kcats :tangle src/kcats/core/errors-builtins.kcats :mkdirp yes
  [error? [[spec [[item] [boolean]]]]]

  ;; handle is a special word only used to unwind the program on
  ;; error, if there's no error and we end up reaching this word, we
  ;; ignore it.
  [handle [[spec [[] []]]
           [definition []]]]

  [fail [[spec [[sized] [*]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/errors.kcats :mkdirp yes
  [[assert [[spec [[program]
                   [*]]]
            [definition [snapshot ;; save stack to print in err message
                         [🛡️] dive ;; run the assertion under the saved stack
                         [🗑️] ;; if passes, drop the saved stack, dont need
                         [string ["assertion failed "] 🪄 🔗 fail] ;; else throw err
                         branch]]]]

   [🩹 [[spec [[[program error-handler] [program to-attempt]] [program]]]
             [definition [[[snapshot] 🐋
                           🔀 [handle] 🔗 💉 ▶️ 
                           [first error?] 🛡️
                           [🗑️ first ✂️1️⃣]
                           [evert 🗑️]
                           ⚖️ ▶️] 🎒]]
             [examples [[[[+]
                          [🗑️ 1
                           [+] [🗑️ 2 +]
                           🩹 ▶️]
                          🩹 ▶️]
                         [3]]

                        [[[1 2 "oh fudge"]
                          [5 +]
                          [🗑️ 5]
                          🩹
                          [🎁] 🪄 🔗 ;; curry the mapping function too
                          🚜 ▶️]
                         [[6 7 5]]]

                        [[[🔀] [🗑️ 🔀] 🩹 ▶️]
                         [🔀]]]]]]

   [retry [[spec [[error] [*]]]
           [definition [[unwound] lookup
                        ▶️]]
           [examples [[[2 3 "four" * + handle [🗑️ 4] 🪄 retry] [14]]]]]]]
  🔗
#+end_src
** Methods
We want a way of adding methods to a word that's already set up as a
simple 'decide' form. This will add the method at the beginning -
adding it at the end is not good because often there's a catchall
condition at the end, and adding beyond that means the new condition
is unreachable. Adding at the beginning is not always what the user
wants either, though. So maybe this could be improved by taking
another argument: a program to combine the item and the existing list
(that defaults to =prepend= here).
#+begin_src kcats :tangle src/kcats/stdlib/methods.kcats :mkdirp yes
  [[addmethod [[spec [[[program method] [program condition] [program definition]]
                      [[program newdefinition]]]]
               [definition [[[2️⃣ 1️⃣] prepend] 🎒
                            [0] 🔀 update]]
               [examples [[[[[[[count 3 >] ["foo" put]]
                              [[☯️] ["bar" put]]] decide]
                            [count 1 =] [rest] addmethod]

                           [[[[[count 1 =] [rest]]
                              [[count 3 >] ["foo" put]]
                              [[☯️] ["bar" put]]]
                             decide]]]]]]]

   [method? [[spec [[program] [boolean]]]
             [definition [[[first [[pair?]
                                   [[list?] every?]] every?]
                           [second [decide] unwrap =]]
                          every?]]]]]
  🔗
#+end_src
** Database
#+begin_src kcats :tangle src/kcats/stdlib/database.kcats :mkdirp yes
  [[[list selection] [list constraints]]
   [string]]

  [[fork [[▶️] map]]
   [triangle [[🔳 [[📤] 🪄 🔀 [[put] 🛡️ sink 🔀 pair] bail] collect] •🛡️]]
   [indexed-as-property [🔀 indexed
                         [unwrap sink assign] map •🗑️]]
   [join-all [[first empty] 🛡️ 🔀 [🔗] 🪜]]
   [selectkeys [set [1️⃣ [first] dive contains?] 🎒 filter]]
   [invert [[reverse] map association]]

   ;; datalog variables
   [variable? [[[word?]
                [string last \? =]] [▶️] every?]]
   [variable= [[[pair [variable?] every?] [=]] [▶️] every?]] 

   ;; datalog constraints
   [slots [[entity attribute value]]]
   [slot-combos [slots [slots [pair] map] map join-all]]
   [constraint [unwrap slots reverse label]] 

   ;; links between datalog constraints
   [links [slot-combos
           [[wrap] map unwrap •🔀 
            [[[lookup] 💉] both] pairwise 
            variable=]
           filter    
           [unwrap pair sink pair
            [[index] lookup] map 🔀 zip]
           map]]
   [all-links [🔳 sink
               [[[[index] lookup] 🛡️] both ;; lookup the indices of both constraints
                [•🔀] 🪄 sink ;; move the indices under the constraints
                [links] •🛡️
                🔀 [•🗑️ •🗑️ 🔗] 🪄] 

               🪜 🗑️]]
   [format-link [[🔗] 💉 unwrap [string] map
                 "c{0}.{1} = c{2}.{3}" 🔀 format]] 

   ;; formatting pieces of query data into text
   [anded-together [" AND " interpose join-all]]

   ;; where clause data processing
   [where-data [[[index] lookup] 🛡️ 🔀 
                [[[second variable? ☯️]
                  [first [index] unwrap = ☯️]] [▶️] every?] filter 
                [🔀 prepend] map •🗑️]]
   [format-where [[string] map 
                  "c{0}.{1} = :c{0}{1}" 🔀 format]]
   [make-where [first [where] lookup anded-together]]
   [format-join [[[[on] lookup]
                  [[where] lookup]
                  [[index] lookup string]] [▶️] map
                 [🔗 anded-together] 💉 
                 "JOIN EAV c{1} ON {0}" 🔀 format]]
   [make-query [rest [[on]
                      [[format-link] map] update
                      [format-join] 🛡️ [🔗] 🔀 assign] map]]

   ;; SQL parameters for rusqlite
   [param-name [[string] map ":c{0}{1}" 🔀 format]]
   [extract-params [🔳 association 🔀 [[params] lookup 🔗] 🪜]]


   ;; SELECT clause
   [wordval? [second word?]]
   [invert [[reverse] map association]]
   [validate [[[second ☯️]
               [first "All selected query variables must appear somewhere in constraints"
                [reason variable] label fail]
               when] map]]
   [select-data [🔀
                 [[slots selectkeys invert] 🛡️
                  [wordval?] filter 🔗 association] map
                 🔀
                 [[[[index 1️⃣] selectkeys] 🎒 ;; make the program to cut down 
                   map 
                   [count 2 =] filter first [second] map
                   [first number?] [reverse] when] ;; items are in random order due to coming from association, fix the order
                  map]
                 🛡️ ••🗑️ zip
                 validate]]

   ;; query 
   [extract-data [[[[unwrap all-links]
                    [first where-data   ; [🔗] 💉 unwrap
                     ;; build the query param map
                     [[🔳 🔀
                       [[param-name] 🛡️ [last] 🪄 wrap 🔀 assign]
                       🪜]
                      ;; build the actual query where clauses
                      [[format-where] map]]
                     fork]]
                   fork] 🛡️
                  ;; combine extracted items

                  [first] 🪄 ;; keep the original constraint to add properties to
                  unwrap unwrap [where params on] label 🔗]]
   [format-select [[unwrap 🔀
                    string butlast ;; remove the ? from the variable name for result column
                    put
                    [string] map %
                    "c{1}.{0} as {2}" 🔀 format] map ", " interpose join-all]]]

  ;; This is the program we need to modify that is `query`

  [🔀
   ;; expand all combinations of constraints
   [constraint] map
   ;;🔳 prepend ;; an empty constraint to represent the orignal EAV table we're joining with
   [index] indexed-as-property
   triangle
   ;; for each pair of constraints, build the "ON" clause data for the JOIN
   [extract-data] map
   [[extract-params]
    [make-query]
    [make-where]
    [🔀 select-data]] fork 
   •🗑️ ;; don't need original anymore
   unwrap float
   [[🔗] lookup] map  
   🔀 format-select 
   [" " interpose join-all] 🪄 triplet reverse
   "SELECT {0} from EAV as c0 {1} WHERE {2}" 🔀 format
   🔀 ••🗑️]

  let
  [definition spec] label
  [query] 🔀 assign
#+end_src
** Pipes
#+begin_src kcats :tangle src/kcats/core/pipes-builtins.kcats :mkdirp yes
  [pipe? [[spec [[item] [boolean]]]
          [examples [[[timestamps pipe?] [✔️]]
                     [[standard pipe?] [✔️]]
                     [[[1 2 3] pipe?] [🔳]]
                     [[5 pipe?] [🔳]]]]]]

  [animate [[spec [[environment] 🔳]]]]

  [attend [[spec [[list] [list]]]]]

  [file-in [[spec [[string] [pipe]]]]]

  [file-out [[spec [[string] [pipe]]]]]

  [handoff [[spec [🔳 [pipe]]]]]

  [receiver [[spec [[pipe] [pipe]]]]]

  [select [[spec [[[list pipes]] [item pipe [list pipes]]]]]]

  [sender [[spec [[pipe] [pipe]]]]]

  [serversocket [[spec [[integer string] [pipe]]]]]

  [socket [[spec [[integer string] [pipe]]]]]

  [standard [[spec [🔳 [pipe]]]]]

  [timer [[spec [[integer] [pipe]]]]]

  [timestamps [[spec [🔳 [pipe]]]]]

  [database [[spec [[[sized params] string] 🔳]]]]

  [persist [[spec [[sized] 🔳]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/pipes.kcats :mkdirp yes
  [[pipe-in [[spec [[item] [pipe]]]
             [definition [association
                          [[[type [file] unwrap =]
                            [value file-in]]
                           [[type [stdout] unwrap =]
                            [stdout]]]
                          decide]]]]

   [tunnel [[spec [[item] [pipe]]]
            [definition [association
                         [[[type [ip-host] unwrap =]
                           [👥
                            [port] lookup
                            [[address] lookup] 🪄
                            serversocket]]
                          [[type [ip-client] unwrap =]
                           [👥
                            [port] lookup
                            [[address] lookup] 🪄
                            socket]]]
                         decide]]]]

   [pipe-out [[spec [[item] [pipe]]]
              [definition [association
                           [[[type [file] unwrap =]
                             [value file-out]]
                            [[type [ip-host] unwrap =]
                             [👥
                              [port] lookup
                              [[address] lookup] 🪄
                              serversocket]]]
                           decide]]]]

   [spit [[spec [[item [item target]] 🔳]]
          [definition [[pipe-in] 🪄 encode put 🗑️]]]]

   [slurp [[spec [[pipe] [item]]]
           [definition [[📤] [🔗] fold string [🗑️ 🗑️] 🪄]]]]

   [print [[spec [[string] 🔳]]
           [definition [[standard] 🪄 "\n" 🔗 encodestring put 🗑️]]]]

   ;;[slurp [[spec [[[item target]] [item pipe]]]]]

   [sleep [[spec [[integer] 🔳]]
           [definition [timer 📤 🗑️ 🗑️]]]]

   [future [[spec [[program] [pipe]]]
            [definition [handoff 🔀
                         [[✂️1️⃣ snapshot] ;; return entire stack
                          dive put 🗑️] 🎒
                         dictionary 🔀 spawn animate]]
            [examples [[[1 [2 +] future 📤 •🗑️] [1 [3]]]]]]]

   [generator [[spec [[[program generator-maker]] [[program wrapped-generator]]]]
               [definition [🔳 🔀 💉
                            [[generate] 💉 📤]]]]]  ;; generate from the wrapped generator

   [siphon [[spec [[[receptacle output] [program generator]] [[receptacle output]]]]
            [description "Generates values from a wrapped generator (stacked generator inside a list), until exhausted, puts all items into the output receptacle"]
            [definition [🔳 ;; placeholder that gets dropped (next
                         ;; iteration it will hold a copy of the last
                         ;; element which is only needed to check if
                         ;; the loop continues and can be dropped
                         ;; after)
                         [empty?] ;; stop when generator returns
                         ;; nothing
                         [🗑️ ;; the last value
                          [generate 👥] 🪄
                          sink
                          [[put] bail] 🪄]
                         until
                         🗑️ 🗑️ sink 🗑️ 🗑️]] ;; the now-empty dispenser
            [examples [[[[[integers 5 taker] generator 🔳 siphon] 🛡️] [[0 1 2 3 4]]]]]]]

   [close [[spec [[pipe] 🔳]]
           [definition [🗑️]]]]]
  🔗
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [consume]]
 [handled []]
 [reason "not enough items on stack"]
 [type error]
 [unwound [join]]]
[[pipe-in [[spec [[item] [pipe]]]
           [definition [association [[[type [file] unwrap =] [value file-in]]
                                     [[type [stdout] unwrap =] [stdout]]]
                        decide]]]]
 [tunnel [[spec [[item] [pipe]]]
          [definition [association [[[type [ip-host] unwrap =] [👥 [port] lookup [[address]
                                                                                 lookup]
                                                                🪄 serversocket]]
                                    [[type [ip-client] unwrap =] [👥 [port] lookup [[address] lookup]
                                                                  🪄 socket]]]
                       decide]]]]
 [pipe-out [[spec [[item] [pipe]]]
            [definition [association [[[type [file] unwrap =] [value file-out]]
                                      [[type [ip-host] unwrap =] [👥 [port] lookup [[address] lookup]
                                                                  🪄 serversocket]]]
                         decide]]]]
 [spit [[spec [[item [item target]]
               []]]
        [definition [[pipe-in] 🪄 encode put 🗑️]]]]
 [slurp [[spec [[pipe] [item]]]
         [definition [[📤] [🔗] fold string [🗑️ 🗑️]
                      🪄]]]]
 [print [[spec [[string] []]]
         [definition [[standard] 🪄 "\n" 🔗 encodestring put 🗑️]]]]
 [sleep [[spec [[integer] []]]
         [definition [timer 📤 🗑️ 🗑️]]]]
 [future [[spec [[program] [pipe]]]
          [definition [handoff 🔀 [[✂️1️⃣ snapshot]
                                  dive put 🗑️]
                       🎒 dictionary 🔀 spawn animate]]
          [examples [[[1 [2 +]
                       future 📤 •🗑️]
                      [1 [3]]]]]]]
 [generator [[spec [[[program generator-maker]] [[program wrapped-generator]]]]
             [definition [[] 🔀 💉 [[generate] 💉 📤]]]]]
 [siphon [[spec [[[receptacle output]
                  [program generator]]
                 [[receptacle output]]]]
          [description "Generates values from a wrapped generator (stacked generator inside a list), until exhausted, puts all items into the output receptacle"]
          [definition [[] [empty?] [🗑️ [generate 👥]
                                    🪄 sink [[put] bail]
                                    🪄]
                       until 🗑️ 🗑️ sink 🗑️ 🗑️]]
          [examples [[[[[integers 5 taker] generator [] siphon] 🛡️]
                      [[0 1 2 3 4]]]]]]]
 [close [[spec [[pipe] []]]
         [definition [🗑️]]]]]
#+end_src

** Crypto
#+begin_src kcats :tangle src/kcats/stdlib/crypto-builtins.kcats :mkdirp yes
  [random [[spec [[integer] [bytes]]]]]

  [key [[spec [[bytes] [bytes]]]
        [examples [[[["foo" encode key] 2 times =] [✔️]]]]]]

  [sign [[spec [[[bytes message] [association key]] [bytes]]]]]

  [verify [[spec [[[bytes signature]
                   [bytes message]
                   [sized key]]

                  [boolean]]]
           [examples [[["foo" encode key "we attack at dawn" encode [sign] 🛡️ verify] [✔️]]]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/crypto.kcats :mkdirp yes
  [[delegated [[spec [[[association pubkey]] [program]]]
               [definition [[[sink ;; css cs pk
                              [[hash] [🛡️ 🪄] decorated ;; css csh cs pk
                               float ;; cs css csh pk
                               [verify] 🪄
                               [🔳]  ;; the program to run if the child script isn't authorized
                               branch] ;; runs the child script if the sig on its hash is verified
                              [🗑️ 🗑️ ;; the sig and (empty) child script -> pk sig msg
                               sink ;; sig msg pk
                               verify]
                              [👥] •🪄 branch]
                             [🔳] 🩹]
                            🔀 prepend]]]] ;; prepend the pubkey

   [hash [[spec [[item] [bytes]]]
          [definition [[[[bytes?] [hashbytes]]
                        [[true] [encode hash]]]
                       decide]]]]]
  🔗
#+end_src

** Time and date
#+begin_src kcats :tangle src/kcats/stdlib/time.kcats :mkdirp yes
  [[milliseconds [[spec [[integer] [integer]]]
                  [definition 🔳]]]

   [seconds [[spec [[integer] [integer]]]
             [definition [1000 *]]]]

   [minutes [[spec [[integer] [integer]]]
             [definition [seconds 60 *]]]]

   [hours [[spec [[integer] [integer]]]
           [definition [minutes 60 *]]]]

   [days [[spec [[integer] [integer]]]
          [definition [hours 24 *]]]]]
  🔗
#+end_src
** Nested Environments
#+begin_src kcats :tangle src/kcats/core/environment-builtins.kcats :mkdirp yes 
  [environment [[spec [[sized] [environment]]]
                [examples [[[[[program [1 2 3]]] environment eval-step [stack] lookup] [[1]]]]]]]

  [environment? [[spec [[item] [boolean]]]
                 [examples [[[[[program [1 inc]]] environment environment?] [✔️]]
                            [[[[program [1 inc]]] environment?] [🔳]]]]]]

  [eval-step [[spec [[environment] [environment]]]
              [examples [[[[[program [1 inc]]] environment
                           eval-step eval-step
                           [stack] lookup]
                          [[2]]]]]]]

  [evaluate [[spec [[item] [environment]]]
             [examples [[[[[program [1 2 3 4 + *]]] environment
                          evaluate
                          [stack] lookup]
                         [[14 1]]]]]]]

  [finished? [[spec [[environment] [boolean]]]
              [examples [[[[[program [1 2 3 4 + *]]] environment
                          finished?]
                         [🔳]]
                        [[[[program [1 2 3 4 + *]]] environment
                          evaluate
                          finished?]
                         [✔️]]]]]]

  [using [[spec [[[list modules] [sized env]] [environment]]]]]

  [use [[spec [[[program [list modules]] [*]]]]
        [definition [[program] label environment 🔀 ;; lm env
                     [[stack] [snapshot] divedown assign] 🪄 ;; capture the stack at runtime
                     using ;; set up the resolver 
                     evaluate ;; execute the program in the inner environment
                     [stack] lookup restore ;; replace the stack with the result from the inner env
                     ]]]]
#+end_src

#+begin_src kcats :tangle src/kcats/core/environment.kcats :mkdirp yes
  [tos [[spec [[environment] [item]]]
        [definition [[stack] lookup first]]
        [examples [[[[[stack [1 2 3]]
                      [program [[+] 🪜]]]
                     tos]
                    [1]]]]]]

  [top [[spec [[environment] [item]]]
        [definition [[program] lookup first]]
        [examples [[[[[stack [1 2 3]]
                      [program [[+] 🪜]]]
                     toe]
                    [[+]]]]]]]

  [stage [[spec [[program] [environment]]]
          [definition [[program] label environment]]]]

  [capture [[spec [[environment] [environment]]]
            [doc "Capture the outer stack and assign it to the inner env's stack"]
            [definition [[stack]
                         [snapshot] divedown
                         assign]]]]

  [spawn [[spec [[program dictionary] [environment]]]
          [definition [[snapshot] •🪄 ;; p d s
                       [program dictionary stack] label
                       environment]]
          [examples [[[1 2 3 dictionary [🔀 👥] spawn]
                      [1 2 3 [[program [🔀 👥]] [stack [3 2 1]]] environment]]]]]]

  [confine [[spec [[[program module] dictionary] [*]]]
            [definition [spawn evaluate [stack] lookup restore]]]]
#+end_src
*** Debugging

#+begin_src kcats :tangle src/kcats/stdlib/debug.kcats :mkdirp yes
  [[break [[spec [[[program condition] environment]
                  [[program condition] environment]]]
           [definition [[[[🔀 something?] ;; still running
                          [▶️ ☯️]] ;; check condition not true yet
                         [▶️]
                         every?] ;; break?
                        [[eval-step] 🪄]  ;; evaluate the environment one step
                        while]]]]

   [breakpoint [[spec [🔳 🔳]]
                [definition 🔳]]]

   [sprint [[spec [[environment]
                   [environment]]]
            [definition [[[program 0] lookup wrap [breakpoint] =] break
                         🗑️ ;; the condition
                         🔳 [eval-step] when]]]] ;; advance past the breakpoint word if the program isn't complete


   [advance [[spec [[environment] [environment]]]
             [definition [[[program] lookup count] 🛡️ 🔀 ;; count up the program length, we'll run until it's smaller than this

                          [[program] lookup count  ;; only stop if expr empty or shorter than we started off
                           [[positive?] [<=]] [▶️] every?]
                          [eval-step]  ;; evaluate the environment one step
                          while
                          •🗑️]]]]  ;; drop the program length item

   [stepper [[spec [🔳 [program]]]
             [definition [[eval-step 👥]]]]]

   [tracer [[spec [[program] [[program generator]]]]
            [definition [stage stepper]]]]

   [dump [[spec [🔳 🔳]]
          [definition [snapshot wrap emit autoformat print]]]]

   [heatmap [[spec [[program] [association]]]
             [definition [[tracer
                           ;; what item is being ▶️d
                           [[program] lookup [first]
                            ;; don't emit 🔳 or the execution stops, use 0 instead
                            bail 0 or]
                           each 
                           [word?] keep ;; count only words, which filters out the 0's from above
                           frequencies] •🛡️]]]]]


  🔗
#+end_src

#+begin_src kcats :tangle src/kcats/stdlib/debug-step.kcats :mkdirp yes
  [[evaluating? [[program] lookup [evaluate] starts?]]
   [with-innermost [[🔳 🔀
                     [[evaluating?]
                      [[stack 0] 👥 [lookup] 🪄 🔀 [🔗] 🪄 ] ;; append the next part of the path to the accumulator
                      while 🔀] 🛡️ ••🗑️]
                    🪄 ;; under the stepping prog
                    [update] •🛡️ flip 🗑️

                    ;; find which envs are finished and remove
                    ;; 'evaluate' from parent
                    [0 -2 slice 👥] [collect] shielddeep 
                    [[[[[evaluating?]
                        [[stack 0] lookup finished?]]
                       [execute] every?]
                      [[program] [rest] update]
                      when]
                     [update] •🛡️ flip 🗑️ 🗑️]
                    🪜]]]
  🔗
#+end_src
* Issues
** DONE Get rid of platform-specific definitions
** DONE fix evaluate
#+begin_src kcats
  [[program [1 1 +]]] environment evaluate [stack] lookup
#+end_src

#+RESULTS:
:
: [[2]]
** TODO merkle tree functions
#+begin_src kcats
"foo" "bar" join hash "foobar" hash =
#+end_src

#+RESULTS:
#+begin_src kcats
yes
#+end_src

First let's figure out how to represent a tree:

#+begin_src kcats
  ;[5 [[3 [[1c 🔳]
  ;        [2c 🔳]]]
  ;    [4 [[3c 🔳]]]]]
  [[hash 🔳]
   [children [second]]
   [data [first]]
   [node [🔳 pair]]
   [empty-node [#b64 "" hash node]]
   [child [[children] 🪄 get]]
   [addchild [[pop] 🪄 put put]]
   [rawpath [1 [interpose] 🛡️ 🔀 prepend •🗑️]]
   [siblings [🔳 node sink [addchild] 🪄 addchild]]
   ;[path [🔳 [📤 🔀 [child] 🪄 path] [drop] ⚖️]]
   [path [dec 2 radix rawpath]]
   [parent [butlast butlast]]
   [rehash [[children [data] map] 🛡️
            [first] 🛡️ empty 🔀 [join] 🪜
            hash wrap [0] 🔀 update]]
   ;; lopsidedtree n
   [balance 🔳]
   ;; node tree cur-ct
   [add [[👥 path [pop zero?] [parent] when] •🪄  ;; node tree path ct
         •🔀 ;; node path tree ct
         🔳]]
   [add [[odd?]
         ;; insert an unbalanced node (empty sibling)
         [empty-node siblings [path parent]]
         ;; otherwise replace the empty sibling
         🔳
        ]]]
  ; ["" drop
  ;  ;[0 🔳] 1 node addchild 2 node 3 node addchild addchild
  ;  ;[1 0]  1 [interpose] shield 🔀 put •🗑️ lookup
  ;  "foo"  hash node "bar"  hash node siblings
  ;  ;; update the root node
  ;  rehash
  ;  ; now add a new sibling
  ;  "baz"  hash node siblings
  ;  rehash
  ;  3 path [pop zero?] [butlast butlast] 🔳 ⚖️
  ;  ;dump
  ;  ["quux" hash node siblings rehash ] update
  ; ]
  [["foo" "bar" "baz" "quux"] [node] map 🔳
  let
#+end_src

#+RESULTS:
#+begin_src kcats
[["foo" 🔳]
 ["bar" 🔳]
 ["baz" 🔳]
 ["quux" 🔳]]
#+end_src

+ 1234
  + 12
    + 1
    + 2
  + 34
    + 3
    + 4

 + 5
 + 6
#+RESULTS:
#+begin_src kcats
  ["foobarbaz" [["foobar" [["foo" 🔳]
                           ["bar" 🔳]]]
                ["bazquux" [["baz" 🔳]
                            ["quux" 🔳]]]]]
  ["" 🔳]
#+end_src

interpose impl
#+begin_src kcats
[1 3 4] [foo] unwrap interpose
#+end_src

#+RESULTS:
#+begin_src kcats
[1 foo 3 foo 4]
#+end_src

#+begin_src kcats
[0 [[1 🔳]
    [2 [[3 🔳]]]]]
  [1 0] 1 [interpose] 🛡️ 🔀 prepend 0 put •🗑️ [inc] update
#+end_src

#+RESULTS:
#+begin_src kcats
[0 [[1 🔳]
    [2 [[4 🔳]]]]]
#+end_src

We need a function that, given a number n, gives the path in the
merkle tree. eg, 8 would be 1 1 1. Is it just =n-1= in binary?
6 would be 1 0 1. Ok so just write a function to expand binary digits:

#+begin_src kcats
8 dec 2 radix
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 1]
#+end_src

#+begin_src kcats
["foobarbaz" [["foobar" [["foo" 🔳]
                         ["bar" 🔳]]]
              ["baz" 🔳]]] [1 1] [🗑️ 🗑️ "hi" "there"] update
#+end_src

#+RESULTS:
#+begin_src kcats
["foobarbaz" [["foobar" [["foo" 🔳]
                         ["bar" 🔳]]]
              "there"]]
#+end_src

#+begin_src kcats
  [[hash 🔳]
   [children [second]]
   [data [first]]
   [node [🔳 pair]]
   [child [[children] 🪄 get]]
   [addchild [[pop] 🪄 put put]]
   [siblings [🔳 node sink [addchild] 🪄 addchild]]
   ;[path [🔳 [📤 🔀 [child] 🪄 path] [🗑️] ⚖️]]
   [path [dec 2 radix nodepath]]
   [rehash [[children [data] map] 🛡️ [first] 🛡️ empty 🔀 [join] 🪜 hash wrap [0] 🔀 update]]]
  [["foobarbaz" [["foobar" [["foo" 🔳]
                            ["bar" 🔳]]]
                 ["baz" 🔳]]]
   [1 1]

   ["bazquux" [["baz" 🔳]
               ["quux" 🔳]]]
   assign]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
["foobarbaz" [["foobar" [["foo" 🔳]
                         ["bar" 🔳]]]
              ["bazquux" [["baz" 🔳]
                          ["quux" 🔳]]]]]
#+end_src

#+begin_src kcats
  [["bazquux" [["baz" 🔳]
               ["quux" 🔳]]]
   [1 1]
   ["foobarbaz" [["foobar" [["foo" 🔳]
                            ["bar" 🔳]]]
                 ["baz" 🔳]]]]
  reverse unwrap assign
#+end_src

#+RESULTS:
#+begin_src kcats
["foobarbaz" [["foobar" [["foo" 🔳]
                         ["bar" 🔳]]]
              ["bazquux" [["baz" 🔳]
                          ["quux" 🔳]]]]]
#+end_src

#+begin_src kcats

  [
   [children [second]]
   [data [first]]
   [node [🔳 pair]]
   [addchild [[pop] 🪄 put put]]
   [siblings [🔳 node sink [addchild] 🪄 addchild]]
   [nodepath [1 [interpose] 🛡️ 🔀 prepend •🗑️]]
   [padded [[[[count] 🛡️] dive -] 🪄
            🔀 repeat
            🔀 join]]
   [path [[dec 2 radix] 🪄 2 log ceiling 0 padded nodepath]] ;; item-ct index
   [depth 🔳]

   [rehash [[children [data] map] 🛡️
            [first] 🛡️ empty 🔀
            [join] 🪜
            hash
            wrap [0] 🔀 update]]
   [joiner [[2 2 partition
             [[count 1 =] [🔳 put] when
              unwrap siblings] each]
            assemble [rehash] map]]
   [merkle [[hash node] map
            [count 1 >] [joiner] while]]]
  [["a" "b" "c" "d" "e"]
   count
   5 ;; 2nd item
   🔀 path ]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 1 0 1 0]
#+end_src

#+RESULTS:
#+begin_src kcats
[[#b64 "FO3l6Ol62TcjJ3KPUJm5VgSjlZPKw704o0OtdiBSE+c=" [[#b64 "5aAf7hTg7VxIcU8iGA8lrYNltT+XefedxKPX6Tlj+Uo="
                                                        [[#b64 "ypeBEsobvcr6wjGzmiPcTaeG7/gUfE5yuYB3ha/uSLs=" 🔳]
                                                         [#b64 "PiPoFgA5WUoziU9lZOGxNIu9egCI1CxKy3PurtWcAJ0=" 🔳]]]
                                                       [#b64 "v/4LNNuha8b6wXwIusVdZ2ze1aSt5B/iyZJKXd6PPls=" [[#b64 "Ln0sA6lQeuJl7PW1NWiFpTOTogKdJBOUmXJloaJa78Y="
                                                                                                              🔳]
                                                                                                             [#b64 "GKw+c0PwFokMUQ6T+TUmEWnZ4/VlQ2Qpgw+vCTT0+OQ=" 🔳]]]]]]
#+end_src

#+begin_src kcats
  [1 1 1] 5 0 [[[count] 🛡️] dive -] 🪄
          🔀 repeat
          🔀 join
#+end_src

#+RESULTS:
#+begin_src kcats
[0 0 1 1 1]
#+end_src
** CANCELED Make taker/dropper more flexible
Goal: implement drop and drop-while with the same logic

Canceled - the commonality between drop and drop-while are too small to be worth trying to factor out.

#+begin_src kcats
  [1 2 3 4 5] [📤]
  3
  [[[positive?]
    [[generate 🗑️] 🪄 dec]
    while
    [generate 🔀] 🪄 float]
   bail]
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[4 5]
[[[positive?] [[generate 🗑️]
               🪄 dec]
  while [generate 🔀]
  🪄 float]
 bail]
0 [📤] 🔳
#+end_src


This is what drop-while looks like
#+begin_src kcats
  🔳 [📤]
  [positive?]
  🔳 ;; the state (whether threshold reached)
  [🔳 ;; condition - whether we've finished dropping or not 
   [[generate] divedown] ;; true - pass everything else through
   [[[generate] divedown] ;; prime init
    [[[👥] divedown execute] bail] ;; bring pred up and exec it
    [🗑️] ;; if pred passes drop the value
    prime ;; after this should have value on top
    [🗑️ true] 🪄 ;; set flag
   ] ;; false - generate, check pred, repeat
   ⚖️]
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
🔳 [🔳 [[generate] divedown]
    [[[generate] divedown]
     [[[👥] divedown execute] bail]
     [🗑️] prime [🗑️ yes]
     🪄]
    ⚖️]
yes [positive?] [📤] 🔳
#+end_src
