#    -*- mode: org -*-


Archived entries from file /home/user/workspace/kcats/production.org


* DONE assign doesn't overwrite a nested value properly
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[[a b] [c d]] association
[a e] "foo!" assign
#+end_src

#+RESULTS:
: 
: [[[c d] [a [[e "foo!"]]]]]

This errors out because =b= isn't an association. But we want it to
overwrite =b= with =[[d "foo!"] ]=.

* DONE Serialization treats any tagged literal as byte string
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:

* DONE Serialization panics on reading invalid data
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Should return Result objects from to_item. I don't think it is
necessary for from_item - since we're using a subset of edn, all Items
should be convertible to valid edn. But not all valid edn is
convertible to an Item.

* DONE Association list and list of equal content don't compare equal
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** Description
Probably need a custom PartialEq impl for Item here that converts the
list to a hash before comparing. Return false if the item doesn't
convert.

The sticky issue here is that when we read a literal like =[[type
foo][value bar] ]=, how do we know whether it should be compared to
something else as a hashmap (that ignores order) or a plain list (that
doesn't). We can probably deduce that if one of the arguments is a
hashmap, then the other should be treated as one. However what if both
are plain lists? It's still possible the intent was hashmap.
** Hacky Solution
what if you execute =[[a b][c d] ] [[c d][a b] ] == ? It's impossible
to know the intent. I think maybe the best way out is to treat
anything associative-shaped as association, and if the user wants
ordered comparison, let him use a different operator, =ordered== or
something.

So the comparison of two items that are either List or Assoc goes like this:

If either item is Assoc, then convert the other to Assoc (if
necessary) and do straight =.

If they're both List, compare lengths. If not equal, return
false. Otherwise, examine items- If they're all pairs, convert both to
assoc. finally do straight =.
** Better solution
Add a word =associative=. If that follows a list, it's converted to a
hashmap and then it's easy to compare to another hashmap. The
representation is unchanged of course. But it lets the programmer
specify the intent of how === should behave.

This does reveal a problem with the unit tests that are specified as
examples in the lexicon. Those tests will execute the program and then
compare the representation of the resulting stack, with the
representation given. As we now can see, comparing representations is
insufficient, we need to be able to compare actual implementations.

That means, the unit test's expected value should be calculated and
not just read in. For most tests, no changes will be required (it's
just putting values on the stack and no further calculation needed).

But in the end we'll need to compare actual stack to expected stack,
not a stack to a representation. So the unit test logic will need to
run two environments, the actual and the expected, and then compare them.

The previous solution just isn't going to cut it - when we go to
implement sets it's going to be completely impossible to use a
heuristic to figure out what the intent was. Lists and sets will look
the same. So in the case of sets we'll have to specify the word =set=.

Do we have to be explicit when comparing list to association?  we
could either always return false (they're different types), or we
could compare them as lists or as maps.

The question then is if the two intents don't match, what do we do?  I
can't think of a reasonable answer- does order matter? We have
conflicting answer with no way to resolve it. Maybe it's safest to
just return false.

You can argue maybe even if order matters, maybe the two lists are in
the same order and should therefore compare equal. But associatives
don't have a defined order, so that would be just leaving it up to
chance and it wouldn't even be consistent across time. So that doesn't
seem wise.

So here's the plan: 
Examples:
#+begin_src kcats
[[a b] [c d]] association
[[c d] [a b]] association
=
=> true

[[a b] [c d]]
[[c d] [a b]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]]
=
=> true

[a a b c]
[a b c]
=
=> false

[a b c] set
[a b c]
=
=> false

[a b c] set
[b a c] set
=
=> true
#+end_src

* DONE Items of equal content don't compare equal
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
+ handle [[type error] [asked [consume]] [reason "not enough items on stack"]] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
dictionary [swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
[] environment [dictionary swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

This matches clojure
#+begin_src kcats
1 1.0 =
#+end_src

#+RESULTS:
: 
: [false]

#+begin_src kcats
[] [] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
"foo" bytes "foo" bytes =
#+end_src

#+RESULTS:
: 
: [true]


* DONE Change unit tests to make the expected take a program and eval it
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
This is to fix the cases that result in associatives or sets where
order doesn't matter but we don't have a way to declare how the values
should be conmpared. We can't just compare representations, we need to
compare two actual stacks.

So instead of
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]]]]
#+end_src

We should write
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]] association]]
#+end_src

So that the two stacks will compare equal.

* DONE create an environment from data (including an existing stack)
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It'd be nice to copy paste the output of one execution and have it pick up again eg
#+begin_src kcats
[[stack [1 2 3]]
 [expression [+]]]
#+end_src

There are potential issues here - such as the representation of an
associative is just a list, so when it's read back in it won't be the same:
#+begin_src kcats
[[stack [[[a b] [c d]]
         [[c d] [a b]]]]
 [expression [=]]]
#+end_src

If the two lists on the stack were actually associatives, they were
equal before but now they won't be.

I don't know that this is such a big problem, it's not possible for
everything in the language to be sensibly round-tripped via
serialization (eg stateful things like pipes).

If it's important to compare as associative, then make that part of
the expression.

What should =environment= take as an argument? Seems like it should
take an association (or assoc-shaped list).

#+begin_src kcats
[] environment
#+end_src

#+RESULTS:
: 
: [[[stack []] [expression []]]]

should give the default env.

#+begin_src kcats
[[expression [1 2 +]]] environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

should give the unexecuted env

#+begin_src kcats
[[expression [+]] [stack [3 2]]] environment evaluate [stack] lookup first
#+end_src

#+RESULTS:
: 
: [5]


should execute env with default dictionary plus whatever we add

#+begin_src kcats
[[dictionary [[foo [[definition [inc +]]
                    [spec [[number] [number]]]]]
              [bar [[definition [foo 5 *]]
                    [spec [[number] [number]]]]]]]
 [expression [1 2 bar]]]

environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [20]] [expression []]]]

should give the default env with the additional dict entries


#+begin_src kcats
[[expression
  [21449

   [] swap 2

   [/ 2 >]
   [ [mod 0 =]
     [clone sink [pack] dipdown / 2]
     [inc]
     if]
   while

   discard pack
  ]]]
environment
advance advance advance advance advance advance
eval-step
#+end_src

#+RESULTS:
: 
: [[[stack [[[mod 0 =] [clone sink [pack] dipdown / 2] [inc] if] [/ 2 >] 2 21449 []]] [expression [swap wrap [shield] join clone dipdown join loop discard pack]]]]


#+begin_src kcats
[[expression [1 2 +]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

#+begin_src kcats
dictionary count
#+end_src

#+RESULTS:
: 
: [118]


* DONE In-thread error handling
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Error structs
** DONE Stop on unrecoverable error
** DONE Be able to resume execution after an error
*** Notes
#+begin_src  kcats
2 [1 4 0] [[/] [discard 0] recover] map

#+end_src

#+RESULTS:

#+begin_src kcats
2 [1 4 0] [[/] [discard 0] recover] map

[1 0 /] [discard 0] recover
1 [0 /] [discard 0] . recover
1 . snapshot
    [0 /] inject first
    [error?] [discard 0] [] if
    resume
err [error?]  

t r recover
[snapshot] dipdown ;; rec test ss
[inject] dip swap ;; res rec
[first error?] ;; err? res rec
discard execute;; drop the snapshot and run recovery
evert discard ;; use snapshot as stack


; inject the program into a snapshot. If there's an error on top
; afterward, inject the recovery in there too. It'll have access to
; the whole context. If there's no error, evert and drop the ToS.

;; the execution will stop after injecting into the snapshot, so
;; "first" won't even get executed here.

[discard] [discard] recover

;; here we recover from underflow by just dropping the error


[1 0 /] . execute
. 1 0 /
err . [discard 0] execute resume
                        ;; ^ this is in the expression so keep going, actual word doesn't do anything


;; when the ToS is err, how do we know whether to stop?  we can look
;; at the expression to see what's coming. We can't do that at every
;; step of the entire execution but we don't have to. Just when ToS =
;; err. The challenge is to encode this just with the stack/expr and
;; no extra state. We can put a word like "continue" in the expr, but
;; at some point we actually have to have an err on ToS and do
;; something with it. The only place we can put some kind of flag not
;; to abort, is in the expression (or maybe the dictionary).

;; another approach is to explicitly continue unless halt is called,
;; but the error-producer doesn't know whether the error can be
;; handled or not.


;; how to unwind. can we just naively unwind to the next instance of
;; 'recover' in the expression? or will quoted programs mess this up?
;; Let's work through it

;; here the recover is quoted, but by the time an error occurs and we
;; look at the expression, it'll be there:
2 [1 4 0] [[/ 12 +] [discard 0] recover] map

2 err . 12 + resume [error?] [discard 0] if
2 err . [error?] [discard 0] [] if 

;; so the problem is even after we've unwound the expression to
;; 'resume', the error is still on the ToS! Now we want to actually do
;; the recovery, but we've already gotten rid of the flag that tells
;; us we're doing that. Maybe we can modify the error object itself to
;; note that it's been flagged for processing. Maybe [[type error]
;; [detected? true] [message "oops"]]. Or maybe we can convert it from
;; the error object to a richer object that contains the whole
;; stack/expr at the time it happened.

;; maybe we need a primitive here: fail, which will put a new item on
;; ToS which includes the whole env field plus a message field to
;; describe what is wrong.

;; eg

1 0 /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]]

1 0 . "division by zero" capture /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]] . /

;; ok what's the best we got so far?

;; i think it's recover/resume, without requiring nested env. Have the
;; error type with a flag detected?. Eval will do the following: if
;; there's an error on top, and there is no 'detected?' field, unwind
;; the expression to 'resume' (if there is one, otherwise clean the
;; expression). Set the detected field and continue. presumably what's
;; next is the error handler if there's anything left in the
;; expression.

;; ok this is good but it'd be nice to know what the expression was
;; before it gets unwound. For example what if the handler wants to
;; log the error? By the time it can do that, the original word that
;; errored is not in the expression anymore. The error object would
;; have to contain a snapshot (not just of the stack, but the
;; expression too). what about snapshotting the stack and cherry
;; picking the error object before the recovery? How does the recovery
;; distinguish different types of errors (java's catch-by-class is
;; kind of weak)

;;eg

1 "foo" + 0 /

;; there's 2 things wrong here, what if we only want to recover from
;; division by zero? well, we can only wrap / in a recover. ok waht about this

"foo" 0 /

;; this will actually error with type mismatch

;; how are we supposed to serialize these things? This makes me think
;; the rust structs need to be easily representable as kcats. And then
;; what are we supposed to do with error literals (the reader would
;; need to convert them). What would error literals look like,
;; especially user-defined errors?

[[error "oh noes"]]

;; but then how to subtype them? Here we have a sort of pseudoprogram
;; that demonstrates what the interpreter couldn't do. for example [0
;; /] means it can't divide by zero. And then there's a string that
;; just says what the program can't do. eg 'number' is a word that may
;; or may not exist (I suppose it should, to do parseInt type stuff)
;; but the point is it's pseudocode that in many cases will work as
;; real code, but not guaranteed.

[[type error]
 [asked [0 /]]
 [reason "cannot divide by zero"]]

[[type error]
 [asked [number]]
 [reason "not a number"]]

[[type error]
 [asked [consume]]
 [reason "not enough items on stack"]]

[[type error]
 [asked [2 get]]
 [reason "not enough items in the list"]]

[[type error]
 [asked [bloop]]
 [reason "word is not defined"]]
#+end_src

#+begin_src kcats
17
[+]
[discard 5 +]

[[handle] join] dip ;; add handle to the end of test
[snapshot] dipdown ;; rec test ss
sink inject ;; res rec
[first error?] ;; err? res rec
[first swap execute];; drop the snapshot and run recovery
[evert discard] ;; use snapshot as stack
if

#+end_src

#+RESULTS:
: 
: [22]


#+begin_src kcats :results code
5
[1 2 "oh fudge"]
[[+]
 [discard discard]
 recover]
map
#+end_src

#+RESULTS:
#+begin_src kcats

stack: [[[reason "type mismatch"] [asked [number]] [type error]] "oh fudge" 5]
expression: [handle [[[discard discard] "oh fudge" 5]] unwrap evert [first error?] [first swap execute] [evert discard] if [[[5] [6 7] 5]] unwrap evert first swap [pack] dip discard]
#+end_src

#+begin_src kcats
 [+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: stack: [[[type error] [asked [consume]] [reason "not enough items on stack"]]]
: expression: [handle [[[discard 1 [+] [discard 2 +] recover]]] unwrap evert [first error?] [first swap execute] [evert discard] if]

#+begin_src kcats
5 handle 

#+end_src

#+RESULTS:
: 
: [5]

** DONE Errors during recovery are improperly caught
The current implementation cannot tell the difference between an error
that was put on the stack during the "test" program, vs one that was
put there during the recovery. So if the recovery throws an error, it
*should* halt the execution, but it won't. Instead the program will
continue executing and words will be invoked with errors on the stack
that shouldn't be invoked.

I think I have a solution, but it does require modifying the error
object by setting a =handled?= flag (note the plan is for this to be
an implementation detail and from kcats point of view the error object
will not be visibly modified). The recovery program will have a word
=handle= inserted in the first position. The word =handle= will set
the flag on the error to =true=. Then =eval= can stop when a) there's
an error on the stack with no =handled? = true= AND the word =handle=
isn't in the expression. If =handle= *is* in the expression, we need
to unwind the expression up to but not including the =handle= word.

The word =handle= has to be an atomic operation (an axiom word that
sets the flag in one evaluation step, otherwise the progam would halt
before the flag could be set.)

We can delete the word =resume=.

#+begin_src kcats :results code
 discard 1 2 + handle discard 3 4 +
#+end_src

#+RESULTS:
#+begin_src kcats

[7]
#+end_src

#+begin_src kcats
1 [[zero?] [pos?]] [execute] every?
#+end_src

#+RESULTS:
: 
: [[] 1]

#+begin_src kcats
1 [[zero?] [positive?]] [execute] any?
#+end_src

#+RESULTS:
: 
: [true 1]


* Attribute database using CozoDB
:PROPERTIES:
:ARCHIVE_TIME: 2024-01-17 Wed 19:32
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues/Database
:ARCHIVE_CATEGORY: production
:END:
The idea here is to ignore identity in the database and make that the
responsibility of the client. The database only links attributes, and
has nothing to say about whether a given entity is the "same" entity
as another. It only says "something has both the color brown and the
height 1.5m". What attributes are sufficient to establish identity is
not part of the database. It's just a graph connecting attribute/value
pairs.
**  First experiments
#+begin_src fundamental
  ?[a_attr, a_val, b_attr, b_val] <-
  [
    ["author", "George Orwell", "title", "1984"],
    ["author", "George Orwell", "title", "Animal Farm"],
    ["author", "George Orwell", "genre", "dystopia"],
    ["genre", "dystopia", "title", "1984"],
    ["created", "1949", "title", "1984"],
    ["format", "book", "title", "1984"],
    ["language", "english", "title", "1984"],
    ["name", "George Orwell", "created", "1905"],
    ["name", "George Orwell", "sex", "male"]
  ]

  :replace also {a_attr, a_val, b_attr, b_val}
#+end_src

#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": ":create attributes { a_attr: String, a_val: Any, b_attr: String, b_val: Any}",
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "status"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "OK"
    ]
  ],
  "took": 0.016436112
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 79
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Tue, 19 Dec 2023 23:25:15 GMT
// Request duration: 0.018199s
#+END_SRC

#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "?[a_attr, a_val, b_attr, b_val] <- [['author', 'George Orwell', 'title', '1984'], ['author', 'George Orwell', 'title', 'Animal Farm'], ['author', 'George Orwell', 'genre', 'dystopia'], ['genre', 'dystopia', 'title', '1984'], ['created', '1949', 'title', '1984'], ['format', 'book', 'title', '1984'], ['language', 'english', 'title', '1984'], ['name', 'George Orwell', 'created', '1905'], ['name', 'George Orwell', 'sex', 'male']] :put attributes",
     "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "status"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "OK"
    ]
  ],
  "took": 0.011967695
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// access-control-allow-origin: *
// transfer-encoding: chunked
// date: Tue, 19 Dec 2023 23:39:51 GMT
// Request duration: 0.064371s
#+END_SRC

"When was the author of 1984 born?"
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[born] := linked['title', '1984', 'author', author], linked['created', born, 'name', author]", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "born"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "1905"
    ]
  ],
  "took": 0.001707655
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 79
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Tue, 19 Dec 2023 23:56:27 GMT
// Request duration: 0.002975s
#+END_SRC

"What books did the author of 1984 write?"
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[title] := linked['title', '1984', 'author', author], linked['title', title, 'author', author]", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "title"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "1984"
    ],
    [
      "Animal Farm"
    ]
  ],
  "took": 0.001771184
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 96
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Wed, 20 Dec 2023 00:05:26 GMT
// Request duration: 0.002879s
#+END_SRC



How to write that query in kcats format?
#+begin_src kcats
  [[title "1984" author a?]
   [created c? name a?]
   [c?]]
#+end_src

Everything about Orwell
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[a1, v, a2] := linked[a1, v, a2, 'George Orwell'] ", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "a1",
    "v",
    "a2"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "created",
      "1905",
      "name"
    ],
    [
      "genre",
      "dystopia",
      "author"
    ],
    [
      "sex",
      "male",
      "name"
    ],
    [
      "title",
      "1984",
      "author"
    ],
    [
      "title",
      "Animal Farm",
      "author"
    ]
  ],
  "took": 0.00130435
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 213
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Wed, 20 Dec 2023 00:14:07 GMT
// Request duration: 0.002445s
#+END_SRC

** Using org-mode eval
Now we have an org-mode evaluator!
#+begin_src cozodb :results value table
{:create attributes {a_attr: String, b_attr: String, a_val: Any, b_val: Any}}
#+end_src

#+RESULTS:
| OK |

#+begin_src cozodb :results value table
  %import /home/v/workspace/kcats/countries-cozo.json
#+end_src

#+RESULTS:
| [31mparser::pest[0m |


#+begin_src cozodb
::index create attributes:rev {b_attr, a_attr, b_val, a_val}
#+end_src

#+begin_src cozodb :results value table
  linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]
  ?[title] := linked['title', '1984', 'author', author], linked['title', title, 'author', author]
#+end_src

#+RESULTS:

What movies has robert de niro been in?
#+begin_src cozodb
linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]
?[title] := linked['title', title, 'cast', cast], actor in cast, actor == 'Robert De Niro'
#+end_src

#+RESULTS:
| GoodFellas                    |
| Jackie Brown                  |
| Mean Streets                  |
| Midnight Run                  |
| Once Upon a Time in America   |
| Raging Bull                   |
| Righteous Kill                |
| Silver Linings Playbook       |
| Stardust                      |
| The Irishman                  |
| The Irishman: In Conversation |
| The Score                     |



What directors has robert de niro worked with?
#+begin_src cozodb
  linked[a, oa, v, ov] := *attributes[a, oa, v, ov] or *attributes[oa, a, ov, v]
  ?[director] := linked['title', 'cast', title, cast],
                 linked['title', 'director', title, director], 
                 actor in cast, actor = 'Robert De Niro' 
#+end_src

#+RESULTS:
|                   |
| David O. Russell  |
| Frank Oz          |
| Jon Avnet         |
| Martin Brest      |
| Martin Scorsese   |
| Matthew Vaughn    |
| Quentin Tarantino |
| Sergio Leone      |


What movies had both Adam Sandler and David Spade?
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title] := linked['title', title, 'cast', cast],
              actor1 in cast,
              actor2 in cast,
              actor1 == 'Adam Sandler', actor2 == 'David Spade'
#+end_src

#+RESULTS:
| Grown Ups                             |
| Hotel Transylvania 3: Summer Vacation |
| The Do-Over                           |
| The Ridiculous 6                      |

Adam Sandler's 5 most recent movies
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
   ?[title, year] := linked['title', title, 'cast', cast],
                     linked['release_year', year, 'title', title],
                     actor in cast, actor == 'Adam Sandler',
   :limit 5
   :order -year
#+end_src

#+RESULTS:
| Hubie Halloween                       | 2020 |
| Murder Mystery                        | 2019 |
| Uncut Gems                            | 2019 |
| ADAM SANDLER 100% FRESH               | 2018 |
| Hotel Transylvania 3: Summer Vacation | 2018 |

What actors have been in the most movies with Sandler
#+begin_src cozodb
  ?[count(title), actor2] := linked['title', title, 'cast', cast],
                    target = 'Adam Sandler',
                    actor1 in cast, actor1 == target,
                    actor2 in cast, actor2 != target
  :limit 10
  :order -count(title)
#+end_src

#+RESULTS:
| 7 | Rob Schneider     |
| 6 | Allen Covert      |
| 5 | Nick Swardson     |
| 5 | Steve Buscemi     |
| 4 | David Spade       |
| 4 | Kevin James       |
| 3 | Blake Clark       |
| 3 | Colin Quinn       |
| 3 | John Turturro     |
| 3 | Jonathan Loughran |


#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[attr, val] := linked['title', 'Murder Mystery', attr, val]
#+end_src

#+RESULTS:
| cast         | [Adam Sandler Jennifer Aniston Luke Evans Gemma Arterton Adeel Akhtar Luis Gerardo M√©ndez Dany Boon Terence Stamp]                               |
| country      | United States                                                                                                                                    |
| description  | On a long-awaited trip to Europe, a New York City cop and his hairdresser wife scramble to solve a baffling murder aboard a billionaire's yacht. |
| director     | Kyle Newacheck                                                                                                                                   |
| duration     | 98                                                                                                                                               |
| rating       | PG-13                                                                                                                                            |
| release_year | 2019                                                                                                                                             |
| type         | Movie                                                                                                                                            |

10 longest movie titles
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title, ct] := linked['title', title, _, _], ct = length(title)
  :limit 10
  :order -ct
#+end_src 

#+RESULTS:
| Jim & Andy: The Great Beyond - Featuring a Very Special, Contractually Obligated Mention of Tony Clifton | 104 |
| Ken Burns Presents: College Behind Bars: A Film by Lynn Novick and Produced by Sarah Botstein  |  93 |
| Mike Birbiglia: What I Should Have Said Was Nothing: Tales from My Secret Public Journal       |  88 |
| The Power of Grayskull: The Definitive History of He-Man and the Masters of the Universe       |  88 |
| Steve Martin and Martin Short: An Evening You Will Forget for the Rest of Your Life            |  83 |
| Cultivating the Seas: History and Future of the Full-Cycle Cultured Kindai Tuna                |  79 |
| Power Rangers Samurai: Christmas Together, Friends Forever (Christmas Special)                 |  78 |
| Willy and the Guardians of the Lake: Tales from the Lakeside Winter Adventure                  |  77 |
| Ya no estoy aqu√≠: Una conversaci√≥n entre Guillermo del Toro y Alfonso Cuar√≥n                   |  76 |
| The Road to El Camino: Behind the Scenes of El Camino: A Breaking Bad Movie                    |  75 |

#+begin_src cozodb
  linked[a, oa, v,  ov] := *attributes[a, oa, v, ov] or *attributes[oa, a, v, ov]
  ?[count(title)] := linked['title', title, _, _], 
#+end_src 

#+RESULTS:
| 70456 |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title] := linked['director', 'Steven Spielberg', 'title', title ], 
#+end_src 

#+RESULTS:
| Catch Me If You Can                                |
| Indiana Jones and the Kingdom of the Crystal Skull |
| Indiana Jones and the Last Crusade                 |
| Indiana Jones and the Raiders of the Lost Ark      |
| Indiana Jones and the Temple of Doom               |
| Jaws                                               |
| Lincoln                                            |
| Schindler's List                                   |
| The Adventures of Tintin                           |
| The BFG                                            |
| War Horse                                          |

#+begin_src cozodb
  ::explain {
            linked[a, v, oa, ov] := *attributes[a, v, oa, ov]
  ?[title] := linked['title', title, 'director', 'Steven Spielberg'] }
#+end_src 

#+RESULTS:
| 0 | 0 | ?      | 3         |     load_mem | ?                  | S.0.0                              | :null                             | []                 | [*1 *2 *3]          |            |
| 0 | 0 | ?      | 2         |     load_mem | linked             | Mbfbb                              | :null                             | []                 | [**0 title **1 **2] |            |
| 0 | 0 | ?      | 1         | mem_mat_join | :null              | ((*1 . **0) (*2 . **1) (*3 . **2)) | :null                             | [title]            |                     |            |
| 0 | 0 | ?      | 0         |          out | :null              | :null                              | :null                             | [title]            |                     |            |
| 0 | 1 | linked | Mbfbb     |            4 | load_mem           | linked                             | S.0.0bfbb                         | :null              | []                  | [a oa ov]  |
| 0 | 1 | linked | Mbfbb     |            3 | load_stored        | :attributes                        | :null                             | []                 | [**0 v **1 **2]     |            |
| 0 | 1 | linked | Mbfbb     |            2 | stored_mat_join    | :null                              | ((a . **0) (oa . **1) (ov . **2)) | :null              | [a oa ov v]         |            |
| 0 | 1 | linked | Mbfbb     |            1 | reorder            | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 1 | linked | Mbfbb     |            0 | out                | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 2 | linked | Mbfbb     |            4 | load_mem           | linked                             | S.1.0bfbb                         | :null              | []                  | [a oa ov]  |
| 0 | 2 | linked | Mbfbb     |            3 | load_stored        | :attributes                        | :null                             | []                 | [**0 **1 **2 v]     |            |
| 0 | 2 | linked | Mbfbb     |            2 | stored_prefix_join | :null                              | ((a . **2) (oa . **0) (ov . **1)) | :null              | [a oa ov v]         |            |
| 0 | 2 | linked | Mbfbb     |            1 | reorder            | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 2 | linked | Mbfbb     |            0 | out                | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 3 | linked | Ibfbb     |            1 | load_mem           | ?                                  | S.0.0                             | :null              | []                  | [*1 *2 *3] |
| 0 | 3 | linked | Ibfbb     |            0 | out                | :null                              | :null                             | :null              | [*1 *2 *3]          |            |
| 0 | 4 | ?      | S.0.0     |            3 | unify              | *1                                 | :null                             | "title"            | [*1]                |            |
| 0 | 4 | ?      | S.0.0     |            2 | unify              | *2                                 | :null                             | "director"         | [*1 *2]             |            |
| 0 | 4 | ?      | S.0.0     |            1 | unify              | *3                                 | :null                             | "Steven Spielberg" | [*1 *2 *3]          |            |
| 0 | 4 | ?      | S.0.0     |            0 | out                | :null                              | :null                             | :null              | [*1 *2 *3]          |            |
| 0 | 5 | linked | S.0.0bfbb |            1 | load_mem           | linked                             | Ibfbb                             | :null              | []                  | [a oa ov]  |
| 0 | 5 | linked | S.0.0bfbb |            0 | out                | :null                              | :null                             | :null              | [a oa ov]           |            |
| 0 | 6 | linked | S.1.0bfbb |            1 | load_mem           | linked                             | Ibfbb                             | :null              | []                  | [a oa ov]  |
| 0 | 6 | linked | S.1.0bfbb |            0 | out                | :null                              | :null                             | :null              | [a oa ov]           |            |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[c] := linked['timezone', 'America/New_York', 'country', c]
#+end_src

#+RESULTS:
| United States |


#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v, distance] := linked['coordinates', c, a, v], distance = l2_dist(vec([35.99403, -78.89862], 'F32'), c)
  :limit 10
  :order distance
#+end_src

#+RESULTS:
#+begin_example
[31meval::throw[0m

  [31m√ó[0m Evaluation of expression failed
   ‚ï≠‚îÄ[1:1]
 [2m1[0m ‚îÇ linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
 [2m2[0m ‚îÇ ?[a, v, distance] := linked['coordinates', c, a, v], distance = l2_dist(vec([35.99403, -78.89862], 'F32'), c)
   ¬∑ [35;1m                                                                ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[0m
 [2m3[0m ‚îÇ :limit 10
   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ
[36m  help: [0m'l2_dist' requires two vectors of the same type
#+end_example

Furthest cities (the distance formula isn't quite right but
demonstrates the concept). Disambiguate the city of Durham from other
durhams, using the state.
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[v, s, country, distance] := linked['coordinates', c, 'state', 'North Carolina'], 
        linked['coordinates', c, 'name', 'Durham'],
        linked['coordinates', c2, 'name', v], distance = l2_dist(vec(c), vec(c2)),
        linked['coordinates', c2, 'state', s],
        linked['name', s, 'country', country]
        :limit 10
        :order -distance
#+end_src

#+RESULTS:
| Gisborne    | Gisborne District    | New Zealand | 71571.2578125 |
| Wairoa      | Hawke's Bay Region   | New Zealand |       71301.0 |
| Napier      | Hawke's Bay Region   | New Zealand |   71137.46875 |
| Hastings    | Hawke's Bay Region   | New Zealand |   71127.15625 |
| Taradale    | Hawke's Bay Region   | New Zealand | 71111.7421875 |
| Opotiki     | Bay of Plenty Region | New Zealand |    71107.5625 |
| Castlepoint | Wellington Region    | New Zealand |       70996.5 |
| Whakatane   | Bay of Plenty Region | New Zealand | 70945.6328125 |
| Murupara    | Bay of Plenty Region | New Zealand |  70875.046875 |
| Edgecumbe   | Bay of Plenty Region | New Zealand | 70871.4765625 |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v] := linked['coordinates', c, 'country', 'United States'], linked['coordinates', c, a, v]
#+end_src

#+RESULTS:
| country    | Liberia                              |
| country    | United States                        |
| name       | Alabama                              |
| name       | Alaska                               |
| name       | American Samoa                       |
| name       | Arizona                              |
| name       | Arkansas                             |
| name       | Baker Island                         |
| name       | California                           |
| name       | Colorado                             |
| name       | Connecticut                          |
| name       | Delaware                             |
| name       | District of Columbia                 |
| name       | Florida                              |
| name       | Georgia                              |
| name       | Guam                                 |
| name       | Hawaii                               |
| name       | Howland Island                       |
| name       | Idaho                                |
| name       | Illinois                             |
| name       | Indiana                              |
| name       | Iowa                                 |
| name       | Jarvis Island                        |
| name       | Johnston Atoll                       |
| name       | Kansas                               |
| name       | Kentucky                             |
| name       | Kingman Reef                         |
| name       | Louisiana                            |
| name       | Maine                                |
| name       | Maryland                             |
| name       | Maryland County                      |
| name       | Massachusetts                        |
| name       | Michigan                             |
| name       | Midway Atoll                         |
| name       | Minnesota                            |
| name       | Mississippi                          |
| name       | Missouri                             |
| name       | Montana                              |
| name       | Navassa Island                       |
| name       | Nebraska                             |
| name       | Nevada                               |
| name       | New Hampshire                        |
| name       | New Jersey                           |
| name       | New Mexico                           |
| name       | New York                             |
| name       | North Carolina                       |
| name       | North Dakota                         |
| name       | Northern Mariana Islands             |
| name       | Ohio                                 |
| name       | Oklahoma                             |
| name       | Oregon                               |
| name       | Palmyra Atoll                        |
| name       | Pennsylvania                         |
| name       | Puerto Rico                          |
| name       | Rhode Island                         |
| name       | South Carolina                       |
| name       | South Dakota                         |
| name       | Tennessee                            |
| name       | Texas                                |
| name       | United States Minor Outlying Islands |
| name       | United States Virgin Islands         |
| name       | Utah                                 |
| name       | Vermont                              |
| name       | Virginia                             |
| name       | Wake Island                          |
| name       | Washington                           |
| name       | West Virginia                        |
| name       | Wisconsin                            |
| name       | Wyoming                              |
| state_code | AK                                   |
| state_code | AL                                   |
| state_code | AR                                   |
| state_code | AS                                   |
| state_code | AZ                                   |
| state_code | CA                                   |
| state_code | CO                                   |
| state_code | CT                                   |
| state_code | DC                                   |
| state_code | DE                                   |
| state_code | FL                                   |
| state_code | GA                                   |
| state_code | GU                                   |
| state_code | HI                                   |
| state_code | IA                                   |
| state_code | ID                                   |
| state_code | IL                                   |
| state_code | IN                                   |
| state_code | KS                                   |
| state_code | KY                                   |
| state_code | LA                                   |
| state_code | MA                                   |
| state_code | MD                                   |
| state_code | ME                                   |
| state_code | MI                                   |
| state_code | MN                                   |
| state_code | MO                                   |
| state_code | MP                                   |
| state_code | MS                                   |
| state_code | MT                                   |
| state_code | MY                                   |
| state_code | NC                                   |
| state_code | ND                                   |
| state_code | NE                                   |
| state_code | NH                                   |
| state_code | NJ                                   |
| state_code | NM                                   |
| state_code | NV                                   |
| state_code | NY                                   |
| state_code | OH                                   |
| state_code | OK                                   |
| state_code | OR                                   |
| state_code | PA                                   |
| state_code | PR                                   |
| state_code | RI                                   |
| state_code | SC                                   |
| state_code | SD                                   |
| state_code | TN                                   |
| state_code | TX                                   |
| state_code | UM                                   |
| state_code | UM-67                                |
| state_code | UM-71                                |
| state_code | UM-76                                |
| state_code | UM-79                                |
| state_code | UM-81                                |
| state_code | UM-84                                |
| state_code | UM-86                                |
| state_code | UM-89                                |
| state_code | UM-95                                |
| state_code | UT                                   |
| state_code | VA                                   |
| state_code | VI                                   |
| state_code | VT                                   |
| state_code | WA                                   |
| state_code | WI                                   |
| state_code | WV                                   |
| state_code | WY                                   |

** Using an artificial entity column
#+begin_src cozodb :results value table
{:create eav {entity: Uuid, attribute: String, value: Any}}
#+end_src

What type should =entity= be? Some keys are uuids that link to pk attrs,
others are just the entity id. Maybe everything should use uuid? 
** Add source and time columns
#+begin_src cozodb :results value table
  {:create trust {source: Bytes,
                  target: Bytes,
                  with: Any,
                  ts: Validity default 'ASSERT'
                  =>
                  score: Int,
                  }}
#+end_src

#+RESULTS:
| [31mparser::pest[0m |


#+begin_src cozodb
::remove trust
#+end_src

#+RESULTS:
: [31mquery::relation_not_found[0m
: 
:   [31m√ó[0m Cannot find requested stored relation 'trusted_attributes'

#+begin_src cozodb 
  ?[source, target, with, ts, score] <-
  [
   ["bWU=", "QWxpY2U=", 'introduce', 'ASSERT', 11]       
  ]
  :put trust {source, target, with, ts, score}
#+end_src

#+RESULTS:
: [31meval::invalid_validity[0m
: 
:   [31m√ó[0m when executing against relation 'trust'
: [31m  ‚îú‚îÄ‚ñ∂ [0mwhen processing tuple ["bWU=", "QWxpY2U=", "introduce", [1703279106.2922018, true], 10]
: [31m  ‚ï∞‚îÄ‚ñ∂ [0m[1703279106.2922018, true] cannot be coerced into validity

#+begin_src cozodb
::relations
#+end_src

#+RESULTS:
| attributes     | 4 | normal | 4 | 0 | 0 | 0 | 0 |   |
| attributes:rev | 4 | index  | 4 | 0 | 0 | 0 | 0 |   |
| trust          | 5 | normal | 4 | 1 | 0 | 0 | 0 |   |

#+begin_src cozodb
?[source, target, with, score] := *trust[source, target, with, ts, score @ 'NOW']
#+end_src

#+RESULTS:
| bWU= | QWxpY2U= | introduce | 11 |

** Questions
What about when we insert "name=Alice, height=1.2", and then later
"name=Alice, height=1.3"?

I think part of the problem is we can't just arbitrarily pair
attributes, one of them has to be the "key".

For example, let's say we don't do that and we have:
[name Alice, height 1.6]
[height 1.6, weight 50]

In this case the "link" is height. But we don't want to link to
anything that's 1.6m high.

The first attribute has to be something that identifies the
entity. But as we know, not every entity has a single attribute that
uniquely identifies it. eg Person. The name isn't unique, but let's
say name+birthday is unique.

[name Alice, height 1.6]
[name Alice, bday 1/1]
[name Alice, bday 6/4]
[name Alice, height 1.3]

What we need is a unique id to attach to her attributes:

[id 1, name Alice]
[id 1, bday 1/1]
;; now we can hang other attrs off the id
[id 1, height 1.6]

One question is, does every entity have some unique attribute? It may,
but either we may not know it or it's really a combination of more
than one.

So there's several solutions,
+ Make the first attr a compound of multiple actual attrs, and make
  the individual ones linked from there.
+ Hash the multiple attrs

 If the attrs are a tuple, in theory we can fetch the record directly
  ,if the user knows how the key is built. THat's better than a
  generated id which the user is guaranteed not to know. So given
  this, let's remodel.

** kcats query format
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v] := linked['coordinates', c, 'country', 'United States'], linked['coordinates', c, a, v]
#+end_src

Let's say we wanted to write this query as kcats data instead of a string. How?
We've got 2 rules, one with an =or= and the other an =and=.

We could create some words to build some more explicit objects.
#+begin_src kcats
  [a v oa ov] [linked]  
  [a oa v ov] [attributes] rel ;; *attributes[a, oa, v,  ov]
  [a oa v ov] [attributes rev] index ;; *attributes:rev[a, oa, v, ov]
  or
  rule
  [a v] [?]
  ["coordinates" c "country" "United States"] [linked] rel
  ["coordinates" c a v] [linked] rel
  and
  rule

#+end_src

Of course, the most straightforward is to probably just build the
query string, it's just a bit error prone and inefficient.

Let's do that query and dump the parsed object, so we can imitate it a bit:

#+begin_src rust :crates '(cozo)
  extern crate cozo;
  use cozo;

  fn main() {
      let db = DbInstance::new("mem", "", Default::default());
      db.par
  }
#+end_src
Ok nevermind those functions that deal with parsed scripts are
private. I guess we'll have to just build the query string!

#+begin_src kcats
  [[comma-separate [[string] map ", " interpose "" swap [join] step]]]
  [[a b c d] comma-separate]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
"a, b, c, d"
#+end_src

** Import into cozo by reading json
#+begin_src kcats
  "Ama Qamata, Khosi Ngema, Gail Mabalane, Thabang Molaba, Dillon Windvogel, Natasha Thahane, Arno Greeff, Xolile Tshabalala, Getmore Sithole, Cindy Mahlangu, Ryle De Morny, Greteli Fincham, Sello Maake Ka-Ncube, Odwa Gwanya, Mekaila Mathys, Sandi Schultz, Duane Williams, Shamilla Miller, Patrick Mofokeng"
  [", " split] assemble
#+end_src

#+RESULTS:
#+begin_src kcats
["Ama Qamata" "Khosi Ngema" "Gail Mabalane" "Thabang Molaba" "Dillon Windvogel" "Natasha Thahane"
 "Arno Greeff" "Xolile Tshabalala" "Getmore Sithole" "Cindy Mahlangu" "Ryle De Morny"
 "Greteli Fincham" "Sello Maake Ka-Ncube" "Odwa Gwanya" "Mekaila Mathys" "Sandi Schultz"
 "Duane Williams" "Shamilla Miller" "Patrick Mofokeng"]
#+end_src

#+begin_src kcats
  "/home/jweiss/Downloads/netflix_titles.json" file-out slurp decodejson 

  [[
  [[second [[string?]
            [\" contains?]] [execute] every?] any? not] keep
    [["cast"] [[", " split] assemble] update
     [take] [] into 
     encodejson "u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- {} ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}"
     swap wrap format database
    ]
    each]
   assemble 
   count]
  [[unwound] unassign dropdown] recover
#+end_src

#+RESULTS:
#+begin_src kcats
8450
#+end_src

#+begin_src kcats
  dictionary

  [[
  [[second [[string?]
            [\" contains?]] [execute] every?] any? not] keep
    [["cast"] [[", " split] assemble] update
     [take] [] into 
     encodejson "u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- {} ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}"
     swap wrap format database
    ]
    each]
   assemble 
   count]
  [[unwound] unassign dropdown] recover
#+end_src


#+begin_src cozodb
  u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- [["cast",[]],["show_id","s11"],["release_year",2021],["title","Vendetta: Truth, Lies and The Mafia"],["director",""],["country",""],
          ["duration","1 Season"],["description","Sicily boasts a bold 'Anti-Mafia' coalition. But what happens when those trying to bring down organized crime are accused of being criminals themselves?"],["type","TV Show"],["date_added","September 24, 2021"],["rating","TV-MA"],["listed_in","Crime TV Shows, Docuseries, International TV Shows"]] ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}

#+end_src

#+RESULTS:
| OK |


#+begin_src cozodb
  u[uuid] <- [[rand_uuid_v1()]]
  av[attribute, value] <- [["release_year",2021],["director","Julien Leclercq"],["description","To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war."],["duration","1 Season"],["rating","TV-MA"],["title","Ganglands"],["cast",["Sami Bouajila","Tracy Gotoas","Samuel Jouy","Nabiha Akkari","Sofia Lesaffre","Salim Kechiouche","Noureddine Farihi","Geert Van Rampelberg","Bakary Diombera"]],["type","TV Show"],["date_added","September 24, 2021"],["country",""],["listed_in","Crime TV Shows, International TV Shows, TV Action & Adventure"],["show_id","s3"]]
  ?[entity, attribute, value] :=  av[attribute, value], u[entity]

  :put eav {entity, attribute, value} :returning

#+end_src

#+RESULTS:
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | cast         | [Sami Bouajila Tracy Gotoas Samuel Jouy Nabiha Akkari Sofia Lesaffre Salim Kechiouche Noureddine Farihi Geert Van Rampelberg Bakary Diombera]      |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | country      |                                                                                                                                                    |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | date_added   | September 24, 2021                                                                                                                                 |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | description  | To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war. |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | director     | Julien Leclercq                                                                                                                                    |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | duration     | 1 Season                                                                                                                                           |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | listed_in    | Crime TV Shows, International TV Shows, TV Action & Adventure                                                                                      |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | rating       | TV-MA                                                                                                                                              |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | release_year | 2021                                                                                                                                               |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | show_id      | s3                                                                                                                                                 |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | title        | Ganglands                                                                                                                                          |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | type         | TV Show                                                                                                                                            |

#+begin_src cozodb
  linked[a1, v1, a2, v2] := *eav[id, a1, v1], *eav[id, a2, v2]
             ?[title] := linked['title', title, 'cast', cast],
              actor1 in cast,
              actor2 in cast,
              actor1 == 'Adam Sandler', actor2 == 'David Spade'
#+end_src

#+RESULTS:
| Grown Ups                             |
| Hotel Transylvania 3: Summer Vacation |
| The Do-Over                           |
| The Ridiculous 6                      |

#+begin_src cozodb
    linked[a1, v1, a2, v2] := *eav:v[v1, id, a1], *eav:v[v2, id, a2]
    ?[count(title), actor2] := linked['title', title, 'cast', cast],
                      target = 'Adam Sandler',
                      actor1 in cast, actor1 == target,
                      actor2 in cast, actor2 != target
    :limit 10
    :order -count(title)
#+end_src

#+RESULTS:
| 7 | Rob Schneider     |
| 6 | Allen Covert      |
| 5 | Nick Swardson     |
| 5 | Steve Buscemi     |
| 4 | David Spade       |
| 4 | Kevin James       |
| 3 | Blake Clark       |
| 3 | Colin Quinn       |
| 3 | John Turturro     |
| 3 | Jonathan Loughran |

#+begin_src cozodb
::index create eav:v {value, entity, attribute}
#+end_src

#+RESULTS:
| OK |

#+begin_src cozodb
  linked[id, a1, v1, a2, v2] := *eav:v[v1, id, a1], *eav:v[v2, id, a2]
  ?[id, a, v] := linked[id, 'title', title, 'director', 'Steven Spielberg'],
           *eav[id, a, v]


#+end_src


* DONE Install the lexicon in the proper place
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in =/usr/share/kcats= or =~/.local/share/kcats= or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.


* CANCELED Add option to read an alternative lexicon file
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
The builtins can stay inside the binary, but we should have a cmdline
option to start without the usual lexicon. Should probably add a word
'lexicon' to add a parsed object as the lexicon.

* DONE Package the binary for various platforms
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Would be nice to build rpms/debs etc so users can skip the nasty build
process.

* DONE Optimize memory allocation
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Lists
#+begin_src kcats
[[a b]] [a] lookup
#+end_src

#+RESULTS:
: b

* DONE pack and unpack are not inverse
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :result code
[1 2 3] unpack pack
#+end_src

#+RESULTS:
: 
: [[2 3 1]]

It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.

Solution: rename to put take

* DONE true and false are not words?
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :results code
[true] unwrap word?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

If you didn't know =true= was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).

It's messy because true/false are the only "words" you can put onto
the stack without wrapping.

There are several ways to deal with this:

+ just leave as is (these look like words but don't act like them)

+ Use something else for boolean values, like 0b 1b or something (ugly, no)

+ Revert to allowing bare words (that aren't actions) to go onto the
  stack unwrapped, so that true/false aren't different

Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.

* DONE Division by zero panics
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:

* DONE 'Fail' is not defined
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
We need to be able to throw our own errors (eg lookup tries to do this)

#+begin_src kcats
1 2 [1 "two" +] [fail] recover 3 4 
#+end_src

#+RESULTS:
: converting to error: Error([[type error] [asked [number]] [unwound [+]] [reason "type mismatch"]])
: [[type error] [asked [number]] [unwound [3 4]] [reason "type mismatch"]] 2 1


* DONE 'dictionary' doesn't allow access to the data inside definitions
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
The definition is just shown as the word itself and we can't access
spec, definition etc.

#+begin_src kcats :results code
dictionary [swap spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item a] [item b]] [[item b] [item a]]]
#+end_src


* DONE Change boolean operators to retain values
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
=or= and =and= should return the actual value if it is truthy, instead
of =true=. But neither should ever return =[]=, but use =false=
instead.
#+begin_src kcats
2 [] or
#+end_src

#+RESULTS:
: 2

#+begin_src kcats
1 10 inc 1 range take swap [*] step
#+end_src

#+RESULTS:
: 3628800

This does bring up the question of whether the boolean type is really
needed. It may be possible to use =[]= as =false= and anything else as
=true= (=1= for example, or maybe the bare word =true= which then
wouldn't carry any other meaning). Or possible use some other word
than =true=, eg =something=.

Does this make sense when applied to boolean logic?

#+begin_example
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
#+end_example

I think it doesn't make sense.

Maybe yes/no?

#+begin_example
yes or no = yes ?
#+end_example
#+begin_src kcats
5 3 =
#+end_src

#+RESULTS:
: 
: [[]]

#+begin_src kcats
5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide
#+end_src

#+RESULTS:
: 
: ["five" 5]

#+begin_src kcats
[3 5 7] [even?] any? false =
#+end_src

#+RESULTS:
: 
: stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
: program: [false =]

* DONE 'recover' is broken
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[+]
[drop 1
 [+] [drop 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: [3]

#+begin_src kcats
[[program [[+] [3] recover]]] environment advance advance
eval-step
advance
advance
advance
advance
advance
eval-step
advance
advance
advance
#+end_src


* DONE Fix handle in nested env
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
=handle= doesn't work properly in a nested environment. That is
because =eval= has some logic to check for uncaught exceptions, but
the =advance= self-hosted evaluator doesn't.

#+begin_src kcats
1 + handle error?
#+end_src

#+RESULTS:
: Env: [Word(0x5d29b8fb5b00 : "handle"), Entry(Entry { word: 0x5d29b8fc2600 : "error?", examples: None, spec: Some([List([Word(0x5d29b8fb6c00 : "item")]), List([Word(0x5d29b8fb6820 : "boolean")])]), serialize: false, definition: Builtin })]
: handle is Word(0x5d29b8fb5b00 : "handle") Word(0x5d29b8fb5b00 : "handle")
: expr contains handle? true
: Word(0x5d29b8fb5b00 : "handle") vs Word(0x5d29b8fb5b00 : "handle")
: 
: [true 1]

#+begin_src kcats
+ handle type
#+end_src

Looks like the word =error?= is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
=type=, which expects the builtin version of =error?=).

#+begin_src kcats
[[program [+]]] environment eval-step 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]]]] [program []]]]

#+begin_src kcats
[[program [1 +]]] environment advance advance advance 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [program [+]]]]

#+begin_src kcats
[[program [[[3]] [+ handle] dip]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [program [+_handle [[[3]]] unwrap]]]]

#+begin_src kcats
[[program [+ handle]]] environment eval-step eval-step
#+end_src

#+RESULTS:
: { stack: [], program: [[[program [+ handle]]] environment eval-step eval-step] }
: { stack: [[[program [+ handle]]]], program: [environment eval-step eval-step] }
: { stack: [[[stack []] [program [+ handle]]]], program: [eval-step eval-step] }
: { stack: [], program: [+ handle] }
: { stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [program [+ handle]]]], program: [eval-step] }
: { stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], program: [+ handle] }
: 
: [[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [program [+ handle]]]]

There is a problem in the design where an error (with no =handle=) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.

A possible solution is to have whatever =eval= we're using halt but
remove the =halt= bit (in the current design it's the =is_handled=
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.

Also for nested envs we need several words to help deal with errors:

+ a word that tells whether the env will halt: that there's an error
  on ToS with halt bit set, and =handle= does not appear in the
  program. The word can efficiently return =false= if ToS isn't an
  Error.

+ A word that removes the halt bit - as the last thing to do before
  exiting.

So what about the word =advance= that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In =eval= it's pretty obvious if we
halted on error - the program isn't empty (that's the only other
reason to stop). We could see in =advance= that the program got
longer, but isn't very obvious in many cases.

Another possibility is letting the program unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
=recover= is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the program that will know what to do. But
there may not be, and the end result is a major unwind of the
program, at least, all the way to the deepest =recover=. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on. 

But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong *and*
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.

Maybe another possibility is unwinding the program **into** the
error object. In other words, whatever program items we lop off, we
save them in the error object, in a field named, say, =unwound= or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
program from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
=rewind= or something, that restores the program from the error on
ToS and clears the halt bit.

I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the program item that threw the error so
we would still have it to retry. I'm thinking syntax like this:

#+begin_src kcats
[+] [[1 1] dip retry] recover
#+end_src

In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:

#+begin_src kcats
[[stack [[[type error] [asked [consume]] [unwound [+]]]]
 [program [[1 1] dip retry]]]]
#+end_src

So we =dip= the numbers underneath the error, then calling =retry= on
an error will extract the =unwound= field (discarding the rest of the
error) and =execute= it. So then we end up with =1 1 +=.

Ok i actually implemented this (and I don't think it was difficult)
but i don't know what I did with it. I know it worked quite well and I
wanted to keep it. Need to do it again.

#+begin_src kcats
  ;; there needs to be 3 numbers here to add/mult but we forgot!
  + * 1 2 3
  handle ;; catch the error here, stack is empty except the error
  [5 6 7] dip ;; put numbers underneath
  retry ;; rerun what failed before
#+end_src

#+RESULTS:
: 
: [3 2 1 65]

Now put it together using the higher-level =recover=

#+begin_src kcats
  [+ *] [[5 6 7] dip retry] recover
#+end_src

#+RESULTS:
: 
: [65]


* DONE Lots of association-like objects that aren't
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait *and* make the trait object part of the
Item enum.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar { Int(i32), Foo(Box<dyn Foo>), Quux(Quux) }
#+end_src

#+RESULTS:

Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar<'a> { Int(i32), Foo(&'a dyn Foo), Quux(&'a Quux) }
#+end_src

#+RESULTS:


#+begin_src kcats :results code
  dictionary [advance definition] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[[program] lookup count] shield swap [[program] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap drop]]
#+end_src

#+begin_src kcats :results code
  [[program [1 1 +]]] environment eval-step [stack] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[1]]
#+end_src

#+begin_src kcats :results code
[] environment association?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

#+begin_src kcats
dictionary [fail] lookup
#+end_src

#+RESULTS:
: [[spec [[string] [*]]] [definition []]]


* DONE scoping of dictionary entries
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
The original design was to have the dictionary be a single atomic data
structure that code could modify basically at will, with words like
=inscribe= (to add words) etc.

However I think a better design would be something like this:

#+begin_src kcats
  [[add1 [1 +]]] [3 add1] augment
#+end_src

Where the word =augment= takes an association (more specifically, a
dictionary) and overlays that on top of the builtin dictionary. Then
those new words become accessible just as if they were built in, then
the 2nd argument (a program) is executed as usual. After execution,
the learned words are no longer accessible.

It would be possible to nest calls to =augment= (where the program has
its own call to =augment=).

As for implementation, it may be possible to do a kcats-only impl, but
I don't think it's going to perform well. This is going to be the
normal mode of execution. Very few programs will run with only the
builtin words. In fact, it may be a good idea to break up the lexicon
into components - have pipes be a separate library that has to be
loaded with =augment=.

There is some overlap in functionality here, between =decide= and
=augment= - both are designed to provide context. Maybe =decide= provides
context on how a given word (whose overall meaning doesn't change)
applies to a given piece of data. And =augment= provides completely new
words, or provides a new meaning. Probably it's not going to be common
to replace meanings - maybe for security reasons. For example, when
running untrusted code, you may want to eliminate certain words (like
those that have side effects like writing to disk or the
network). That brings up the possible feature of not just merging new
items into the dictionary but doing arbitrary combinators, where =join=
is just a common use case. In that case, maybe =augment= isn't the right
word because you might be actually restricting the dictionary. So we
need a more generic term for "changing the language". Garble? babel?
I like =babel= - it captures the fact that we're moving from one
language (the set of builtin words) to lots of different languages. I also like =lingo=.

#+begin_src kcats
  [[clone *] [square] assign] ;; operate on the dictionary - add word 'square'
  [3 square]
  lingo
#+end_src

would print 9.

The idea here is to have local lingo, possibly down to quite small
pieces of code. I'm thinking on the order of 10 words is probably
enough to have certain words added or changed.

Special care will need to be taken, if you want to change the meaning
of the word, but re-use the old meaning as part of the new
meaning. You can't just overwrite the definition with a new one that
contains the word itself, expecting *that* word to refer to the old
meaning. You'll have to capture the old definition and incorporate
it. =update= should help.
** What to call this word
+ learn (but unlearn after?)
+ specialize
+ extend
+ adapt
+ augment 
+ refine
+ supplement
+ babel
+ lingo <= front runner.
** Implementation
It seems viable that we could use the stack to hold dictionary changes.

We'd have to retain a copy of the original dictionary to restore later.

An axiom word like =definitions= or something that sets the dictionary
to ToS would help. I think the rest could be pure kcats.

it'd be something like:

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float ;; d p n
  swapdown ;; d n p
  [redefine ;; p
   execute]
  dip ;; d
  redefine
#+end_src

#+RESULTS:
: 81

A few problems remaining above:
- [X] Need to specify the word inside the definition.
- [X] Need to explicitly convert the definition to an association.

But I think this proves the concept.

Probably want to eventually make a rust implementation.

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float
  swapdown
  [redefine] dip dictionary [square] lookup
 
#+end_src

#+begin_src kcats :results code 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  lingo 
#+end_src

#+begin_src kcats
  dictionary [square] [[definition [clone *]]
                       [spec [[number] [number]]]] assign
  [square] lookup
#+end_src

#+RESULTS:
: Warning, failed to insert into dictionary: List([List([Word(0x5dcc4c2878e0 : "definition"), List([Entry(Entry { word: 0x5dcc4c26dea0 : "clone", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5dcc4c26dea0 : "clone")]), List([Int(1), Int(2), Int(3), Int(3)])])]), spec: Some([List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])]), List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")]), List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5dcc4c2579c0 : "*", examples: None, spec: Some([List([Word(0x5dcc4c258ab0 : "number"), Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])]), serialize: false, definition: Builtin })])]), List([Word(0x5dcc4c25a6a0 : "spec"), List([List([Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])])])])
: []


* DONE Move environment stuff into own module
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :results code
  [[program [1 2 3]]] environment 
#+end_src

#+RESULTS:
#+begin_src kcats
{ stack: [], program: [[[program [1 2 3]]] environment] }
{ stack: [[[program [1 2 3]]]], program: [environment] }

[[[stack []] [program [1 2 3]]]]
#+end_src

#+begin_src kcats
1 2 +
#+end_src

#+RESULTS:
: 
: [3]


* DONE When printing results, don't wrap the stack
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Evaling =1 1 += should print =2=, not =[2]=. We don't have to wrap the
input, so why wrap the output.


* DONE Update pipes to use enums instead of traits
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It's worked out well for everything else, and I don't think anyone
else will be implementing these traits.

Looking at this I am not in that big a hurry to change it, with traits
at least I can spread out the impls into different modules. with enums
that'd be awkward.


* CANCELED Recover clears the stack built up in the try program
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:12
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
#+begin_src kcats :results code
 [2 3 "four" * +] [] recover
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [unwound [* +]] [type error] [asked [number]]]
#+end_src

Apparently this was my design. I am not so sure about it now, that we
have =retry=. If an error occurs in the middle of a program, what do we
do with the stack? If the recovery is meant to be "try something else
instead of the entire program" then restoring the stack makes
sense. However then that breaks use of =retry= because the recovery
can't pick up where the program left off.

Maybe =recover= and =retry= are mutually exclusive.

We could also use =retry= with =handle=:

#+begin_src kcats
2 3 "four" * + handle [drop 4] dip retry
#+end_src

#+RESULTS:
: 14

To make this work you have to know which item is the potential problem.

Specifying alternates seems useful, such that it will keep retrying
until it hits an empty alternates object or the program finishes. Each
time an alternate is tried it is removed from the list.

#+begin_src kcats
[2 3 ["four" 4] alternates * +] retry 
#+end_src


* DONE List access and update by index
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:12
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
I think re-using =lookup= and =assign= for lists, using their index, makes sense here:
#+begin_src kcats
  [5 10 15 20] [1] lookup
#+end_src
should print 10.

#+begin_src kcats
  [5 10 15 20] [1] 30 assign
#+end_src

#+RESULTS:
: [5 30 15 20]

 would leave =[5 30 15 20]=.

 The problem here is that this is ambiguous:

#+begin_src kcats
  [[a b] [c d]] [0] [d e] assign

  ;; is it (assigned as a hashmap by key)
  ;;[[a b] [c d] [0 [d e]]]

  ;; or is it (assigned as a vector by index)
  ;;[[d e] [c d]]
#+end_src

#+RESULTS:
: [[d e] [c d]]

We could clear up the ambiguity by saying that int keys on a list mean
vector behavior. If you want the other you have to specify =association=
first.

lets check some corner cases - creating nested lists
#+begin_src kcats
  [1 2 3] [1 0 0] "foo" assign
;; should be [1 [[foo]] 3]
#+end_src

#+RESULTS:
: [1 [["foo"]] 3]

What do we do when we're requested to assign beyond the end of the
list? We can extend the list and pad it with =Nothing=, although this
seems maybe going a bit too far to honor the user's request that maybe
doesn't make sense.

#+begin_src kcats
  [1 2 3] [1 2] "foo" assign
#+end_src

#+RESULTS:
: [1 [[] [] "foo"] 3]

Now let's test mixed list/assoc

#+begin_src kcats
  [1 2 3] [1 foo baz 0] "bar" assign
#+end_src

#+RESULTS:
: [1 [[foo [[baz [[0 "bar"]]]]]] 3]

Note that here, the last 0 index inserts as a map key because the
object is already an assoc. The contract is basically that once you're
in assoc-land you stay there.

Now check the changes for =lookup=

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] lookup
#+end_src

#+RESULTS:
: 45

make sure update works too

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] [inc] update
#+end_src

#+RESULTS:
: [1 4 [34 6 46] 99 23]

#+begin_src kcats
true not
#+end_src

#+RESULTS:
: []


* DONE Multithreading
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:12
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** Overview
There are a few major components here:
+ Be able to tell whether an environment can advance. It's basically
  "if there's nothing in the program, it's done, otherwise it can
  run unless it's currently putting/taking from a pipe"
** Pipes
It's not clear to me what to do about pipes. As soon as we call =take=
(for example) we're going to block the rust thread. In order to use
lightweight "threads" we're going to need a non-blocking check to see
if something can come out (or fit in) the pipe. For things like files
and sockets, it looks like we will need =tokio=.

tokio has Task which can manage this. It looks like tokio has file io
and network io that will automatically yield and allow other tasks to
run.

So then another question is, how to use something like =select= in
kcats. It might be possible to pass in a list of pipes to select and
then return the item that came out (along with the pipe itself i
guess). But this is advanced functionality that probably isn't a high
priority.

I think the basic design here is that each environment is a single
"thread" of execution, and that will map to a tokio Task. Pipe
operations within an env will call the async functions but will
immediately =await=. That should yield to allow other envs to run.

It looks like the =async= will creep all the way up to =axiom::eval=. If
the criteria is that anything we want to be able to pre-empt (if it's
waiting on i/o) needs to be labeled async, then everything up to =eval=
is going to be =async=.

I think that means fns like =f_stack1= etc will need to be async because
the =f= it calls can potentially call i/o. Actually it's probably best
to make new async versions of these so we don't have to make all the
Item fns async too.

We'll also need to think about what to do about dangling
environments - let's say we have the main env, and it spawns env e,
which will feed values back to main. But let's say main is done and
doesn't want any more values from e. Is the entire program done and we
can garbage collect e? My first instinct here is to blow everything
away as soon as main is done. If we don't want to exit we should be
taking from a pipe that won't produce anything until we're ready to
exit. So we're not going to =join= with other environment's tasks.
** DONE Add tokio as dep
** DONE Prepare for multithreading
*** DONE Use Arc instead of Rc
Does Arc have =make_mut=?  Yes! So hopefully it will be a drop-in
replacement.
** DONE Update pipe types for fs and net to use tokio calls
One problem here is that we don't have a trivial way to mix step
functions that are pure vs involving pipes.

If we don't know until runtime what it is, we have to assume async and
there's probably a huge performance hit.

Maybe one way to proceed is to make an =Item= variant =Future=. So if
we're taking from a pipe, we can just put the =Future= on the stack and
continue. Of course, very soon we'll need to access the value and call
=await= on it. 

What then, do we do about =put=? Let's say the pipe is full and the put
needs to wait. We can return the Env but we still need to await sometime.

Maybe in eval-step, we can check if the top item is a Future. If so,
await it. If it returns another Item, replace it. If it returns Unit,
just drop it. Somewhere we'd need a type =Option<Item>= for what the
futures return (None if we're just waiting on a value to put into a
pipe, Item if we're taking)

So will this work in nested envs? I am not sure but I can't think of
why it wouldn't.

If this works then only eval/eval-step will need =async=.
** DONE Use channel type to implement handoff pipe
*** DONE Use crossbeam channels
mpsc doesn't allow us to clone the receiver (Out) end of the pipe, and
that would seem like a rather sharp corner to users of kcats who
generally aren't too performance sensitive and want simple programs to
"just work".

#+begin_src kcats :results code
  handoff clone
  wrap [5 put "hello" put] join
  [] swap [[program]] dip assign environment animate take [take] dip
#+end_src

#+RESULTS:
#+begin_src kcats
5 "hello" [[type pipe] [handoff todo: id-or-hash here]]
#+end_src

#+RESULTS:
:

One issue here is that we accidentally made a bidirectional channel. I
don't know if that should be the default mode of operation. When we
create a handoff maybe we should really create two stack items: the in
and out. 

The question is, what should be a tunnel? I am not sure single stack
items really should allow both put and take.

The problem with splitting them is it can exascerbate the already
difficult problem of stack manipulation (if indeed you actually need
to read from a file and then write to the same spot... is that
common?)

The benefit is that a process that's supposed to be reading can't
accidentally write, if it doesn't have the In part of the pipe.

For now I think I'm inclined to leave it as-is and see how it goes.
*** TODO Nonblocking eval-step (for inner envs)
It would be nice if calling eval-step on an inner env and having it
block, wouldn't block the outer env (or at least it would be nice if
it were an option not to wait). Maybe =try_eval_step= which tries to
make progress immediately and if it can't, just returns as-is.

There's probably a way to do this by polling the future. using =select!=
with a short timeout future would do it but there's probably a better
way.
*** TODO Combine implementations for net and fs
They're both using AsyncReadExt and AsyncWriteExt methods. The only
difference between them is how the pipes are created. It would be
easier to make pipes for stdin/stdout this way.  I tried it but the
compiler complained about not being able to make trait objects out of
them. Will revisit later.

** DONE Implement 'spawn' or equavalent
Can probably think of a better name. What we're doing is taking an
environment that's a local piece of data on the stack and spitting it
out to make it its own autonomous thing.
=animate= seems rather fitting.

#+begin_src kcats
 [[program [+ 1 1]]] environment animate 
#+end_src

#+RESULTS:
: 
** DONE Implement 'future' or equivalent
The idea here is to take an program and run it in its own spawned
env, and when it's done, snapshot the stack and put it into a
pipe and close it. The original env gets the other end of the pipe.

I think the new env should probably inherit the current env's stack.
#+begin_src kcats :results code
  1 2 [+] 
  ;; make a pipe
  handoff swap
  ;; save the stack, including pipe
  [snapshot] dip
  ;; prepare the program for the new env
  ;; end up with [[+ snapshot] dip swap put]
  [snapshot] join wrap [dip swap put drop] join
  ; ;; now we have expr stack
  pair
  [stack program] swap zip environment
  animate take
#+end_src

#+RESULTS:
#+begin_src kcats
[3] [[type pipe] [handoff todo: id-or-hash here]] 2 1
#+end_src

#+begin_src kcats
  1 [2 +] future take swap drop
#+end_src

#+RESULTS:
: [3] 1

* DONE Implement print (opposite of read)
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
We don't have a way to convert objects to their string serialization
Completed as the word emit

* DONE logical enum hierarchy
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Collection hierarchy
There are read (peek/first) and write operations (pack/put/conj).

Then there are read/write ops like (take/unpack) that mutate the coll
and also return a value.

An In pipe supports only write. An Out pipe supports only
read-write. Pipes in general do not support peeking.

Collections (lists, maps, sets etc) support all of them.

It's not clear how to support overlapping functionality in an enum.
** DONE pipe as list-like thing
Are both words =put= and =pack= needed (similarly =take= and =unpack=)? Seems
like the former should be all that's needed. That starts to address
that pack/unpack aren't inverse (they shouldn't be because it's really
put/take, and whether you get the last item back or not depends on the
underlying impl - a stack you would, a queue you wouldn't).

Also take in other langs takes a number arg (how many to take). You
could do this as =[take] 5 times=, but that's less efficient. Could
maybe create a new word like =split= or =unload= or something.

The possibility that these words might block, and you don't know
except by the argument type, is a bit off-putting, and maybe these
should be different words? I don't know, the contract is to "take
thing out of other thing" and sometimes that's instant and sometimes
it isn't. (You can ask if the object is a pipe before taking)

=step= should work on pipes. It continues until the pipe closes. How do
we write step in terms of take? The problem is we don't know when to
stop. We know if a collection is empty, but we need to know if a pipe
is closed. The way pipes work now is that if something goes wrong, it
produces an error from the pipe. That's ok for pipes, where we're ok
with the limitation that you can't tell whether the error was
generated during the take or was the actual data sent. However when
dealing with lists, errors are never generated, they're always the
item in the list. We want step to treat both errors and =nothing= as
actual items and not a flag value for error conditions

OK here's a plan: Result<Option<Item>>.  If the pipe is closed, return
Ok(None), if error return Err. The way we differentiate between Errors
in a list and Errors that just happened, is already implemented: via
the 'handled' field of the Error. So if there's a error in the list,
it'll have handled=true and it won't cause the program to
unwind. If it's an actual error reading from the underlying data,
it'll have handled=false and unwind. This will also allow us to
support Nothing in lists and pipes, we won't reserve it as a sentinel
value.
** DONE Step accepts pipes
** DONE Set close = drop
** DONE Remove closed? 
*** DONE Write assemble in terms of step
I don't think we actually need assemble anymore, since this is just a
regular =step= (same as reducing any other iterable).
*** DONE Do something with network pipes
I think this does have a notion of closing.
** DONE make a polymorphic 'join'
:LOGBOOK:
CLOCK: [2023-01-04 Wed 05:48]--[2023-01-04 Wed 07:26] =>  1:38
:END:
The problem is that it's not symmetrical. If you have two different
types, whose semantics do you use? Sometimes it's obvious regardless
of order. Other times I suppose it's ok to use the first one (the
deeper in the stack).

 - list assoc -> list
 - assoc list -> list
 - list string -> list
 - assoc string -> error
 - assoc assoc -> assoc (merge top into 2nd)

   #+begin_src kcats :results code
     [[a b] [c d]] [[e f]] join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a b] [c d] [e f]]
   #+end_src

   #+begin_src kcats :results code
     [[a b] [c d]] association [[a f]] association join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a f] [c d]]
   #+end_src
** DONE Update spec types to be more abstract
For example, =step= now accepts not only lists but also out-pipes. So
really the spec type for this argument should be =iterable= or
something.

For ideas of what to call these types, how about =in= and =out=? So eg
step takes a program and an out. =put= takes an =in=, =take= takes an =out=. I
am not sure if the =tunnel= concept will be necessary.

* DONE Support char type
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
If we don't support char, that breaks the abstraction of a String as a
sort of collection. A collection of what? Characters, not 1-length
strings.

Might have to do something similar with byte, but a byte array can
also be thought of as an array of ints (8 bit unsigned), and we
already have an integer type (even though it holds more bits).

* DONE implement sleep                                               :stdlib:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
helps with debugging multithreading

#+begin_src kcats
1000 sleep
#+end_src

#+RESULTS:
#+begin_src kcats

#+end_src

#+begin_src kcats
timestamps take [1000 timer take] shield drop [take] dive 1000 - 100 within? 
#+end_src

#+RESULTS:
#+begin_src kcats
true [[type out]
      [from systemtime]
      [values [[type integer]
               [units milliseconds]]]]
#+end_src


* DONE handoff tests
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
This should block, not error
#+begin_src kcats
handoff take
#+end_src

#+RESULTS:
: [[reason "type mismatch"] [unwound [unpack]] [type error] [asked [list]] [actual [[type pipe] [handoff todo: id-or-hash here]]] [handled true]] [[handoff todo: id-or-hash here] [type pipe]]

#+begin_src kcats
  handoff [1 2 +] future take 
#+end_src

#+RESULTS:
: [3 [[type pipe] [handoff todo: id-or-hash here]]] [[handoff todo: id-or-hash here] [type pipe]] [[handoff todo: id-or-hash here] [type pipe]]

#+begin_src kcats
handoff clone [snapshot] dip swap [1 put 2 put] join [[] [program]] dip assign environment animate take [take] dip +
#+end_src

#+RESULTS:
: 3 [[type pipe] [handoff todo: id-or-hash here]] [[type pipe] [handoff todo: id-or-hash here]]

Should make a word that creates an inner env with access to a handoff also present in the outer env.
#+begin_src kcats
    [[1 2 3] [put] step close] handoff clone ; p h h
    [wrap swap join [[] [program]] dip assign environment animate] dip
    0 swap [+] step
  ;;[snapshot] dip swap  join [[] [program]] dip assign environment animate take [take] dip +
#+end_src

#+RESULTS:
: 6

#+begin_src kcats
    [[1 2 3] [put] step close] handoff clone ; p h h
    [wrap swap join [[] [program]] dip assign environment animate] dip
    0 swap [+] step
  ;;[snapshot] dip swap  join [[] [program]] dip assign environment animate take [take] dip +
#+end_src

Read from one file and write to another 
#+begin_src kcats
  [[file "/tmp/bar"]] pipe-in
  [[file "/tmp/foo"]] pipe-out 
  [put] step
#+end_src

#+RESULTS:
: [[type pipe] [file "/tmp/bar"]]

As a library function
#+begin_src kcats :results code
  "/tmp/bar" "/tmp/foo" file-out [file-in] dip
  [put] step close
#+end_src

#+RESULTS:
#+begin_src kcats
Closing In
[[file "/tmp/bar"] [type pipe]]
#+end_src


* DONE Investigate simpler map/filter impls
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :results code
7 8 [+] [] [] sink [shielddown dip] decorate [swap] unwrap prepend [swap put] join step
#+end_src

#+RESULTS:
#+begin_src kcats
[+] 8 7
#+end_src

#+begin_src kcats :results code
3 [1 2 3 4 5 6] [drop odd?] [] sink [shield dip] decorate [swap] unwrap prepend [sink [put] [drop] branch] join step
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3 4 5 6] 3
#+end_src


* DONE Allow generator transforms to work on pipes
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
pipe + [take] = generator

* DONE Implement hashset                                             :stdlib:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-12-31 Sun 13:55]
Once we have this, we can implement stuff like the =distinct= transform
function.

** DONE Implement set membership check
- State "DONE"       from "INPROGRESS" [2023-12-31 Sun 13:55]
Could possibly piggyback on =lookup= here, but the semantics are a
little different (nested sets are not allowed, return value is the
same as the key argument).

Another option is to call it =contains?= and check for membership. The
implementation could accept any Sized type, but it's not obvious how
to handle map types - are we checking just for the key, or key/val
pair? I lean slightly toward just the key, but hard to say. For list
types do we convert or promote to set, or just do a (worst case) full
pass over the elements? Vec[Deque] has a contains method so I'm
inclined to just use that.

*** DONE Substring or subcollection
- State "DONE"       from "TODO"       [2023-12-31 Sun 13:55]
Included as part of this should be substring and subarray checking. eg
="foobar" "bar" contains?= should return =true=. It's a different behavior
when the member and collection are the same type vs different
types. Should probably error when it's two different collection types,
eg =[1 2 3] [2 3] set contains?= should error.

#+begin_src kcats
"foobar" "oob" contains?
#+end_src

#+RESULTS:
#+begin_src kcats
yes
#+end_src

#+begin_src kcats
[1 2 3] set 3 contains?
#+end_src

#+RESULTS:
#+begin_src kcats
yes
#+end_src


* DONE Implement until
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
like =while= but always runs the body once.

#+begin_src kcats :results code
  64 [50 >] [clone *] ;; until
  swap ;; pred body
  [not] join ;; reverse logic
  [shield] decorate ;; add shield to the pred program -> pred body
  join ;; [body ..  pred]
  true swap ;; run at least once
  loop
#+end_src

#+RESULTS:
#+begin_src kcats
4096
#+end_src

use until in places I wish i'd had it:
laster:
#+begin_src kcats :results code
  [1 2 3 4] liberate
  [] []
  [[empty?]
   ;; l sl
   [swap ;; sl l
    drop ;; l
    [generate] dip ;; sl l
    swap] ;; l sl 
   until swap
   [[]] dipdown] ;; replace the empty state
  collect
#+end_src

joiner
#+begin_src kcats :results code
  [[1 2 3] [4 5 6] [7 8 9]] liberate
  [] []
  [empty?]
  [drop ;; r
   [generate] dip ;; r i
   swap ;; i r
   clone ;; i i r
   [join] dip ;; i r2
  ] until  generate
#+end_src
#+RESULTS:
#+begin_src kcats
[1 2 3 4 5 6 7 8 9] [] [take] []
#+end_src

#+begin_src kcats
[1 2 3 4] liberate generate
#+end_src

#+RESULTS:
: 1 [take] [2 3 4]


* DONE CI on github                                                   :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:


* DONE Add a kcats logo to github project page                        :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:


* DONE Add a video snippet of repl interaction to github project page :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:


* DONE Write an alpha release announcement                            :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-02-23 Fri 15:14]
Show HN: Kcats: A Powerful, Beginner-Friendly, Stack-Based Programming Language
#+begin_src fundamental
  Hello everyone,

  I'm excited to introduce the alpha release of kcats, a fresh take on stack-based programming languages, inspired by the language Joy, designed with simplicity, learnability, and functionality in mind.

  Our aim with kcats is to make it easier for anyone to write short programs for personal automation tasks. We believe that existing languages require learning too many specialized functions and concepts. Kcats addresses these issues by offering a streamlined alternative. Originally conceived as a scripting language for a forthcoming messaging protocol, it's useful for general programming as well.

  Key features of kcats:

      Simplicity: kcats emphasizes fewer, general-purpose tools instead
      of a complex array of specialized ones. Its syntax uses words and
      bracket quotation marks [ and ], and no other symbols. It uses a
      few simple programming concepts including stacks, lists,
      functions, and pipes.

      Introspective: The documentation, examples, and even the entire
      state of a running program, are data that can be queried and
      processed with the language itself. Kcats is its own debugger.

      Powerful and Versatile: Despite its simplicity, kcats is designed
      to be a powerful tool capable of handling a wide range of
      programming tasks. The tools programmers use in other languages
      are there, and built from simple primitives - closures, error
      handling, metaprogramming, multithreading, channels, generators,
      i/o, and serialization.

      A Focus on Tooling: kcats intends to make tool development,
      including IDEs and debuggers, as easy as possible.

  As this is the alpha release, we eagerly welcome all feedback, contributions, and constructive criticisms from the community. We're especially interested in improving the documentation and learning experience.

  Join us in exploring this new language and contribute to making programming more accessible to everyone. Your feedback is essential to making it intuitive and easy to use!

  Please check out our docs and alpha release here:
  https://github.com/skyrod-vactai/kcats

  Happy coding!

  Best, Skyrod
#+end_src
#+begin_src fundamental
  Announcing the Alpha Release of kcats: A Simple, Powerful,
  Beginner-Friendly, Stack-Based Programming Language

  Hello everyone,

  I'm excited to introduce the alpha release of kcats, a fresh take on
  stack-based programming languages, inspired by the language Joy,
  designed with simplicity, learnability, and functionality in mind.

  Our aim with kcats is to make it easier for anyone to write short
  programs for personal automation tasks. We believe that existing
  languages require learning too many specialized functions and
  concepts. Kcats addresses these issues by offering a streamlined
  alternative. Originally conceived as a scripting language for a
  forthcoming messaging protocol, it's useful for general programming as
  well.

  Key features of kcats:

      Simplicity: kcats emphasizes fewer, general-purpose tools instead
      of a complex array of specialized ones. Its syntax uses words and
      bracket quotation marks [ and ], and no other symbols. It uses a
      few simple programming concepts including stacks, lists,
      functions, and pipes.

      Introspective: The documentation, examples, and even the entire
      state of a running program, are data that can be queried and
      processed with the language itself. Kcats is its own debugger.

      Powerful and Versatile: Despite its simplicity, kcats is designed
      to be a powerful tool capable of handling a wide range of
      programming tasks. The tools programmers use in other languages
      are there, and built from simple primitives - closures, error
      handling, metaprogramming, multithreading, channels, generators,
      i/o, and serialization.

      A Focus on Tooling: kcats intends to make tool development,
      including IDEs and debuggers, as easy as possible.

  As this is the alpha release, we eagerly welcome all feedback,
  contributions, and constructive criticisms from the community. We're
  especially interested in improving the documentation and learning
  experience.

  Join us in exploring this new language and contribute to making
  programming more accessible to everyone. Your feedback is essential to
  making it intuitive and easy to use!

  Please check out our alpha release here:
  https://github.com/skyrod-vactai/kcats

  Happy coding!

  Best, Skyrod

#+end_src


* INPROGRESS Post announcement on various forums                      :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: INPROGRESS
:END:

- [ ] Hacker news
- [X] Reddit r/concatenative
- [ ] Reddit r/programming
- [ ] r/learnprogramming
- [ ] r/coding
- [X] programming.dev
** DONE Solve some programmer.dev challenges
- State "DONE"       from "TODO"       [2023-10-05 Thu 11:11]
Remove matching parens
#+begin_src kcats
  "[(({})({)(()}]"
  [[\[ \]] [\{ \}] [\( \)]]
  "" float
  [[[last] dive wrap swap [lookup] dip =]
   [drop pop drop]
   [put]
   if] step
   dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
"[(({)(}]"
#+end_src


* DONE [#A] Auto code formatter
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:15
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-09-22 Fri 09:25]
This is desperately needed, as a big blob of output line-wrapped is
very hard to read.

I am not sure exactly how to determine where line breaks should occur
but literally anything is better than how it is now.
#+begin_src kcats :results code
[[foo bar][baz [[quux floop][toop poop]]]]
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo bar]
 [baz [[quux floop]
       [toop poop]]]]
#+end_src

now test decreasing indent
#+begin_src kcats :results code
  [[foo bar] [baz [[quux floop] [toop poop]]] goop]
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo bar]
 [baz [[quux floop]
       [toop poop]]]
 goop]
#+end_src

#+begin_src kcats :results code
  [[[1 2 3] [4 5 6] [7 8 9]] liberate [] [] [empty?] [drop [generate] dip swap clone [join] dip] until  generate] reverse
#+end_src

#+RESULTS:
#+begin_src kcats
[generate until [drop [generate] dip swap clone [join] dip] [empty?] [] [] liberate
 [[1 2 3] [4 5 6] [7 8 9]]]
#+end_src

#+begin_src kcats :results code
[blahblah blah [blah blah foop foop [toopy] foop foop] toop [blah foop] toopy]
#+end_src

#+RESULTS:
#+begin_src kcats
[blahblah blah [blah blah foop foop [toopy] foop foop] toop [blah foop]
 toopy]
#+end_src

#+begin_src kcats :results code
[[[1 2 =] [false]] [[1 1 =] [true]]]
#+end_src

#+RESULTS:
#+begin_src kcats
[[[1 2 =] [false]]
 [[1 1 =] [true]]]
#+end_src

#+begin_src kcats :results code
[[[] b] [c d]]
#+end_src

#+RESULTS:
#+begin_src kcats
[[[] b]
 [c d]]
#+end_src

#+begin_src kcats :results code
 [[a b] [c d]] "hello"
#+end_src

#+RESULTS:
#+begin_src kcats
"hello" [[a b]
         [c d]]
#+end_src


* DONE Have eval-step return nothing when program is done
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:15
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
That means eval needs to keep the input until it checks the output.

That may make normal runtime a little less efficient but it means
debuggers and step generators are easy and more efficient.

At that point =stepper= can be removed and we can use =eval-step= in its place. 

(actually stepper still has a use, it just doesn't need to check for =nothing= anymore)


* DONE print
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It's probably just an alias for something like =[standard] dip bytes put
drop= (write to stdout and then drop the pipe).


* DONE Remove references to "expression"
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
I think the expression is just a "program". I suppose *the* program. But
still "program". And yes, it gets shorter as it runs. Still, it's a program.
** DONE Clear up odd language
There are places in the docs where we used "expression" and "program"
in the same phrase, where now it says program in both places, and it's
confusing.

* DONE implement breakpoints
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Fix break arg order
 I think the args are in the wrong order - env should be under the program.
 #+begin_src kcats 
   [[program [1 [1 2 3] [+] step]]] environment
   [[program 0] lookup wrap [+] =]
   [[[swap something?] ;; still running
     [execute not]] ;; check condition not true yet
    [execute]
    every?] ;; break?
   [[eval-step] dip]  ;; evaluate the environment one step
   while
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [[program 0]
  lookup wrap [+] =]
 [[stack [1 1]]
  [program [+ [2 3]
               [+] step]]]
 #+end_src
** DONE Test breakpoint
#+begin_src kcats
  [[program [2 [100 breakpoint <] [2 *] while]]] environment [sprint clone] collect
#+end_src

#+RESULTS:
#+begin_src kcats
[[[program [< [[2]] unwrap evert first [[2 *]] unwrap [[[100 breakpoint <] shield]]
               unwrap join loop]]
  [stack [100 2]]]
 [[program [< [[4]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 4]]]
 [[program [< [[8]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 8]]]
 [[program [< [[16]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 16]]]
 [[program [< [[32]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 32]]]
 [[program [< [[64]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 64]]]
 [[stack [100 128]]
  [program [< [[128]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]]]
[sprint clone]
[]
#+end_src

* DONE Rewrite future in terms of spawn
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
  1 [2 +]
  ;; do other stuff

  handoff swap 
  [snapshot] join ;; return the whole stack
  wrap [dive put drop] join 
  spawn animate

    4 5 + drop

  take dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
[3] 1
#+end_src

* DONE Re-implement let
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
I think it's pretty useless as-is. I think it should just be a quicker
version of lingo, where you don't need to specify a spec, and it
always adds items to the dictionary instead of arbitrary changes.

#+begin_src kcats
  [[times5 [5 *]]
   [doubledec [dec dec]]]
  [3 times5 doubledec]
  [[[1] [[[[spec [[] []]]] ;; spec of self-insert
          [definition]] dip
         assign] ;; build a full entry
    update]
   map wrap [join] join] dip
lingo
#+end_src

#+RESULTS:
#+begin_src kcats
13
#+end_src

* DONE Loop combinator that has an initialization program
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Like =while= but calls init before starting and each time through the loop. Call it =prime=?
#+begin_src kcats
  timestamps
  [take] [odd?] [dump drop] [clone [execute] dip] dipdown float  join while  
#+end_src

* DONE startswith/endswith
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Note this impl is not efficient because it zips the entire input
before starting comparison. An efficient one would keep an index
counter and compare via lookup.

starts
#+begin_src kcats
"abcd" "" zip [unwrap =] every? 
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

ends
#+begin_src kcats
"abcd" "abcd" [reverse] both zip [[=] inject first] map [] every? 
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

* DONE map doesn't handle nothing values
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[1 2 3 4 5] [odd?] map
#+end_src

#+RESULTS:
#+begin_src kcats
[yes [] yes [] yes]
#+end_src

ughhh should probably revert the change that left map in terms of
generators, because map isn't indefinite and has different handling of =nothing=.

* DONE Separate formatting from emitting
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-19 Thu 21:04]
- State "INPROGRESS" from "TODO"       [2023-09-23 Sat 10:29]

* DONE Fix line breaks with byte literals
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-11-19 Sun 19:17]
- State "INPROGRESS" from "TODO"       [2023-11-19 Sun 18:48]
#+begin_src kcats
"foo" bytes key
#+end_src

#+RESULTS:
#+begin_src kcats
[[type elliptic-curve-key]
 [public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="]
 [secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="]]
#+end_src

Line break doesn't get added because it thinks =#b64= is an item when
it's really a parsing hint.

* DONE slice ordered items
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-19 Thu 21:04]
- State "INPROGRESS" from "TODO"       [2023-10-04 Wed 19:00]
We have indexing to a single subitem but we need to be able to get
ranges too. I think all the underlying types support it so we just
need to expose it.
#+begin_src kcats
"foobarbaz" 3 60 slice
#+end_src

#+RESULTS:
#+begin_src kcats
#+end_src

#+begin_src kcats
[a b c d e f] 2 4 slice
#+end_src

#+RESULTS:
#+begin_src kcats
[c d]
#+end_src

This works but currently panics if you go beyond the valid
indices. Should probably throw a proper error.

* DONE Templating
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-19 Thu 21:04]
- State "INPROGRESS" from "DONE"       [2023-10-15 Sun 17:23]
- State "DONE"       from "INPROGRESS" [2023-10-09 Mon 19:04]
- State "INPROGRESS" from "TODO"       [2023-10-09 Mon 19:04]
It would be nice if we could build nested programs as a template
instead of assembling them from parts.

For example lets say I wanted =[foo [[blah] dip] shield]= where =blah= is
a runtime value. Currently I'd have to use =join= to put it together.

#+begin_src kcats
  [[w1 [join]]]
  ["baz" "bar" "foo" [[w1] shield] dip]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
"foo" "bazbar" "bar" "baz"
#+end_src

This isn't quite "templating", since it requires that the =let= scope
encompasses wherever the program is *executed*, and not just where it is
built. What we want is a portable program with =join= substituted for
=w1=. I think recursive replace should be straightforward enough.

#+begin_quote
function template_recurse(template, mapping):
    if template is a list:
        return [template_recurse(item, mapping) for item in template]
    else if template is a placeholder (string) and template in mapping:
        return mapping[template]
    else:
        return template

function template(template, mapping):
    return template_recurse(template, mapping)
#+end_quote

#+begin_src kcats
  [[*a* [foo]] [*b* bar]] [*a* [*b*] c d 1 2 3]
  ; t v
  [list? not] ;; recur condition
  [[word?]
   [[wrap lookup] shield clone [dropdown] [drop] branch dropdown]
   when]
  [] ;; rec1
  [map] recur dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo] [bar] c d 1 2 3]
#+end_src

Note this currently behaves oddly if you don't declare the mapping as
an association and you have integers in your template. Should probably
fix that, I don't think we intend to replace ints with other values
based on index.

Come to think of it, since the template's values will come from the
stack, I think we should let the caller construct that first and then
put the template on top.

Test this out on the current impl of =until=.
#+begin_src kcats
  2 [even?] [inc]
  pair [pred body] swap zip 
  [[splice body] [[splice pred] not] shield] template
  yes swap loop
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src

Aha, we need =unquote-splicing= ! Well I am not sure how to implement that.

So this is implementing the different syntax for placeholders, =[poke
a]= and =[splice a]=. However splicing is still not supported, as it
requires a different =recur= structure.

#+begin_src kcats
  [[a [foo]] [b bar]] [[poke a] [[poke b] x [poke a]] c d 1 2 3]
  ; t v
  [[subs-point? [[[list?]
                  [count 2 =]
                  [first [poke splice] set swap contains?]]
                 [execute] every?]]]
  [[[[list? not]
     [subs-point?]] [execute] any?];; recur condition
   [[subs-point?]
    [second [wrap lookup] shield clone [dropdown] [drop] branch ]
    when dump]
   [] ;;  rec t v

   ;;ok so the idea here is to just use `step` and the trick is that the
   ;; recur fn needs to have the accumulator out of the way, via `dip`,
   ;; and then the step fn (after the recur is done) should have the acc
   ;; on top again, with the new value beneath, which it can just `swap
   ;; put` or `swap join` i suppose. So we need to append that part to
   ;; the step program.
   [[] sink ;; rec t acc v
    ;; now build the step fn to include the push into acc
    [dip] decorate ;; run the rec with dip (under the acc) 
    [swap] swap join ;; prepend floating the acc to the top before the dipping
    ;; then after the dipping we have acc res 
    [swap put swap] join step
   ]

   ;;drop dump
   ;; rec2 acc t  v
   ;;  
   recur dropdown]
  let
#+end_src

Ok so maybe an easier way to think about this is using =let= and calling
the templating recursively.

#+begin_src kcats
  [[a [foo quux]] [b bar]]
  [[[a b [splice a] c]]]
  ; [[poke a] [[poke b] x [splice a]] c d 1 2 3]
    ; t v
    [[subs-point? [[[list?]
                    [count 2 =]
                    [first [poke splice] set swap contains?]]
                   [execute] every?]]
     [subs [second [wrap lookup] shield clone
            [dropdown] [drop] branch]]
     ;; takes t v
     [template [[[[subs-point?] [[first wrap [poke] =]
                                 [subs wrap]
                                 [subs] if]]
                 [[list?] [[] swap ;;  t acc v
                           [swap [template] dive join] step wrap]]
                 [[yes] [wrap]]]
                decide]]]
    [template]
    let unwrap dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
[[[a b foo quux c]]]
#+end_src

#+begin_src kcats
[[body [inc]] [pred [even?]]]
[[not [splice pred]] shield] template
#+end_src

#+RESULTS:
#+begin_src kcats
[not even? shield]
#+end_src


* DONE Eliminate 'nothing'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-17 Tue 18:58]
The concept is confusing because an empty container is not =nothing=. 
** DONE Rename nothing? to empty?
- State "DONE"       from "INPROGRESS" [2023-10-17 Tue 18:51]
- State "INPROGRESS" from "TODO"       [2023-10-17 Tue 18:33]
** DONE Use yes instead of true
- State "DONE"       from "INPROGRESS" [2023-10-17 Tue 18:33]
- State "INPROGRESS" from "TODO"       [2023-10-17 Tue 18:06]

* DONE Reimplement every? and any? using recursive call
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-20 Fri 13:48]
- State "INPROGRESS" from "TODO"       [2023-10-20 Fri 13:45]
#+begin_src kcats
    -12 [[negative?] [even?]] [execute]
    [[every? [[swap]
              [[take] dip clone [float [shielddown] dive] dive 
               []
               [drop every?]
               [dropdown dropdown] if]
              [drop drop yes] if]]]
    [every?]
    draft 

#+end_src

#+RESULTS:
#+begin_src kcats
yes -12
#+end_src

#+begin_src kcats
  11 [[negative?] [even?]] [execute]
  [[any? [[swap]
            [[take] dip clone [float [shielddown] dive] dive 
             []
             [dropdown dropdown]
             [drop any?] if]
            [drop drop []] if]]]
  [any?]
  draft

#+end_src

#+RESULTS:
#+begin_src kcats
[] 11
#+end_src

* DONE Remove notion of Nothing from the implementation
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-21 Sat 11:29]
- State "INPROGRESS" from "TODO"       [2023-10-21 Sat 11:29]
I don't think the performance boost (if any) is worth it. Everywhere
we use NOTHING now, we can just set it to an empty List. And probably
rename it to Empty or something like that. There's no need for the enum variant.

* DONE improve 'capture' semantics with 'bind'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-12-30 Sat 14:34]
- State "INPROGRESS" from "TODO"       [2023-10-30 Mon 17:02]
The problem is that =capture= as written, doesn't make it obvious that
it's combining the captured items with the stack at the time of
execution - what it actually does is takes the top item from the stack
and puts it on top of the captured stack (dropping the rest of the
current stack).

So what's missing is the 'arity'. Also it's not clear that we always
want the current stack items on top of the captured stack. For
example, what if we wanted a "subtract 5 from" closure:

#+begin_src kcats
[5] [-] capture [10] dip execute 
#+end_src

#+RESULTS:
#+begin_src kcats
-5
#+end_src

What we got was actually "subtract from 5".

But that's easy enough to fix:

#+begin_src kcats
[5] [swap -] capture [10] dip execute 
#+end_src

#+RESULTS:
#+begin_src kcats
5
#+end_src

I suppose what we could do here is keep with the =down=, =deep= convention
and implement =capturedown= and =capturedeep= to represent the 2 and 3
arities.

I am not even sure we need something this complex - joy doesn't seem
to have it at all. What we could do instead is just prepend stuff to a
program, which could be equivalent to =partial= in clojure. So to do
"subtract 5 from":

#+begin_src kcats
10 [-] 5 prepend execute
#+end_src

#+RESULTS:
#+begin_src kcats
5
#+end_src

And to do "subtract from 10":

#+begin_src kcats
  ;6 [-] [10 swap] swap join execute
  6 10 [-] [swap] unwrap prepend swap prepend execute
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src

Of course in many cases we are trying to partial in a value from the stack:

#+begin_src kcats
6 10 [-] [swap] swap join swap prepend execute  

#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src

So there's two things happening: inserting values from the stack and
inserting operations to move those values into the correct position on
the stack later.

What words will help us here? I suppose we could do =partial= =partialdown= etc:

#+begin_src kcats
  [[bind [swap prepend]]
   [binddown [[swap] swap join swap prepend]]
   [binddeep [[sink] swap join swap prepend]]]

  ;10 [-] partial [25] dip execute]
  ;[10 5 [-] binddown bind ] ;; bind multiple
  [5 [range] binddeep [10 2] dip execute]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
[5 7 9]
#+end_src

One question here is whether the binding should consume the value from
the stack, I think it should and if the caller doesn't want that he
can use the =shielddown= combinator.

Ok let's see if we can go back and use this in existing code.

* DONE Implement more functions from Joy
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2023-10-30 Mon 16:31]
+ over
+ dupd (clonedown)
+ dupdd (clonedeep)
+ tuck (opposite of over: under) 

* DONE implement 'label'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2023-11-10 Fri 14:05]
We're "labeling" items on the stack and get a map. eg
="Alice" 23 "123 Main St" [address age name] label=

The question is do we label from stack's top to bottom or the other
direction? Let's try "top first" - if we have a literal we can just
write a map literal to start, so i think this is ok.

#+begin_src kcats 
  "Alice" 23 "123 Main St" [address age name]
  [] swap ;; labels acc
  [wrap float assign] step
#+end_src

#+RESULTS:
#+begin_src kcats
[[address "123 Main St"]
 [age 23]
 [name "Alice"]]
#+end_src

* DONE Refactor bytes as 'encode'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-12-02 Sat 15:12]
- State "INPROGRESS" from "TODO"       [2023-12-02 Sat 14:44]
Make this a multimethod

* DONE Deterministic serialization
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-02-19 Mon 17:27]
- State "INPROGRESS" from "TODO"       [2024-02-19 Mon 17:27]
We need to be able to serialize some things the same way every time
(for example if we're taking the hash of some program or data). For
now we'll make that the default serialization, even though it's
slower. If needed we can make a separate "emit" word to not bother
with determinism.

* DONE Make assemble not depend on template
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2024-02-22 Thu 17:19]
We've got a cyclic dependency here:

assemble -> template -> let -> draft -> revise -> assemble

Easiet way I see to break this is to not use templating for assemble,
which is not that hard to write without it (just not as clear).

#+begin_src kcats
  [1 2 3 4 5] [[odd?] keep]
  
#+end_src

#+RESULTS:
#+begin_src kcats
[1 3 5]
#+end_src

* CANCELED Library definitions and loading
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 16:52
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2024-02-23 Fri 16:51] \\
  Superseded by module work with inscribe/resolve
We don't have a good story yet for how new words are loaded and accessed.

Right now I'm using =let= but the danger with this method is that you
can pretty easily accidentally overwrite some word that your program
depends on deep in its expanded expression, and that causes behavior
that's both unexpected and difficult to debug.

So what I think we really want is for the new definitions to only
apply for the literal program we write. A naive implementation would
just recursively replace words in the program with their definitions,
but that could be problematic when a word is used as data and not
meant to be an action word.

Really =template= is close to what we want here. It's just ugly to have
to write =[poke mynewword]= instead of just calling =mynewword= like you
normally would.

Another approach is to just not allow =let= to overwrite.
** INPROGRESS Template-based let macro 
 - State "INPROGRESS" from "TODO"       [2024-01-01 Mon 22:00]
*** DONE Versioned Words   
- State "DONE"       from "TODO"       [2024-01-02 Tue 17:32]
*** DONE Versioned dictionary
- State "DONE"       from "TODO"       [2024-01-02 Tue 17:32]
*** DONE Dict lookups respect version but = doesn't
- State "DONE"       from "TODO"       [2024-01-02 Tue 17:32]
*** DONE Version words in a program
- State "DONE"       from "INPROGRESS" [2024-01-07 Sun 09:11]
- State "INPROGRESS" from "TODO"       [2024-01-02 Tue 17:45]
*** DONE Dictionary update to copy all touched words to versioned word
- State "DONE"       from "INPROGRESS" [2024-01-07 Sun 09:11]
- State "INPROGRESS" from "TODO"       [2024-01-02 Tue 17:45]
Here's how I think it could work:

A rust function would take:
+ A list or assoc of updates (word, update-prog)
+ A program to run

Do the following:
+ [X] extract the words into a set
+ [X] clone the current dictionary, save it
+ [X] Increment the version in the current dictionary
+ [X] For each word, if the non-versioned word exists in the dictionary, copy it to the versioned word
+ [X] Recursively run through the program, updating words with the new version
+ [X] Change all the keys in the updates to the new version
+ [X] place into expression: get dictionary, step through updates, calling update, redefine
+ [X] place into expression: program (unwrapped)
+ [X] place into expression: the old dictionary, redefine
+ [ ] All values in the updates need to get versioned with the words defined before it

This should give us
+ The ability to do =let*= type stuff - refer to one function in the
  definition of another but we would need to be careful to only update
  program in the values with the words that have already been defined,
  not the whole word list. - make tests for this
+ The implementation details don't leak into the language, this
  function could just be called =let=. The existing one we could rename
  to something more indicative of unsafe operations.

  test it
    Can call new words
  #+begin_src kcats
    
    [[foo [[[definition [inc bar]]
            [spec [[number] [number]]]]]]]
    [1 foo] inscribe
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  2
  #+end_src

    Can still access base words like swap
  #+begin_src kcats
  [[foo ["foo"]]] [1 2 swap foo] draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "foo" 1 2
  #+end_src

    Words no longer accessible after let ends
  #+begin_src kcats
  [[[foo ["foo"]]] [1 2 swap foo] draft foo] [] recover type [error] unwrap =
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  yes
  #+end_src

   Previously defined words can be used inline
  #+begin_src kcats
    [[square [clone *]]
     [fourth [square square]]]
    [3 fourth] draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  81
  #+end_src

  Words can call themselves
  #+begin_src kcats
    [[factorial [[swap positive?]
                 [[*] shielddown [dec] dip self]
                 when]]]
    [6 1 factorial dropdown]
    draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  720
  #+end_src

  We can update the definition of existing words
  #+begin_src kcats
    [[hash [[type [foo] unwrap =]
            [drop "foo" hash]
            addmethod]]]
    [[[foo 1]] association hash] let*
    "foo" hash =
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  yes
  #+end_src

  We can nest let blocks
  #+begin_src kcats
    [[foo ["foo"]]
     [quux ["quux"]]]
    [foo
     [[foo [foo "foo2"]]
      [bar [foo "bar"]]]
     [1 2 3 bar quux]
     draft]
    draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "quux" "bar" "foo2" "foo" 3 2 1 "foo"
  #+end_src

  We can modify previous let words
  #+begin_src kcats
    [[foo ["foo"]]]
    [foo
     [[foo ["bar" put]]]
     [foo]
     revise]
    draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "bar" "foo"
  #+end_src

  We can modify axiom words

  #+begin_src kcats
    [[swap [[[definition [dump swap]]]]]]
    [1 2 swap]
    inscribe
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [2 1]
  1 2
  #+end_src

*** TODO Word to create full dictentry update from just the definition update
#+begin_src kcats
[[foo [[definition] [["foo"]] update]]] [foo] let*
#+end_src

#+RESULTS:
#+begin_src kcats
"foo"
#+end_src

#+begin_src kcats
  [[foo [["foo"]]]]
  [[1] [[[definition]] swap wrap join [update] join] update] map
  ;[foo] let*
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo [[definition] [["foo"]] update]]]
#+end_src

Maybe we should stick a default spec in there?

#+begin_src kcats
  [[foo ["foo"]]]
  
  [foo] draft
#+end_src

#+RESULTS:
#+begin_src kcats
"foo"
#+end_src

*** TODO kcats impl
#+begin_src kcats 
  ;[foo] 1 version [foo] 2 version =
  ;dictionary [*version*] [[definition [1]]] assign
  [[foo [["foo"]]]
   [bar [["bar"]]]
   [lookup [["swappie"]]]] 
  [foo bar swap]
  dictionary
  [+version+ definition] [[] [[inc] inject] [[0]] if] update ;; d p u

  [[+version+ definition] lookup first] shield ;; v d p u
  [sink] dip ;; v p u d
  clone ;; v v p u d 
  [version swap] dip version   ;; u p d

   swapdown   ;; u d p
  [ unwrap [wrap [definition] join] dip  update] step 
  define
  execute
#+end_src

*** TODO Discussion
In the context of loading libraries, how do we do it? It seems like
some libraries may need both kinds of changes (global/local): some
changes are method additions and others are new words. What is loading
a library? Is it just arbitrary code execution? That would be
flexible, but not very secure. Maybe it's ok if the library publisher
is authenticated?

What does loading a library look like? Presumably we load it by its
hash. And it's not a permanent change, it's only for a given block of
code. But it seems clear that the library's words need to apply not
just to the top level? Or do they? Libraries can do lots of things,
including extending the language so it's hard to predict exactly how
they would be loaded.
#+begin_src kcats
[
#+end_src


* Simple Test
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 16:52
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues/Database
:ARCHIVE_CATEGORY: production
:END:
#+begin_src kcats
"create table Person (firstName text not null, lastName text not null, email text)" database 
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

#+begin_src kcats
"insert into Person (firstName, lastName, email) values ('Skywife', 'Vactai', 'skywife@skyrod.me')" database 
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

#+begin_src kcats
  "select (firstName) from Person where lastName='Vactai'" database 
#+end_src

#+RESULTS:
#+begin_src kcats
[[[firstName "Skyrod"]] [[firstName "Skykid"]] [[firstName "Skywife"]]]
#+end_src


#+begin_src kcats
dictionary [swap] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[definition builtin-function]
 [examples [[[1 2 3 swap] [1 3 2]]]]
 [spec [[[item a]
         [item b]]
        [[item b]
         [item a]]]]]
#+end_src

* CANCELED Call stack in errors                     :debugging:errorHandling:
:PROPERTIES:
:ARCHIVE_TIME: 2024-05-22 Wed 09:46
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2024-05-22 Wed 09:46] \\
  I don't know how to implement this so will reopen if needed
It would be nice to see the call stack, if possible. For example if
foo calls bar, and bar fails, it'd be nice to know we're in the middle
of executing foo also. I have no idea how to implement this at the
moment though. Each time we look up a word during eval-step we could
add it to the call stack, and place a special word at the end of the
program to 'pop' from that stack. But I think if we ran =step= on 10,000
item list, the call stack would get at least that deep because step
puts itself back in the program.

So maybe a "call stack" isn't exactly what we want, I'm not even sure
it's possible to get what we want here.
