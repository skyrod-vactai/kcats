#    -*- mode: org -*-


Archived entries from file /home/user/workspace/kcats/production.org


* DONE assign doesn't overwrite a nested value properly
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[[a b] [c d]] association
[a e] "foo!" assign
#+end_src

#+RESULTS:
: 
: [[[c d] [a [[e "foo!"]]]]]

This errors out because =b= isn't an association. But we want it to
overwrite =b= with =[[d "foo!"] ]=.

* DONE Serialization treats any tagged literal as byte string
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:

* DONE Serialization panics on reading invalid data
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Should return Result objects from to_item. I don't think it is
necessary for from_item - since we're using a subset of edn, all Items
should be convertible to valid edn. But not all valid edn is
convertible to an Item.

* DONE Association list and list of equal content don't compare equal
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** Description
Probably need a custom PartialEq impl for Item here that converts the
list to a hash before comparing. Return false if the item doesn't
convert.

The sticky issue here is that when we read a literal like =[[type
foo][value bar] ]=, how do we know whether it should be compared to
something else as a hashmap (that ignores order) or a plain list (that
doesn't). We can probably deduce that if one of the arguments is a
hashmap, then the other should be treated as one. However what if both
are plain lists? It's still possible the intent was hashmap.
** Hacky Solution
what if you execute =[[a b][c d] ] [[c d][a b] ] == ? It's impossible
to know the intent. I think maybe the best way out is to treat
anything associative-shaped as association, and if the user wants
ordered comparison, let him use a different operator, =ordered== or
something.

So the comparison of two items that are either List or Assoc goes like this:

If either item is Assoc, then convert the other to Assoc (if
necessary) and do straight =.

If they're both List, compare lengths. If not equal, return
false. Otherwise, examine items- If they're all pairs, convert both to
assoc. finally do straight =.
** Better solution
Add a word =associative=. If that follows a list, it's converted to a
hashmap and then it's easy to compare to another hashmap. The
representation is unchanged of course. But it lets the programmer
specify the intent of how === should behave.

This does reveal a problem with the unit tests that are specified as
examples in the lexicon. Those tests will execute the program and then
compare the representation of the resulting stack, with the
representation given. As we now can see, comparing representations is
insufficient, we need to be able to compare actual implementations.

That means, the unit test's expected value should be calculated and
not just read in. For most tests, no changes will be required (it's
just putting values on the stack and no further calculation needed).

But in the end we'll need to compare actual stack to expected stack,
not a stack to a representation. So the unit test logic will need to
run two environments, the actual and the expected, and then compare them.

The previous solution just isn't going to cut it - when we go to
implement sets it's going to be completely impossible to use a
heuristic to figure out what the intent was. Lists and sets will look
the same. So in the case of sets we'll have to specify the word =set=.

Do we have to be explicit when comparing list to association?  we
could either always return false (they're different types), or we
could compare them as lists or as maps.

The question then is if the two intents don't match, what do we do?  I
can't think of a reasonable answer- does order matter? We have
conflicting answer with no way to resolve it. Maybe it's safest to
just return false.

You can argue maybe even if order matters, maybe the two lists are in
the same order and should therefore compare equal. But associatives
don't have a defined order, so that would be just leaving it up to
chance and it wouldn't even be consistent across time. So that doesn't
seem wise.

So here's the plan: 
Examples:
#+begin_src kcats
[[a b] [c d]] association
[[c d] [a b]] association
=
=> true

[[a b] [c d]]
[[c d] [a b]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]]
=
=> true

[a a b c]
[a b c]
=
=> false

[a b c] set
[a b c]
=
=> false

[a b c] set
[b a c] set
=
=> true
#+end_src

* DONE Items of equal content don't compare equal
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
+ handle [[type error] [asked [consume]] [reason "not enough items on stack"]] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
dictionary [swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
[] environment [dictionary swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

This matches clojure
#+begin_src kcats
1 1.0 =
#+end_src

#+RESULTS:
: 
: [false]

#+begin_src kcats
[] [] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
"foo" bytes "foo" bytes =
#+end_src

#+RESULTS:
: 
: [true]


* DONE Change unit tests to make the expected take a program and eval it
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
This is to fix the cases that result in associatives or sets where
order doesn't matter but we don't have a way to declare how the values
should be conmpared. We can't just compare representations, we need to
compare two actual stacks.

So instead of
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]]]]
#+end_src

We should write
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]] association]]
#+end_src

So that the two stacks will compare equal.

* DONE create an environment from data (including an existing stack)
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It'd be nice to copy paste the output of one execution and have it pick up again eg
#+begin_src kcats
[[stack [1 2 3]]
 [expression [+]]]
#+end_src

There are potential issues here - such as the representation of an
associative is just a list, so when it's read back in it won't be the same:
#+begin_src kcats
[[stack [[[a b] [c d]]
         [[c d] [a b]]]]
 [expression [=]]]
#+end_src

If the two lists on the stack were actually associatives, they were
equal before but now they won't be.

I don't know that this is such a big problem, it's not possible for
everything in the language to be sensibly round-tripped via
serialization (eg stateful things like pipes).

If it's important to compare as associative, then make that part of
the expression.

What should =environment= take as an argument? Seems like it should
take an association (or assoc-shaped list).

#+begin_src kcats
[] environment
#+end_src

#+RESULTS:
: 
: [[[stack []] [expression []]]]

should give the default env.

#+begin_src kcats
[[expression [1 2 +]]] environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

should give the unexecuted env

#+begin_src kcats
[[expression [+]] [stack [3 2]]] environment evaluate [stack] lookup first
#+end_src

#+RESULTS:
: 
: [5]


should execute env with default dictionary plus whatever we add

#+begin_src kcats
[[dictionary [[foo [[definition [inc +]]
                    [spec [[number] [number]]]]]
              [bar [[definition [foo 5 *]]
                    [spec [[number] [number]]]]]]]
 [expression [1 2 bar]]]

environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [20]] [expression []]]]

should give the default env with the additional dict entries


#+begin_src kcats
[[expression
  [21449

   [] swap 2

   [/ 2 >]
   [ [mod 0 =]
     [clone sink [pack] dipdown / 2]
     [inc]
     if]
   while

   discard pack
  ]]]
environment
advance advance advance advance advance advance
eval-step
#+end_src

#+RESULTS:
: 
: [[[stack [[[mod 0 =] [clone sink [pack] dipdown / 2] [inc] if] [/ 2 >] 2 21449 []]] [expression [swap wrap [shield] join clone dipdown join loop discard pack]]]]


#+begin_src kcats
[[expression [1 2 +]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

#+begin_src kcats
dictionary count
#+end_src

#+RESULTS:
: 
: [118]


* DONE In-thread error handling
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Error structs
** DONE Stop on unrecoverable error
** DONE Be able to resume execution after an error
*** Notes
#+begin_src  kcats
2 [1 4 0] [[/] [discard 0] recover] map

#+end_src

#+RESULTS:

#+begin_src kcats
2 [1 4 0] [[/] [discard 0] recover] map

[1 0 /] [discard 0] recover
1 [0 /] [discard 0] . recover
1 . snapshot
    [0 /] inject first
    [error?] [discard 0] [] if
    resume
err [error?]  

t r recover
[snapshot] dipdown ;; rec test ss
[inject] dip swap ;; res rec
[first error?] ;; err? res rec
discard execute;; drop the snapshot and run recovery
evert discard ;; use snapshot as stack


; inject the program into a snapshot. If there's an error on top
; afterward, inject the recovery in there too. It'll have access to
; the whole context. If there's no error, evert and drop the ToS.

;; the execution will stop after injecting into the snapshot, so
;; "first" won't even get executed here.

[discard] [discard] recover

;; here we recover from underflow by just dropping the error


[1 0 /] . execute
. 1 0 /
err . [discard 0] execute resume
                        ;; ^ this is in the expression so keep going, actual word doesn't do anything


;; when the ToS is err, how do we know whether to stop?  we can look
;; at the expression to see what's coming. We can't do that at every
;; step of the entire execution but we don't have to. Just when ToS =
;; err. The challenge is to encode this just with the stack/expr and
;; no extra state. We can put a word like "continue" in the expr, but
;; at some point we actually have to have an err on ToS and do
;; something with it. The only place we can put some kind of flag not
;; to abort, is in the expression (or maybe the dictionary).

;; another approach is to explicitly continue unless halt is called,
;; but the error-producer doesn't know whether the error can be
;; handled or not.


;; how to unwind. can we just naively unwind to the next instance of
;; 'recover' in the expression? or will quoted programs mess this up?
;; Let's work through it

;; here the recover is quoted, but by the time an error occurs and we
;; look at the expression, it'll be there:
2 [1 4 0] [[/ 12 +] [discard 0] recover] map

2 err . 12 + resume [error?] [discard 0] if
2 err . [error?] [discard 0] [] if 

;; so the problem is even after we've unwound the expression to
;; 'resume', the error is still on the ToS! Now we want to actually do
;; the recovery, but we've already gotten rid of the flag that tells
;; us we're doing that. Maybe we can modify the error object itself to
;; note that it's been flagged for processing. Maybe [[type error]
;; [detected? true] [message "oops"]]. Or maybe we can convert it from
;; the error object to a richer object that contains the whole
;; stack/expr at the time it happened.

;; maybe we need a primitive here: fail, which will put a new item on
;; ToS which includes the whole env field plus a message field to
;; describe what is wrong.

;; eg

1 0 /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]]

1 0 . "division by zero" capture /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]] . /

;; ok what's the best we got so far?

;; i think it's recover/resume, without requiring nested env. Have the
;; error type with a flag detected?. Eval will do the following: if
;; there's an error on top, and there is no 'detected?' field, unwind
;; the expression to 'resume' (if there is one, otherwise clean the
;; expression). Set the detected field and continue. presumably what's
;; next is the error handler if there's anything left in the
;; expression.

;; ok this is good but it'd be nice to know what the expression was
;; before it gets unwound. For example what if the handler wants to
;; log the error? By the time it can do that, the original word that
;; errored is not in the expression anymore. The error object would
;; have to contain a snapshot (not just of the stack, but the
;; expression too). what about snapshotting the stack and cherry
;; picking the error object before the recovery? How does the recovery
;; distinguish different types of errors (java's catch-by-class is
;; kind of weak)

;;eg

1 "foo" + 0 /

;; there's 2 things wrong here, what if we only want to recover from
;; division by zero? well, we can only wrap / in a recover. ok waht about this

"foo" 0 /

;; this will actually error with type mismatch

;; how are we supposed to serialize these things? This makes me think
;; the rust structs need to be easily representable as kcats. And then
;; what are we supposed to do with error literals (the reader would
;; need to convert them). What would error literals look like,
;; especially user-defined errors?

[[error "oh noes"]]

;; but then how to subtype them? Here we have a sort of pseudoprogram
;; that demonstrates what the interpreter couldn't do. for example [0
;; /] means it can't divide by zero. And then there's a string that
;; just says what the program can't do. eg 'number' is a word that may
;; or may not exist (I suppose it should, to do parseInt type stuff)
;; but the point is it's pseudocode that in many cases will work as
;; real code, but not guaranteed.

[[type error]
 [asked [0 /]]
 [reason "cannot divide by zero"]]

[[type error]
 [asked [number]]
 [reason "not a number"]]

[[type error]
 [asked [consume]]
 [reason "not enough items on stack"]]

[[type error]
 [asked [2 get]]
 [reason "not enough items in the list"]]

[[type error]
 [asked [bloop]]
 [reason "word is not defined"]]
#+end_src

#+begin_src kcats
17
[+]
[discard 5 +]

[[handle] join] dip ;; add handle to the end of test
[snapshot] dipdown ;; rec test ss
sink inject ;; res rec
[first error?] ;; err? res rec
[first swap execute];; drop the snapshot and run recovery
[evert discard] ;; use snapshot as stack
if

#+end_src

#+RESULTS:
: 
: [22]


#+begin_src kcats :results code
5
[1 2 "oh fudge"]
[[+]
 [discard discard]
 recover]
map
#+end_src

#+RESULTS:
#+begin_src kcats

stack: [[[reason "type mismatch"] [asked [number]] [type error]] "oh fudge" 5]
expression: [handle [[[discard discard] "oh fudge" 5]] unwrap evert [first error?] [first swap execute] [evert discard] if [[[5] [6 7] 5]] unwrap evert first swap [pack] dip discard]
#+end_src

#+begin_src kcats
 [+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: stack: [[[type error] [asked [consume]] [reason "not enough items on stack"]]]
: expression: [handle [[[discard 1 [+] [discard 2 +] recover]]] unwrap evert [first error?] [first swap execute] [evert discard] if]

#+begin_src kcats
5 handle 

#+end_src

#+RESULTS:
: 
: [5]

** DONE Errors during recovery are improperly caught
The current implementation cannot tell the difference between an error
that was put on the stack during the "test" program, vs one that was
put there during the recovery. So if the recovery throws an error, it
*should* halt the execution, but it won't. Instead the program will
continue executing and words will be invoked with errors on the stack
that shouldn't be invoked.

I think I have a solution, but it does require modifying the error
object by setting a =handled?= flag (note the plan is for this to be
an implementation detail and from kcats point of view the error object
will not be visibly modified). The recovery program will have a word
=handle= inserted in the first position. The word =handle= will set
the flag on the error to =true=. Then =eval= can stop when a) there's
an error on the stack with no =handled? = true= AND the word =handle=
isn't in the expression. If =handle= *is* in the expression, we need
to unwind the expression up to but not including the =handle= word.

The word =handle= has to be an atomic operation (an axiom word that
sets the flag in one evaluation step, otherwise the progam would halt
before the flag could be set.)

We can delete the word =resume=.

#+begin_src kcats :results code
 discard 1 2 + handle discard 3 4 +
#+end_src

#+RESULTS:
#+begin_src kcats

[7]
#+end_src

#+begin_src kcats
1 [[zero?] [pos?]] [execute] every?
#+end_src

#+RESULTS:
: 
: [[] 1]

#+begin_src kcats
1 [[zero?] [positive?]] [execute] any?
#+end_src

#+RESULTS:
: 
: [true 1]


* Attribute database using CozoDB
:PROPERTIES:
:ARCHIVE_TIME: 2024-01-17 Wed 19:32
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues/Database
:ARCHIVE_CATEGORY: production
:END:
The idea here is to ignore identity in the database and make that the
responsibility of the client. The database only links attributes, and
has nothing to say about whether a given entity is the "same" entity
as another. It only says "something has both the color brown and the
height 1.5m". What attributes are sufficient to establish identity is
not part of the database. It's just a graph connecting attribute/value
pairs.
**  First experiments
#+begin_src fundamental
  ?[a_attr, a_val, b_attr, b_val] <-
  [
    ["author", "George Orwell", "title", "1984"],
    ["author", "George Orwell", "title", "Animal Farm"],
    ["author", "George Orwell", "genre", "dystopia"],
    ["genre", "dystopia", "title", "1984"],
    ["created", "1949", "title", "1984"],
    ["format", "book", "title", "1984"],
    ["language", "english", "title", "1984"],
    ["name", "George Orwell", "created", "1905"],
    ["name", "George Orwell", "sex", "male"]
  ]

  :replace also {a_attr, a_val, b_attr, b_val}
#+end_src

#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": ":create attributes { a_attr: String, a_val: Any, b_attr: String, b_val: Any}",
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "status"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "OK"
    ]
  ],
  "took": 0.016436112
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 79
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Tue, 19 Dec 2023 23:25:15 GMT
// Request duration: 0.018199s
#+END_SRC

#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "?[a_attr, a_val, b_attr, b_val] <- [['author', 'George Orwell', 'title', '1984'], ['author', 'George Orwell', 'title', 'Animal Farm'], ['author', 'George Orwell', 'genre', 'dystopia'], ['genre', 'dystopia', 'title', '1984'], ['created', '1949', 'title', '1984'], ['format', 'book', 'title', '1984'], ['language', 'english', 'title', '1984'], ['name', 'George Orwell', 'created', '1905'], ['name', 'George Orwell', 'sex', 'male']] :put attributes",
     "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "status"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "OK"
    ]
  ],
  "took": 0.011967695
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// access-control-allow-origin: *
// transfer-encoding: chunked
// date: Tue, 19 Dec 2023 23:39:51 GMT
// Request duration: 0.064371s
#+END_SRC

"When was the author of 1984 born?"
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[born] := linked['title', '1984', 'author', author], linked['created', born, 'name', author]", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "born"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "1905"
    ]
  ],
  "took": 0.001707655
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 79
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Tue, 19 Dec 2023 23:56:27 GMT
// Request duration: 0.002975s
#+END_SRC

"What books did the author of 1984 write?"
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[title] := linked['title', '1984', 'author', author], linked['title', title, 'author', author]", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "title"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "1984"
    ],
    [
      "Animal Farm"
    ]
  ],
  "took": 0.001771184
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 96
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Wed, 20 Dec 2023 00:05:26 GMT
// Request duration: 0.002879s
#+END_SRC



How to write that query in kcats format?
#+begin_src kcats
  [[title "1984" author a?]
   [created c? name a?]
   [c?]]
#+end_src

Everything about Orwell
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[a1, v, a2] := linked[a1, v, a2, 'George Orwell'] ", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "a1",
    "v",
    "a2"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "created",
      "1905",
      "name"
    ],
    [
      "genre",
      "dystopia",
      "author"
    ],
    [
      "sex",
      "male",
      "name"
    ],
    [
      "title",
      "1984",
      "author"
    ],
    [
      "title",
      "Animal Farm",
      "author"
    ]
  ],
  "took": 0.00130435
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 213
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Wed, 20 Dec 2023 00:14:07 GMT
// Request duration: 0.002445s
#+END_SRC

** Using org-mode eval
Now we have an org-mode evaluator!
#+begin_src cozodb :results value table
{:create attributes {a_attr: String, b_attr: String, a_val: Any, b_val: Any}}
#+end_src

#+RESULTS:
| OK |

#+begin_src cozodb :results value table
  %import /home/v/workspace/kcats/countries-cozo.json
#+end_src

#+RESULTS:
| [31mparser::pest[0m |


#+begin_src cozodb
::index create attributes:rev {b_attr, a_attr, b_val, a_val}
#+end_src

#+begin_src cozodb :results value table
  linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]
  ?[title] := linked['title', '1984', 'author', author], linked['title', title, 'author', author]
#+end_src

#+RESULTS:

What movies has robert de niro been in?
#+begin_src cozodb
linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]
?[title] := linked['title', title, 'cast', cast], actor in cast, actor == 'Robert De Niro'
#+end_src

#+RESULTS:
| GoodFellas                    |
| Jackie Brown                  |
| Mean Streets                  |
| Midnight Run                  |
| Once Upon a Time in America   |
| Raging Bull                   |
| Righteous Kill                |
| Silver Linings Playbook       |
| Stardust                      |
| The Irishman                  |
| The Irishman: In Conversation |
| The Score                     |



What directors has robert de niro worked with?
#+begin_src cozodb
  linked[a, oa, v, ov] := *attributes[a, oa, v, ov] or *attributes[oa, a, ov, v]
  ?[director] := linked['title', 'cast', title, cast],
                 linked['title', 'director', title, director], 
                 actor in cast, actor = 'Robert De Niro' 
#+end_src

#+RESULTS:
|                   |
| David O. Russell  |
| Frank Oz          |
| Jon Avnet         |
| Martin Brest      |
| Martin Scorsese   |
| Matthew Vaughn    |
| Quentin Tarantino |
| Sergio Leone      |


What movies had both Adam Sandler and David Spade?
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title] := linked['title', title, 'cast', cast],
              actor1 in cast,
              actor2 in cast,
              actor1 == 'Adam Sandler', actor2 == 'David Spade'
#+end_src

#+RESULTS:
| Grown Ups                             |
| Hotel Transylvania 3: Summer Vacation |
| The Do-Over                           |
| The Ridiculous 6                      |

Adam Sandler's 5 most recent movies
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
   ?[title, year] := linked['title', title, 'cast', cast],
                     linked['release_year', year, 'title', title],
                     actor in cast, actor == 'Adam Sandler',
   :limit 5
   :order -year
#+end_src

#+RESULTS:
| Hubie Halloween                       | 2020 |
| Murder Mystery                        | 2019 |
| Uncut Gems                            | 2019 |
| ADAM SANDLER 100% FRESH               | 2018 |
| Hotel Transylvania 3: Summer Vacation | 2018 |

What actors have been in the most movies with Sandler
#+begin_src cozodb
  ?[count(title), actor2] := linked['title', title, 'cast', cast],
                    target = 'Adam Sandler',
                    actor1 in cast, actor1 == target,
                    actor2 in cast, actor2 != target
  :limit 10
  :order -count(title)
#+end_src

#+RESULTS:
| 7 | Rob Schneider     |
| 6 | Allen Covert      |
| 5 | Nick Swardson     |
| 5 | Steve Buscemi     |
| 4 | David Spade       |
| 4 | Kevin James       |
| 3 | Blake Clark       |
| 3 | Colin Quinn       |
| 3 | John Turturro     |
| 3 | Jonathan Loughran |


#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[attr, val] := linked['title', 'Murder Mystery', attr, val]
#+end_src

#+RESULTS:
| cast         | [Adam Sandler Jennifer Aniston Luke Evans Gemma Arterton Adeel Akhtar Luis Gerardo Méndez Dany Boon Terence Stamp]                               |
| country      | United States                                                                                                                                    |
| description  | On a long-awaited trip to Europe, a New York City cop and his hairdresser wife scramble to solve a baffling murder aboard a billionaire's yacht. |
| director     | Kyle Newacheck                                                                                                                                   |
| duration     | 98                                                                                                                                               |
| rating       | PG-13                                                                                                                                            |
| release_year | 2019                                                                                                                                             |
| type         | Movie                                                                                                                                            |

10 longest movie titles
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title, ct] := linked['title', title, _, _], ct = length(title)
  :limit 10
  :order -ct
#+end_src 

#+RESULTS:
| Jim & Andy: The Great Beyond - Featuring a Very Special, Contractually Obligated Mention of Tony Clifton | 104 |
| Ken Burns Presents: College Behind Bars: A Film by Lynn Novick and Produced by Sarah Botstein  |  93 |
| Mike Birbiglia: What I Should Have Said Was Nothing: Tales from My Secret Public Journal       |  88 |
| The Power of Grayskull: The Definitive History of He-Man and the Masters of the Universe       |  88 |
| Steve Martin and Martin Short: An Evening You Will Forget for the Rest of Your Life            |  83 |
| Cultivating the Seas: History and Future of the Full-Cycle Cultured Kindai Tuna                |  79 |
| Power Rangers Samurai: Christmas Together, Friends Forever (Christmas Special)                 |  78 |
| Willy and the Guardians of the Lake: Tales from the Lakeside Winter Adventure                  |  77 |
| Ya no estoy aquí: Una conversación entre Guillermo del Toro y Alfonso Cuarón                   |  76 |
| The Road to El Camino: Behind the Scenes of El Camino: A Breaking Bad Movie                    |  75 |

#+begin_src cozodb
  linked[a, oa, v,  ov] := *attributes[a, oa, v, ov] or *attributes[oa, a, v, ov]
  ?[count(title)] := linked['title', title, _, _], 
#+end_src 

#+RESULTS:
| 70456 |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title] := linked['director', 'Steven Spielberg', 'title', title ], 
#+end_src 

#+RESULTS:
| Catch Me If You Can                                |
| Indiana Jones and the Kingdom of the Crystal Skull |
| Indiana Jones and the Last Crusade                 |
| Indiana Jones and the Raiders of the Lost Ark      |
| Indiana Jones and the Temple of Doom               |
| Jaws                                               |
| Lincoln                                            |
| Schindler's List                                   |
| The Adventures of Tintin                           |
| The BFG                                            |
| War Horse                                          |

#+begin_src cozodb
  ::explain {
            linked[a, v, oa, ov] := *attributes[a, v, oa, ov]
  ?[title] := linked['title', title, 'director', 'Steven Spielberg'] }
#+end_src 

#+RESULTS:
| 0 | 0 | ?      | 3         |     load_mem | ?                  | S.0.0                              | :null                             | []                 | [*1 *2 *3]          |            |
| 0 | 0 | ?      | 2         |     load_mem | linked             | Mbfbb                              | :null                             | []                 | [**0 title **1 **2] |            |
| 0 | 0 | ?      | 1         | mem_mat_join | :null              | ((*1 . **0) (*2 . **1) (*3 . **2)) | :null                             | [title]            |                     |            |
| 0 | 0 | ?      | 0         |          out | :null              | :null                              | :null                             | [title]            |                     |            |
| 0 | 1 | linked | Mbfbb     |            4 | load_mem           | linked                             | S.0.0bfbb                         | :null              | []                  | [a oa ov]  |
| 0 | 1 | linked | Mbfbb     |            3 | load_stored        | :attributes                        | :null                             | []                 | [**0 v **1 **2]     |            |
| 0 | 1 | linked | Mbfbb     |            2 | stored_mat_join    | :null                              | ((a . **0) (oa . **1) (ov . **2)) | :null              | [a oa ov v]         |            |
| 0 | 1 | linked | Mbfbb     |            1 | reorder            | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 1 | linked | Mbfbb     |            0 | out                | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 2 | linked | Mbfbb     |            4 | load_mem           | linked                             | S.1.0bfbb                         | :null              | []                  | [a oa ov]  |
| 0 | 2 | linked | Mbfbb     |            3 | load_stored        | :attributes                        | :null                             | []                 | [**0 **1 **2 v]     |            |
| 0 | 2 | linked | Mbfbb     |            2 | stored_prefix_join | :null                              | ((a . **2) (oa . **0) (ov . **1)) | :null              | [a oa ov v]         |            |
| 0 | 2 | linked | Mbfbb     |            1 | reorder            | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 2 | linked | Mbfbb     |            0 | out                | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 3 | linked | Ibfbb     |            1 | load_mem           | ?                                  | S.0.0                             | :null              | []                  | [*1 *2 *3] |
| 0 | 3 | linked | Ibfbb     |            0 | out                | :null                              | :null                             | :null              | [*1 *2 *3]          |            |
| 0 | 4 | ?      | S.0.0     |            3 | unify              | *1                                 | :null                             | "title"            | [*1]                |            |
| 0 | 4 | ?      | S.0.0     |            2 | unify              | *2                                 | :null                             | "director"         | [*1 *2]             |            |
| 0 | 4 | ?      | S.0.0     |            1 | unify              | *3                                 | :null                             | "Steven Spielberg" | [*1 *2 *3]          |            |
| 0 | 4 | ?      | S.0.0     |            0 | out                | :null                              | :null                             | :null              | [*1 *2 *3]          |            |
| 0 | 5 | linked | S.0.0bfbb |            1 | load_mem           | linked                             | Ibfbb                             | :null              | []                  | [a oa ov]  |
| 0 | 5 | linked | S.0.0bfbb |            0 | out                | :null                              | :null                             | :null              | [a oa ov]           |            |
| 0 | 6 | linked | S.1.0bfbb |            1 | load_mem           | linked                             | Ibfbb                             | :null              | []                  | [a oa ov]  |
| 0 | 6 | linked | S.1.0bfbb |            0 | out                | :null                              | :null                             | :null              | [a oa ov]           |            |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[c] := linked['timezone', 'America/New_York', 'country', c]
#+end_src

#+RESULTS:
| United States |


#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v, distance] := linked['coordinates', c, a, v], distance = l2_dist(vec([35.99403, -78.89862], 'F32'), c)
  :limit 10
  :order distance
#+end_src

#+RESULTS:
#+begin_example
[31meval::throw[0m

  [31m×[0m Evaluation of expression failed
   ╭─[1:1]
 [2m1[0m │ linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
 [2m2[0m │ ?[a, v, distance] := linked['coordinates', c, a, v], distance = l2_dist(vec([35.99403, -78.89862], 'F32'), c)
   · [35;1m                                                                ─────────────────────────────────────────────[0m
 [2m3[0m │ :limit 10
   ╰────
[36m  help: [0m'l2_dist' requires two vectors of the same type
#+end_example

Furthest cities (the distance formula isn't quite right but
demonstrates the concept). Disambiguate the city of Durham from other
durhams, using the state.
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[v, s, country, distance] := linked['coordinates', c, 'state', 'North Carolina'], 
        linked['coordinates', c, 'name', 'Durham'],
        linked['coordinates', c2, 'name', v], distance = l2_dist(vec(c), vec(c2)),
        linked['coordinates', c2, 'state', s],
        linked['name', s, 'country', country]
        :limit 10
        :order -distance
#+end_src

#+RESULTS:
| Gisborne    | Gisborne District    | New Zealand | 71571.2578125 |
| Wairoa      | Hawke's Bay Region   | New Zealand |       71301.0 |
| Napier      | Hawke's Bay Region   | New Zealand |   71137.46875 |
| Hastings    | Hawke's Bay Region   | New Zealand |   71127.15625 |
| Taradale    | Hawke's Bay Region   | New Zealand | 71111.7421875 |
| Opotiki     | Bay of Plenty Region | New Zealand |    71107.5625 |
| Castlepoint | Wellington Region    | New Zealand |       70996.5 |
| Whakatane   | Bay of Plenty Region | New Zealand | 70945.6328125 |
| Murupara    | Bay of Plenty Region | New Zealand |  70875.046875 |
| Edgecumbe   | Bay of Plenty Region | New Zealand | 70871.4765625 |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v] := linked['coordinates', c, 'country', 'United States'], linked['coordinates', c, a, v]
#+end_src

#+RESULTS:
| country    | Liberia                              |
| country    | United States                        |
| name       | Alabama                              |
| name       | Alaska                               |
| name       | American Samoa                       |
| name       | Arizona                              |
| name       | Arkansas                             |
| name       | Baker Island                         |
| name       | California                           |
| name       | Colorado                             |
| name       | Connecticut                          |
| name       | Delaware                             |
| name       | District of Columbia                 |
| name       | Florida                              |
| name       | Georgia                              |
| name       | Guam                                 |
| name       | Hawaii                               |
| name       | Howland Island                       |
| name       | Idaho                                |
| name       | Illinois                             |
| name       | Indiana                              |
| name       | Iowa                                 |
| name       | Jarvis Island                        |
| name       | Johnston Atoll                       |
| name       | Kansas                               |
| name       | Kentucky                             |
| name       | Kingman Reef                         |
| name       | Louisiana                            |
| name       | Maine                                |
| name       | Maryland                             |
| name       | Maryland County                      |
| name       | Massachusetts                        |
| name       | Michigan                             |
| name       | Midway Atoll                         |
| name       | Minnesota                            |
| name       | Mississippi                          |
| name       | Missouri                             |
| name       | Montana                              |
| name       | Navassa Island                       |
| name       | Nebraska                             |
| name       | Nevada                               |
| name       | New Hampshire                        |
| name       | New Jersey                           |
| name       | New Mexico                           |
| name       | New York                             |
| name       | North Carolina                       |
| name       | North Dakota                         |
| name       | Northern Mariana Islands             |
| name       | Ohio                                 |
| name       | Oklahoma                             |
| name       | Oregon                               |
| name       | Palmyra Atoll                        |
| name       | Pennsylvania                         |
| name       | Puerto Rico                          |
| name       | Rhode Island                         |
| name       | South Carolina                       |
| name       | South Dakota                         |
| name       | Tennessee                            |
| name       | Texas                                |
| name       | United States Minor Outlying Islands |
| name       | United States Virgin Islands         |
| name       | Utah                                 |
| name       | Vermont                              |
| name       | Virginia                             |
| name       | Wake Island                          |
| name       | Washington                           |
| name       | West Virginia                        |
| name       | Wisconsin                            |
| name       | Wyoming                              |
| state_code | AK                                   |
| state_code | AL                                   |
| state_code | AR                                   |
| state_code | AS                                   |
| state_code | AZ                                   |
| state_code | CA                                   |
| state_code | CO                                   |
| state_code | CT                                   |
| state_code | DC                                   |
| state_code | DE                                   |
| state_code | FL                                   |
| state_code | GA                                   |
| state_code | GU                                   |
| state_code | HI                                   |
| state_code | IA                                   |
| state_code | ID                                   |
| state_code | IL                                   |
| state_code | IN                                   |
| state_code | KS                                   |
| state_code | KY                                   |
| state_code | LA                                   |
| state_code | MA                                   |
| state_code | MD                                   |
| state_code | ME                                   |
| state_code | MI                                   |
| state_code | MN                                   |
| state_code | MO                                   |
| state_code | MP                                   |
| state_code | MS                                   |
| state_code | MT                                   |
| state_code | MY                                   |
| state_code | NC                                   |
| state_code | ND                                   |
| state_code | NE                                   |
| state_code | NH                                   |
| state_code | NJ                                   |
| state_code | NM                                   |
| state_code | NV                                   |
| state_code | NY                                   |
| state_code | OH                                   |
| state_code | OK                                   |
| state_code | OR                                   |
| state_code | PA                                   |
| state_code | PR                                   |
| state_code | RI                                   |
| state_code | SC                                   |
| state_code | SD                                   |
| state_code | TN                                   |
| state_code | TX                                   |
| state_code | UM                                   |
| state_code | UM-67                                |
| state_code | UM-71                                |
| state_code | UM-76                                |
| state_code | UM-79                                |
| state_code | UM-81                                |
| state_code | UM-84                                |
| state_code | UM-86                                |
| state_code | UM-89                                |
| state_code | UM-95                                |
| state_code | UT                                   |
| state_code | VA                                   |
| state_code | VI                                   |
| state_code | VT                                   |
| state_code | WA                                   |
| state_code | WI                                   |
| state_code | WV                                   |
| state_code | WY                                   |

** Using an artificial entity column
#+begin_src cozodb :results value table
{:create eav {entity: Uuid, attribute: String, value: Any}}
#+end_src

What type should =entity= be? Some keys are uuids that link to pk attrs,
others are just the entity id. Maybe everything should use uuid? 
** Add source and time columns
#+begin_src cozodb :results value table
  {:create trust {source: Bytes,
                  target: Bytes,
                  with: Any,
                  ts: Validity default 'ASSERT'
                  =>
                  score: Int,
                  }}
#+end_src

#+RESULTS:
| [31mparser::pest[0m |


#+begin_src cozodb
::remove trust
#+end_src

#+RESULTS:
: [31mquery::relation_not_found[0m
: 
:   [31m×[0m Cannot find requested stored relation 'trusted_attributes'

#+begin_src cozodb 
  ?[source, target, with, ts, score] <-
  [
   ["bWU=", "QWxpY2U=", 'introduce', 'ASSERT', 11]       
  ]
  :put trust {source, target, with, ts, score}
#+end_src

#+RESULTS:
: [31meval::invalid_validity[0m
: 
:   [31m×[0m when executing against relation 'trust'
: [31m  ├─▶ [0mwhen processing tuple ["bWU=", "QWxpY2U=", "introduce", [1703279106.2922018, true], 10]
: [31m  ╰─▶ [0m[1703279106.2922018, true] cannot be coerced into validity

#+begin_src cozodb
::relations
#+end_src

#+RESULTS:
| attributes     | 4 | normal | 4 | 0 | 0 | 0 | 0 |   |
| attributes:rev | 4 | index  | 4 | 0 | 0 | 0 | 0 |   |
| trust          | 5 | normal | 4 | 1 | 0 | 0 | 0 |   |

#+begin_src cozodb
?[source, target, with, score] := *trust[source, target, with, ts, score @ 'NOW']
#+end_src

#+RESULTS:
| bWU= | QWxpY2U= | introduce | 11 |

** Questions
What about when we insert "name=Alice, height=1.2", and then later
"name=Alice, height=1.3"?

I think part of the problem is we can't just arbitrarily pair
attributes, one of them has to be the "key".

For example, let's say we don't do that and we have:
[name Alice, height 1.6]
[height 1.6, weight 50]

In this case the "link" is height. But we don't want to link to
anything that's 1.6m high.

The first attribute has to be something that identifies the
entity. But as we know, not every entity has a single attribute that
uniquely identifies it. eg Person. The name isn't unique, but let's
say name+birthday is unique.

[name Alice, height 1.6]
[name Alice, bday 1/1]
[name Alice, bday 6/4]
[name Alice, height 1.3]

What we need is a unique id to attach to her attributes:

[id 1, name Alice]
[id 1, bday 1/1]
;; now we can hang other attrs off the id
[id 1, height 1.6]

One question is, does every entity have some unique attribute? It may,
but either we may not know it or it's really a combination of more
than one.

So there's several solutions,
+ Make the first attr a compound of multiple actual attrs, and make
  the individual ones linked from there.
+ Hash the multiple attrs

 If the attrs are a tuple, in theory we can fetch the record directly
  ,if the user knows how the key is built. THat's better than a
  generated id which the user is guaranteed not to know. So given
  this, let's remodel.

** kcats query format
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v] := linked['coordinates', c, 'country', 'United States'], linked['coordinates', c, a, v]
#+end_src

Let's say we wanted to write this query as kcats data instead of a string. How?
We've got 2 rules, one with an =or= and the other an =and=.

We could create some words to build some more explicit objects.
#+begin_src kcats
  [a v oa ov] [linked]  
  [a oa v ov] [attributes] rel ;; *attributes[a, oa, v,  ov]
  [a oa v ov] [attributes rev] index ;; *attributes:rev[a, oa, v, ov]
  or
  rule
  [a v] [?]
  ["coordinates" c "country" "United States"] [linked] rel
  ["coordinates" c a v] [linked] rel
  and
  rule

#+end_src

Of course, the most straightforward is to probably just build the
query string, it's just a bit error prone and inefficient.

Let's do that query and dump the parsed object, so we can imitate it a bit:

#+begin_src rust :crates '(cozo)
  extern crate cozo;
  use cozo;

  fn main() {
      let db = DbInstance::new("mem", "", Default::default());
      db.par
  }
#+end_src
Ok nevermind those functions that deal with parsed scripts are
private. I guess we'll have to just build the query string!

#+begin_src kcats
  [[comma-separate [[string] map ", " interpose "" swap [join] step]]]
  [[a b c d] comma-separate]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
"a, b, c, d"
#+end_src

** Import into cozo by reading json
#+begin_src kcats
  "Ama Qamata, Khosi Ngema, Gail Mabalane, Thabang Molaba, Dillon Windvogel, Natasha Thahane, Arno Greeff, Xolile Tshabalala, Getmore Sithole, Cindy Mahlangu, Ryle De Morny, Greteli Fincham, Sello Maake Ka-Ncube, Odwa Gwanya, Mekaila Mathys, Sandi Schultz, Duane Williams, Shamilla Miller, Patrick Mofokeng"
  [", " split] assemble
#+end_src

#+RESULTS:
#+begin_src kcats
["Ama Qamata" "Khosi Ngema" "Gail Mabalane" "Thabang Molaba" "Dillon Windvogel" "Natasha Thahane"
 "Arno Greeff" "Xolile Tshabalala" "Getmore Sithole" "Cindy Mahlangu" "Ryle De Morny"
 "Greteli Fincham" "Sello Maake Ka-Ncube" "Odwa Gwanya" "Mekaila Mathys" "Sandi Schultz"
 "Duane Williams" "Shamilla Miller" "Patrick Mofokeng"]
#+end_src

#+begin_src kcats
  "/home/jweiss/Downloads/netflix_titles.json" file-out slurp decodejson 

  [[
  [[second [[string?]
            [\" contains?]] [execute] every?] any? not] keep
    [["cast"] [[", " split] assemble] update
     [take] [] into 
     encodejson "u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- {} ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}"
     swap wrap format database
    ]
    each]
   assemble 
   count]
  [[unwound] unassign dropdown] recover
#+end_src

#+RESULTS:
#+begin_src kcats
8450
#+end_src

#+begin_src kcats
  dictionary

  [[
  [[second [[string?]
            [\" contains?]] [execute] every?] any? not] keep
    [["cast"] [[", " split] assemble] update
     [take] [] into 
     encodejson "u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- {} ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}"
     swap wrap format database
    ]
    each]
   assemble 
   count]
  [[unwound] unassign dropdown] recover
#+end_src


#+begin_src cozodb
  u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- [["cast",[]],["show_id","s11"],["release_year",2021],["title","Vendetta: Truth, Lies and The Mafia"],["director",""],["country",""],
          ["duration","1 Season"],["description","Sicily boasts a bold 'Anti-Mafia' coalition. But what happens when those trying to bring down organized crime are accused of being criminals themselves?"],["type","TV Show"],["date_added","September 24, 2021"],["rating","TV-MA"],["listed_in","Crime TV Shows, Docuseries, International TV Shows"]] ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}

#+end_src

#+RESULTS:
| OK |


#+begin_src cozodb
  u[uuid] <- [[rand_uuid_v1()]]
  av[attribute, value] <- [["release_year",2021],["director","Julien Leclercq"],["description","To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war."],["duration","1 Season"],["rating","TV-MA"],["title","Ganglands"],["cast",["Sami Bouajila","Tracy Gotoas","Samuel Jouy","Nabiha Akkari","Sofia Lesaffre","Salim Kechiouche","Noureddine Farihi","Geert Van Rampelberg","Bakary Diombera"]],["type","TV Show"],["date_added","September 24, 2021"],["country",""],["listed_in","Crime TV Shows, International TV Shows, TV Action & Adventure"],["show_id","s3"]]
  ?[entity, attribute, value] :=  av[attribute, value], u[entity]

  :put eav {entity, attribute, value} :returning

#+end_src

#+RESULTS:
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | cast         | [Sami Bouajila Tracy Gotoas Samuel Jouy Nabiha Akkari Sofia Lesaffre Salim Kechiouche Noureddine Farihi Geert Van Rampelberg Bakary Diombera]      |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | country      |                                                                                                                                                    |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | date_added   | September 24, 2021                                                                                                                                 |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | description  | To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war. |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | director     | Julien Leclercq                                                                                                                                    |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | duration     | 1 Season                                                                                                                                           |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | listed_in    | Crime TV Shows, International TV Shows, TV Action & Adventure                                                                                      |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | rating       | TV-MA                                                                                                                                              |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | release_year | 2021                                                                                                                                               |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | show_id      | s3                                                                                                                                                 |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | title        | Ganglands                                                                                                                                          |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | type         | TV Show                                                                                                                                            |

#+begin_src cozodb
  linked[a1, v1, a2, v2] := *eav[id, a1, v1], *eav[id, a2, v2]
             ?[title] := linked['title', title, 'cast', cast],
              actor1 in cast,
              actor2 in cast,
              actor1 == 'Adam Sandler', actor2 == 'David Spade'
#+end_src

#+RESULTS:
| Grown Ups                             |
| Hotel Transylvania 3: Summer Vacation |
| The Do-Over                           |
| The Ridiculous 6                      |

#+begin_src cozodb
    linked[a1, v1, a2, v2] := *eav:v[v1, id, a1], *eav:v[v2, id, a2]
    ?[count(title), actor2] := linked['title', title, 'cast', cast],
                      target = 'Adam Sandler',
                      actor1 in cast, actor1 == target,
                      actor2 in cast, actor2 != target
    :limit 10
    :order -count(title)
#+end_src

#+RESULTS:
| 7 | Rob Schneider     |
| 6 | Allen Covert      |
| 5 | Nick Swardson     |
| 5 | Steve Buscemi     |
| 4 | David Spade       |
| 4 | Kevin James       |
| 3 | Blake Clark       |
| 3 | Colin Quinn       |
| 3 | John Turturro     |
| 3 | Jonathan Loughran |

#+begin_src cozodb
::index create eav:v {value, entity, attribute}
#+end_src

#+RESULTS:
| OK |

#+begin_src cozodb
  linked[id, a1, v1, a2, v2] := *eav:v[v1, id, a1], *eav:v[v2, id, a2]
  ?[id, a, v] := linked[id, 'title', title, 'director', 'Steven Spielberg'],
           *eav[id, a, v]


#+end_src


* DONE Install the lexicon in the proper place
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in =/usr/share/kcats= or =~/.local/share/kcats= or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.


* CANCELED Add option to read an alternative lexicon file
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
The builtins can stay inside the binary, but we should have a cmdline
option to start without the usual lexicon. Should probably add a word
'lexicon' to add a parsed object as the lexicon.

* DONE Package the binary for various platforms
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Would be nice to build rpms/debs etc so users can skip the nasty build
process.

* DONE Optimize memory allocation
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Lists
#+begin_src kcats
[[a b]] [a] lookup
#+end_src

#+RESULTS:
: b

* DONE pack and unpack are not inverse
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :result code
[1 2 3] unpack pack
#+end_src

#+RESULTS:
: 
: [[2 3 1]]

It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.

Solution: rename to put take

* DONE true and false are not words?
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :results code
[true] unwrap word?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

If you didn't know =true= was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).

It's messy because true/false are the only "words" you can put onto
the stack without wrapping.

There are several ways to deal with this:

+ just leave as is (these look like words but don't act like them)

+ Use something else for boolean values, like 0b 1b or something (ugly, no)

+ Revert to allowing bare words (that aren't actions) to go onto the
  stack unwrapped, so that true/false aren't different

Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.

* DONE Division by zero panics
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:

* DONE 'Fail' is not defined
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
We need to be able to throw our own errors (eg lookup tries to do this)

#+begin_src kcats
1 2 [1 "two" +] [fail] recover 3 4 
#+end_src

#+RESULTS:
: converting to error: Error([[type error] [asked [number]] [unwound [+]] [reason "type mismatch"]])
: [[type error] [asked [number]] [unwound [3 4]] [reason "type mismatch"]] 2 1


* DONE 'dictionary' doesn't allow access to the data inside definitions
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
The definition is just shown as the word itself and we can't access
spec, definition etc.

#+begin_src kcats :results code
dictionary [swap spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[[item a] [item b]] [[item b] [item a]]]
#+end_src


* DONE Change boolean operators to retain values
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
=or= and =and= should return the actual value if it is truthy, instead
of =true=. But neither should ever return =[]=, but use =false=
instead.
#+begin_src kcats
2 [] or
#+end_src

#+RESULTS:
: 2

#+begin_src kcats
1 10 inc 1 range take swap [*] step
#+end_src

#+RESULTS:
: 3628800

This does bring up the question of whether the boolean type is really
needed. It may be possible to use =[]= as =false= and anything else as
=true= (=1= for example, or maybe the bare word =true= which then
wouldn't carry any other meaning). Or possible use some other word
than =true=, eg =something=.

Does this make sense when applied to boolean logic?

#+begin_example
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
#+end_example

I think it doesn't make sense.

Maybe yes/no?

#+begin_example
yes or no = yes ?
#+end_example
#+begin_src kcats
5 3 =
#+end_src

#+RESULTS:
: 
: [[]]

#+begin_src kcats
5 [[[3 =] ["three"]]
                         [[5 =] ["five"]]
                         [[7 =] ["seven"]]
                         [[true] ["something else"]]]
                      decide
#+end_src

#+RESULTS:
: 
: ["five" 5]

#+begin_src kcats
[3 5 7] [even?] any? false =
#+end_src

#+RESULTS:
: 
: stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
: program: [false =]

* DONE 'recover' is broken
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[+]
[drop 1
 [+] [drop 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: [3]

#+begin_src kcats
[[program [[+] [3] recover]]] environment advance advance
eval-step
advance
advance
advance
advance
advance
eval-step
advance
advance
advance
#+end_src


* DONE Fix handle in nested env
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
=handle= doesn't work properly in a nested environment. That is
because =eval= has some logic to check for uncaught exceptions, but
the =advance= self-hosted evaluator doesn't.

#+begin_src kcats
1 + handle error?
#+end_src

#+RESULTS:
: Env: [Word(0x5d29b8fb5b00 : "handle"), Entry(Entry { word: 0x5d29b8fc2600 : "error?", examples: None, spec: Some([List([Word(0x5d29b8fb6c00 : "item")]), List([Word(0x5d29b8fb6820 : "boolean")])]), serialize: false, definition: Builtin })]
: handle is Word(0x5d29b8fb5b00 : "handle") Word(0x5d29b8fb5b00 : "handle")
: expr contains handle? true
: Word(0x5d29b8fb5b00 : "handle") vs Word(0x5d29b8fb5b00 : "handle")
: 
: [true 1]

#+begin_src kcats
+ handle type
#+end_src

Looks like the word =error?= is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
=type=, which expects the builtin version of =error?=).

#+begin_src kcats
[[program [+]]] environment eval-step 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]]]] [program []]]]

#+begin_src kcats
[[program [1 +]]] environment advance advance advance 
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [program [+]]]]

#+begin_src kcats
[[program [[[3]] [+ handle] dip]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [program [+_handle [[[3]]] unwrap]]]]

#+begin_src kcats
[[program [+ handle]]] environment eval-step eval-step
#+end_src

#+RESULTS:
: { stack: [], program: [[[program [+ handle]]] environment eval-step eval-step] }
: { stack: [[[program [+ handle]]]], program: [environment eval-step eval-step] }
: { stack: [[[stack []] [program [+ handle]]]], program: [eval-step eval-step] }
: { stack: [], program: [+ handle] }
: { stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [program [+ handle]]]], program: [eval-step] }
: { stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], program: [+ handle] }
: 
: [[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [program [+ handle]]]]

There is a problem in the design where an error (with no =handle=) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.

A possible solution is to have whatever =eval= we're using halt but
remove the =halt= bit (in the current design it's the =is_handled=
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.

Also for nested envs we need several words to help deal with errors:

+ a word that tells whether the env will halt: that there's an error
  on ToS with halt bit set, and =handle= does not appear in the
  program. The word can efficiently return =false= if ToS isn't an
  Error.

+ A word that removes the halt bit - as the last thing to do before
  exiting.

So what about the word =advance= that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In =eval= it's pretty obvious if we
halted on error - the program isn't empty (that's the only other
reason to stop). We could see in =advance= that the program got
longer, but isn't very obvious in many cases.

Another possibility is letting the program unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
=recover= is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the program that will know what to do. But
there may not be, and the end result is a major unwind of the
program, at least, all the way to the deepest =recover=. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on. 

But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong *and*
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.

Maybe another possibility is unwinding the program **into** the
error object. In other words, whatever program items we lop off, we
save them in the error object, in a field named, say, =unwound= or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
program from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
=rewind= or something, that restores the program from the error on
ToS and clears the halt bit.

I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the program item that threw the error so
we would still have it to retry. I'm thinking syntax like this:

#+begin_src kcats
[+] [[1 1] dip retry] recover
#+end_src

In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:

#+begin_src kcats
[[stack [[[type error] [asked [consume]] [unwound [+]]]]
 [program [[1 1] dip retry]]]]
#+end_src

So we =dip= the numbers underneath the error, then calling =retry= on
an error will extract the =unwound= field (discarding the rest of the
error) and =execute= it. So then we end up with =1 1 +=.

Ok i actually implemented this (and I don't think it was difficult)
but i don't know what I did with it. I know it worked quite well and I
wanted to keep it. Need to do it again.

#+begin_src kcats
  ;; there needs to be 3 numbers here to add/mult but we forgot!
  + * 1 2 3
  handle ;; catch the error here, stack is empty except the error
  [5 6 7] dip ;; put numbers underneath
  retry ;; rerun what failed before
#+end_src

#+RESULTS:
: 
: [3 2 1 65]

Now put it together using the higher-level =recover=

#+begin_src kcats
  [+ *] [[5 6 7] dip retry] recover
#+end_src

#+RESULTS:
: 
: [65]


* DONE Lots of association-like objects that aren't
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait *and* make the trait object part of the
Item enum.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar { Int(i32), Foo(Box<dyn Foo>), Quux(Quux) }
#+end_src

#+RESULTS:

Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.

#+begin_src rust
trait Foo {};

struct Quux { }

impl Foo for Quux {}

enum Bar<'a> { Int(i32), Foo(&'a dyn Foo), Quux(&'a Quux) }
#+end_src

#+RESULTS:


#+begin_src kcats :results code
  dictionary [advance definition] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[[program] lookup count] shield swap [[program] lookup count [[positive?] [<=]] [execute] every?] [eval-step] while swap drop]]
#+end_src

#+begin_src kcats :results code
  [[program [1 1 +]]] environment eval-step [stack] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[1]]
#+end_src

#+begin_src kcats :results code
[] environment association?
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

#+begin_src kcats
dictionary [fail] lookup
#+end_src

#+RESULTS:
: [[spec [[string] [*]]] [definition []]]


* DONE scoping of dictionary entries
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
The original design was to have the dictionary be a single atomic data
structure that code could modify basically at will, with words like
=inscribe= (to add words) etc.

However I think a better design would be something like this:

#+begin_src kcats
  [[add1 [1 +]]] [3 add1] augment
#+end_src

Where the word =augment= takes an association (more specifically, a
dictionary) and overlays that on top of the builtin dictionary. Then
those new words become accessible just as if they were built in, then
the 2nd argument (a program) is executed as usual. After execution,
the learned words are no longer accessible.

It would be possible to nest calls to =augment= (where the program has
its own call to =augment=).

As for implementation, it may be possible to do a kcats-only impl, but
I don't think it's going to perform well. This is going to be the
normal mode of execution. Very few programs will run with only the
builtin words. In fact, it may be a good idea to break up the lexicon
into components - have pipes be a separate library that has to be
loaded with =augment=.

There is some overlap in functionality here, between =decide= and
=augment= - both are designed to provide context. Maybe =decide= provides
context on how a given word (whose overall meaning doesn't change)
applies to a given piece of data. And =augment= provides completely new
words, or provides a new meaning. Probably it's not going to be common
to replace meanings - maybe for security reasons. For example, when
running untrusted code, you may want to eliminate certain words (like
those that have side effects like writing to disk or the
network). That brings up the possible feature of not just merging new
items into the dictionary but doing arbitrary combinators, where =join=
is just a common use case. In that case, maybe =augment= isn't the right
word because you might be actually restricting the dictionary. So we
need a more generic term for "changing the language". Garble? babel?
I like =babel= - it captures the fact that we're moving from one
language (the set of builtin words) to lots of different languages. I also like =lingo=.

#+begin_src kcats
  [[clone *] [square] assign] ;; operate on the dictionary - add word 'square'
  [3 square]
  lingo
#+end_src

would print 9.

The idea here is to have local lingo, possibly down to quite small
pieces of code. I'm thinking on the order of 10 words is probably
enough to have certain words added or changed.

Special care will need to be taken, if you want to change the meaning
of the word, but re-use the old meaning as part of the new
meaning. You can't just overwrite the definition with a new one that
contains the word itself, expecting *that* word to refer to the old
meaning. You'll have to capture the old definition and incorporate
it. =update= should help.
** What to call this word
+ learn (but unlearn after?)
+ specialize
+ extend
+ adapt
+ augment 
+ refine
+ supplement
+ babel
+ lingo <= front runner.
** Implementation
It seems viable that we could use the stack to hold dictionary changes.

We'd have to retain a copy of the original dictionary to restore later.

An axiom word like =definitions= or something that sets the dictionary
to ToS would help. I think the rest could be pure kcats.

it'd be something like:

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float ;; d p n
  swapdown ;; d n p
  [redefine ;; p
   execute]
  dip ;; d
  redefine
#+end_src

#+RESULTS:
: 81

A few problems remaining above:
- [X] Need to specify the word inside the definition.
- [X] Need to explicitly convert the definition to an association.

But I think this proves the concept.

Probably want to eventually make a rust implementation.

#+begin_src kcats 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  dictionary ;; fetch the dictionary
  sink ;; p o d
  [clone] dipdown ;; p o d d
  [execute] dip ;; n=new-dict p n d
  float
  swapdown
  [redefine] dip dictionary [square] lookup
 
#+end_src

#+begin_src kcats :results code 
  [[square] [[definition [clone *]]
            ; [word square]
             [spec [[number] [number]]]] assign];; ops-dict
  [9 square];; program-to-run
  lingo 
#+end_src

#+begin_src kcats
  dictionary [square] [[definition [clone *]]
                       [spec [[number] [number]]]] assign
  [square] lookup
#+end_src

#+RESULTS:
: Warning, failed to insert into dictionary: List([List([Word(0x5dcc4c2878e0 : "definition"), List([Entry(Entry { word: 0x5dcc4c26dea0 : "clone", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5dcc4c26dea0 : "clone")]), List([Int(1), Int(2), Int(3), Int(3)])])]), spec: Some([List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])]), List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")]), List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5dcc4c2579c0 : "*", examples: None, spec: Some([List([Word(0x5dcc4c258ab0 : "number"), Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])]), serialize: false, definition: Builtin })])]), List([Word(0x5dcc4c25a6a0 : "spec"), List([List([Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])])])])
: []


* DONE Move environment stuff into own module
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :results code
  [[program [1 2 3]]] environment 
#+end_src

#+RESULTS:
#+begin_src kcats
{ stack: [], program: [[[program [1 2 3]]] environment] }
{ stack: [[[program [1 2 3]]]], program: [environment] }

[[[stack []] [program [1 2 3]]]]
#+end_src

#+begin_src kcats
1 2 +
#+end_src

#+RESULTS:
: 
: [3]


* DONE When printing results, don't wrap the stack
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Evaling =1 1 += should print =2=, not =[2]=. We don't have to wrap the
input, so why wrap the output.


* DONE Update pipes to use enums instead of traits
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It's worked out well for everything else, and I don't think anyone
else will be implementing these traits.

Looking at this I am not in that big a hurry to change it, with traits
at least I can spread out the impls into different modules. with enums
that'd be awkward.


* CANCELED Recover clears the stack built up in the try program
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:12
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
#+begin_src kcats :results code
 [2 3 "four" * +] [] recover
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"] [unwound [* +]] [type error] [asked [number]]]
#+end_src

Apparently this was my design. I am not so sure about it now, that we
have =retry=. If an error occurs in the middle of a program, what do we
do with the stack? If the recovery is meant to be "try something else
instead of the entire program" then restoring the stack makes
sense. However then that breaks use of =retry= because the recovery
can't pick up where the program left off.

Maybe =recover= and =retry= are mutually exclusive.

We could also use =retry= with =handle=:

#+begin_src kcats
2 3 "four" * + handle [drop 4] dip retry
#+end_src

#+RESULTS:
: 14

To make this work you have to know which item is the potential problem.

Specifying alternates seems useful, such that it will keep retrying
until it hits an empty alternates object or the program finishes. Each
time an alternate is tried it is removed from the list.

#+begin_src kcats
[2 3 ["four" 4] alternates * +] retry 
#+end_src


* DONE List access and update by index
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:12
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
I think re-using =lookup= and =assign= for lists, using their index, makes sense here:
#+begin_src kcats
  [5 10 15 20] [1] lookup
#+end_src
should print 10.

#+begin_src kcats
  [5 10 15 20] [1] 30 assign
#+end_src

#+RESULTS:
: [5 30 15 20]

 would leave =[5 30 15 20]=.

 The problem here is that this is ambiguous:

#+begin_src kcats
  [[a b] [c d]] [0] [d e] assign

  ;; is it (assigned as a hashmap by key)
  ;;[[a b] [c d] [0 [d e]]]

  ;; or is it (assigned as a vector by index)
  ;;[[d e] [c d]]
#+end_src

#+RESULTS:
: [[d e] [c d]]

We could clear up the ambiguity by saying that int keys on a list mean
vector behavior. If you want the other you have to specify =association=
first.

lets check some corner cases - creating nested lists
#+begin_src kcats
  [1 2 3] [1 0 0] "foo" assign
;; should be [1 [[foo]] 3]
#+end_src

#+RESULTS:
: [1 [["foo"]] 3]

What do we do when we're requested to assign beyond the end of the
list? We can extend the list and pad it with =Nothing=, although this
seems maybe going a bit too far to honor the user's request that maybe
doesn't make sense.

#+begin_src kcats
  [1 2 3] [1 2] "foo" assign
#+end_src

#+RESULTS:
: [1 [[] [] "foo"] 3]

Now let's test mixed list/assoc

#+begin_src kcats
  [1 2 3] [1 foo baz 0] "bar" assign
#+end_src

#+RESULTS:
: [1 [[foo [[baz [[0 "bar"]]]]]] 3]

Note that here, the last 0 index inserts as a map key because the
object is already an assoc. The contract is basically that once you're
in assoc-land you stay there.

Now check the changes for =lookup=

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] lookup
#+end_src

#+RESULTS:
: 45

make sure update works too

#+begin_src kcats
[1 4 [34 6 45] 99 23] [2 2] [inc] update
#+end_src

#+RESULTS:
: [1 4 [34 6 46] 99 23]

#+begin_src kcats
true not
#+end_src

#+RESULTS:
: []


* DONE Multithreading
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:12
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** Overview
There are a few major components here:
+ Be able to tell whether an environment can advance. It's basically
  "if there's nothing in the program, it's done, otherwise it can
  run unless it's currently putting/taking from a pipe"
** Pipes
It's not clear to me what to do about pipes. As soon as we call =take=
(for example) we're going to block the rust thread. In order to use
lightweight "threads" we're going to need a non-blocking check to see
if something can come out (or fit in) the pipe. For things like files
and sockets, it looks like we will need =tokio=.

tokio has Task which can manage this. It looks like tokio has file io
and network io that will automatically yield and allow other tasks to
run.

So then another question is, how to use something like =select= in
kcats. It might be possible to pass in a list of pipes to select and
then return the item that came out (along with the pipe itself i
guess). But this is advanced functionality that probably isn't a high
priority.

I think the basic design here is that each environment is a single
"thread" of execution, and that will map to a tokio Task. Pipe
operations within an env will call the async functions but will
immediately =await=. That should yield to allow other envs to run.

It looks like the =async= will creep all the way up to =axiom::eval=. If
the criteria is that anything we want to be able to pre-empt (if it's
waiting on i/o) needs to be labeled async, then everything up to =eval=
is going to be =async=.

I think that means fns like =f_stack1= etc will need to be async because
the =f= it calls can potentially call i/o. Actually it's probably best
to make new async versions of these so we don't have to make all the
Item fns async too.

We'll also need to think about what to do about dangling
environments - let's say we have the main env, and it spawns env e,
which will feed values back to main. But let's say main is done and
doesn't want any more values from e. Is the entire program done and we
can garbage collect e? My first instinct here is to blow everything
away as soon as main is done. If we don't want to exit we should be
taking from a pipe that won't produce anything until we're ready to
exit. So we're not going to =join= with other environment's tasks.
** DONE Add tokio as dep
** DONE Prepare for multithreading
*** DONE Use Arc instead of Rc
Does Arc have =make_mut=?  Yes! So hopefully it will be a drop-in
replacement.
** DONE Update pipe types for fs and net to use tokio calls
One problem here is that we don't have a trivial way to mix step
functions that are pure vs involving pipes.

If we don't know until runtime what it is, we have to assume async and
there's probably a huge performance hit.

Maybe one way to proceed is to make an =Item= variant =Future=. So if
we're taking from a pipe, we can just put the =Future= on the stack and
continue. Of course, very soon we'll need to access the value and call
=await= on it. 

What then, do we do about =put=? Let's say the pipe is full and the put
needs to wait. We can return the Env but we still need to await sometime.

Maybe in eval-step, we can check if the top item is a Future. If so,
await it. If it returns another Item, replace it. If it returns Unit,
just drop it. Somewhere we'd need a type =Option<Item>= for what the
futures return (None if we're just waiting on a value to put into a
pipe, Item if we're taking)

So will this work in nested envs? I am not sure but I can't think of
why it wouldn't.

If this works then only eval/eval-step will need =async=.
** DONE Use channel type to implement handoff pipe
*** DONE Use crossbeam channels
mpsc doesn't allow us to clone the receiver (Out) end of the pipe, and
that would seem like a rather sharp corner to users of kcats who
generally aren't too performance sensitive and want simple programs to
"just work".

#+begin_src kcats :results code
  handoff clone
  wrap [5 put "hello" put] join
  [] swap [[program]] dip assign environment animate take [take] dip
#+end_src

#+RESULTS:
#+begin_src kcats
5 "hello" [[type pipe] [handoff todo: id-or-hash here]]
#+end_src

#+RESULTS:
:

One issue here is that we accidentally made a bidirectional channel. I
don't know if that should be the default mode of operation. When we
create a handoff maybe we should really create two stack items: the in
and out. 

The question is, what should be a tunnel? I am not sure single stack
items really should allow both put and take.

The problem with splitting them is it can exascerbate the already
difficult problem of stack manipulation (if indeed you actually need
to read from a file and then write to the same spot... is that
common?)

The benefit is that a process that's supposed to be reading can't
accidentally write, if it doesn't have the In part of the pipe.

For now I think I'm inclined to leave it as-is and see how it goes.
*** TODO Nonblocking eval-step (for inner envs)
It would be nice if calling eval-step on an inner env and having it
block, wouldn't block the outer env (or at least it would be nice if
it were an option not to wait). Maybe =try_eval_step= which tries to
make progress immediately and if it can't, just returns as-is.

There's probably a way to do this by polling the future. using =select!=
with a short timeout future would do it but there's probably a better
way.
*** TODO Combine implementations for net and fs
They're both using AsyncReadExt and AsyncWriteExt methods. The only
difference between them is how the pipes are created. It would be
easier to make pipes for stdin/stdout this way.  I tried it but the
compiler complained about not being able to make trait objects out of
them. Will revisit later.

** DONE Implement 'spawn' or equavalent
Can probably think of a better name. What we're doing is taking an
environment that's a local piece of data on the stack and spitting it
out to make it its own autonomous thing.
=animate= seems rather fitting.

#+begin_src kcats
 [[program [+ 1 1]]] environment animate 
#+end_src

#+RESULTS:
: 
** DONE Implement 'future' or equivalent
The idea here is to take an program and run it in its own spawned
env, and when it's done, snapshot the stack and put it into a
pipe and close it. The original env gets the other end of the pipe.

I think the new env should probably inherit the current env's stack.
#+begin_src kcats :results code
  1 2 [+] 
  ;; make a pipe
  handoff swap
  ;; save the stack, including pipe
  [snapshot] dip
  ;; prepare the program for the new env
  ;; end up with [[+ snapshot] dip swap put]
  [snapshot] join wrap [dip swap put drop] join
  ; ;; now we have expr stack
  pair
  [stack program] swap zip environment
  animate take
#+end_src

#+RESULTS:
#+begin_src kcats
[3] [[type pipe] [handoff todo: id-or-hash here]] 2 1
#+end_src

#+begin_src kcats
  1 [2 +] future take swap drop
#+end_src

#+RESULTS:
: [3] 1

* DONE Implement print (opposite of read)
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
We don't have a way to convert objects to their string serialization
Completed as the word emit

* DONE logical enum hierarchy
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Collection hierarchy
There are read (peek/first) and write operations (pack/put/conj).

Then there are read/write ops like (take/unpack) that mutate the coll
and also return a value.

An In pipe supports only write. An Out pipe supports only
read-write. Pipes in general do not support peeking.

Collections (lists, maps, sets etc) support all of them.

It's not clear how to support overlapping functionality in an enum.
** DONE pipe as list-like thing
Are both words =put= and =pack= needed (similarly =take= and =unpack=)? Seems
like the former should be all that's needed. That starts to address
that pack/unpack aren't inverse (they shouldn't be because it's really
put/take, and whether you get the last item back or not depends on the
underlying impl - a stack you would, a queue you wouldn't).

Also take in other langs takes a number arg (how many to take). You
could do this as =[take] 5 times=, but that's less efficient. Could
maybe create a new word like =split= or =unload= or something.

The possibility that these words might block, and you don't know
except by the argument type, is a bit off-putting, and maybe these
should be different words? I don't know, the contract is to "take
thing out of other thing" and sometimes that's instant and sometimes
it isn't. (You can ask if the object is a pipe before taking)

=step= should work on pipes. It continues until the pipe closes. How do
we write step in terms of take? The problem is we don't know when to
stop. We know if a collection is empty, but we need to know if a pipe
is closed. The way pipes work now is that if something goes wrong, it
produces an error from the pipe. That's ok for pipes, where we're ok
with the limitation that you can't tell whether the error was
generated during the take or was the actual data sent. However when
dealing with lists, errors are never generated, they're always the
item in the list. We want step to treat both errors and =nothing= as
actual items and not a flag value for error conditions

OK here's a plan: Result<Option<Item>>.  If the pipe is closed, return
Ok(None), if error return Err. The way we differentiate between Errors
in a list and Errors that just happened, is already implemented: via
the 'handled' field of the Error. So if there's a error in the list,
it'll have handled=true and it won't cause the program to
unwind. If it's an actual error reading from the underlying data,
it'll have handled=false and unwind. This will also allow us to
support Nothing in lists and pipes, we won't reserve it as a sentinel
value.
** DONE Step accepts pipes
** DONE Set close = drop
** DONE Remove closed? 
*** DONE Write assemble in terms of step
I don't think we actually need assemble anymore, since this is just a
regular =step= (same as reducing any other iterable).
*** DONE Do something with network pipes
I think this does have a notion of closing.
** DONE make a polymorphic 'join'
:LOGBOOK:
CLOCK: [2023-01-04 Wed 05:48]--[2023-01-04 Wed 07:26] =>  1:38
:END:
The problem is that it's not symmetrical. If you have two different
types, whose semantics do you use? Sometimes it's obvious regardless
of order. Other times I suppose it's ok to use the first one (the
deeper in the stack).

 - list assoc -> list
 - assoc list -> list
 - list string -> list
 - assoc string -> error
 - assoc assoc -> assoc (merge top into 2nd)

   #+begin_src kcats :results code
     [[a b] [c d]] [[e f]] join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a b] [c d] [e f]]
   #+end_src

   #+begin_src kcats :results code
     [[a b] [c d]] association [[a f]] association join
   #+end_src

   #+RESULTS:
   #+begin_src kcats
   [[a f] [c d]]
   #+end_src
** DONE Update spec types to be more abstract
For example, =step= now accepts not only lists but also out-pipes. So
really the spec type for this argument should be =iterable= or
something.

For ideas of what to call these types, how about =in= and =out=? So eg
step takes a program and an out. =put= takes an =in=, =take= takes an =out=. I
am not sure if the =tunnel= concept will be necessary.

* DONE Support char type
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
If we don't support char, that breaks the abstraction of a String as a
sort of collection. A collection of what? Characters, not 1-length
strings.

Might have to do something similar with byte, but a byte array can
also be thought of as an array of ints (8 bit unsigned), and we
already have an integer type (even though it holds more bits).

* DONE implement sleep                                               :stdlib:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
helps with debugging multithreading

#+begin_src kcats
1000 sleep
#+end_src

#+RESULTS:
#+begin_src kcats

#+end_src

#+begin_src kcats
timestamps take [1000 timer take] shield drop [take] dive 1000 - 100 within? 
#+end_src

#+RESULTS:
#+begin_src kcats
true [[type out]
      [from systemtime]
      [values [[type integer]
               [units milliseconds]]]]
#+end_src


* DONE handoff tests
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:13
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
This should block, not error
#+begin_src kcats
handoff take
#+end_src

#+RESULTS:
: [[reason "type mismatch"] [unwound [unpack]] [type error] [asked [list]] [actual [[type pipe] [handoff todo: id-or-hash here]]] [handled true]] [[handoff todo: id-or-hash here] [type pipe]]

#+begin_src kcats
  handoff [1 2 +] future take 
#+end_src

#+RESULTS:
: [3 [[type pipe] [handoff todo: id-or-hash here]]] [[handoff todo: id-or-hash here] [type pipe]] [[handoff todo: id-or-hash here] [type pipe]]

#+begin_src kcats
handoff clone [snapshot] dip swap [1 put 2 put] join [[] [program]] dip assign environment animate take [take] dip +
#+end_src

#+RESULTS:
: 3 [[type pipe] [handoff todo: id-or-hash here]] [[type pipe] [handoff todo: id-or-hash here]]

Should make a word that creates an inner env with access to a handoff also present in the outer env.
#+begin_src kcats
    [[1 2 3] [put] step close] handoff clone ; p h h
    [wrap swap join [[] [program]] dip assign environment animate] dip
    0 swap [+] step
  ;;[snapshot] dip swap  join [[] [program]] dip assign environment animate take [take] dip +
#+end_src

#+RESULTS:
: 6

#+begin_src kcats
    [[1 2 3] [put] step close] handoff clone ; p h h
    [wrap swap join [[] [program]] dip assign environment animate] dip
    0 swap [+] step
  ;;[snapshot] dip swap  join [[] [program]] dip assign environment animate take [take] dip +
#+end_src

Read from one file and write to another 
#+begin_src kcats
  [[file "/tmp/bar"]] pipe-in
  [[file "/tmp/foo"]] pipe-out 
  [put] step
#+end_src

#+RESULTS:
: [[type pipe] [file "/tmp/bar"]]

As a library function
#+begin_src kcats :results code
  "/tmp/bar" "/tmp/foo" file-out [file-in] dip
  [put] step close
#+end_src

#+RESULTS:
#+begin_src kcats
Closing In
[[file "/tmp/bar"] [type pipe]]
#+end_src


* DONE Investigate simpler map/filter impls
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats :results code
7 8 [+] [] [] sink [shielddown dip] decorate [swap] unwrap prepend [swap put] join step
#+end_src

#+RESULTS:
#+begin_src kcats
[+] 8 7
#+end_src

#+begin_src kcats :results code
3 [1 2 3 4 5 6] [drop odd?] [] sink [shield dip] decorate [swap] unwrap prepend [sink [put] [drop] branch] join step
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3 4 5 6] 3
#+end_src


* DONE Allow generator transforms to work on pipes
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
pipe + [take] = generator

* DONE Implement hashset                                             :stdlib:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-12-31 Sun 13:55]
Once we have this, we can implement stuff like the =distinct= transform
function.

** DONE Implement set membership check
- State "DONE"       from "INPROGRESS" [2023-12-31 Sun 13:55]
Could possibly piggyback on =lookup= here, but the semantics are a
little different (nested sets are not allowed, return value is the
same as the key argument).

Another option is to call it =contains?= and check for membership. The
implementation could accept any Sized type, but it's not obvious how
to handle map types - are we checking just for the key, or key/val
pair? I lean slightly toward just the key, but hard to say. For list
types do we convert or promote to set, or just do a (worst case) full
pass over the elements? Vec[Deque] has a contains method so I'm
inclined to just use that.

*** DONE Substring or subcollection
- State "DONE"       from "TODO"       [2023-12-31 Sun 13:55]
Included as part of this should be substring and subarray checking. eg
="foobar" "bar" contains?= should return =true=. It's a different behavior
when the member and collection are the same type vs different
types. Should probably error when it's two different collection types,
eg =[1 2 3] [2 3] set contains?= should error.

#+begin_src kcats
"foobar" "oob" contains?
#+end_src

#+RESULTS:
#+begin_src kcats
yes
#+end_src

#+begin_src kcats
[1 2 3] set 3 contains?
#+end_src

#+RESULTS:
#+begin_src kcats
yes
#+end_src


* DONE Implement until
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
like =while= but always runs the body once.

#+begin_src kcats :results code
  64 [50 >] [clone *] ;; until
  swap ;; pred body
  [not] join ;; reverse logic
  [shield] decorate ;; add shield to the pred program -> pred body
  join ;; [body ..  pred]
  true swap ;; run at least once
  loop
#+end_src

#+RESULTS:
#+begin_src kcats
4096
#+end_src

use until in places I wish i'd had it:
laster:
#+begin_src kcats :results code
  [1 2 3 4] liberate
  [] []
  [[empty?]
   ;; l sl
   [swap ;; sl l
    drop ;; l
    [generate] dip ;; sl l
    swap] ;; l sl 
   until swap
   [[]] dipdown] ;; replace the empty state
  collect
#+end_src

joiner
#+begin_src kcats :results code
  [[1 2 3] [4 5 6] [7 8 9]] liberate
  [] []
  [empty?]
  [drop ;; r
   [generate] dip ;; r i
   swap ;; i r
   clone ;; i i r
   [join] dip ;; i r2
  ] until  generate
#+end_src
#+RESULTS:
#+begin_src kcats
[1 2 3 4 5 6 7 8 9] [] [take] []
#+end_src

#+begin_src kcats
[1 2 3 4] liberate generate
#+end_src

#+RESULTS:
: 1 [take] [2 3 4]


* DONE CI on github                                                   :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:


* DONE Add a kcats logo to github project page                        :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:


* DONE Add a video snippet of repl interaction to github project page :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:


* DONE Write an alpha release announcement                            :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-02-23 Fri 15:14]
Show HN: Kcats: A Powerful, Beginner-Friendly, Stack-Based Programming Language
#+begin_src fundamental
  Hello everyone,

  I'm excited to introduce the alpha release of kcats, a fresh take on stack-based programming languages, inspired by the language Joy, designed with simplicity, learnability, and functionality in mind.

  Our aim with kcats is to make it easier for anyone to write short programs for personal automation tasks. We believe that existing languages require learning too many specialized functions and concepts. Kcats addresses these issues by offering a streamlined alternative. Originally conceived as a scripting language for a forthcoming messaging protocol, it's useful for general programming as well.

  Key features of kcats:

      Simplicity: kcats emphasizes fewer, general-purpose tools instead
      of a complex array of specialized ones. Its syntax uses words and
      bracket quotation marks [ and ], and no other symbols. It uses a
      few simple programming concepts including stacks, lists,
      functions, and pipes.

      Introspective: The documentation, examples, and even the entire
      state of a running program, are data that can be queried and
      processed with the language itself. Kcats is its own debugger.

      Powerful and Versatile: Despite its simplicity, kcats is designed
      to be a powerful tool capable of handling a wide range of
      programming tasks. The tools programmers use in other languages
      are there, and built from simple primitives - closures, error
      handling, metaprogramming, multithreading, channels, generators,
      i/o, and serialization.

      A Focus on Tooling: kcats intends to make tool development,
      including IDEs and debuggers, as easy as possible.

  As this is the alpha release, we eagerly welcome all feedback, contributions, and constructive criticisms from the community. We're especially interested in improving the documentation and learning experience.

  Join us in exploring this new language and contribute to making programming more accessible to everyone. Your feedback is essential to making it intuitive and easy to use!

  Please check out our docs and alpha release here:
  https://github.com/skyrod-vactai/kcats

  Happy coding!

  Best, Skyrod
#+end_src
#+begin_src fundamental
  Announcing the Alpha Release of kcats: A Simple, Powerful,
  Beginner-Friendly, Stack-Based Programming Language

  Hello everyone,

  I'm excited to introduce the alpha release of kcats, a fresh take on
  stack-based programming languages, inspired by the language Joy,
  designed with simplicity, learnability, and functionality in mind.

  Our aim with kcats is to make it easier for anyone to write short
  programs for personal automation tasks. We believe that existing
  languages require learning too many specialized functions and
  concepts. Kcats addresses these issues by offering a streamlined
  alternative. Originally conceived as a scripting language for a
  forthcoming messaging protocol, it's useful for general programming as
  well.

  Key features of kcats:

      Simplicity: kcats emphasizes fewer, general-purpose tools instead
      of a complex array of specialized ones. Its syntax uses words and
      bracket quotation marks [ and ], and no other symbols. It uses a
      few simple programming concepts including stacks, lists,
      functions, and pipes.

      Introspective: The documentation, examples, and even the entire
      state of a running program, are data that can be queried and
      processed with the language itself. Kcats is its own debugger.

      Powerful and Versatile: Despite its simplicity, kcats is designed
      to be a powerful tool capable of handling a wide range of
      programming tasks. The tools programmers use in other languages
      are there, and built from simple primitives - closures, error
      handling, metaprogramming, multithreading, channels, generators,
      i/o, and serialization.

      A Focus on Tooling: kcats intends to make tool development,
      including IDEs and debuggers, as easy as possible.

  As this is the alpha release, we eagerly welcome all feedback,
  contributions, and constructive criticisms from the community. We're
  especially interested in improving the documentation and learning
  experience.

  Join us in exploring this new language and contribute to making
  programming more accessible to everyone. Your feedback is essential to
  making it intuitive and easy to use!

  Please check out our alpha release here:
  https://github.com/skyrod-vactai/kcats

  Happy coding!

  Best, Skyrod

#+end_src


* INPROGRESS Post announcement on various forums                      :alpha:
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:14
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: INPROGRESS
:END:

- [ ] Hacker news
- [X] Reddit r/concatenative
- [ ] Reddit r/programming
- [ ] r/learnprogramming
- [ ] r/coding
- [X] programming.dev
** DONE Solve some programmer.dev challenges
- State "DONE"       from "TODO"       [2023-10-05 Thu 11:11]
Remove matching parens
#+begin_src kcats
  "[(({})({)(()}]"
  [[\[ \]] [\{ \}] [\( \)]]
  "" float
  [[[last] dive wrap swap [lookup] dip =]
   [drop pop drop]
   [put]
   if] step
   dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
"[(({)(}]"
#+end_src


* DONE [#A] Auto code formatter
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:15
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-09-22 Fri 09:25]
This is desperately needed, as a big blob of output line-wrapped is
very hard to read.

I am not sure exactly how to determine where line breaks should occur
but literally anything is better than how it is now.
#+begin_src kcats :results code
[[foo bar][baz [[quux floop][toop poop]]]]
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo bar]
 [baz [[quux floop]
       [toop poop]]]]
#+end_src

now test decreasing indent
#+begin_src kcats :results code
  [[foo bar] [baz [[quux floop] [toop poop]]] goop]
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo bar]
 [baz [[quux floop]
       [toop poop]]]
 goop]
#+end_src

#+begin_src kcats :results code
  [[[1 2 3] [4 5 6] [7 8 9]] liberate [] [] [empty?] [drop [generate] dip swap clone [join] dip] until  generate] reverse
#+end_src

#+RESULTS:
#+begin_src kcats
[generate until [drop [generate] dip swap clone [join] dip] [empty?] [] [] liberate
 [[1 2 3] [4 5 6] [7 8 9]]]
#+end_src

#+begin_src kcats :results code
[blahblah blah [blah blah foop foop [toopy] foop foop] toop [blah foop] toopy]
#+end_src

#+RESULTS:
#+begin_src kcats
[blahblah blah [blah blah foop foop [toopy] foop foop] toop [blah foop]
 toopy]
#+end_src

#+begin_src kcats :results code
[[[1 2 =] [false]] [[1 1 =] [true]]]
#+end_src

#+RESULTS:
#+begin_src kcats
[[[1 2 =] [false]]
 [[1 1 =] [true]]]
#+end_src

#+begin_src kcats :results code
[[[] b] [c d]]
#+end_src

#+RESULTS:
#+begin_src kcats
[[[] b]
 [c d]]
#+end_src

#+begin_src kcats :results code
 [[a b] [c d]] "hello"
#+end_src

#+RESULTS:
#+begin_src kcats
"hello" [[a b]
         [c d]]
#+end_src


* DONE Have eval-step return nothing when program is done
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:15
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
That means eval needs to keep the input until it checks the output.

That may make normal runtime a little less efficient but it means
debuggers and step generators are easy and more efficient.

At that point =stepper= can be removed and we can use =eval-step= in its place. 

(actually stepper still has a use, it just doesn't need to check for =nothing= anymore)


* DONE print
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It's probably just an alias for something like =[standard] dip bytes put
drop= (write to stdout and then drop the pipe).


* DONE Remove references to "expression"
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
I think the expression is just a "program". I suppose *the* program. But
still "program". And yes, it gets shorter as it runs. Still, it's a program.
** DONE Clear up odd language
There are places in the docs where we used "expression" and "program"
in the same phrase, where now it says program in both places, and it's
confusing.

* DONE implement breakpoints
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Fix break arg order
 I think the args are in the wrong order - env should be under the program.
 #+begin_src kcats 
   [[program [1 [1 2 3] [+] step]]] environment
   [[program 0] lookup wrap [+] =]
   [[[swap something?] ;; still running
     [execute not]] ;; check condition not true yet
    [execute]
    every?] ;; break?
   [[eval-step] dip]  ;; evaluate the environment one step
   while
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [[program 0]
  lookup wrap [+] =]
 [[stack [1 1]]
  [program [+ [2 3]
               [+] step]]]
 #+end_src
** DONE Test breakpoint
#+begin_src kcats
  [[program [2 [100 breakpoint <] [2 *] while]]] environment [sprint clone] collect
#+end_src

#+RESULTS:
#+begin_src kcats
[[[program [< [[2]] unwrap evert first [[2 *]] unwrap [[[100 breakpoint <] shield]]
               unwrap join loop]]
  [stack [100 2]]]
 [[program [< [[4]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 4]]]
 [[program [< [[8]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 8]]]
 [[program [< [[16]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 16]]]
 [[program [< [[32]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 32]]]
 [[program [< [[64]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]
  [stack [100 64]]]
 [[stack [100 128]]
  [program [< [[128]] unwrap evert first [2 * [100 breakpoint <] shield] loop]]]]
[sprint clone]
[]
#+end_src

* DONE Rewrite future in terms of spawn
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
  1 [2 +]
  ;; do other stuff

  handoff swap 
  [snapshot] join ;; return the whole stack
  wrap [dive put drop] join 
  spawn animate

    4 5 + drop

  take dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
[3] 1
#+end_src

* DONE Re-implement let
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
I think it's pretty useless as-is. I think it should just be a quicker
version of lingo, where you don't need to specify a spec, and it
always adds items to the dictionary instead of arbitrary changes.

#+begin_src kcats
  [[times5 [5 *]]
   [doubledec [dec dec]]]
  [3 times5 doubledec]
  [[[1] [[[[spec [[] []]]] ;; spec of self-insert
          [definition]] dip
         assign] ;; build a full entry
    update]
   map wrap [join] join] dip
lingo
#+end_src

#+RESULTS:
#+begin_src kcats
13
#+end_src

* DONE Loop combinator that has an initialization program
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Like =while= but calls init before starting and each time through the loop. Call it =prime=?
#+begin_src kcats
  timestamps
  [take] [odd?] [dump drop] [clone [execute] dip] dipdown float  join while  
#+end_src

* DONE startswith/endswith
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Note this impl is not efficient because it zips the entire input
before starting comparison. An efficient one would keep an index
counter and compare via lookup.

starts
#+begin_src kcats
"abcd" "" zip [unwrap =] every? 
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

ends
#+begin_src kcats
"abcd" "abcd" [reverse] both zip [[=] inject first] map [] every? 
#+end_src

#+RESULTS:
#+begin_src kcats
true
#+end_src

* DONE map doesn't handle nothing values
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[1 2 3 4 5] [odd?] map
#+end_src

#+RESULTS:
#+begin_src kcats
[yes [] yes [] yes]
#+end_src

ughhh should probably revert the change that left map in terms of
generators, because map isn't indefinite and has different handling of =nothing=.

* DONE Separate formatting from emitting
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-19 Thu 21:04]
- State "INPROGRESS" from "TODO"       [2023-09-23 Sat 10:29]

* DONE Fix line breaks with byte literals
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-11-19 Sun 19:17]
- State "INPROGRESS" from "TODO"       [2023-11-19 Sun 18:48]
#+begin_src kcats
"foo" bytes key
#+end_src

#+RESULTS:
#+begin_src kcats
[[type elliptic-curve-key]
 [public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="]
 [secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="]]
#+end_src

Line break doesn't get added because it thinks =#b64= is an item when
it's really a parsing hint.

* DONE slice ordered items
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-19 Thu 21:04]
- State "INPROGRESS" from "TODO"       [2023-10-04 Wed 19:00]
We have indexing to a single subitem but we need to be able to get
ranges too. I think all the underlying types support it so we just
need to expose it.
#+begin_src kcats
"foobarbaz" 3 60 slice
#+end_src

#+RESULTS:
#+begin_src kcats
#+end_src

#+begin_src kcats
[a b c d e f] 2 4 slice
#+end_src

#+RESULTS:
#+begin_src kcats
[c d]
#+end_src

This works but currently panics if you go beyond the valid
indices. Should probably throw a proper error.

* DONE Templating
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:16
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-19 Thu 21:04]
- State "INPROGRESS" from "DONE"       [2023-10-15 Sun 17:23]
- State "DONE"       from "INPROGRESS" [2023-10-09 Mon 19:04]
- State "INPROGRESS" from "TODO"       [2023-10-09 Mon 19:04]
It would be nice if we could build nested programs as a template
instead of assembling them from parts.

For example lets say I wanted =[foo [[blah] dip] shield]= where =blah= is
a runtime value. Currently I'd have to use =join= to put it together.

#+begin_src kcats
  [[w1 [join]]]
  ["baz" "bar" "foo" [[w1] shield] dip]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
"foo" "bazbar" "bar" "baz"
#+end_src

This isn't quite "templating", since it requires that the =let= scope
encompasses wherever the program is *executed*, and not just where it is
built. What we want is a portable program with =join= substituted for
=w1=. I think recursive replace should be straightforward enough.

#+begin_quote
function template_recurse(template, mapping):
    if template is a list:
        return [template_recurse(item, mapping) for item in template]
    else if template is a placeholder (string) and template in mapping:
        return mapping[template]
    else:
        return template

function template(template, mapping):
    return template_recurse(template, mapping)
#+end_quote

#+begin_src kcats
  [[*a* [foo]] [*b* bar]] [*a* [*b*] c d 1 2 3]
  ; t v
  [list? not] ;; recur condition
  [[word?]
   [[wrap lookup] shield clone [dropdown] [drop] branch dropdown]
   when]
  [] ;; rec1
  [map] recur dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo] [bar] c d 1 2 3]
#+end_src

Note this currently behaves oddly if you don't declare the mapping as
an association and you have integers in your template. Should probably
fix that, I don't think we intend to replace ints with other values
based on index.

Come to think of it, since the template's values will come from the
stack, I think we should let the caller construct that first and then
put the template on top.

Test this out on the current impl of =until=.
#+begin_src kcats
  2 [even?] [inc]
  pair [pred body] swap zip 
  [[splice body] [[splice pred] not] shield] template
  yes swap loop
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src

Aha, we need =unquote-splicing= ! Well I am not sure how to implement that.

So this is implementing the different syntax for placeholders, =[poke
a]= and =[splice a]=. However splicing is still not supported, as it
requires a different =recur= structure.

#+begin_src kcats
  [[a [foo]] [b bar]] [[poke a] [[poke b] x [poke a]] c d 1 2 3]
  ; t v
  [[subs-point? [[[list?]
                  [count 2 =]
                  [first [poke splice] set swap contains?]]
                 [execute] every?]]]
  [[[[list? not]
     [subs-point?]] [execute] any?];; recur condition
   [[subs-point?]
    [second [wrap lookup] shield clone [dropdown] [drop] branch ]
    when dump]
   [] ;;  rec t v

   ;;ok so the idea here is to just use `step` and the trick is that the
   ;; recur fn needs to have the accumulator out of the way, via `dip`,
   ;; and then the step fn (after the recur is done) should have the acc
   ;; on top again, with the new value beneath, which it can just `swap
   ;; put` or `swap join` i suppose. So we need to append that part to
   ;; the step program.
   [[] sink ;; rec t acc v
    ;; now build the step fn to include the push into acc
    [dip] decorate ;; run the rec with dip (under the acc) 
    [swap] swap join ;; prepend floating the acc to the top before the dipping
    ;; then after the dipping we have acc res 
    [swap put swap] join step
   ]

   ;;drop dump
   ;; rec2 acc t  v
   ;;  
   recur dropdown]
  let
#+end_src

Ok so maybe an easier way to think about this is using =let= and calling
the templating recursively.

#+begin_src kcats
  [[a [foo quux]] [b bar]]
  [[[a b [splice a] c]]]
  ; [[poke a] [[poke b] x [splice a]] c d 1 2 3]
    ; t v
    [[subs-point? [[[list?]
                    [count 2 =]
                    [first [poke splice] set swap contains?]]
                   [execute] every?]]
     [subs [second [wrap lookup] shield clone
            [dropdown] [drop] branch]]
     ;; takes t v
     [template [[[[subs-point?] [[first wrap [poke] =]
                                 [subs wrap]
                                 [subs] if]]
                 [[list?] [[] swap ;;  t acc v
                           [swap [template] dive join] step wrap]]
                 [[yes] [wrap]]]
                decide]]]
    [template]
    let unwrap dropdown
#+end_src

#+RESULTS:
#+begin_src kcats
[[[a b foo quux c]]]
#+end_src

#+begin_src kcats
[[body [inc]] [pred [even?]]]
[[not [splice pred]] shield] template
#+end_src

#+RESULTS:
#+begin_src kcats
[not even? shield]
#+end_src


* DONE Eliminate 'nothing'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-17 Tue 18:58]
The concept is confusing because an empty container is not =nothing=. 
** DONE Rename nothing? to empty?
- State "DONE"       from "INPROGRESS" [2023-10-17 Tue 18:51]
- State "INPROGRESS" from "TODO"       [2023-10-17 Tue 18:33]
** DONE Use yes instead of true
- State "DONE"       from "INPROGRESS" [2023-10-17 Tue 18:33]
- State "INPROGRESS" from "TODO"       [2023-10-17 Tue 18:06]

* DONE Reimplement every? and any? using recursive call
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-20 Fri 13:48]
- State "INPROGRESS" from "TODO"       [2023-10-20 Fri 13:45]
#+begin_src kcats
    -12 [[negative?] [even?]] [execute]
    [[every? [[swap]
              [[take] dip clone [float [shielddown] dive] dive 
               []
               [drop every?]
               [dropdown dropdown] if]
              [drop drop yes] if]]]
    [every?]
    draft 

#+end_src

#+RESULTS:
#+begin_src kcats
yes -12
#+end_src

#+begin_src kcats
  11 [[negative?] [even?]] [execute]
  [[any? [[swap]
            [[take] dip clone [float [shielddown] dive] dive 
             []
             [dropdown dropdown]
             [drop any?] if]
            [drop drop []] if]]]
  [any?]
  draft

#+end_src

#+RESULTS:
#+begin_src kcats
[] 11
#+end_src

* DONE Remove notion of Nothing from the implementation
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-21 Sat 11:29]
- State "INPROGRESS" from "TODO"       [2023-10-21 Sat 11:29]
I don't think the performance boost (if any) is worth it. Everywhere
we use NOTHING now, we can just set it to an empty List. And probably
rename it to Empty or something like that. There's no need for the enum variant.

* DONE improve 'capture' semantics with 'bind'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-12-30 Sat 14:34]
- State "INPROGRESS" from "TODO"       [2023-10-30 Mon 17:02]
The problem is that =capture= as written, doesn't make it obvious that
it's combining the captured items with the stack at the time of
execution - what it actually does is takes the top item from the stack
and puts it on top of the captured stack (dropping the rest of the
current stack).

So what's missing is the 'arity'. Also it's not clear that we always
want the current stack items on top of the captured stack. For
example, what if we wanted a "subtract 5 from" closure:

#+begin_src kcats
[5] [-] capture [10] dip execute 
#+end_src

#+RESULTS:
#+begin_src kcats
-5
#+end_src

What we got was actually "subtract from 5".

But that's easy enough to fix:

#+begin_src kcats
[5] [swap -] capture [10] dip execute 
#+end_src

#+RESULTS:
#+begin_src kcats
5
#+end_src

I suppose what we could do here is keep with the =down=, =deep= convention
and implement =capturedown= and =capturedeep= to represent the 2 and 3
arities.

I am not even sure we need something this complex - joy doesn't seem
to have it at all. What we could do instead is just prepend stuff to a
program, which could be equivalent to =partial= in clojure. So to do
"subtract 5 from":

#+begin_src kcats
10 [-] 5 prepend execute
#+end_src

#+RESULTS:
#+begin_src kcats
5
#+end_src

And to do "subtract from 10":

#+begin_src kcats
  ;6 [-] [10 swap] swap join execute
  6 10 [-] [swap] unwrap prepend swap prepend execute
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src

Of course in many cases we are trying to partial in a value from the stack:

#+begin_src kcats
6 10 [-] [swap] swap join swap prepend execute  

#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src

So there's two things happening: inserting values from the stack and
inserting operations to move those values into the correct position on
the stack later.

What words will help us here? I suppose we could do =partial= =partialdown= etc:

#+begin_src kcats
  [[bind [swap prepend]]
   [binddown [[swap] swap join swap prepend]]
   [binddeep [[sink] swap join swap prepend]]]

  ;10 [-] partial [25] dip execute]
  ;[10 5 [-] binddown bind ] ;; bind multiple
  [5 [range] binddeep [10 2] dip execute]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
[5 7 9]
#+end_src

One question here is whether the binding should consume the value from
the stack, I think it should and if the caller doesn't want that he
can use the =shielddown= combinator.

Ok let's see if we can go back and use this in existing code.

* DONE Implement more functions from Joy
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2023-10-30 Mon 16:31]
+ over
+ dupd (clonedown)
+ dupdd (clonedeep)
+ tuck (opposite of over: under) 

* DONE implement 'label'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2023-11-10 Fri 14:05]
We're "labeling" items on the stack and get a map. eg
="Alice" 23 "123 Main St" [address age name] label=

The question is do we label from stack's top to bottom or the other
direction? Let's try "top first" - if we have a literal we can just
write a map literal to start, so i think this is ok.

#+begin_src kcats 
  "Alice" 23 "123 Main St" [address age name]
  [] swap ;; labels acc
  [wrap float assign] step
#+end_src

#+RESULTS:
#+begin_src kcats
[[address "123 Main St"]
 [age 23]
 [name "Alice"]]
#+end_src

* DONE Refactor bytes as 'encode'
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-12-02 Sat 15:12]
- State "INPROGRESS" from "TODO"       [2023-12-02 Sat 14:44]
Make this a multimethod

* DONE Deterministic serialization
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-02-19 Mon 17:27]
- State "INPROGRESS" from "TODO"       [2024-02-19 Mon 17:27]
We need to be able to serialize some things the same way every time
(for example if we're taking the hash of some program or data). For
now we'll make that the default serialization, even though it's
slower. If needed we can make a separate "emit" word to not bother
with determinism.

* DONE Make assemble not depend on template
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 15:17
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2024-02-22 Thu 17:19]
We've got a cyclic dependency here:

assemble -> template -> let -> draft -> revise -> assemble

Easiet way I see to break this is to not use templating for assemble,
which is not that hard to write without it (just not as clear).

#+begin_src kcats
  [1 2 3 4 5] [[odd?] keep]
  
#+end_src

#+RESULTS:
#+begin_src kcats
[1 3 5]
#+end_src

* CANCELED Library definitions and loading
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 16:52
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2024-02-23 Fri 16:51] \\
  Superseded by module work with inscribe/resolve
We don't have a good story yet for how new words are loaded and accessed.

Right now I'm using =let= but the danger with this method is that you
can pretty easily accidentally overwrite some word that your program
depends on deep in its expanded expression, and that causes behavior
that's both unexpected and difficult to debug.

So what I think we really want is for the new definitions to only
apply for the literal program we write. A naive implementation would
just recursively replace words in the program with their definitions,
but that could be problematic when a word is used as data and not
meant to be an action word.

Really =template= is close to what we want here. It's just ugly to have
to write =[poke mynewword]= instead of just calling =mynewword= like you
normally would.

Another approach is to just not allow =let= to overwrite.
** INPROGRESS Template-based let macro 
 - State "INPROGRESS" from "TODO"       [2024-01-01 Mon 22:00]
*** DONE Versioned Words   
- State "DONE"       from "TODO"       [2024-01-02 Tue 17:32]
*** DONE Versioned dictionary
- State "DONE"       from "TODO"       [2024-01-02 Tue 17:32]
*** DONE Dict lookups respect version but = doesn't
- State "DONE"       from "TODO"       [2024-01-02 Tue 17:32]
*** DONE Version words in a program
- State "DONE"       from "INPROGRESS" [2024-01-07 Sun 09:11]
- State "INPROGRESS" from "TODO"       [2024-01-02 Tue 17:45]
*** DONE Dictionary update to copy all touched words to versioned word
- State "DONE"       from "INPROGRESS" [2024-01-07 Sun 09:11]
- State "INPROGRESS" from "TODO"       [2024-01-02 Tue 17:45]
Here's how I think it could work:

A rust function would take:
+ A list or assoc of updates (word, update-prog)
+ A program to run

Do the following:
+ [X] extract the words into a set
+ [X] clone the current dictionary, save it
+ [X] Increment the version in the current dictionary
+ [X] For each word, if the non-versioned word exists in the dictionary, copy it to the versioned word
+ [X] Recursively run through the program, updating words with the new version
+ [X] Change all the keys in the updates to the new version
+ [X] place into expression: get dictionary, step through updates, calling update, redefine
+ [X] place into expression: program (unwrapped)
+ [X] place into expression: the old dictionary, redefine
+ [ ] All values in the updates need to get versioned with the words defined before it

This should give us
+ The ability to do =let*= type stuff - refer to one function in the
  definition of another but we would need to be careful to only update
  program in the values with the words that have already been defined,
  not the whole word list. - make tests for this
+ The implementation details don't leak into the language, this
  function could just be called =let=. The existing one we could rename
  to something more indicative of unsafe operations.

  test it
    Can call new words
  #+begin_src kcats
    
    [[foo [[[definition [inc bar]]
            [spec [[number] [number]]]]]]]
    [1 foo] inscribe
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  2
  #+end_src

    Can still access base words like swap
  #+begin_src kcats
  [[foo ["foo"]]] [1 2 swap foo] draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "foo" 1 2
  #+end_src

    Words no longer accessible after let ends
  #+begin_src kcats
  [[[foo ["foo"]]] [1 2 swap foo] draft foo] [] recover type [error] unwrap =
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  yes
  #+end_src

   Previously defined words can be used inline
  #+begin_src kcats
    [[square [clone *]]
     [fourth [square square]]]
    [3 fourth] draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  81
  #+end_src

  Words can call themselves
  #+begin_src kcats
    [[factorial [[swap positive?]
                 [[*] shielddown [dec] dip self]
                 when]]]
    [6 1 factorial dropdown]
    draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  720
  #+end_src

  We can update the definition of existing words
  #+begin_src kcats
    [[hash [[type [foo] unwrap =]
            [drop "foo" hash]
            addmethod]]]
    [[[foo 1]] association hash] let*
    "foo" hash =
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  yes
  #+end_src

  We can nest let blocks
  #+begin_src kcats
    [[foo ["foo"]]
     [quux ["quux"]]]
    [foo
     [[foo [foo "foo2"]]
      [bar [foo "bar"]]]
     [1 2 3 bar quux]
     draft]
    draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "quux" "bar" "foo2" "foo" 3 2 1 "foo"
  #+end_src

  We can modify previous let words
  #+begin_src kcats
    [[foo ["foo"]]]
    [foo
     [[foo ["bar" put]]]
     [foo]
     revise]
    draft
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "bar" "foo"
  #+end_src

  We can modify axiom words

  #+begin_src kcats
    [[swap [[[definition [dump swap]]]]]]
    [1 2 swap]
    inscribe
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [2 1]
  1 2
  #+end_src

*** TODO Word to create full dictentry update from just the definition update
#+begin_src kcats
[[foo [[definition] [["foo"]] update]]] [foo] let*
#+end_src

#+RESULTS:
#+begin_src kcats
"foo"
#+end_src

#+begin_src kcats
  [[foo [["foo"]]]]
  [[1] [[[definition]] swap wrap join [update] join] update] map
  ;[foo] let*
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo [[definition] [["foo"]] update]]]
#+end_src

Maybe we should stick a default spec in there?

#+begin_src kcats
  [[foo ["foo"]]]
  
  [foo] draft
#+end_src

#+RESULTS:
#+begin_src kcats
"foo"
#+end_src

*** TODO kcats impl
#+begin_src kcats 
  ;[foo] 1 version [foo] 2 version =
  ;dictionary [*version*] [[definition [1]]] assign
  [[foo [["foo"]]]
   [bar [["bar"]]]
   [lookup [["swappie"]]]] 
  [foo bar swap]
  dictionary
  [+version+ definition] [[] [[inc] inject] [[0]] if] update ;; d p u

  [[+version+ definition] lookup first] shield ;; v d p u
  [sink] dip ;; v p u d
  clone ;; v v p u d 
  [version swap] dip version   ;; u p d

   swapdown   ;; u d p
  [ unwrap [wrap [definition] join] dip  update] step 
  define
  execute
#+end_src

*** TODO Discussion
In the context of loading libraries, how do we do it? It seems like
some libraries may need both kinds of changes (global/local): some
changes are method additions and others are new words. What is loading
a library? Is it just arbitrary code execution? That would be
flexible, but not very secure. Maybe it's ok if the library publisher
is authenticated?

What does loading a library look like? Presumably we load it by its
hash. And it's not a permanent change, it's only for a given block of
code. But it seems clear that the library's words need to apply not
just to the top level? Or do they? Libraries can do lots of things,
including extending the language so it's hard to predict exactly how
they would be loaded.
#+begin_src kcats
[
#+end_src


* Simple Test
:PROPERTIES:
:ARCHIVE_TIME: 2024-02-23 Fri 16:52
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues/Database
:ARCHIVE_CATEGORY: production
:END:
#+begin_src kcats
"create table Person (firstName text not null, lastName text not null, email text)" database 
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

#+begin_src kcats
"insert into Person (firstName, lastName, email) values ('Skywife', 'Vactai', 'skywife@skyrod.me')" database 
#+end_src

#+RESULTS:
#+begin_src kcats
[]
#+end_src

#+begin_src kcats
  "select (firstName) from Person where lastName='Vactai'" database 
#+end_src

#+RESULTS:
#+begin_src kcats
[[[firstName "Skyrod"]] [[firstName "Skykid"]] [[firstName "Skywife"]]]
#+end_src


#+begin_src kcats
dictionary [swap] lookup
#+end_src

#+RESULTS:
#+begin_src kcats
[[definition builtin-function]
 [examples [[[1 2 3 swap] [1 3 2]]]]
 [spec [[[item a]
         [item b]]
        [[item b]
         [item a]]]]]
#+end_src

* CANCELED Call stack in errors                     :debugging:errorHandling:
:PROPERTIES:
:ARCHIVE_TIME: 2024-05-22 Wed 09:46
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2024-05-22 Wed 09:46] \\
  I don't know how to implement this so will reopen if needed
It would be nice to see the call stack, if possible. For example if
foo calls bar, and bar fails, it'd be nice to know we're in the middle
of executing foo also. I have no idea how to implement this at the
moment though. Each time we look up a word during eval-step we could
add it to the call stack, and place a special word at the end of the
program to 'pop' from that stack. But I think if we ran =step= on 10,000
item list, the call stack would get at least that deep because step
puts itself back in the program.

So maybe a "call stack" isn't exactly what we want, I'm not even sure
it's possible to get what we want here.

* DONE Interactive mode                                               :tools:
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 19:36
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-03-17 Mon 18:36]
run with =kcats -i= for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
** CANCELED Only print the changed part of the stack
- State "CANCELED"   from "TODO"       [2024-05-22 Wed 09:45] \\
  I think it's too complicated for it to be clear exactly what
  changed. How can we tell if we replaced a stack item or added one?
** TODO Emacs keybindings to send common stack ops
+ swap / swapdown
+ clear ([] evert drop)
+ clone
+ snapshot?
+ drop
+ sink / float

* DONE Implement pipes                                               :stdlib:
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-03-19 Wed 16:29]
** DONE Write to a file
#+begin_src kcats
  [[file "/tmp/bar4"]] pipe-in

  ["hello world!"
   "Nice to meet you!"
   "My name is kcats"]

  ["\n" join bytes put]

  step
#+end_src

#+RESULTS:
: [[asked [pipe]] [unwound [["Nice to meet you!" "My name is kcats"] ["\n" join bytes put] step]] [type error] [reason "type mismatch"]] [[type pipe] [file "/tmp/bar4"]]

#+begin_src kcats
  [[file "/tmp/bar101r7"]] pipe-in

  "hello world!"

  bytes put

#+end_src

#+RESULTS:
: [[type pipe] [file "/tmp/bar101r7"]]

#+begin_src kcats
  [[file "/tmp/bar101r7"]] pipe-out

  take

  string

#+end_src

#+RESULTS:
: "hello world!" [[type pipe] [file "/tmp/bar101r7"]]

** DONE Read from a file
#+begin_src kcats :results code
"" [string join] [[file "/tmp/bar2"]] pipe-out

collect 
#+end_src

#+RESULTS:
#+begin_src kcats

stack: [[[reason "type mismatch"] [asked [pipe]] [type error]] [[file "/tmp/bar2"] [type pipe]] ""]
program: [swap [string join] dip [closed? not] shield [take swap [string join] dip [closed? not] shield] loop drop]
#+end_src

#+begin_src kcats :results code
dictionary [collect spec] lookup
#+end_src

#+RESULTS:
#+begin_src kcats

[[[type error] [reason "word is not defined"] [asked [fail]]]
 "Lookup attempted on non association value"
 [spec]
 [[definition [swap [take swap] swap put [dip] join [[closed? not]] dip while drop]]
  [spec [[pipe program] [item]]]]]
#+end_src
** DONE Close a pipe
#+begin_src kcats :results code
[[file "/tmp/foopytoop"]] pipe-in "foo" bytes put close "bar" bytes put
#+end_src

#+RESULTS:
#+begin_src kcats
[[type pipe] [file "/tmp/foopytoop"]]
#+end_src
** DONE Serialize pipes with something sane
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
** DONE Sockets
*** DONE Server Sockets
#+begin_src kcats :results code
[[type ip-host] [address "127.0.0.1"] [port 11211]] pipe-out 
#+end_src

#+RESULTS:
#+begin_src kcats
socket: Int(11211) String("127.0.0.1")
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
#+end_src

#+begin_src kcats :results code
  "127.0.0.1" 12345 serversocket 
#+end_src

#+RESULTS:
#+begin_src kcats
socket: Int(12345) String("127.0.0.1")
[[type pipe] [serversocket todo: fix serversocket local addr async issue]]
#+end_src

#+begin_src kcats :results code
[[type ip-host] [address "127.0.0.1"] [port 11211]] pipe-out ;; server socket
take ;; accept connection by taking a socket out of the pipe
"foo\n" bytes put ;; write a message to the socket
take string ;; get a message from the socket
[drop ;; close the socket
 drop] ;; close the server socket
dip
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [string]] [unwound [take "foo\n" bytes put take string [drop drop] dip]] [type error] [reason "type mismatch"]]
#+end_src

*** DONE Sockets

*** CANCELED Assemble is broken when reading files
- State "CANCELED"   from "INPROGRESS" [2023-10-22 Sun 07:55]
I think it's because =closed?= is broken.

#+begin_src kcats :results code
"" [string join] [[file "bar"]] pipe-out assemble
#+end_src

#+begin_src kcats :results code
"" [string join] [[file "bar"]] pipe-out take drop take drop closed? 
#+end_src

#+RESULTS:
#+begin_src kcats
checking file closed false
Got 3 bytes
checking file closed false
Got 0 bytes
Closing!
checking file closed false
[] [string join] ""
#+end_src

I see the problem. When we clone the pipe, we also clone the =closed=
boolean and we shouldn't be doing that. There should only be one copy
of that. The entire struct should be in an Arc<Mutex> and not just the
file field. And when we modify the boolean, we shouldn't 
** DONE Convert In/Out traits to enums in pipes modules
Enums seem to work well elsewhere, and since pipes are also a closed
set, we can use them here too.

I don't think there will ever be user-created pipe types as it would
have to be done in rust and not in kcats.

** DONE Composable transforms
There should be some way to compose transforms in a pipe. For example,
we can have a pipe that when you put bytes in it, it gets written to a
certain file on disk. But what we really want is that we put bytes
into it, and they get compressed with lz4 before being written to
disk.

I suppose pump could take an optional transducer-like thing, and *those*
could be composable. The transformations I'm thinking of generally
aren't going to be i/o, it's pure computation. Actually I guess any
pipe could take an optional transform. Clojure.core.async channels do this.

Maybe the first thing to do is implement transducers?
*** DONE Siphon from one pipe to another
A nice primitive would be a word that takes a program (the program
should expect an item on ToS and it should leave a transformed item)
and two pipes, and takes from one pipe, runs the program, and puts the
result back into the 2nd pipe. It should close the output pipe when
the input pipe closes. Should work with generators as input.

This should all work ok except for when programs somewhere in the
generator stack need access to items beneath the generator and we
don't know how to get to them.

The obvious solution to that is to include the needed values in the
program before giving it to the generator. Then the values will be in
a known place on the stack.

This little program will siphon directly from a generator to a
receptacle:
#+begin_src kcats
  integers 5 taker

  [] ;; receptacle
  [] ;; placeholder that gets dropped (next iteration it will hold a
     ;; copy of the last element which is only needed to check if the
     ;; loop continues and can be dropped after)
  [empty?] ;; stop when generator returns nothing
  [drop ;; the last value
   [generate clone] dip
   sink
   [put] dip]
  until
  drop ;; drop the now-empty dispenser
#+end_src

#+RESULTS:
#+begin_src kcats
[0 1 2 3 4 []] [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone]
4
#+end_src

#+begin_src kcats
integers 5 taker [] siphon
#+end_src

#+RESULTS:
#+begin_src kcats
[[type error]
 [actual [[positive?] [dec [generate] dive] [[]] if]]
 [asked [generator]]
 [unwound [siphon]]
 [reason "type mismatch"]
 [handled true]]
[] [[positive?] [dec [generate] dive] [[]] if] 5 [inc clone]
-1
#+end_src

And since pipes can have generator layers put on top of them, I think we're done. 
** CANCELED Filled pipes
Mostly for testing purposes, takes a list and creates a buffered pipe
that offers list items until the list is exhausted and then returns pipe closed errors.

#+begin_src kcats
[1 2 3] filled take
#+end_src

#+RESULTS:
: 1 [[type pipe] [filled todo: id-or-hash here]]

** DONE Object pipes
- State "DONE"       from "INPROGRESS" [2025-03-17 Mon 18:39]
*** CANCELED Generator re-splitting
- State "CANCELED"   from "INPROGRESS" [2025-03-17 Mon 18:39]
- State "INPROGRESS" from "TODO"       [2023-10-19 Thu 21:10]
These pipes should send serialized kcats objects and each put/take
should transfer 1 object. Maybe use protocol buffers or similar

This could be done using a network pipe, and an assemble function that
pulls byte chunks and builds objects when there are enough bytes for
one object, and puts them into a handoff pipe.

This should be possible to do entirely in kcats, similar to how the
interactive mode works. Send a length, then send that number of
bytes. Then the receiving transform can track how many bytes it has
left to receive and the partial encoded item it's got so far. It takes
the next chunk, knocks off that many bytes (if it's more than needed
for that item), and calls =read=. If it's still not enough for the full
item, append to the partial encoded item and decrease the 'bytes
needed' number.

This mechanism of using kcats serialization means we can't send
associations and sets over the wire as-is. We'd have to send them as a
list and convert them at the other end.

Let's see if we can make an object serializer that sends the length
first (separated by \n).

#+begin_src kcats
  [1 2 3] emit bytes
  [count] shield
  string "\n" join bytes
  swap join
#+end_src

#+RESULTS:
#+begin_src kcats
#b64 "NwpbMSAyIDNd"
#+end_src

That's pretty easy! The trickier part is a deserializer where we don't
know how many bytes we're going to get in a chunk.

First we might need a generator that divides into lines.
A generic splitter generator would do most of the work.


#+begin_src kcats
  "foo\nbar\nbaz\n\n" [take]
  "\n"  ;; \f
  [empty] shield
  [[[generate] divedown [clone [put] dip] bail]
   [[[] [drop swap ends? not]] [execute] every?]
   [drop] prime
   drop
   [swap ends?]
   [[[count] shield] dive 
    [[count] shield] dive swap - [0] dip slice]
   when
   [empty] shield swap]
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
["foo" "bar" "baz"] [[[generate] divedown [clone [put] dip] bail] [[[] [drop swap
                                                                        ends? not]]
                                                                   [execute] every?]
                     [drop] prime drop [swap ends?]
                     [[[count] shield]
                      dive [[count] shield]
                      dive swap - [0] dip slice]
                     when [empty] shield swap]
"" "\n" [take] ""
#+end_src

#+begin_src kcats
"foo\nbar\nbaz\n\n" [take]
  "\n"  ;; \f
 split collect
#+end_src

#+RESULTS:
#+begin_src kcats
["foo" "bar" "baz"] [[[generate] divedown [clone [put] dip] bail] [[[] [drop swap
                                                                        ends? not]]
                                                                   [execute] every?]
                     [drop] prime drop [swap ends?]
                     [[[count] shield]
                      dive [[count] shield]
                      dive swap - [0] dip slice]
                     when [empty] shield swap]
"" "\n" [take] ""
#+end_src

Ok this works but ultimately what we need is =resplit= which takes a
list of sized (all the same type presumably) and joins and splits
piece by piece.

We could just create something like =atomize= that takes a generator of
lists, and emits single items.
#+begin_src kcats
  ["foo\n" "bar\nba" "z\n\n"]
  [take] []
  [[] [take] [drop generate take] if] 
#+end_src

#+RESULTS:
#+begin_src kcats
"foo\nbar\nbaz\n\n" [[] [take] [drop generate take] if] [] [take] []
#+end_src

Ok the =atomize= is still handy but what I'm going to do is implement
splitter, that takes a string and emits fields. Then i can use that
generator *within* a re-split chunks generator, that keeps partial
content as state.

So here's that split gen:
#+begin_src kcats
  ;"foo\nbar\nbaz\n\n" [take] "\n"
  ;[1 2 3 2 5] [take] [2]
  ["foo\nbeep" "bar\nba" "z\n\n"] [take] "\n"
  [empty] shield

  ;"foo\nbeep"
  ;; while the state has no separator, pull chunks into it
  [yes
   [[[drop swap contains? not] ;; state doesn't have sep?
     []] ;; last item still something
    [execute] every?] 
   [drop ;; the previous chunk
    [generate] divedown clone [[join] dip] bail]
   while
   drop 
   ;; now call the split generator internally
   wrap [take] put [clone] dive put reverse
   [split execute [dropdown] 3 times] inject 
   unwrap swap 

  ]

  collect
#+end_src

#+RESULTS:
#+begin_src kcats
["foo" "beepbar" "baz"] [yes [[[drop swap contains? not] []]
                              [execute] every?]
                         [drop [generate] divedown clone [[join] dip]
                          bail]
                         while drop wrap [take] put [clone] dive put reverse [split execute [dropdown] 3
                                                                              times]
                         inject unwrap swap]
"" "\n" [take] []
#+end_src

This is great and all, but maybe not quite what we need for object
serialization. Objects can have \n embedded within strings, so that
character doesn't necessarily mean "end of object". It's just used to
separate the byte count from the content.

I think we can implement this pretty directly and easily, especially
if we don't have to account for the case where the count is split
across chunks. We can have a generator with the following state: a
count of chars to read, current content.

Generate, read the count, then loop until there is more content left
in buffer than the count says to expect. Slice off [count] characters
from the buffer and return it if there's enough in the buffer,
otherwise generate and repeat. 

#+begin_src kcats
  ;["5\n[1 2]13\n[ooba " "bazquu]11\nboobooboobo"]
  ["3\n" "fpp4\nfoo"]
  ;[bytes] map
  [take]
  ;[string] each
  "" 0
  [[[complete? [swap count <=]]
    [readcount [drop
                [take] "\n" split generate
                [[drop] 4 times] dip
                [read first] bail 0 or]]]
   [[[[[generate] dive]
      [[[] [\newline contains? not]]
       [execute] every?]
      [join [generate] dive]
      prime join] 
     dip
     [swap \newline contains?] [readcount] when]
    ;[dump [generate] dive [] [join] [drop] if readcount]
    [dump complete? not]
    [[generate] divedown  swap [join] dip] prime]
   let dump cut 0 swap]
  [read first] each
  collect
#+end_src
*** CANCELED Another take on re-splitting
- State "CANCELED"   from "TODO"       [2025-03-17 Mon 18:39]
A more generic version of the re-splitter:

Take as input a buffer (probably of Bytes), and a function of that
buffer that returns 0 or more objects and a new buffer that's the same
or smaller (with parsed objects sliced out). It has additional state of a
buffer of parsed objects (used when we find say, 10 words in a single
byte chunk, if we're trying to parse words - we can't emit 10 objects
at once so we need to save the other 9).

Then the resplitting generator becomes:

- take from parent generator. If empty, emit from the object buffer (if
  any). If non-empty, join with previous byte buffer state
- run the splitter function on the byte buffer, join with previous
  object buffer state, emit one object

  #+begin_src kcats
    ["[foo] [bar] [ba" "z] [quux" "] [[this] " "[that]]" "[foo" "]"] [take] [] []
    ;; if there is already a parsed object, emit it and don't pull from the parent yet
    [[swap not] ;; nothing in output
     [ [generate] divedown join read-chunk]
     while
     [take] dive] collect
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [[foo] [bar] [baz] [quux] [[this] [that]]] [[swap not]
                                              [[generate] divedown join read-chunk] when [take] dive]
  "[foo" [] [take] ["]"]
  #+end_src

#+begin_src kcats
  [["[foo] [bar] [ba"
    "z] [quux"
    "] [[this] "
    "[that]]"
    "[foo" "]"] [take]
   [parse-edn] parse collect]
  shield
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [[foo] [bar] [baz] [quux] [[this] [that]]
   [foo]]
  #+end_src

#+begin_src kcats

  ["[foo]\n [bar] [ba" "z] [quux" "] [[this] " "[that]]" "[other" "]"] [take] [] []

  [[swap not] ;; if there's nothing in the output, 
   [[[generate] divedown ] ;;generate parent
    [[[] [swap not]] [execute] every?] ;; as long as the parent generates and there's no output
    [join read-chunk] prime
    ;; we may have bailed out of the loop either because the parent is done or there's output, see which
    [] [join read-chunk] when
   ] ;; generate until either we have output or the parent returned nothing
   ;; otherwise keep generating 
   when
   [take] dive ] collect
#+end_src

#+RESULTS:
#+begin_src kcats
[[foo] [bar] [baz] [quux] [[this] [that]]
 [other]]
[[swap not]
 [[[generate] divedown]
  [[[] [swap not]]
   [execute] every?]
  [join read-chunk]
  prime [] [join read-chunk]
  when]
 when [take] dive]
[] "" [] [take] []
#+end_src

  Now let's demonstrate with reading UTF8 bytes

  #+begin_src kcats
    ["[foo] [bar] [ba" "z] [quux" "] [[this] " "[that]]" "[foo" "]"] [take] [] []
    ;; if there is already a parsed object, emit it and don't pull from the parent yet
    [[swap not]
     [ [generate] divedown join read-chunk]
     when
     [take] dive] collect
  #+end_src

  #+begin_src kcats
    [[[104 101 108 108 111]              ;; "hello" (all ASCII)
      [228 189 160 229 165 189]          ;; "你好" (two complete Chinese chars)
      [104 105 226]                      ;; "hi" + start of "€"
      [130 172]                          ;; completion of "€"
      [240 159 145]                      ;; start of "👑"
      [145]                              ;; completion of "👑"
      [97 98 99 240]                     ;; "abc" + start of "🌈"
      [159 140 136]]                     ;; completion of "🌈"

     [#b64 "" swap [put] step] map

     [take] [parse-utf8]
     parse "" into] shield

  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "hello你好hi€👑abc🌈"
  #+end_src

  #+begin_src kcats
  #b64 "" 123 put string
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "{"
  #+end_src

  #+begin_src kcats
    "" [104 101 108 108 111] #b64 "" swap [put] step; parse-utf8
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  "" #b64 "aGni" parse-utf8
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  #b64 "4g" "hi"
  #+end_src

  #+begin_src kcats
[[["" #b64 "aGni" parse-utf8] ["hi" #b64 "4g"]]
                        [["" #b64 "aGVsbG8" parse-utf8] ["hello" #b64 ""]]]
  #+end_src

  #+RESULTS:
  #+begin_src kcats
    [parse-utf8 [[spec [[[bytes input] [sized current-output]]
                      [[bytes remaining-input] [string updated-output-sequence]]]]
               [examples [[["" #b64 "aGni" parse-utf8] ["hi" #b64 "4g"]]
                          [["" #b64 "aGVsbG8" parse-utf8] ["hello" #b64 ""]]]]]]
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [parse-utf8 [[spec [[[bytes input]
                       [sized current-output]]
                      [[bytes remaining-input]
                       [string updated-output-sequence]]]]
               [examples [[["" #b64 "aGni" parse-utf8] ["hi" #b64 "4g"]]
                          [["" #b64 "aGVsbG8" parse-utf8] ["hello" #b64 ""]]]]]]
  #+end_src
*** DONE Now that we have generic parser finish the job
- State "DONE"       from "INPROGRESS" [2025-03-17 Mon 18:38]
- State "INPROGRESS" from "TODO"       [2025-03-17 Mon 18:37]
#+begin_src kcats
     1 7 1 range  [1 🔀 inc 1 range 🎁 emit] 🚜 ▶️
     handoff ;; create a channel between two envs
     [liberator [parse-edn] "" parse collect] 
     future 
     ;; now that the receiver is active, start sending
     [🔀 [📮] 🪜 ▶️
      🗑️] ;; drop the channel to signal the other side we're done
     🪄
     📤 ;; the result of the future
#+end_src

well that's lovely we can pass serialized data through a
handoff. Let's pass it through a network pipe, in two separate processes!

the sender
#+begin_src kcats
   ;; now connect to the server and send it
   "localhost" 9998 socket
   ;; data to send
   1 200 1 range  [1 🔀 inc 1 range 🎁 emit encode] 🚜 ▶️
   [📮] 🪜 ▶️ ;; put it all into pipe
   🗑️ ;; close connection
#+end_src

#+RESULTS:
#+begin_src kcats
#+end_src

the receiver - let's make a server that runs forever accepting
connections and parsing what's sent.
#+begin_src kcats 
  "127.0.0.1" 9999 serversocket ;; listen for network connections
  liberator ;; make a generator of client connections

  [liberator ;; generator of byte array coming from client
   [string] each
   [parse-edn] "" parse
   collect emit print] ;; print out the value
  each  ;; do that all for each client connection
  ;collect
  drain ▶️ ;; drive the generator forward, dropping the connections once finished
#+end_src

More interesting would be a repl server, that maintains state in an
inner environment.

#+begin_src kcats 
  "127.0.0.1" 9999 serversocket ;; listen for network connections
  [📤]
  [👥 🎁 ;; [s] s
   [liberator ;; generator of byte array coming from client
    [string] each
    [parse-edn] "" parse [🎁] each
    [] environment ;; e parser*
    evaluator
    [[stack] 🔍] 
    each] 💉 ▶️ ;; make wrapped gen
   extractor
   [emit 🎁 "-> {}\n\n" 🔀 format encode
    ⚓ [📮] •🪄]
   each drain ▶️
   🗑️ 🗑️] ;; the parser and sockets 
  ⏳ ▶️
#+end_src

First write a repl generator: one that takes input from the parent,
calls evaluate on the environment state, yields the new env
#+begin_src kcats
    [[1 1 +] [3 3 *] [+]]
    liberator
    [] environment ; e g
    [[▶️] 🐋]
    [[program] 🔀 assign evaluate]
    [ ;🗑️
     []]
    [over] 🪆 
   [[stack] 🔍] each collect
#+end_src

#+RESULTS:
#+begin_src kcats
[[2] [9 2]
 [11]]
[[dictionary [[lingo 273_entries]
              [modules [#b64 "core"]]
              [words 273_entries]]]
 [program 🔳]
 [stack [11]]]
🔳
#+end_src

now write an adapter to make a wrapped generator a regular one:

#+begin_src kcats
  [] [[1 2 3 4 5] liberator] 💉 ▶️
  [[▶️] 💉 ▶️ 📤]
  []
  [[]]
  [🔀] 🪆 collect
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3 4 5] [🔳]
#+end_src

** DONE Time pipe
Each take from the pipe return the current unix time in ms.  Should be
a "singleton" - probably using Box::leak, so that we can insert a copy
of this pipe whenever we want and it's always a reference to the same
object. Might be an Arc for compatibility even though we don't need to
ref count. (But I suspect we don't need the Arc).

#+begin_src kcats
timestamps take
#+end_src

#+RESULTS:
: 1687273991929 [[from systemtime] [values [[type integer] [units milliseconds]]] [type out]]

** DONE stdin/stdout pipes
Should also be singleton. Should it always be a tunnel or should we
allow separate access to in or out?

#+begin_src kcats
standard "foo" bytes put
#+end_src

#+RESULTS:
: foo[[type tunnel] [peer standard]]

Stdin is not tested, since currently the interpreter reads the program
from stdin. May need to change that (read the program from filesystem
and let the program itself access stdin).
** CANCELED Pipe take outcome
- State "CANCELED"   from "TODO"       [2023-09-22 Fri 09:14] \\
  I don't think there's any glaring inconsistency here - indefinite (or
  i guess I might call them 'unsized') dispensers will dispense =nothing=
  when there's nothing left. That means that when you are using one of
  these, =nothing= is not a valid value you can use in the sequence.
  
  That means, for example, that if you wanted to print whether integers
  are odd or not, you can't quite do that. You'd need to use pairs (the
  original value and true/[] for whether it's odd).
  
  Perhaps later we can think about signaling end-of-stream out of
  band. One way to do that is to use an unhandled error value that
  unwinds the stack, and you have to recover to catch it. But that
  introduces a lot of complexity and I think it may be easier to just
  work around the fact that you can't use =nothing= in the data. It's
  possible that maybe the complexity in the out-of-band impl could be
  abstracted away, so it's worth revisiting later.
There is some inconsistency with what happens when there's nothing
left - empty lists just return nothing on take, but closed pipes
return an error. May need to resolve this inconsistency.

|               | List    | Handoff | Socket  | StaticFile |
|---------------+---------+---------+---------+------------|
| take Items    | Item    | Item    | Bytes   | Bytes      |
| take Past EOF | Nothing | Nothing | Nothing | Nothing    |
| step Past EOF | Exit    | Exit    | Exit    | Exit       |

* DONE read and emit don't have quite the same semantics        :consistency:
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2024-06-14 Fri 06:56]
read will read all the bytes and return however many objects were read.
emit will take an object and return its serialization.

There should be some way of round tripping here, maybe a word =read1= or
something that just reads one object. 

* DONE [#A] Inconsistent stack handling when encountering error :consistency:
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-05-22 Wed 09:34] \\
  I think this is complete, not aware of any more cases. Will reopen if needed
- State "INPROGRESS" from "TODO"       [2023-12-30 Sat 14:17]
Some words pop the arguments off the stack, then if an error is
encountered, throws the error without the args on the stack. Others
leave the args intact. This needs to be consistent.

I would lean towards leaving the args intact so that =retry= is easily applied.
** DONE 'read' on invalid edn consumes the string argument
- State "DONE"       from "TODO"       [2024-05-22 Wed 09:33]
It should attempt to parse before popping the item off the stack.
** DONE Division by zero consumes stack items
- State "DONE"       from "TODO"       [2024-05-22 Wed 09:34]
=5 0 /= shouldn't consume the =5= and =0= - compare to =1 "2" += behavior
(which leaves items on stack).

* DONE Inconsistent expression handling when encountering error
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2023-10-15 Sun 15:24]
- State "INPROGRESS" from "TODO"       [2023-10-15 Sun 15:20]
Some errors lose the word on which they occurred. They should be in
the expression still.

#+begin_src kcats
[[]] [foo] unwrap get
#+end_src

#+RESULTS:
#+begin_src kcats
[[type error]
 [reason "type mismatch"]
 [asked [pair]]
 [actual []]
 [unwound [get]]
 [handled true]]
#+end_src

The word =get= should still be in the =unwound= field.

I think this only works correctly when the invalid argument is caught
by spec checking and not in the actual axiom function.

#+begin_src kcats
  1 "" +
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"]
 [unwound [+]]
 [actual ""]
 [type error]
 [asked [number]]
 [handled true]]
"" 1
#+end_src

Here's an example where the spec is too permissive and the actual
function throws the error.
#+begin_src kcats
1 set
#+end_src

#+RESULTS:
#+begin_src kcats
[[reason "type mismatch"]
 [type error]
 [asked [sized]]
 [unwound [set]]
 [actual 1]
 [handled true]]
#+end_src

The question then is how to fix this? Hopefully this can be fixed
inside =eval_step=. After the function completes, we can check if there
was an error on top (if there wasn't before), and if so, we can replace the 

* DONE Implement sorting                                             :stdlib:
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-05-22 Wed 09:51]
** DONE Implement partialord
- State "DONE"       from "TODO"       [2024-05-22 Wed 09:50]
Each type needs to be comparable to another.

#+begin_src kcats
  [["b" 2]["g" 5]["a", 1]["d" 4] ["c" 3]] association sort-indexed
#+end_src

#+RESULTS:
: [1 2 3 4 5]

#+begin_src kcats
  [-2 10 -8 -12 8 0 1 20]
  [5 - abs]
  [clone] swap join
  [ pair] join
  map  sort-indexed 
#+end_src

#+RESULTS:
: Pair is (Int(-2), Int(7))
: Pair is (Int(10), Int(5))
: Pair is (Int(-8), Int(13))
: Pair is (Int(-12), Int(17))
: Pair is (Int(8), Int(3))
: Pair is (Int(0), Int(5))
: Pair is (Int(1), Int(4))
: Pair is (Int(20), Int(15))
: [8 1 10 0 -2 -8 20 -12]

UHOH
#+begin_src kcats
  ["hi" "there" "what" "is" "your" "birthdate" "homeboy"]
  []
  [clone] swap join
  [pair] join
  map  sort-indexed 
#+end_src

#+RESULTS:
: Pair is (Iterable(Sized(String("hi"))), String("hi"))
: Pair is (Iterable(Sized(String("there"))), String("there"))
: Pair is (Iterable(Sized(String("what"))), String("what"))
: Pair is (Iterable(Sized(String("is"))), String("is"))
: Pair is (Iterable(Sized(String("your"))), String("your"))
: Pair is (Iterable(Sized(String("birthdate"))), String("birthdate"))
: Pair is (Iterable(Sized(String("homeboy"))), String("homeboy"))
: ["birthdate" "hi" "homeboy" "is" "there" "what" "your"]

#+begin_src kcats
8 5 - 
#+end_src

#+RESULTS:
: 3

#+begin_src kcats
1 2 [inc] both
#+end_src

#+RESULTS:
#+begin_src kcats
3 2
#+end_src

** DONE Implement compare
- State "DONE"       from "TODO"       [2024-05-22 Wed 09:39]
Should expose Rust's comparison function. That will allow a native
sort function, for max flexibility (but not performance).

#+begin_src kcats
  "a" "b" compare
#+end_src

#+RESULTS:
#+begin_src kcats
less
#+end_src

#+begin_src kcats
"a" "a" compare
#+end_src

#+RESULTS:
: equal

#+begin_src kcats
["a" "b"] ["a" "c"] compare
#+end_src

#+RESULTS:
: less

#+begin_src kcats
"foo" encode [1] compare
#+end_src

#+RESULTS:
#+begin_src kcats
less
#+end_src

This should work - the empty set and map maybe can't be compared but Nothing should be in there.
#+begin_src kcats
[] -1000 compare
#+end_src

#+RESULTS:
#+begin_src kcats
greater
#+end_src

=<= in terms of compare?
#+begin_src kcats
  "foo" "bar" compare [greater] 🍫 =
#+end_src

#+RESULTS:
#+begin_src kcats
✅
#+end_src


* DONE Stream transformation
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2025-03-19 Wed 16:29]
Problem: kcats doesn't speak http or https or various other protocols
and formats, but rust does. We want to be able to use the complicated
bits of rust, but let kcats decide how to combine them.

Implementation: I think we may need to create a new Rust enum Item
type, that acts as a generator. It has an input method "next_input"
that takes an input chunk which is the result of the generator
beneath, then it either returns None (updated the state, but no new
item yet), or Item (got a new item), or some signal for end of stream,
or Error. So it would have some program with a while loop to
iterate. All such transforms would probably have the same program.

I think what I am getting at here is that Items should implement Rust
traits where possible, eg Read/Write for file and network pipes.

* CANCELED Words that quote programs instead of executing them
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2024-05-22 Wed 19:58] \\
  I don't think there's really any good fix for this.

  For example 'partition' that needs to insert some state before the
  generator. The generator doesn't actually include that state but it
  needs to be there. So the quoted program is needed.
eg =liberate= - it is just =[take]=, so it doesn't actually do anything by
itself. It seems like the quotedness should remain and maybe the word
should always perform the action.

In that case we would have to write =5 [taker]=. I'm not thrilled with
that either, but maybe it's just not a good name.

It does seem like there's an inconsistency having a word quote a
program instead of the caller doing it.

There are certainly words that operate on programs without executing
them (like =each= which just modifies the mapping function to call the
generator below it, it doesn't add an entirely new generator to the
stack) but the word is still executing a program vs just
self-inserting one object.

So I think I do have to fix this. I'm just not sure what to do.

I think it will *look* inconsistent to write:
#+begin_src kcats
  integers
  5 [taker]
  [inc] each
#+end_src
People will see that and wonder why =taker= is quoted but not =each=. It
makes sense when you dive into it.

Isn't this just an implementation detail? In theory =each= could be a
separate generator and honestly it probably should be.
** TODO Get rid of self-inserting programs (esp with generators)
Problem: words like =joiner= and =taker= don't do anything except insert a
program. That, i think, should be an anti-pattern in kcats. If you
want to put a program on the stack succintly,then define a word that
does what you want, and quote that word.

For example, some complex function =foo=, if you want a program on the
stack that does what foo does, use =[foo]=. =foo= itself should perform the action.

There's some confusion because =each= does perform an action: it
modifies the program already on the stack. So you would write =5 [taker]= but =[inc] each=.

One issue is with something like =partition= where there's boilerplate initial state
that needs to go on the stack before the generator program. With =taker=
the user provides the initial state because we don't know what it is in advance.

#+begin_src kcats
  [a b c d e] [take] 2 2 partition generate
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [taker]]
 [handled yes]
 [reason "word is not defined"]
 [type error]
 [unwound [taker collect dropdown dropdown [2] unwrap [2] unwrap float [[]] unwrap
           swap swap drop shift]]]
[[[dictionary dictionary_redacted]
  [program [[] [over wrap take-chunk [join shift]
                bail]
            [[over] dive wrap take-chunk swap drop shift]
            if]]
  [resolver [#b64 "yO3LwN0ITlhqAj8T1IKcUqNoiQmEAyrBwbFpGixDtQ8="]]]
 [stack] [snapshot] divedown assign environment evaluate [stack] lookup restore]
2 [take] [a b c d e]
#+end_src

It's possible for partition to check if the state is present and
create it (since the state is always a list and otherwise it would see
a number). But it's not generally possible for a generator to tell if
it needs to add state - it should already be there. So if we're just
quoting the generator, then what will add it?

Self-insert: can insert 

* CANCELED run multiple programs on same argument to get list
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2024-05-22 Wed 09:43] \\
  I think this is clear enough, no new word needed
#+begin_src kcats
  5 2 [[+] [*]] [execute] map
#+end_src

#+RESULTS:
#+begin_src kcats
[7 10]
2 5
#+end_src


* DONE Non-generator filter
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-05-22 Wed 09:43]
- State "INPROGRESS" from "TODO"       [2024-02-04 Sun 13:50]
map now doesn't require you to bind values (the map function has access to the rest of the stack).
 Do the same for =filter=.

 #+begin_src kcats
   5 [1 2 3 4] [+ odd?]
   [] sink ;; put empty results below list
   [shield dip] decorate ;; run map fn shielded and dipped under result
   [swap] unwrap prepend ;; start by swapping the result back to the top
   [ swap [] [drop swap put] [drop dropdown] if] join ;; end by checking pred, add to result
   step
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [2 4]
 5
 #+end_src


* DONE Make templating a rust function
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2024-08-08 Thu 15:37]
- State "INPROGRESS" from "TODO"       [2024-08-08 Thu 15:36]
Templating is important enough to make it a rust function. No kcats
programs need to be called during the execution of templating so I
think it's easily done in rust. Then that solves the chicken/egg
problem where other stuff depends on template but template depends on
it. 

* DONE Change yes to nonempty container
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2024-12-03 Tue 19:21]
Using some neutral "thing" emoji like:
🔘 or ⚪️ or 🎯 or 🔹 

#+begin_src kcats
[pred] -> [🔘]  ; "container has something"
       -> []    ; "container is empty"
#+end_src

The beauty is:
1. The emoji reinforces that the actual value doesn't matter
2. It's just a token to make the container non-empty
3. Users don't need to remember what it is
4. Visually distinct from actual data values

 So predicates become:
#+begin_src kcats
[even?]    ; Returns [🔘] or []
[any?]     ; Returns [🔘] or []
[empty?]   ; Returns [🔘] or []

#+end_src
This feels more "honest" than:

#+begin_src kcats
[yes]      ; Why yes specifically?
[thing]    ; Still feels like it should mean something
#+end_src

Can also add words =anything= and =nothing= as aliases for these, that we
can use in default branch for =decide= and other places.

Also consider ✅ for 'yes'

* DONE Combinators
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-03-19 Wed 16:28]
- State "INPROGRESS" from "TODO"       [2024-11-13 Wed 09:11]

** DONE Discussion
- State "DONE"       from "TODO"       [2025-03-19 Wed 16:28]
Let's think about what the language would look like if combinators
that take programs didn't actually execute them but rather spit out
new programs. Here's =looped=:

#+begin_src kcats
  [[looped [[[*1 execute
              *1 looped execute]
             []
             branch]
            pack]]]
  [10 yes [-2 * clone 50 <] looped execute]
  let execute 
#+end_src

#+RESULTS:
#+begin_src kcats
160
#+end_src

step

#+begin_src kcats
  [[dipped [wrap [dip] join]]
   [stepped [[clone [take swap 
                     *1 dip
                     *1 stepped execute] [drop] branch]
             pack]]]
  [0 [1 2 3 4] [+] stepped]
  let execute 
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual evert]
 [asked [sized?]]
 [handled []]
 [reason "type mismatch"]
 [type error]
 [unwound [update [dictionary program]
           label environment [*1 capture evaluate [stack] lookup restore] pack execute]]]
[[[[clone [take swap [swap [[[1] [entry] update] shielddown]
                      dip swap put]
           dip [swap [[[1] [entry] update] shielddown]
                dip swap put]
           step execute]
    [drop] branch]
   join]
  [[modules []]
   [words 205_entries]]
  [[dipped [wrap [dip] join]]
   [stepped [[clone [take swap *1 dip *1 stepped execute]
              [drop] branch]
             pack]]]
  []]
 put]
[modules] evert [0 [1 2 3 4] [+] stepped] evert [[clone [take swap [swap [[[1] [entry]
                                                                           update]
                                                                          shielddown]
                                                                    dip swap put]
                                                         dip [swap [[[1] [entry] update] shielddown]
                                                              dip swap put]
                                                         step execute]
                                                  [drop] branch]
                                                 join]
[[modules []]
 [words 205_entries]]
[[dipped [wrap [dip] join]]
 [stepped [[clone [take swap *1 dip *1 stepped execute]
            [drop] branch]
           pack]]]
[]
#+end_src



Here's some more 
#+begin_src kcats :preserve-indent t
  [[dipped [wrap [dip] join]]
   [stepped [[👥 [take swap 
                     ,*1 dip
                     ,*1 stepped ▶️] [drop] branch]
             pack]]
   [💉 [dipped [evert **1 evert] pack]]
   [🛡️ [💉 [snapshot **1 first] pack]]
   [iffed [[**3 ;; the condition
            ,*2 *1 branch] pack]]
   [looped [[[**1
              ,*1 looped ▶️]
             []
             branch]
            pack]]
   [⏳ [[*2 ;; run conditional
             [**1 ;; run body
              ,*2 *1 ⏳ ;; next iteration
              ▶️]
             []] ;; do nothing if condition is false
            pack unwrap iffed]]]
   ;[2 3 [dropdown odd?] shielded ["odd"] ["even"] iffed]
   ;[3 [+] dipped 4 5 float execute]
   ;[1 2 [10 3 4 5] [* +] injection execute]
   ;[1 2 3 [dropdown *] shielded]
    [0 [2 3 4 5] [+] stepped execute]
   ;[5 [0 >] 🛡️
   ; [👥 dec] ⏳ ▶️]
   let ▶️
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual evert]
 [asked [sized?]]
 [handled []]
 [reason "type mismatch"]
 [type error]
 [unwound [update [dictionary program]
           label environment [*1 capture evaluate [stack] lookup restore] pack ▶️]]]
[[[[clone [take swap [swap [[[1] [entry] update] shielddown]
                      dip swap put]
           dip [swap [[[1] [entry] update] shielddown]
                dip swap put]
           step execute]
    [drop] branch]
   join]
  [[modules []]
   [words 205_entries]]
  [[dipped [wrap [dip] join]]
   [stepped [[👥 [take swap *1 dip *1 stepped ▶️]
              [drop] branch]
             pack]]
   [💉 [dipped [evert **1 evert] pack]]
   [🛡️ [💉 [snapshot **1 first] pack]]
   [iffed [[**3 *2 *1 branch] pack]]
   [looped [[[**1 *1 looped ▶️] [] branch] pack]]
   [⏳ [[*2 [**1 *2 *1 ⏳ ▶️] []] pack unwrap iffed]]]
  []]
 put]
[modules] evert [0 [2 3 4 5] [+] stepped execute] evert [[clone [take swap [swap
                                                                            [[[1] [entry] update] shielddown]
                                                                            dip swap put]
                                                                 dip [swap [[[1] [entry] update] shielddown]
                                                                      dip swap put]
                                                                 step execute]
                                                          [drop] branch]
                                                         join]
[[modules []]
 [words 205_entries]]
[[dipped [wrap [dip] join]]
 [stepped [[👥 [take swap *1 dip *1 stepped ▶️]
            [drop] branch]
           pack]]
 [💉 [dipped [evert **1 evert] pack]]
 [🛡️ [💉 [snapshot **1 first] pack]]
 [iffed [[**3 *2 *1 branch] pack]]
 [looped [[[**1 *1 looped ▶️] [] branch] pack]]
 [⏳ [[*2 [**1 *2 *1 ⏳ ▶️] []] pack unwrap iffed]]]
[]
#+end_src

#+begin_src kcats
  1 [2 3 4] [+]
             [ [take swap *1 dip *1 stepped ▶️]
            [] branch] 
           pack execute
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [stepped]]
 [handled []]
 [reason "word is not defined"]
 [type error]
 [unwound [stepped ▶️]]]
[+] [3 4]
3
#+end_src

#+RESULTS:
#+begin_src kcats
1 [2 3 4] [[drop take swap [+] dip [+] stepped ▶️]
           [] branch]
#+end_src


** DONE Update branch behavior to keep conditional
- State "DONE"       from "INPROGRESS" [2024-11-16 Sat 18:52]
- State "INPROGRESS" from "TODO"       [2024-11-13 Wed 12:21]
Currently =branch= discards the value it uses to choose a program to
run. But sometimes the program needs it. The false branch basically
never needs it so maybe we could auto-discard it. AI says that's weird
but I think it's better than having to prepend 'drop' to at least half
the programs.

try 'bail' impl
#+begin_src kcats
  3
  [1 <=] shield
  [] [clone dec] [execute *]
  recur execute
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual [3
                     [1 <=] shield
                     [] [clone dec] [execute *]
                     recur][snapshot evert [1 <=]
          dip evert first [] [clone dec [[snapshot evert [1 <=]
                                          dip evert first]
                                         [] [clone dec]
                                         [execute *]
                                         recur]
                              execute *]
          branch]]
 [asked [number?]]
 [handled []]
 [reason "type mismatch"]
 [type error]
 [unwound [*]]]
[snapshot evert [1 <=]
 dip evert first [] [clone dec [[snapshot evert [1 <=]
                                 dip evert first]
                                [] [clone dec]
                                [execute *]
                                recur]
                     execute *]
 branch]
2 3
#+end_src
#+begin_src kcats
  [[a 1] [b 2]] [b] [inc] shielddown
  [lookup] shield dip execute assign
#+end_src

#+RESULTS:
#+begin_src kcats
[[a 1]
 [b 3]]
#+end_src

recur
#+begin_src kcats
  3
  [1 <=] shield
  [drop] [clone dec] [execute *]
  ;[**2 [*4 *3 *2 *1  recur execute] **1] [pack] shielddeep execute  dropdown if execute 
  recur  execute
#+end_src

#+RESULTS:
#+begin_src kcats
6
#+end_src

decide(r)
#+begin_src kcats
    6 [[even?] []]
    take
    [unwrap ;; break up the pair
     swap 
     shield
     ;; recur 
     flip [*1 decide] pack if execute]
    [drop]
    branch
  ;  [[]] or ;; return a program that returns nothing
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual even?]
 [asked [program?]]
 [handled []]
 [reason "type mismatch"]
 [type error]
 [unwound [if execute]]]
[6 decide]
even? [snapshot evert [[]] dip evert first]
#+end_src

#+begin_src kcats
  words [decide definition] lookup

#+end_src

#+RESULTS:
#+begin_src kcats
[take [unwrap swap shield flip [*1 decide]
       pack if execute]
 bail [[]] or]
#+end_src

flatten
#+begin_src kcats
[a b [c [d e] f] g] [] swap [list? not] shield [drop put] [] [step execute] recur execute
#+end_src

#+RESULTS:
#+begin_src kcats
[a b c d e f g]
#+end_src

#+begin_src kcats
[1 2 [3 [4 5] 6]] [inc wrap] 
  [list? not] shield swap
                        [[] swap]
                        [[join] join step execute wrap]
                        recur ;execute unwrap
#+end_src

#+RESULTS:
#+begin_src kcats
[snapshot evert [list? not]
 dip evert first [inc wrap]
 [[] swap [[snapshot evert [list? not]
            dip evert first]
           [inc wrap]
           [[] swap]
           [[join] join step execute wrap] recur execute]
  [join] join step execute wrap]
 branch]
[1 2 [3 [4 5]
      6]]
#+end_src

#+begin_src kcats
    [1 2 [3 [4 5] 6]] [inc wrap]
    [drop **1] pack 
    [list? not] shield swap
    [[] swap]
    [[join] join step execute wrap]
    recur execute unwrap
#+end_src

#+RESULTS:
#+begin_src kcats
[2 3 [4 [5 6]
      7]]
#+end_src

map
#+begin_src kcats
  [dropdown 5 + +] 

  [[swap *1 shielddown dip swap put] step
   [] sink ;; put empty results below list
   execute] pack

  [12 13 [1 2 3 4]] dip
  execute
#+end_src

#+RESULTS:
#+begin_src kcats
[18 19 20 21] 13 12
#+end_src

filter
#+begin_src kcats
   [1 2 3 4] [odd?]

   [[*1 shield
      [drop swap put] [drop dropdown]
      if step] [] sink execute]  
   pack
   execute
#+end_src

#+RESULTS:
#+begin_src kcats
[[take swap [snapshot evert [odd?] dip evert first [drop swap put] [drop dropdown]
             branch]
  dip [snapshot evert [odd?] dip evert first [drop swap put] [drop dropdown]
       branch]
  step execute]
 [] branch]
[1 2 3 4] []
#+end_src

#+RESULTS:
#+begin_src kcats
       [1 2 3 4] [odd?]
       shield ;; run the predicate with no stack effect
       [drop put] [drop] if ;; if match, drop the pred result and put the original item.

       step
       [*1 [] sink execute] ;; place the empty result container beneath
       pack execute

#+end_src

#+RESULTS:
#+begin_src kcats
[1 3]
#+end_src

#+begin_src kcats
  [1 2 3 4] [odd?] [[shield [drop put] [drop]
    if step] [] sink execute] execute execute
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3 4]
#+end_src



fix step to not literally clone
#+begin_src kcats
  0 [1 23 4 5] [+] [[take swap 
                        ,*1 clone dipdown
                        step execute]
                       [] branch]
                      pack execute
#+end_src

#+RESULTS:
#+begin_src kcats
33
#+end_src

#+begin_src kcats
["hi"] 5 [*1 [positive?] shield [drop dec [*2 clone dip] dip times execute] [drop] if execute] pack 
#+end_src

#+RESULTS:
#+begin_src kcats
[5 [positive?] shield [drop dec [["hi"] clone dip] dip times execute] [drop] if execute]
#+end_src

prime

#+begin_src kcats
  [1 2 3 4 5] [take] [4 mod 0 = not] shield [drop] ;prime
  [clone [drop **1] pack] divedown swap join while join execute
  
  ;[*3 clone *1 swap join *2 swap while] pack execute
  ;[[clone [execute] dip] divedown join while] pack
  ;[clone [execute] dip] divedown  join  while 
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual 1]
 [asked [dispenser?]]
 [handled []]
 [reason "type mismatch"]
 [type error]
 [unwound [take drop [snapshot evert [4 mod 0 = not] dip evert first] [drop take
                                                                       drop]
           while execute]]]
1 [2 3 4 5]
#+end_src

maybe we don't need prime?
#+begin_src kcats
0 [1 2 3 4] [take] [swap [+] dip] while execute
#+end_src

#+RESULTS:
#+begin_src kcats
[] 10
#+end_src

redefine while in terms of recur?

#+begin_src kcats
3 [0 >] shield [drop clone dec] [] [execute] recur execute
#+end_src

#+RESULTS:
#+begin_src kcats
0 1 2 3
#+end_src

** CANCELED Update generators to compose more naturally
- State "CANCELED"   from "INPROGRESS" [2025-03-19 Wed 16:28]
- State "INPROGRESS" from "TODO"       [2024-11-16 Sat 18:52]

 The problem previously was that generators left a bunch of machinery
  on the stack. I think we can compose them via wrapping. I think we
  could have done that before. The challenge is figuring out how to
  keep state inside the program and only putting it onto the stack
  when needed.

  We have a program that produces a value like =[take]= but it's not a
  generator. To be a generator it needs to run itself and leave a copy
  of itself below the produced item. So we can write 'generator', so that you only need to 'execute' the generator:

 #+begin_src kcats
   [1 11 23 4 5 6 7]
   [📤] ⬜ ⬜ [🔀] 🪆 ;; take from the source, swap the recurring
                      ;;program beneath the value, if empty do nothing
   ;; increment each
   [👥 *] •🛡️ [*2 bail **1] pack []
   ;[▶️] 🔀
    [⬜] [🔀] 🪆 ;; execute the generator below. If we get a value,
                         ;; execute the provided program on that value 

   ;; keep odd values
   [odd?]
   ;; build the conditional for recurrence
   [[▶️ ;; execute the generator below to get value v
     [*1 🛡️ ▶️ ☯️] ;; check if v does NOT match given pred, 
     [⬜ ⬜] ;; if generator below is finished, return 2 empty values 
     ↔️]
    [🗑️ 🗑️] ;; drop both the value v and the result of pred
    ⏳ ▶️] ;; repeat until generator below is finished
   pack
   ⬜ [⬜] [🔀] 🪆 ;; drop non-matching values in a while loop
                   ;; then emit a matching value
   ;; collect
   ⬜ [[▶️] 🐋] [📮] ⬜ [▶️] 🪆 ;; place an empty container for results,
   ;; then execute the generator below.
   ;;If we get a value, place it in the container
   ;;and recur, otherwise stop.
   ▶️ ;; execute the whole thing
   ;; result => [5 7]

   ; [1 11 23 4 5 6 7]
   ; liberate
   ; [inc] each
   ; [odd?] keep
   ; collect
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [[actual [📤]]
  [asked [number?]]
  [handled []]
  [reason "type mismatch"]
  [type error]
  [unwound [* [[📤] [[📤] [] [] [🔀] recur execute] [[] [] [🔀] recur execute] [11 23
                                                                            4 5 6 7]] evert dropdown first [[[[📤 [[[📤] [] [] [🔀] recur execute] 🔀]
                                                                                                               [] branch]
                                                                                                              bail snapshot evert [👥 *]
                                                                                                              dip evert dropdown first]
                                                                                                             [] [⬜] [🔀] recur execute]
                                                                                                            🔀]
            [⬜] branch [[odd?] 🛡️ ▶️ ☯️] [⬜ ⬜]
            ↔️ [🗑️ 🗑️ [[▶️ [[odd?] 🛡️ ▶️ ☯️] [⬜ ⬜]
                        ↔️]
                       [🗑️ 🗑️]
                       [] [execute] recur execute]
                execute]
            [] branch [[[[▶️ [[odd?] 🛡️ ▶️ ☯️] [⬜ ⬜]
                          ↔️]
                         [🗑️ 🗑️]
                         ⏳ ▶️]
                        [] [⬜] [🔀] recur execute]
                       🔀]
            [⬜] branch [1] swap [📮 [[[▶️] 🐋]
                                    [📮] [] [▶️] recur execute]
                                 ▶️]

            [] branch]]]
 [📤] [📤] [[📤] [] [] [🔀] recur execute] [[] [] [🔀] recur execute] [11 23 4 5 6 7]
 #+end_src

 below is a version of 'each' that wraps the previous generator (needs
  that dropdeep, not sure why - something to do with the inner
  recurrence replacing itself AND the outer recurrence also replacing
  the inner recurrence along with the outer.

  The solution is to separate the "produce a value" eg =[take]=, from a
  generator (which both produces a value AND sets itself up to be
  called again). The =recur= is a generator, but you don't want to wrap
  a generator with a generator. You want to wrap a *producer* with a
  generator - the generator should be the final bit added, I suppose
  at consumption time? But then once you've made the generator you
  can't add more layers?
 #+begin_src kcats
   [1 11 23 4 5 6 7]
   [📤]; ⬜ ⬜ [🔀] 🪆 ;; take from the source, swap the recurring
   ;;program beneath the value, if empty do nothing
   ;; increment each
   [👥 *] •🛡️ [**2 *1 bail] pack ;[] [⬜] [🔀 ] 🪆 ;; execute the generator below. If we get a value,
   ;execute drop execute
   ;; execute the provided program on that value
    [*1 🐋] pack [] swap  [📮] ⬜ [ ▶️] 🪆 execute
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [1 121 529 16 25 36 49]
 []
 #+end_src

 I don't think this actually works because generators like =keep= need
 to call their parents multiple times. So the generation logic is needed

 #+begin_src kcats
   0 100 1 range
   [📤] 🔳 🔳 [🔀] 🪆 ;; take from the source, swap the recurring
   ;;program beneath the value, if empty do nothing

   ;; increment each
   [👥 *] •🛡️ [**2 *1 bail] 🎒
   [•🗑️] [🔳] [🔀] 🪆 ;; execute the generator below. If we get a value,
   ;; execute the provided program on that value, dropping the parent generator

   [7 mod 0 =]
   ;; build the conditional for recurrence
   [[**2 ;; execute the generator below to get value v
     [*1 🛡️ ▶️ ☯️] ;; check if v does NOT match given pred, 
     [🔳 🔳] ;; if generator below is finished, return 2 empty values 
     ↔️]
    [🗑️ 🗑️] ;; drop both the value v and the result of pred
    ⏳ ▶️] ;; repeat until generator below is finished
   🎒
   [•🗑️] [🔳] [🔀] 🪆 ;; drop non-matching values in a while loop
   ;; then emit a matching value

   ;🔳 [[*1 🐋] 🎒] 🪄 🔀 [📮] 🔳 [▶️] 🪆  ▶️
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [[actual [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
            [] branch [snapshot evert [👥 *]
                       dip evert dropdown first]
            bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                        [] branch [snapshot evert [👥 *]
                                   dip evert dropdown first]
                        bail]
                       [•🗑️] [[]] [🔀] recur ▶️]
                  🔀]
            [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
            ↔️]
           [🗑️ 🗑️]
           ⏳ ▶️]]
  [asked [number?]]
  [handled []]
  [reason "type mismatch"]
  [type error]
  [unwound [* [[[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                 [] branch [snapshot evert [👥 *]
                            dip evert dropdown first]
                 bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                             [] branch [snapshot evert [👥 *]
                                        dip evert dropdown first]
                             bail]
                            [•🗑️] [[]] [🔀] recur ▶️]
                       🔀]
                 [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
                 ↔️]
                [🗑️ 🗑️]
                ⏳ ▶️]
               [[📤] [] [] [🔀] recur ▶️] [[•🗑️] [[]] [🔀] recur ▶️] [1 2 3 4 5 6 7 8 9 10 11 12 13
                                                                   14 15 16 17 18 19 20
                                                                   21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
                                                                   41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
                                                                   61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
                                                                   81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]]
            evert dropdown first [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                        [] branch [snapshot evert [👥 *]
                                                   dip evert dropdown first]
                                        bail]
                                       [•🗑️] [[]] [🔀] recur ▶️]
                                  🔀]
            [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
            ↔️ [🗑️ 🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                        [] branch [snapshot evert [👥 *]
                                   dip evert dropdown first]
                        bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                    [] branch [snapshot evert [👥 *]
                                               dip evert dropdown first]
                                    bail]
                                   [•🗑️] [[]] [🔀] recur ▶️]
                              🔀]
                        [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
                        ↔️]
                       [🗑️ 🗑️]
                       [] [▶️] recur ▶️]
                ▶️]
            [] branch [•🗑️ [[[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                              [] branch [snapshot evert [👥 *]
                                         dip evert dropdown first]
                              bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                          [] branch [snapshot evert [👥 *]
                                                     dip evert dropdown first]
                                          bail]
                                         [•🗑️] [[]] [🔀] recur ▶️]
                                    🔀]
                              [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
                              ↔️]
                             [🗑️ 🗑️]
                             ⏳ ▶️]
                            [•🗑️] [[]] [🔀] recur ▶️]
                       🔀]
            [[]] branch [0] swap [📮 [[[[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                        [] branch [snapshot evert [👥 *]
                                                   dip evert dropdown first]
                                        bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                                    [] branch [snapshot evert [👥 *]
                                                               dip evert dropdown first]
                                                    bail]
                                                   [•🗑️] [[]] [🔀] recur ▶️]
                                              🔀]
                                        [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
                                        ↔️]
                                       [🗑️ 🗑️]
                                       ⏳ ▶️ [•🗑️ [[[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                                    [] branch [snapshot evert [👥 *]
                                                               dip evert dropdown first]
                                                    bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
                                                                [] branch [snapshot evert [👥 *]
                                                                           dip evert dropdown first]
                                                                bail]
                                                               [•🗑️] [[]] [🔀] recur ▶️]
                                                          🔀]
                                                    [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
                                                    ↔️]
                                                   [🗑️ 🗑️]
                                                   ⏳ ▶️]
                                                  [•🗑️] [[]] [🔀] recur ▶️]
                                             🔀]
                                       [[]] branch]
                                      🐋]
                                     [📮] [] [▶️] recur ▶️]
                                  ▶️]

            [] branch]]]
 [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
   [] branch [snapshot evert [👥 *]
              dip evert dropdown first]
   bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
               [] branch [snapshot evert [👥 *]
                          dip evert dropdown first]
               bail]
              [•🗑️] [[]] [🔀] recur ▶️]
         🔀]
   [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
   ↔️]
  [🗑️ 🗑️]
  ⏳ ▶️]
 [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
   [] branch [snapshot evert [👥 *]
              dip evert dropdown first]
   bail [•🗑️ [[📤 [[[📤] [] [] [🔀] recur ▶️] 🔀]
               [] branch [snapshot evert [👥 *]
                          dip evert dropdown first]
               bail]
              [•🗑️] [[]] [🔀] recur ▶️]
         🔀]
   [[]] branch [[7 mod 0 =] 🛡️ ▶️ ☯️] [[] []]
   ↔️]
  [🗑️ 🗑️]
  ⏳ ▶️]
 [[📤] [] [] [🔀] recur ▶️] [[•🗑️] [[]] [🔀] recur ▶️] [1 2 3 4 5 6 7 8 9 10 11 12 13
                                                     14 15 16 17 18 19 20
                                                     21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
                                                     41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
                                                     61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
                                                     81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
 #+end_src

 #+begin_src kcats
   1 100 1 range
   liberate
   [👥 *] each
   [7 mod 0 =] keep
   collect
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [49 196 441 784 1225 1764 2401 3136 3969 4900 5929 7056 8281 9604]
 #+end_src

 work on keep to wrap previous
 #+begin_src kcats
   1 100 1 range liberate
   [ 7 mod 0 =]
   ;; build the conditional for recurrence
   [*2
    [▶️ ;; execute the generator below to get value v
     [*1 🛡️ ▶️ ☯️] ;; check if v does NOT match given pred, 
     [🔳 🔳] ;; if generator below is finished, return 2 empty values 
     ↔️]
    [🗑️ 🗑️] ;; drop both the value v and the result of pred
    ⏳ ▶️ ] ;; repeat until generator below is finished
   🎒
   [•🗑️] [🔳] [ 🔀] 🪆 ;; drop non-matching values in a while loop
   ;; then emit a matching value
   🔳 [[ 🐋] 🎒 ] 🪄 🔀 [📮 •🗑️] 🔳 [▶️] 🪆  ▶️ 
 #+end_src

 #+RESULTS:
 #+begin_src kcats
 [7 14 21 28 35 42 49 56 63 70 77 84 91 98]
 #+end_src

 
** DONE Fix recur logic
- State "DONE"       from "TODO"       [2024-11-17 Sun 19:37]
The branches are backward, should match =while=, with the loop body
being first. Currently recur has the exit branch first and the main
body 2nd.

#+begin_src kcats
  5
  [2 >] shield
  [drop clone dec dump] [] [execute *]
  [**3 [*4 *3 *2 *1 recur execute] **1] [pack]
  shielddeep execute dropdeep swap if execute
#+end_src

#+RESULTS:
#+begin_src kcats
[4 5]
[3 4 5]
[2 3 4 5]
120
#+end_src

#+begin_src kcats
[pred] [then] [else] [combo] [*3 clone [execute] dip []  ] 
#+end_src

** DONE Every
- State "DONE"       from "INPROGRESS" [2024-11-23 Sat 19:56]
- State "INPROGRESS" from "TODO"       [2024-11-23 Sat 11:02]
  two booleans: all matching so far?
   is there any more numbers?
#+begin_src kcats
  ;11 [2 4 6] [+ odd?] •🛡️
  12 [[ even?] [positive?] [3 mod 0 =]] [▶️] •🛡️
   [[📤 🔀 1️⃣ 🐋 👥] ;; more items
    [[] ✅ []] ;; empty list, return ✅
    ↔️] 🎒
   [🗑️ 🗑️]
   [•🗑️]
   [▶️] 🪆 ▶️  
#+end_src

#+RESULTS:
#+begin_src kcats
✅ 12
#+end_src

** DONE Recover
- State "DONE"       from "INPROGRESS" [2025-03-19 Wed 16:27]
- State "INPROGRESS" from "TODO"       [2024-11-23 Sat 19:56]

  #+begin_src kcats
     1 [+] [🗑️ 2 +]
    [[snapshot] 🐋
    🔀 [handle] 🔗 💉 ▶️ 
    [first error?] 🛡️
    [🗑️ ✂️1️⃣]
    [evert 🗑️]
    ⚖️ ▶️] 🎒 ▶️ 


    ;[[[✂️1️⃣ handle] 🎒] 🪄 ;; add handle to the end of test
    ;[snapshot] •🪄 ;; rec test ss
    ;sink inject ▶️ ;; res rec
    ;first error?] 🛡️  ;; err? res rec
    ;[🗑️ •🗑️ 🔀 ▶️];; drop the snapshot and run recovery
    ;[evert 🗑️] ;; use snapshot as stack
    ;if ▶️ 
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  3
  #+end_src

  #+begin_src kcats
    [1 2 "oh fudge"]
    [5 +]
    [🗑️ 5]
    [[📸] 🐋
     🔀 [handle] 🔗 💉 ▶️ 
     [first error?] 🛡️
     [🗑️ ✂️1️⃣]
     [evert 🗑️]
     ⚖️ ▶️] 🎒 [🎁] 🪄 🔗 🚜 ▶️

  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [6 7 5]
  #+end_src

* DONE Support 'doc' field of dictionary entries
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2024-12-03 Tue 19:08]

* DONE Back to stacking generators with optional encapsulation
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-03-19 Wed 16:27]
- State "INPROGRESS" from "TODO"       [2024-12-11 Wed 20:12]
** INPROGRESS See if we can wrap state with generator

- State "INPROGRESS" from "TODO"       [2024-12-11 Wed 20:12]
The fact that there's leftover state even after a generator is done,
seems wrong. We should get rid of both.

#+begin_src kcats
  [1 2 3 4 5] liberator 5
  [[[positive?] 🛡️ [🗑️ 1️⃣ 🐋] [🔳] ⚖️ ▶️] 🎒]
  🐋 [[dec •🗑️]
      🪄]
  [🗑️ 🗑️ 🔳]
  [🔀] 🪆

  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3 4 5]
#+end_src

I think a good approach here may be to use evert/inject. So instead of
just stacking generators right on top of the stack, wrap it in a list,
and inject to generate a value, then take to extract:

#+begin_src kcats
  []  [[1 2 3 4 5] liberator [👥 *] each collect] 💉 ▶️
  [▶️] 💉 ▶️ 📤
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [consume]]
 [handled 🔳]
 [reason "not enough items on stack"]
 [type error]
 [unwound [🔀 [[📸 🧦 [👥 *]
               🪄 🧦 •🗑️ first]
              bail]
           🪄 🔀 [•🗑️ [[📤 [[[📤] 🔳 🔳 [🔀] 🪆 ▶️] 🔀]
                      🔳 ↔️ 🔀 [[📸 🧦 [👥 *]
                               🪄 🧦 •🗑️ first]
                              bail]
                      🪄 🔀]
                     [•🗑️] [🔳] [🔀] 🪆 ▶️]
                🔀]
           [🔳] ↔️ [1 4 9 16 25] 🔀 [📮 •🗑️ [[[📤 [[[📤] 🔳 🔳 [🔀] 🪆 ▶️] 🔀]
                                            🔳 ↔️ 🔀 [[📸 🧦 [👥 *]
                                                     🪄 🧦 •🗑️ first]
                                                    bail]
                                            🪄 🔀 [•🗑️ [[📤 [[[📤] 🔳 🔳 [🔀] 🪆 ▶️] 🔀]
                                                       🔳 ↔️ 🔀 [[📸 🧦 [👥 *]
                                                                🪄 🧦 •🗑️ first]
                                                               bail]
                                                       🪄 🔀]
                                                      [•🗑️] [🔳] [🔀] 🪆 ▶️]
                                                 🔀]
                                            [🔳] ↔️]
                                           🐋]
                                          [📮 •🗑️]
                                          🔳 [▶️] 🪆 ▶️]
                                   ▶️]
           🔳 ↔️ 🔳 🧦 [▶️] 💉 ▶️ 📤]]]
🔳
#+end_src


#+begin_src kcats
[1 2 3 4 5] liberator [👥 *] each collect
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [consume]]
 [handled 🔳]
 [reason "not enough items on stack"]
 [type error]
 [unwound [🔀 [[📸 🧦 [👥 *]
               🪄 🧦 •🗑️ first]
              bail]
           🪄 🔀 [•🗑️ [[📤 [[[📤] 🔳 🔳 [🔀] 🪆 ▶️] 🔀]
                      🔳 ↔️ 🔀 [[📸 🧦 [👥 *]
                               🪄 🧦 •🗑️ first]
                              bail]
                      🪄 🔀]
                     [•🗑️] [🔳] [🔀] 🪆 ▶️]
                🔀]
           [🔳] ↔️ [1 4 9 16 25] 🔀 [📮 •🗑️ [[[📤 [[[📤] 🔳 🔳 [🔀] 🪆 ▶️] 🔀]
                                            🔳 ↔️ 🔀 [[📸 🧦 [👥 *]
                                                     🪄 🧦 •🗑️ first]
                                                    bail]
                                            🪄 🔀 [•🗑️ [[📤 [[[📤] 🔳 🔳 [🔀] 🪆 ▶️] 🔀]
                                                       🔳 ↔️ 🔀 [[📸 🧦 [👥 *]
                                                                🪄 🧦 •🗑️ first]
                                                               bail]
                                                       🪄 🔀]
                                                      [•🗑️] [🔳] [🔀] 🪆 ▶️]
                                                 🔀]
                                            [🔳] ↔️]
                                           🐋]
                                          [📮 •🗑️]
                                          🔳 [▶️] 🪆 ▶️]
                                   ▶️]
           🔳 ↔️]]]
🔳
#+end_src
** INPROGRESS Convert some generators to not wrap
- State "INPROGRESS" from "TODO"       [2024-12-11 Wed 20:12]

  #+begin_src kcats
    -1 [👥 inc] generator ▶️ 
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  0 [[👥 inc]
     🔳 🔳 [🔀] 🪆 ▶️]
  -1
  #+end_src

   test combining generators
  #+begin_src kcats
      [] [integers generator] 💉 ▶️
      [] [5 taker]  💉 ▶️ 🔀 🔗 
    [collect] 💉 ▶️ first
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [0 1 2 3 4]
  #+end_src
  
now try combining before execution
   #+begin_src kcats
         [integers generator] 💉 
         [5 taker]  💉 🔗
         [] 🔀 ▶️ 
      [collect] 💉 ▶️ first
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [0 1 2 3 4]
  #+end_src

  encapsulation
  #+begin_src kcats
    [[1 2 3 4 5] liberator
     [odd?] keep
     collect]
    [] 🔀 💉 ▶️ first 
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [1 3 5]
  #+end_src

  aka assemble
  #+begin_src kcats
    [1 2 3 4 5]
    [[odd?] keep
     collect]
    [liberator ✂️1️⃣] 🎒
    [🎁] 🪄 💉 ▶️ first 
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [1 3 5]
  #+end_src

*** each 
   #+begin_src kcats
     integers generator
     5 taker
     [👥 *]
     •🛡️ ;; prevent mapping program from overwriting stack
     [▶️ 1️⃣ bail] 🎒 ;; only execute the mapping program if parent produces value
     [] [🔳] [🔀] 🪆 
     collect
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [0 1 4 9 16] 4
  #+end_src
*** joiner 
  #+begin_src kcats
    [[1 2 3] [4 5 6] [7 8 9]] liberator
    [🔗] fold
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  [1 2 3 4 5 6 7 8 9]
  #+end_src
#+begin_src kcats
 
#+end_src

#+RESULTS:
#+begin_src kcats
[[expected [[🔗] fold]]
 [handled 🔳]
 [reason "Deprecated"]
 [unwound 🔳]]
#+end_src
*** skipper 
#+begin_src kcats
  ;integers generator
  [1 2 3 4 5 6 7 8 9 10] liberator
  [5 <]
  ✅
  [[[▶️] •🪄 
    [[▶️] 🛡️ 🪄 and]
    [🔳] ↔️]
   [••🗑️] ⏳ ▶️] 🔳 🔳
  [🛟 🔳 ⚓]
  🪆
  ;30 taker
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[5 6 7 8 9 10] [[[[▶️] •🪄 [[▶️] 🛡️ 🪄 and] [🔳] ↔️] [••🗑️] ⏳ ▶️] 🔳 [dump] [🛟 🔳 ⚓] 🪆
                ▶️]
🔳 [5 <]
#+end_src

have : rform pred val
need : val rform [] pred gform
float -> val rform pred
[] sink 
#+RESULTS:
#+begin_src kcats
[[[[[▶️] •🪄 [[▶️] 🛡️ 🪄 and] 🔳 ↔️] [••🗑️] ⏳ ▶️] 🔳 🔳 [dump 🛟 🔳 🔀 dump] 🪆 ▶️] [5 <]
 5 [[inc 👥]
    🔳 🔳 [🔀] 🪆 ▶️]
 5]
[5 🔳 [[[[▶️] •🪄 [[▶️] 🛡️ 🪄 and] 🔳 ↔️] [••🗑️] ⏳ ▶️] 🔳 🔳 [dump 🛟 🔳 🔀 dump] 🪆 ▶️] [5
                                                                                <]
 [[inc 👥]
  🔳 🔳 [🔀] 🪆 ▶️]
 5]
[[[[▶️] •🪄 [[▶️] 🛡️ 🪄 and] 🔳 ↔️] [••🗑️] ⏳ ▶️] 🔳 🔳 [dump 🛟 🔳 🔀 dump] 🪆 ▶️] [5 <]
[[inc 👥]
 🔳 🔳 [🔀] 🪆 ▶️]
5
#+end_src

#+begin_src kcats
  [] ☯️ ☯️
#+end_src

#+RESULTS:
#+begin_src kcats
🔳
#+end_src

#+begin_src kcats
  ;integers generator
  [1 2 3 4 5 6 7 1] liberator
  [5 <]
  [[▶️] 🐋] ;; get the item from parent
  [🔀 [▶️] 🛡️ ▶️] ;; run the pred on it, keep the pred
  [🗑️ [] []] ⚖️ ;; when parent is empty, leave negative on the stack
  [🗑️ •🗑️] ⏳ ▶️ ;; keep consuming items while they match pred
  [🗑️ []] ;; first value that doesn't match pred, drop pred,
  ;; leave an empty generator that falls through to the value below
  [[[]]] ↔️ ;; if parent ran out, leave a generator that produces end-of-stream
  ;30 taker
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[5 6 7 1]
#+end_src
#+begin_src kcats
  [1 2 -3 4 5]
  [[positive?] skipper collect]
  assemble
#+end_src

#+RESULTS:
#+begin_src kcats
[-3 4 5]
#+end_src

*** keep
#+begin_src kcats
    integers generator
    [odd?]

    [▶️  ;; exec the generator below to get value v
     [1️⃣ 🛡️ ▶️ ☯️] ;; check if v does NOT match given pred, 
     [🔳 🔳] ;; if generator below is finished, return 2 empty values 
     ↔️ ] 🎒
    [🗑️ 🗑️] ;; drop both the value v and the result of pred
    ⏳ ;; repeat until generator below is finished
    [] [🔳] [🔀] 🪆
    5 taker
    collect
#+end_src

#+RESULTS:
#+begin_src kcats
[1 3 5 7 9] [[inc 👥]
             🔳 🔳 [🔀] 🪆 ▶️]
9
#+end_src
*** dropper
#+begin_src kcats
    [1 2 3 4 5 6 7] liberator
    6 
    [[[[[positive?] 🛡️ ▶️]
       [[▶️] 🐋 ]] [▶️] 💯 ▶️]

     [🗑️ dec] ⏳ ▶️ dump [🗑️ ▶️] [] ↔️] collect
  ;▶️ 🗑️ ▶️ 🗑️ ▶️ 🗑️ ▶️ 
#+end_src

#+RESULTS:
#+begin_src kcats
[0 [[📤] 🔳 🔳 [🔀] 🪆 ▶️] [7]]
[7]
#+end_src

#+begin_src kcats
  [1 2 3 4 5 6 7 8 9 10] 
   [  11
     [positive?] 🛡️ ;; condition
     [🗑️ [▶️] 🐋 ;; call parent 
      [] ;; if we get something, we're done
      [🗑️ [[]] [] []] ;; otherwise signal stop with empty generator
      ↔️]
     [🗑️ ▶️ []] ⚖️ ;; if counter reaches zero we're done dropping 
     [🗑️ dec] ⏳ ;; decrement the counter and drop the value we got
  ;10 taker
     collect] assemble
  ;
#+end_src

#+RESULTS:
#+begin_src kcats
🔳
#+end_src

#+begin_src kcats
    [1 2 3 4 5] liberator
    3
    [positive?] 🛡️ ;; counter still positive?
    [🗑️ [▶️] 🐋 ;; run the parent generator
     [] [[] []] ↔️] ;; add padding to drop later
    [🔳] ⚖️ ;; otherwise return nothing
    [[dec] 🪄] ;; decrement counter
    [🗑️ 🗑️ 🔳] ;; discard the counter and parent, all done
    [🔀] 🪆
    collect
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3] [4 5]
#+end_src

#+begin_src kcats

#+end_src
*** catcher
#+begin_src kcats
  [1 2 3 -4 5] liberator
  [positive?]
  [[▶️] 🐋 ;; get value from parent
   [🔀 [▶️] 🛡️ ▶️] bail ;; only check pred iff we get a value, preserve pred
   🔳
   [🔳 🔳 🔳] ↔️] ;; place some dummy values to drop if we didn't get a value
  [🗑️ 🔀] ;; iff pred matches drop the pred result 
  [🗑️ 🗑️ 🗑️ 🔳] ;; otherwise drop all the stuff we no longer need
  ⚖️ 🔳
  [[🔳] 🔳] [🔀] 🪆 collect

#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3] [🔳] -4 [[📤] 🔳 🔳 [🔀] 🪆 ▶️] [5]
#+end_src
*** produce
#+begin_src kcats
  [integers generator
   [👥 *] each
   10 taker
   [+] fold] [] 🔀 💉 ▶️ first
#+end_src

#+RESULTS:
#+begin_src kcats
285
#+end_src
*** cram
#+begin_src kcats
  ;[▶️] 🪄 ;; generate the first item below the reducer
  integers generator 5 dropper 10 taker
  0
  [+]
  [[▶️] •🐋] ;; check that we generated another item
  [🔀 [▶️] 🛡️ ▶️ ⚓ •🗑️ ••🗑️] ;; if so, run the reducer shielded and drop component items
  🔳 ;; otherwise stop
  [▶️] 🪆
  ▶️ 🗑️
#+end_src

#+RESULTS:
#+begin_src kcats
95 14
#+end_src
*** indexer
#+begin_src kcats
  [foo bar baz] liberator
  0 [[▶️] 🐋 [[pair] •🛡️ ▶️ [inc] 🪄] bail]
  [] [🗑️ []] [🔀] 🪆 collect 
#+end_src

#+RESULTS:
#+begin_src kcats
[[0 foo]
 [1 bar]
 [2 baz]]
#+end_src

#+begin_src kcats
  [foo bar baz] [indexer collect] assemble 
#+end_src

#+RESULTS:
#+begin_src kcats
[[0 foo]
 [1 bar]
 [2 baz]]
#+end_src
*** flatten
#+begin_src kcats
   [a [b [c e f] d]] 🔳 🔀
   [list?] 🛡️ [🗑️] [📮] [🪜 ▶️] 🪆 ▶️
#+end_src

#+RESULTS:
#+begin_src kcats
[a b c e f d]
#+end_src
*** siphon
deprecate?
#+begin_src kcats
  [integers generator
   100 dropper
   10 taker
   [character] each
   "" 🧹 ▶️]
  siphon
#+end_src

#+RESULTS:
#+begin_src kcats
"defghijklm"
#+end_src

* DONE max-by min-by
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "TODO"       [2025-03-19 Wed 16:26]
#+begin_src kcats
  [[price 25] [name bar]] [[price 15] [name foo]]
  [[price] lookup]
  [compare-by 🎁] •🛡️ ▶️ [less] =
  [🗑️ •🗑️] [🗑️] ↔️ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[price 25]
 [name bar]]
#+end_src

* DONE Fix panic on network connection refused
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-03-17 Mon 19:35]
- State "INPROGRESS" from "TODO"       [2025-03-17 Mon 19:04]
Running kcats...

thread 'main' panicked at src/types/container/pipe/net.rs:156:27:
called `Result::unwrap()` on an `Err` value: Os { code: 111, kind: ConnectionRefused, message: "Connection refused" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


--- Process exited abnormally with code 101 ---

* DONE Fix the way serversocket and other pipes get printed
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:10
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-03-19 Wed 16:26]
- State "INPROGRESS" from "TODO"       [2025-03-17 Mon 19:58]
currently =[[serversocket todo: fix serversocket local addr async issue] [type pipe]]=.

#+begin_src kcats
"127.0.0.1" 8899 serversocket 
#+end_src

#+RESULTS:
#+begin_src kcats
[[address 127.0.0.1]
 [pipe-type serversocket]
 [port 8899]
 [produces socket]
 [type pipe]]
#+end_src

#+begin_src kcats
  [[type pipe]
   [destination [[type file]
                 [path "/foo/bar"]]]
   [in [[type bytes]]]
   [out [[type bytes]]]]

  [[type pipe]
   [destination [[type serversocket]
                 [port 9999]]]
   [out [[type socket]]]]

#+end_src

#+begin_src kcats
  handoff 👥 
#+end_src

#+RESULTS:
#+begin_src kcats
[[capacity 0]
 [endpoint [[handoff 0]]]
 [in item]
 [out item]
 [receivers 2]
 [senders 2]
 [type pipe]]
[[capacity 0]
 [endpoint [[handoff 0]]]
 [in item]
 [out item]
 [receivers 2]
 [senders 2]
 [type pipe]]
#+end_src

#+begin_src kcats
  1000 timer 📤 🗑️ 📤 
#+end_src

#+RESULTS:
#+begin_src kcats
#+end_src

#+begin_src kcats
  timestamps 📤
#+end_src

#+RESULTS:
#+begin_src kcats
1742385892702 [[endpoint systemtime]
               [out [[type integer]
                     [units milliseconds]]]
               [type pipe]]
#+end_src

#+begin_src kcats
standard
#+end_src

#+RESULTS:
#+begin_src kcats
[[peer standard]
 [type tunnel]]
#+end_src

* DONE Pattern matching and destructuring
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
- State "DONE"       from "INPROGRESS" [2025-05-15 Thu 16:02]
- State "INPROGRESS" from "TODO"       [2025-04-02 Wed 19:50]
Pattern match is fairly simple if you specify paths:

#+begin_src kcats
  [[foo [[bar [[splook zoop]]]]]
   [baz [item1 item2 item3]]
   [quux [[bloop toop] [foop gloop]]]]
  [[foo bar] [baz 2] [quux foop]] [🔍] 🚜 ▶️
#+end_src

#+RESULTS:
#+begin_src kcats
[[[splook zoop]] item3 gloop] [[foo [[bar [[splook zoop]]]]]
                               [baz [item1 item2 item3]]
                               [quux [[bloop toop]
                                      [foop gloop]]]]
#+end_src

the trick is specifying an actual pattern.

#+begin_src kcats
  [[foo [[bar [[splook zoop]]]]]
   [baz [item1 item2 item3]]
   [quux [[bloop toop] [foop gloop]]]]
  [[foo [[bar 1️⃣]]]
   [baz [_ _ 2️⃣]]
   [quux [[foop 3️⃣]]]]
  match
#+end_src

#+begin_src kcats
  [[foo bar]
   [baz quux]
   [goop [[a b]
          [c d]]]]
  [[foo thing?]
   [goop [[a bee?]]]
   [barx other?]]
  unpack
#+end_src

#+RESULTS:
#+begin_src kcats
[[bee? b]
 [thing? bar]]
#+end_src

#+begin_src kcats
[a b c] [_ b 1️⃣] unpack
#+end_src

#+RESULTS:
#+begin_src kcats
[[1️⃣ c]]
#+end_src


#+begin_src kcats
  [anything
   [foo [this is a] 12]
   [5 [this is b] 5]
   []
   thisisc]
  [_
   [_ 📨a 12]
   [5 📨b 5]
   []
   📨c] 
  unpack
#+end_src

#+RESULTS:
#+begin_src kcats
[[a [this is a]]
 [b [this is b]]
 [c thisisc]]
#+end_src

#+begin_src kcats
  [[a [[b 12]
       [c 15]]]
   [d [[e []]
       [f [5 4 3 2 1]]]]] assocify
  ;[[a 📨a]
  ; [d [[f [_ 1️⃣ 📨b]]]]] 
 ; ⛏️
#+end_src

#+RESULTS:
#+begin_src kcats
  [[a [[b 12]
       [c 15]]]
   [d [[e 🔳]
       [f [5 4 3 2 1]]]]] [a] 🍫 get type
#+end_src

#+RESULTS:
#+begin_src kcats
list
#+end_src

* CANCELED Spec analysis
:PROPERTIES:
:ARCHIVE_TIME: 2025-06-03 Tue 21:11
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: CANCELED
:END:
- State "CANCELED"   from "TODO"       [2025-05-15 Thu 19:44] \\
  not feasible to be very formal with this, lots of programs will not be analyzable.
We should be able to get information about what a program does by
compiling the spec for each of its components. It should be a function
called =effect= that takes a program as an argument, and returns its
spec.

#+begin_src kcats
  lingo [🔀 👥] [🎁 [spec] 🔗 🔍] 🚜 ▶️
#+end_src

#+RESULTS:
#+begin_src kcats
  [[[[item a] [item b]]
    [[item b] [item a]]]
   [[[item a]]
    [[item a] [item a]]]]
#+end_src

so here the program is =[🔀 👥]=, and we can see the output of =🔀= is [b
a], and the input of =👥= is [a] so we can consider that item named both
=b= and =a= in different places.

So we might expect to see the combined spec of something like:

#+begin_src kcats
  [[[item a] [item b]]
   [[item b] [item b] [item a]]]
#+end_src

what about something like
#+begin_src kcats
  lingo [[🔀] 🪄] [🎁 [spec] 🔗 🔍] 🚜 ▶️
#+end_src

#+RESULTS:
#+begin_src kcats
[🔳 [[program [item a]]
    [[item a]
     ,*]]]
275_entries
#+end_src

What we're actually doing here is swapping, dipped. Dip runs the
program underneath the top stack item. So to figure out the effect of
the whole program, we have to find the effect of the program argument
to dip, which is just the effect of swap. So the total effect would look like:

#+begin_src kcats
  [[program [item a] [item b] [item c]]
   [[item a] [item c] [item b]]]
#+end_src

one thing i don't have right now is a way to express in my spec
format, the idea of an output effect being "the effect of executing an
input program".

I suspect that the possibilities of what programs can do is too
arbitrary to make a declarative format that captures every
possibility.

For example:

#+begin_src kcats
  [👥 🔀] [🛟 🗑️] 🔗 ▶️
#+end_src

This combines two programs and then executes them. So we don't know
what the program actually is until runtime. So =effect= cannot determine
what the "effect" of execute will be until it's run the 'join' operation.
