#    -*- mode: org -*-


Archived entries from file /home/user/workspace/kcats/production.org


* DONE assign doesn't overwrite a nested value properly
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
[[a b] [c d]] association
[a e] "foo!" assign
#+end_src

#+RESULTS:
: 
: [[[c d] [a [[e "foo!"]]]]]

This errors out because =b= isn't an association. But we want it to
overwrite =b= with =[[d "foo!"] ]=.

* DONE Serialization treats any tagged literal as byte string
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:

* DONE Serialization panics on reading invalid data
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
Should return Result objects from to_item. I don't think it is
necessary for from_item - since we're using a subset of edn, all Items
should be convertible to valid edn. But not all valid edn is
convertible to an Item.

* DONE Association list and list of equal content don't compare equal
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** Description
Probably need a custom PartialEq impl for Item here that converts the
list to a hash before comparing. Return false if the item doesn't
convert.

The sticky issue here is that when we read a literal like =[[type
foo][value bar] ]=, how do we know whether it should be compared to
something else as a hashmap (that ignores order) or a plain list (that
doesn't). We can probably deduce that if one of the arguments is a
hashmap, then the other should be treated as one. However what if both
are plain lists? It's still possible the intent was hashmap.
** Hacky Solution
what if you execute =[[a b][c d] ] [[c d][a b] ] == ? It's impossible
to know the intent. I think maybe the best way out is to treat
anything associative-shaped as association, and if the user wants
ordered comparison, let him use a different operator, =ordered== or
something.

So the comparison of two items that are either List or Assoc goes like this:

If either item is Assoc, then convert the other to Assoc (if
necessary) and do straight =.

If they're both List, compare lengths. If not equal, return
false. Otherwise, examine items- If they're all pairs, convert both to
assoc. finally do straight =.
** Better solution
Add a word =associative=. If that follows a list, it's converted to a
hashmap and then it's easy to compare to another hashmap. The
representation is unchanged of course. But it lets the programmer
specify the intent of how === should behave.

This does reveal a problem with the unit tests that are specified as
examples in the lexicon. Those tests will execute the program and then
compare the representation of the resulting stack, with the
representation given. As we now can see, comparing representations is
insufficient, we need to be able to compare actual implementations.

That means, the unit test's expected value should be calculated and
not just read in. For most tests, no changes will be required (it's
just putting values on the stack and no further calculation needed).

But in the end we'll need to compare actual stack to expected stack,
not a stack to a representation. So the unit test logic will need to
run two environments, the actual and the expected, and then compare them.

The previous solution just isn't going to cut it - when we go to
implement sets it's going to be completely impossible to use a
heuristic to figure out what the intent was. Lists and sets will look
the same. So in the case of sets we'll have to specify the word =set=.

Do we have to be explicit when comparing list to association?  we
could either always return false (they're different types), or we
could compare them as lists or as maps.

The question then is if the two intents don't match, what do we do?  I
can't think of a reasonable answer- does order matter? We have
conflicting answer with no way to resolve it. Maybe it's safest to
just return false.

You can argue maybe even if order matters, maybe the two lists are in
the same order and should therefore compare equal. But associatives
don't have a defined order, so that would be just leaving it up to
chance and it wouldn't even be consistent across time. So that doesn't
seem wise.

So here's the plan: 
Examples:
#+begin_src kcats
[[a b] [c d]] association
[[c d] [a b]] association
=
=> true

[[a b] [c d]]
[[c d] [a b]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]] association
=
=> false

[[a b] [c d]]
[[a b] [c d]]
=
=> true

[a a b c]
[a b c]
=
=> false

[a b c] set
[a b c]
=
=> false

[a b c] set
[b a c] set
=
=> true
#+end_src

* DONE Items of equal content don't compare equal
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
#+begin_src kcats
+ handle [[type error] [asked [consume]] [reason "not enough items on stack"]] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
dictionary [swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
[] environment [dictionary swap] lookup [swap] unwrap = 
#+end_src

#+RESULTS:
: 
: [true]

This matches clojure
#+begin_src kcats
1 1.0 =
#+end_src

#+RESULTS:
: 
: [false]

#+begin_src kcats
[] [] association =
#+end_src

#+RESULTS:
: 
: [true]

#+begin_src kcats
"foo" bytes "foo" bytes =
#+end_src

#+RESULTS:
: 
: [true]


* DONE Change unit tests to make the expected take a program and eval it
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
This is to fix the cases that result in associatives or sets where
order doesn't matter but we don't have a way to declare how the values
should be conmpared. We can't just compare representations, we need to
compare two actual stacks.

So instead of
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]]]]
#+end_src

We should write
#+begin_src kcats
[[[[a b] [c d]] [a] 5 assign]
 [[[a 5] [c d]] association]]
#+end_src

So that the two stacks will compare equal.

* DONE create an environment from data (including an existing stack)
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
It'd be nice to copy paste the output of one execution and have it pick up again eg
#+begin_src kcats
[[stack [1 2 3]]
 [expression [+]]]
#+end_src

There are potential issues here - such as the representation of an
associative is just a list, so when it's read back in it won't be the same:
#+begin_src kcats
[[stack [[[a b] [c d]]
         [[c d] [a b]]]]
 [expression [=]]]
#+end_src

If the two lists on the stack were actually associatives, they were
equal before but now they won't be.

I don't know that this is such a big problem, it's not possible for
everything in the language to be sensibly round-tripped via
serialization (eg stateful things like pipes).

If it's important to compare as associative, then make that part of
the expression.

What should =environment= take as an argument? Seems like it should
take an association (or assoc-shaped list).

#+begin_src kcats
[] environment
#+end_src

#+RESULTS:
: 
: [[[stack []] [expression []]]]

should give the default env.

#+begin_src kcats
[[expression [1 2 +]]] environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

should give the unexecuted env

#+begin_src kcats
[[expression [+]] [stack [3 2]]] environment evaluate [stack] lookup first
#+end_src

#+RESULTS:
: 
: [5]


should execute env with default dictionary plus whatever we add

#+begin_src kcats
[[dictionary [[foo [[definition [inc +]]
                    [spec [[number] [number]]]]]
              [bar [[definition [foo 5 *]]
                    [spec [[number] [number]]]]]]]
 [expression [1 2 bar]]]

environment evaluate
#+end_src

#+RESULTS:
: 
: [[[stack [20]] [expression []]]]

should give the default env with the additional dict entries


#+begin_src kcats
[[expression
  [21449

   [] swap 2

   [/ 2 >]
   [ [mod 0 =]
     [clone sink [pack] dipdown / 2]
     [inc]
     if]
   while

   discard pack
  ]]]
environment
advance advance advance advance advance advance
eval-step
#+end_src

#+RESULTS:
: 
: [[[stack [[[mod 0 =] [clone sink [pack] dipdown / 2] [inc] if] [/ 2 >] 2 21449 []]] [expression [swap wrap [shield] join clone dipdown join loop discard pack]]]]


#+begin_src kcats
[[expression [1 2 +]]] environment advance advance advance
#+end_src

#+RESULTS:
: 
: [[[stack [3]] [expression []]]]

#+begin_src kcats
dictionary count
#+end_src

#+RESULTS:
: 
: [118]


* DONE In-thread error handling
:PROPERTIES:
:ARCHIVE_TIME: 2022-12-03 Sat 20:40
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues
:ARCHIVE_CATEGORY: production
:ARCHIVE_TODO: DONE
:END:
** DONE Error structs
** DONE Stop on unrecoverable error
** DONE Be able to resume execution after an error
*** Notes
#+begin_src  kcats
2 [1 4 0] [[/] [discard 0] recover] map

#+end_src

#+RESULTS:

#+begin_src kcats
2 [1 4 0] [[/] [discard 0] recover] map

[1 0 /] [discard 0] recover
1 [0 /] [discard 0] . recover
1 . snapshot
    [0 /] inject first
    [error?] [discard 0] [] if
    resume
err [error?]  

t r recover
[snapshot] dipdown ;; rec test ss
[inject] dip swap ;; res rec
[first error?] ;; err? res rec
discard execute;; drop the snapshot and run recovery
evert discard ;; use snapshot as stack


; inject the program into a snapshot. If there's an error on top
; afterward, inject the recovery in there too. It'll have access to
; the whole context. If there's no error, evert and drop the ToS.

;; the execution will stop after injecting into the snapshot, so
;; "first" won't even get executed here.

[discard] [discard] recover

;; here we recover from underflow by just dropping the error


[1 0 /] . execute
. 1 0 /
err . [discard 0] execute resume
                        ;; ^ this is in the expression so keep going, actual word doesn't do anything


;; when the ToS is err, how do we know whether to stop?  we can look
;; at the expression to see what's coming. We can't do that at every
;; step of the entire execution but we don't have to. Just when ToS =
;; err. The challenge is to encode this just with the stack/expr and
;; no extra state. We can put a word like "continue" in the expr, but
;; at some point we actually have to have an err on ToS and do
;; something with it. The only place we can put some kind of flag not
;; to abort, is in the expression (or maybe the dictionary).

;; another approach is to explicitly continue unless halt is called,
;; but the error-producer doesn't know whether the error can be
;; handled or not.


;; how to unwind. can we just naively unwind to the next instance of
;; 'recover' in the expression? or will quoted programs mess this up?
;; Let's work through it

;; here the recover is quoted, but by the time an error occurs and we
;; look at the expression, it'll be there:
2 [1 4 0] [[/ 12 +] [discard 0] recover] map

2 err . 12 + resume [error?] [discard 0] if
2 err . [error?] [discard 0] [] if 

;; so the problem is even after we've unwound the expression to
;; 'resume', the error is still on the ToS! Now we want to actually do
;; the recovery, but we've already gotten rid of the flag that tells
;; us we're doing that. Maybe we can modify the error object itself to
;; note that it's been flagged for processing. Maybe [[type error]
;; [detected? true] [message "oops"]]. Or maybe we can convert it from
;; the error object to a richer object that contains the whole
;; stack/expr at the time it happened.

;; maybe we need a primitive here: fail, which will put a new item on
;; ToS which includes the whole env field plus a message field to
;; describe what is wrong.

;; eg

1 0 /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]]

1 0 . "division by zero" capture /

[environment [[stack [1 0]]
              [expression [/]]
              [error "division by zero"]]] . /

;; ok what's the best we got so far?

;; i think it's recover/resume, without requiring nested env. Have the
;; error type with a flag detected?. Eval will do the following: if
;; there's an error on top, and there is no 'detected?' field, unwind
;; the expression to 'resume' (if there is one, otherwise clean the
;; expression). Set the detected field and continue. presumably what's
;; next is the error handler if there's anything left in the
;; expression.

;; ok this is good but it'd be nice to know what the expression was
;; before it gets unwound. For example what if the handler wants to
;; log the error? By the time it can do that, the original word that
;; errored is not in the expression anymore. The error object would
;; have to contain a snapshot (not just of the stack, but the
;; expression too). what about snapshotting the stack and cherry
;; picking the error object before the recovery? How does the recovery
;; distinguish different types of errors (java's catch-by-class is
;; kind of weak)

;;eg

1 "foo" + 0 /

;; there's 2 things wrong here, what if we only want to recover from
;; division by zero? well, we can only wrap / in a recover. ok waht about this

"foo" 0 /

;; this will actually error with type mismatch

;; how are we supposed to serialize these things? This makes me think
;; the rust structs need to be easily representable as kcats. And then
;; what are we supposed to do with error literals (the reader would
;; need to convert them). What would error literals look like,
;; especially user-defined errors?

[[error "oh noes"]]

;; but then how to subtype them? Here we have a sort of pseudoprogram
;; that demonstrates what the interpreter couldn't do. for example [0
;; /] means it can't divide by zero. And then there's a string that
;; just says what the program can't do. eg 'number' is a word that may
;; or may not exist (I suppose it should, to do parseInt type stuff)
;; but the point is it's pseudocode that in many cases will work as
;; real code, but not guaranteed.

[[type error]
 [asked [0 /]]
 [reason "cannot divide by zero"]]

[[type error]
 [asked [number]]
 [reason "not a number"]]

[[type error]
 [asked [consume]]
 [reason "not enough items on stack"]]

[[type error]
 [asked [2 get]]
 [reason "not enough items in the list"]]

[[type error]
 [asked [bloop]]
 [reason "word is not defined"]]
#+end_src

#+begin_src kcats
17
[+]
[discard 5 +]

[[handle] join] dip ;; add handle to the end of test
[snapshot] dipdown ;; rec test ss
sink inject ;; res rec
[first error?] ;; err? res rec
[first swap execute];; drop the snapshot and run recovery
[evert discard] ;; use snapshot as stack
if

#+end_src

#+RESULTS:
: 
: [22]


#+begin_src kcats :results code
5
[1 2 "oh fudge"]
[[+]
 [discard discard]
 recover]
map
#+end_src

#+RESULTS:
#+begin_src kcats

stack: [[[reason "type mismatch"] [asked [number]] [type error]] "oh fudge" 5]
expression: [handle [[[discard discard] "oh fudge" 5]] unwrap evert [first error?] [first swap execute] [evert discard] if [[[5] [6 7] 5]] unwrap evert first swap [pack] dip discard]
#+end_src

#+begin_src kcats
 [+]
[discard 1
 [+] [discard 2 +]
 recover]
recover
#+end_src

#+RESULTS:
: 
: stack: [[[type error] [asked [consume]] [reason "not enough items on stack"]]]
: expression: [handle [[[discard 1 [+] [discard 2 +] recover]]] unwrap evert [first error?] [first swap execute] [evert discard] if]

#+begin_src kcats
5 handle 

#+end_src

#+RESULTS:
: 
: [5]

** DONE Errors during recovery are improperly caught
The current implementation cannot tell the difference between an error
that was put on the stack during the "test" program, vs one that was
put there during the recovery. So if the recovery throws an error, it
*should* halt the execution, but it won't. Instead the program will
continue executing and words will be invoked with errors on the stack
that shouldn't be invoked.

I think I have a solution, but it does require modifying the error
object by setting a =handled?= flag (note the plan is for this to be
an implementation detail and from kcats point of view the error object
will not be visibly modified). The recovery program will have a word
=handle= inserted in the first position. The word =handle= will set
the flag on the error to =true=. Then =eval= can stop when a) there's
an error on the stack with no =handled? = true= AND the word =handle=
isn't in the expression. If =handle= *is* in the expression, we need
to unwind the expression up to but not including the =handle= word.

The word =handle= has to be an atomic operation (an axiom word that
sets the flag in one evaluation step, otherwise the progam would halt
before the flag could be set.)

We can delete the word =resume=.

#+begin_src kcats :results code
 discard 1 2 + handle discard 3 4 +
#+end_src

#+RESULTS:
#+begin_src kcats

[7]
#+end_src

#+begin_src kcats
1 [[zero?] [pos?]] [execute] every?
#+end_src

#+RESULTS:
: 
: [[] 1]

#+begin_src kcats
1 [[zero?] [positive?]] [execute] any?
#+end_src

#+RESULTS:
: 
: [true 1]


* Attribute database using CozoDB
:PROPERTIES:
:ARCHIVE_TIME: 2024-01-17 Wed 19:32
:ARCHIVE_FILE: ~/workspace/kcats/production.org
:ARCHIVE_OLPATH: Production implementation/Issues/Database
:ARCHIVE_CATEGORY: production
:END:
The idea here is to ignore identity in the database and make that the
responsibility of the client. The database only links attributes, and
has nothing to say about whether a given entity is the "same" entity
as another. It only says "something has both the color brown and the
height 1.5m". What attributes are sufficient to establish identity is
not part of the database. It's just a graph connecting attribute/value
pairs.
**  First experiments
#+begin_src fundamental
  ?[a_attr, a_val, b_attr, b_val] <-
  [
    ["author", "George Orwell", "title", "1984"],
    ["author", "George Orwell", "title", "Animal Farm"],
    ["author", "George Orwell", "genre", "dystopia"],
    ["genre", "dystopia", "title", "1984"],
    ["created", "1949", "title", "1984"],
    ["format", "book", "title", "1984"],
    ["language", "english", "title", "1984"],
    ["name", "George Orwell", "created", "1905"],
    ["name", "George Orwell", "sex", "male"]
  ]

  :replace also {a_attr, a_val, b_attr, b_val}
#+end_src

#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": ":create attributes { a_attr: String, a_val: Any, b_attr: String, b_val: Any}",
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "status"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "OK"
    ]
  ],
  "took": 0.016436112
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 79
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Tue, 19 Dec 2023 23:25:15 GMT
// Request duration: 0.018199s
#+END_SRC

#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "?[a_attr, a_val, b_attr, b_val] <- [['author', 'George Orwell', 'title', '1984'], ['author', 'George Orwell', 'title', 'Animal Farm'], ['author', 'George Orwell', 'genre', 'dystopia'], ['genre', 'dystopia', 'title', '1984'], ['created', '1949', 'title', '1984'], ['format', 'book', 'title', '1984'], ['language', 'english', 'title', '1984'], ['name', 'George Orwell', 'created', '1905'], ['name', 'George Orwell', 'sex', 'male']] :put attributes",
     "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "status"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "OK"
    ]
  ],
  "took": 0.011967695
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// access-control-allow-origin: *
// transfer-encoding: chunked
// date: Tue, 19 Dec 2023 23:39:51 GMT
// Request duration: 0.064371s
#+END_SRC

"When was the author of 1984 born?"
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[born] := linked['title', '1984', 'author', author], linked['created', born, 'name', author]", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "born"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "1905"
    ]
  ],
  "took": 0.001707655
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 79
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Tue, 19 Dec 2023 23:56:27 GMT
// Request duration: 0.002975s
#+END_SRC

"What books did the author of 1984 write?"
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[title] := linked['title', '1984', 'author', author], linked['title', title, 'author', author]", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "title"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "1984"
    ],
    [
      "Animal Farm"
    ]
  ],
  "took": 0.001771184
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 96
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Wed, 20 Dec 2023 00:05:26 GMT
// Request duration: 0.002879s
#+END_SRC



How to write that query in kcats format?
#+begin_src kcats
  [[title "1984" author a?]
   [created c? name a?]
   [c?]]
#+end_src

Everything about Orwell
#+begin_src restclient
  POST http://127.0.0.1:3000/text-query
  Content-Type: application/json

  {"script": "linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]\n?[a1, v, a2] := linked[a1, v, a2, 'George Orwell'] ", 
   "params": {}}
#+end_src

#+RESULTS:
#+BEGIN_SRC js
{
  "headers": [
    "a1",
    "v",
    "a2"
  ],
  "next": null,
  "ok": true,
  "rows": [
    [
      "created",
      "1905",
      "name"
    ],
    [
      "genre",
      "dystopia",
      "author"
    ],
    [
      "sex",
      "male",
      "name"
    ],
    [
      "title",
      "1984",
      "author"
    ],
    [
      "title",
      "Animal Farm",
      "author"
    ]
  ],
  "took": 0.00130435
}
// POST http://127.0.0.1:3000/text-query
// HTTP/1.1 200 OK
// content-type: application/json
// content-length: 213
// access-control-allow-origin: *
// vary: origin
// vary: access-control-request-method
// vary: access-control-request-headers
// date: Wed, 20 Dec 2023 00:14:07 GMT
// Request duration: 0.002445s
#+END_SRC

** Using org-mode eval
Now we have an org-mode evaluator!
#+begin_src cozodb :results value table
{:create attributes {a_attr: String, b_attr: String, a_val: Any, b_val: Any}}
#+end_src

#+RESULTS:
| OK |

#+begin_src cozodb :results value table
  %import /home/v/workspace/kcats/countries-cozo.json
#+end_src

#+RESULTS:
| [31mparser::pest[0m |


#+begin_src cozodb
::index create attributes:rev {b_attr, a_attr, b_val, a_val}
#+end_src

#+begin_src cozodb :results value table
  linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]
  ?[title] := linked['title', '1984', 'author', author], linked['title', title, 'author', author]
#+end_src

#+RESULTS:

What movies has robert de niro been in?
#+begin_src cozodb
linked[a, v, oa, ov] := *attributes[a, v, oa, ov] or *attributes[oa, ov, a, v]
?[title] := linked['title', title, 'cast', cast], actor in cast, actor == 'Robert De Niro'
#+end_src

#+RESULTS:
| GoodFellas                    |
| Jackie Brown                  |
| Mean Streets                  |
| Midnight Run                  |
| Once Upon a Time in America   |
| Raging Bull                   |
| Righteous Kill                |
| Silver Linings Playbook       |
| Stardust                      |
| The Irishman                  |
| The Irishman: In Conversation |
| The Score                     |



What directors has robert de niro worked with?
#+begin_src cozodb
  linked[a, oa, v, ov] := *attributes[a, oa, v, ov] or *attributes[oa, a, ov, v]
  ?[director] := linked['title', 'cast', title, cast],
                 linked['title', 'director', title, director], 
                 actor in cast, actor = 'Robert De Niro' 
#+end_src

#+RESULTS:
|                   |
| David O. Russell  |
| Frank Oz          |
| Jon Avnet         |
| Martin Brest      |
| Martin Scorsese   |
| Matthew Vaughn    |
| Quentin Tarantino |
| Sergio Leone      |


What movies had both Adam Sandler and David Spade?
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title] := linked['title', title, 'cast', cast],
              actor1 in cast,
              actor2 in cast,
              actor1 == 'Adam Sandler', actor2 == 'David Spade'
#+end_src

#+RESULTS:
| Grown Ups                             |
| Hotel Transylvania 3: Summer Vacation |
| The Do-Over                           |
| The Ridiculous 6                      |

Adam Sandler's 5 most recent movies
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
   ?[title, year] := linked['title', title, 'cast', cast],
                     linked['release_year', year, 'title', title],
                     actor in cast, actor == 'Adam Sandler',
   :limit 5
   :order -year
#+end_src

#+RESULTS:
| Hubie Halloween                       | 2020 |
| Murder Mystery                        | 2019 |
| Uncut Gems                            | 2019 |
| ADAM SANDLER 100% FRESH               | 2018 |
| Hotel Transylvania 3: Summer Vacation | 2018 |

What actors have been in the most movies with Sandler
#+begin_src cozodb
  ?[count(title), actor2] := linked['title', title, 'cast', cast],
                    target = 'Adam Sandler',
                    actor1 in cast, actor1 == target,
                    actor2 in cast, actor2 != target
  :limit 10
  :order -count(title)
#+end_src

#+RESULTS:
| 7 | Rob Schneider     |
| 6 | Allen Covert      |
| 5 | Nick Swardson     |
| 5 | Steve Buscemi     |
| 4 | David Spade       |
| 4 | Kevin James       |
| 3 | Blake Clark       |
| 3 | Colin Quinn       |
| 3 | John Turturro     |
| 3 | Jonathan Loughran |


#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[attr, val] := linked['title', 'Murder Mystery', attr, val]
#+end_src

#+RESULTS:
| cast         | [Adam Sandler Jennifer Aniston Luke Evans Gemma Arterton Adeel Akhtar Luis Gerardo M√©ndez Dany Boon Terence Stamp]                               |
| country      | United States                                                                                                                                    |
| description  | On a long-awaited trip to Europe, a New York City cop and his hairdresser wife scramble to solve a baffling murder aboard a billionaire's yacht. |
| director     | Kyle Newacheck                                                                                                                                   |
| duration     | 98                                                                                                                                               |
| rating       | PG-13                                                                                                                                            |
| release_year | 2019                                                                                                                                             |
| type         | Movie                                                                                                                                            |

10 longest movie titles
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title, ct] := linked['title', title, _, _], ct = length(title)
  :limit 10
  :order -ct
#+end_src 

#+RESULTS:
| Jim & Andy: The Great Beyond - Featuring a Very Special, Contractually Obligated Mention of Tony Clifton | 104 |
| Ken Burns Presents: College Behind Bars: A Film by Lynn Novick and Produced by Sarah Botstein  |  93 |
| Mike Birbiglia: What I Should Have Said Was Nothing: Tales from My Secret Public Journal       |  88 |
| The Power of Grayskull: The Definitive History of He-Man and the Masters of the Universe       |  88 |
| Steve Martin and Martin Short: An Evening You Will Forget for the Rest of Your Life            |  83 |
| Cultivating the Seas: History and Future of the Full-Cycle Cultured Kindai Tuna                |  79 |
| Power Rangers Samurai: Christmas Together, Friends Forever (Christmas Special)                 |  78 |
| Willy and the Guardians of the Lake: Tales from the Lakeside Winter Adventure                  |  77 |
| Ya no estoy aqu√≠: Una conversaci√≥n entre Guillermo del Toro y Alfonso Cuar√≥n                   |  76 |
| The Road to El Camino: Behind the Scenes of El Camino: A Breaking Bad Movie                    |  75 |

#+begin_src cozodb
  linked[a, oa, v,  ov] := *attributes[a, oa, v, ov] or *attributes[oa, a, v, ov]
  ?[count(title)] := linked['title', title, _, _], 
#+end_src 

#+RESULTS:
| 70456 |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[title] := linked['director', 'Steven Spielberg', 'title', title ], 
#+end_src 

#+RESULTS:
| Catch Me If You Can                                |
| Indiana Jones and the Kingdom of the Crystal Skull |
| Indiana Jones and the Last Crusade                 |
| Indiana Jones and the Raiders of the Lost Ark      |
| Indiana Jones and the Temple of Doom               |
| Jaws                                               |
| Lincoln                                            |
| Schindler's List                                   |
| The Adventures of Tintin                           |
| The BFG                                            |
| War Horse                                          |

#+begin_src cozodb
  ::explain {
            linked[a, v, oa, ov] := *attributes[a, v, oa, ov]
  ?[title] := linked['title', title, 'director', 'Steven Spielberg'] }
#+end_src 

#+RESULTS:
| 0 | 0 | ?      | 3         |     load_mem | ?                  | S.0.0                              | :null                             | []                 | [*1 *2 *3]          |            |
| 0 | 0 | ?      | 2         |     load_mem | linked             | Mbfbb                              | :null                             | []                 | [**0 title **1 **2] |            |
| 0 | 0 | ?      | 1         | mem_mat_join | :null              | ((*1 . **0) (*2 . **1) (*3 . **2)) | :null                             | [title]            |                     |            |
| 0 | 0 | ?      | 0         |          out | :null              | :null                              | :null                             | [title]            |                     |            |
| 0 | 1 | linked | Mbfbb     |            4 | load_mem           | linked                             | S.0.0bfbb                         | :null              | []                  | [a oa ov]  |
| 0 | 1 | linked | Mbfbb     |            3 | load_stored        | :attributes                        | :null                             | []                 | [**0 v **1 **2]     |            |
| 0 | 1 | linked | Mbfbb     |            2 | stored_mat_join    | :null                              | ((a . **0) (oa . **1) (ov . **2)) | :null              | [a oa ov v]         |            |
| 0 | 1 | linked | Mbfbb     |            1 | reorder            | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 1 | linked | Mbfbb     |            0 | out                | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 2 | linked | Mbfbb     |            4 | load_mem           | linked                             | S.1.0bfbb                         | :null              | []                  | [a oa ov]  |
| 0 | 2 | linked | Mbfbb     |            3 | load_stored        | :attributes                        | :null                             | []                 | [**0 **1 **2 v]     |            |
| 0 | 2 | linked | Mbfbb     |            2 | stored_prefix_join | :null                              | ((a . **2) (oa . **0) (ov . **1)) | :null              | [a oa ov v]         |            |
| 0 | 2 | linked | Mbfbb     |            1 | reorder            | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 2 | linked | Mbfbb     |            0 | out                | :null                              | :null                             | :null              | [a v oa ov]         |            |
| 0 | 3 | linked | Ibfbb     |            1 | load_mem           | ?                                  | S.0.0                             | :null              | []                  | [*1 *2 *3] |
| 0 | 3 | linked | Ibfbb     |            0 | out                | :null                              | :null                             | :null              | [*1 *2 *3]          |            |
| 0 | 4 | ?      | S.0.0     |            3 | unify              | *1                                 | :null                             | "title"            | [*1]                |            |
| 0 | 4 | ?      | S.0.0     |            2 | unify              | *2                                 | :null                             | "director"         | [*1 *2]             |            |
| 0 | 4 | ?      | S.0.0     |            1 | unify              | *3                                 | :null                             | "Steven Spielberg" | [*1 *2 *3]          |            |
| 0 | 4 | ?      | S.0.0     |            0 | out                | :null                              | :null                             | :null              | [*1 *2 *3]          |            |
| 0 | 5 | linked | S.0.0bfbb |            1 | load_mem           | linked                             | Ibfbb                             | :null              | []                  | [a oa ov]  |
| 0 | 5 | linked | S.0.0bfbb |            0 | out                | :null                              | :null                             | :null              | [a oa ov]           |            |
| 0 | 6 | linked | S.1.0bfbb |            1 | load_mem           | linked                             | Ibfbb                             | :null              | []                  | [a oa ov]  |
| 0 | 6 | linked | S.1.0bfbb |            0 | out                | :null                              | :null                             | :null              | [a oa ov]           |            |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[c] := linked['timezone', 'America/New_York', 'country', c]
#+end_src

#+RESULTS:
| United States |


#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v, distance] := linked['coordinates', c, a, v], distance = l2_dist(vec([35.99403, -78.89862], 'F32'), c)
  :limit 10
  :order distance
#+end_src

#+RESULTS:
#+begin_example
[31meval::throw[0m

  [31m√ó[0m Evaluation of expression failed
   ‚ï≠‚îÄ[1:1]
 [2m1[0m ‚îÇ linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
 [2m2[0m ‚îÇ ?[a, v, distance] := linked['coordinates', c, a, v], distance = l2_dist(vec([35.99403, -78.89862], 'F32'), c)
   ¬∑ [35;1m                                                                ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[0m
 [2m3[0m ‚îÇ :limit 10
   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ
[36m  help: [0m'l2_dist' requires two vectors of the same type
#+end_example

Furthest cities (the distance formula isn't quite right but
demonstrates the concept). Disambiguate the city of Durham from other
durhams, using the state.
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[v, s, country, distance] := linked['coordinates', c, 'state', 'North Carolina'], 
        linked['coordinates', c, 'name', 'Durham'],
        linked['coordinates', c2, 'name', v], distance = l2_dist(vec(c), vec(c2)),
        linked['coordinates', c2, 'state', s],
        linked['name', s, 'country', country]
        :limit 10
        :order -distance
#+end_src

#+RESULTS:
| Gisborne    | Gisborne District    | New Zealand | 71571.2578125 |
| Wairoa      | Hawke's Bay Region   | New Zealand |       71301.0 |
| Napier      | Hawke's Bay Region   | New Zealand |   71137.46875 |
| Hastings    | Hawke's Bay Region   | New Zealand |   71127.15625 |
| Taradale    | Hawke's Bay Region   | New Zealand | 71111.7421875 |
| Opotiki     | Bay of Plenty Region | New Zealand |    71107.5625 |
| Castlepoint | Wellington Region    | New Zealand |       70996.5 |
| Whakatane   | Bay of Plenty Region | New Zealand | 70945.6328125 |
| Murupara    | Bay of Plenty Region | New Zealand |  70875.046875 |
| Edgecumbe   | Bay of Plenty Region | New Zealand | 70871.4765625 |

#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v] := linked['coordinates', c, 'country', 'United States'], linked['coordinates', c, a, v]
#+end_src

#+RESULTS:
| country    | Liberia                              |
| country    | United States                        |
| name       | Alabama                              |
| name       | Alaska                               |
| name       | American Samoa                       |
| name       | Arizona                              |
| name       | Arkansas                             |
| name       | Baker Island                         |
| name       | California                           |
| name       | Colorado                             |
| name       | Connecticut                          |
| name       | Delaware                             |
| name       | District of Columbia                 |
| name       | Florida                              |
| name       | Georgia                              |
| name       | Guam                                 |
| name       | Hawaii                               |
| name       | Howland Island                       |
| name       | Idaho                                |
| name       | Illinois                             |
| name       | Indiana                              |
| name       | Iowa                                 |
| name       | Jarvis Island                        |
| name       | Johnston Atoll                       |
| name       | Kansas                               |
| name       | Kentucky                             |
| name       | Kingman Reef                         |
| name       | Louisiana                            |
| name       | Maine                                |
| name       | Maryland                             |
| name       | Maryland County                      |
| name       | Massachusetts                        |
| name       | Michigan                             |
| name       | Midway Atoll                         |
| name       | Minnesota                            |
| name       | Mississippi                          |
| name       | Missouri                             |
| name       | Montana                              |
| name       | Navassa Island                       |
| name       | Nebraska                             |
| name       | Nevada                               |
| name       | New Hampshire                        |
| name       | New Jersey                           |
| name       | New Mexico                           |
| name       | New York                             |
| name       | North Carolina                       |
| name       | North Dakota                         |
| name       | Northern Mariana Islands             |
| name       | Ohio                                 |
| name       | Oklahoma                             |
| name       | Oregon                               |
| name       | Palmyra Atoll                        |
| name       | Pennsylvania                         |
| name       | Puerto Rico                          |
| name       | Rhode Island                         |
| name       | South Carolina                       |
| name       | South Dakota                         |
| name       | Tennessee                            |
| name       | Texas                                |
| name       | United States Minor Outlying Islands |
| name       | United States Virgin Islands         |
| name       | Utah                                 |
| name       | Vermont                              |
| name       | Virginia                             |
| name       | Wake Island                          |
| name       | Washington                           |
| name       | West Virginia                        |
| name       | Wisconsin                            |
| name       | Wyoming                              |
| state_code | AK                                   |
| state_code | AL                                   |
| state_code | AR                                   |
| state_code | AS                                   |
| state_code | AZ                                   |
| state_code | CA                                   |
| state_code | CO                                   |
| state_code | CT                                   |
| state_code | DC                                   |
| state_code | DE                                   |
| state_code | FL                                   |
| state_code | GA                                   |
| state_code | GU                                   |
| state_code | HI                                   |
| state_code | IA                                   |
| state_code | ID                                   |
| state_code | IL                                   |
| state_code | IN                                   |
| state_code | KS                                   |
| state_code | KY                                   |
| state_code | LA                                   |
| state_code | MA                                   |
| state_code | MD                                   |
| state_code | ME                                   |
| state_code | MI                                   |
| state_code | MN                                   |
| state_code | MO                                   |
| state_code | MP                                   |
| state_code | MS                                   |
| state_code | MT                                   |
| state_code | MY                                   |
| state_code | NC                                   |
| state_code | ND                                   |
| state_code | NE                                   |
| state_code | NH                                   |
| state_code | NJ                                   |
| state_code | NM                                   |
| state_code | NV                                   |
| state_code | NY                                   |
| state_code | OH                                   |
| state_code | OK                                   |
| state_code | OR                                   |
| state_code | PA                                   |
| state_code | PR                                   |
| state_code | RI                                   |
| state_code | SC                                   |
| state_code | SD                                   |
| state_code | TN                                   |
| state_code | TX                                   |
| state_code | UM                                   |
| state_code | UM-67                                |
| state_code | UM-71                                |
| state_code | UM-76                                |
| state_code | UM-79                                |
| state_code | UM-81                                |
| state_code | UM-84                                |
| state_code | UM-86                                |
| state_code | UM-89                                |
| state_code | UM-95                                |
| state_code | UT                                   |
| state_code | VA                                   |
| state_code | VI                                   |
| state_code | VT                                   |
| state_code | WA                                   |
| state_code | WI                                   |
| state_code | WV                                   |
| state_code | WY                                   |

** Using an artificial entity column
#+begin_src cozodb :results value table
{:create eav {entity: Uuid, attribute: String, value: Any}}
#+end_src

What type should =entity= be? Some keys are uuids that link to pk attrs,
others are just the entity id. Maybe everything should use uuid? 
** Add source and time columns
#+begin_src cozodb :results value table
  {:create trust {source: Bytes,
                  target: Bytes,
                  with: Any,
                  ts: Validity default 'ASSERT'
                  =>
                  score: Int,
                  }}
#+end_src

#+RESULTS:
| [31mparser::pest[0m |


#+begin_src cozodb
::remove trust
#+end_src

#+RESULTS:
: [31mquery::relation_not_found[0m
: 
:   [31m√ó[0m Cannot find requested stored relation 'trusted_attributes'

#+begin_src cozodb 
  ?[source, target, with, ts, score] <-
  [
   ["bWU=", "QWxpY2U=", 'introduce', 'ASSERT', 11]       
  ]
  :put trust {source, target, with, ts, score}
#+end_src

#+RESULTS:
: [31meval::invalid_validity[0m
: 
:   [31m√ó[0m when executing against relation 'trust'
: [31m  ‚îú‚îÄ‚ñ∂ [0mwhen processing tuple ["bWU=", "QWxpY2U=", "introduce", [1703279106.2922018, true], 10]
: [31m  ‚ï∞‚îÄ‚ñ∂ [0m[1703279106.2922018, true] cannot be coerced into validity

#+begin_src cozodb
::relations
#+end_src

#+RESULTS:
| attributes     | 4 | normal | 4 | 0 | 0 | 0 | 0 |   |
| attributes:rev | 4 | index  | 4 | 0 | 0 | 0 | 0 |   |
| trust          | 5 | normal | 4 | 1 | 0 | 0 | 0 |   |

#+begin_src cozodb
?[source, target, with, score] := *trust[source, target, with, ts, score @ 'NOW']
#+end_src

#+RESULTS:
| bWU= | QWxpY2U= | introduce | 11 |

** Questions
What about when we insert "name=Alice, height=1.2", and then later
"name=Alice, height=1.3"?

I think part of the problem is we can't just arbitrarily pair
attributes, one of them has to be the "key".

For example, let's say we don't do that and we have:
[name Alice, height 1.6]
[height 1.6, weight 50]

In this case the "link" is height. But we don't want to link to
anything that's 1.6m high.

The first attribute has to be something that identifies the
entity. But as we know, not every entity has a single attribute that
uniquely identifies it. eg Person. The name isn't unique, but let's
say name+birthday is unique.

[name Alice, height 1.6]
[name Alice, bday 1/1]
[name Alice, bday 6/4]
[name Alice, height 1.3]

What we need is a unique id to attach to her attributes:

[id 1, name Alice]
[id 1, bday 1/1]
;; now we can hang other attrs off the id
[id 1, height 1.6]

One question is, does every entity have some unique attribute? It may,
but either we may not know it or it's really a combination of more
than one.

So there's several solutions,
+ Make the first attr a compound of multiple actual attrs, and make
  the individual ones linked from there.
+ Hash the multiple attrs

 If the attrs are a tuple, in theory we can fetch the record directly
  ,if the user knows how the key is built. THat's better than a
  generated id which the user is guaranteed not to know. So given
  this, let's remodel.

** kcats query format
#+begin_src cozodb
  linked[a, v, oa, ov] := *attributes[a, oa, v,  ov] or *attributes:rev[a, oa, v, ov]
  ?[a, v] := linked['coordinates', c, 'country', 'United States'], linked['coordinates', c, a, v]
#+end_src

Let's say we wanted to write this query as kcats data instead of a string. How?
We've got 2 rules, one with an =or= and the other an =and=.

We could create some words to build some more explicit objects.
#+begin_src kcats
  [a v oa ov] [linked]  
  [a oa v ov] [attributes] rel ;; *attributes[a, oa, v,  ov]
  [a oa v ov] [attributes rev] index ;; *attributes:rev[a, oa, v, ov]
  or
  rule
  [a v] [?]
  ["coordinates" c "country" "United States"] [linked] rel
  ["coordinates" c a v] [linked] rel
  and
  rule

#+end_src

Of course, the most straightforward is to probably just build the
query string, it's just a bit error prone and inefficient.

Let's do that query and dump the parsed object, so we can imitate it a bit:

#+begin_src rust :crates '(cozo)
  extern crate cozo;
  use cozo;

  fn main() {
      let db = DbInstance::new("mem", "", Default::default());
      db.par
  }
#+end_src
Ok nevermind those functions that deal with parsed scripts are
private. I guess we'll have to just build the query string!

#+begin_src kcats
  [[comma-separate [[string] map ", " interpose "" swap [join] step]]]
  [[a b c d] comma-separate]
  let
#+end_src

#+RESULTS:
#+begin_src kcats
"a, b, c, d"
#+end_src

** Import into cozo by reading json
#+begin_src kcats
  "Ama Qamata, Khosi Ngema, Gail Mabalane, Thabang Molaba, Dillon Windvogel, Natasha Thahane, Arno Greeff, Xolile Tshabalala, Getmore Sithole, Cindy Mahlangu, Ryle De Morny, Greteli Fincham, Sello Maake Ka-Ncube, Odwa Gwanya, Mekaila Mathys, Sandi Schultz, Duane Williams, Shamilla Miller, Patrick Mofokeng"
  [", " split] assemble
#+end_src

#+RESULTS:
#+begin_src kcats
["Ama Qamata" "Khosi Ngema" "Gail Mabalane" "Thabang Molaba" "Dillon Windvogel" "Natasha Thahane"
 "Arno Greeff" "Xolile Tshabalala" "Getmore Sithole" "Cindy Mahlangu" "Ryle De Morny"
 "Greteli Fincham" "Sello Maake Ka-Ncube" "Odwa Gwanya" "Mekaila Mathys" "Sandi Schultz"
 "Duane Williams" "Shamilla Miller" "Patrick Mofokeng"]
#+end_src

#+begin_src kcats
  "/home/jweiss/Downloads/netflix_titles.json" file-out slurp decodejson 

  [[
  [[second [[string?]
            [\" contains?]] [execute] every?] any? not] keep
    [["cast"] [[", " split] assemble] update
     [take] [] into 
     encodejson "u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- {} ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}"
     swap wrap format database
    ]
    each]
   assemble 
   count]
  [[unwound] unassign dropdown] recover
#+end_src

#+RESULTS:
#+begin_src kcats
8450
#+end_src

#+begin_src kcats
  dictionary

  [[
  [[second [[string?]
            [\" contains?]] [execute] every?] any? not] keep
    [["cast"] [[", " split] assemble] update
     [take] [] into 
     encodejson "u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- {} ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}"
     swap wrap format database
    ]
    each]
   assemble 
   count]
  [[unwound] unassign dropdown] recover
#+end_src


#+begin_src cozodb
  u[uuid] <- [[rand_uuid_v1()]] av[attribute, value] <- [["cast",[]],["show_id","s11"],["release_year",2021],["title","Vendetta: Truth, Lies and The Mafia"],["director",""],["country",""],
          ["duration","1 Season"],["description","Sicily boasts a bold 'Anti-Mafia' coalition. But what happens when those trying to bring down organized crime are accused of being criminals themselves?"],["type","TV Show"],["date_added","September 24, 2021"],["rating","TV-MA"],["listed_in","Crime TV Shows, Docuseries, International TV Shows"]] ?[entity, attribute, value] :=  av[attribute, value], u[entity] :put eav {entity, attribute, value}

#+end_src

#+RESULTS:
| OK |


#+begin_src cozodb
  u[uuid] <- [[rand_uuid_v1()]]
  av[attribute, value] <- [["release_year",2021],["director","Julien Leclercq"],["description","To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war."],["duration","1 Season"],["rating","TV-MA"],["title","Ganglands"],["cast",["Sami Bouajila","Tracy Gotoas","Samuel Jouy","Nabiha Akkari","Sofia Lesaffre","Salim Kechiouche","Noureddine Farihi","Geert Van Rampelberg","Bakary Diombera"]],["type","TV Show"],["date_added","September 24, 2021"],["country",""],["listed_in","Crime TV Shows, International TV Shows, TV Action & Adventure"],["show_id","s3"]]
  ?[entity, attribute, value] :=  av[attribute, value], u[entity]

  :put eav {entity, attribute, value} :returning

#+end_src

#+RESULTS:
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | cast         | [Sami Bouajila Tracy Gotoas Samuel Jouy Nabiha Akkari Sofia Lesaffre Salim Kechiouche Noureddine Farihi Geert Van Rampelberg Bakary Diombera]      |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | country      |                                                                                                                                                    |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | date_added   | September 24, 2021                                                                                                                                 |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | description  | To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war. |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | director     | Julien Leclercq                                                                                                                                    |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | duration     | 1 Season                                                                                                                                           |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | listed_in    | Crime TV Shows, International TV Shows, TV Action & Adventure                                                                                      |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | rating       | TV-MA                                                                                                                                              |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | release_year | 2021                                                                                                                                               |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | show_id      | s3                                                                                                                                                 |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | title        | Ganglands                                                                                                                                          |
| inserted | 36fc42bd-a775-11ee-a783-d0c86867d02e | type         | TV Show                                                                                                                                            |

#+begin_src cozodb
  linked[a1, v1, a2, v2] := *eav[id, a1, v1], *eav[id, a2, v2]
             ?[title] := linked['title', title, 'cast', cast],
              actor1 in cast,
              actor2 in cast,
              actor1 == 'Adam Sandler', actor2 == 'David Spade'
#+end_src

#+RESULTS:
| Grown Ups                             |
| Hotel Transylvania 3: Summer Vacation |
| The Do-Over                           |
| The Ridiculous 6                      |

#+begin_src cozodb
    linked[a1, v1, a2, v2] := *eav:v[v1, id, a1], *eav:v[v2, id, a2]
    ?[count(title), actor2] := linked['title', title, 'cast', cast],
                      target = 'Adam Sandler',
                      actor1 in cast, actor1 == target,
                      actor2 in cast, actor2 != target
    :limit 10
    :order -count(title)
#+end_src

#+RESULTS:
| 7 | Rob Schneider     |
| 6 | Allen Covert      |
| 5 | Nick Swardson     |
| 5 | Steve Buscemi     |
| 4 | David Spade       |
| 4 | Kevin James       |
| 3 | Blake Clark       |
| 3 | Colin Quinn       |
| 3 | John Turturro     |
| 3 | Jonathan Loughran |

#+begin_src cozodb
::index create eav:v {value, entity, attribute}
#+end_src

#+RESULTS:
| OK |

#+begin_src cozodb
  linked[id, a1, v1, a2, v2] := *eav:v[v1, id, a1], *eav:v[v2, id, a2]
  ?[id, a, v] := linked[id, 'title', title, 'director', 'Steven Spielberg'],
           *eav[id, a, v]


#+end_src

