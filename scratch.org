#+PROPERTY: header-args:kcats :results code :exports both


* Stuff
#+begin_src kcats
  1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] generator
#+end_src

#+RESULTS:
#+begin_src kcats
[[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥ [[[[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸]
0 1
#+end_src

#+begin_src kcats
  1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] generator ;; our original generator
  [odd?] keep ;; a generator that keeps calling the one
              ;; below it until it gets something that
              ;; passes the predicate we specified
  4 taker ;; another generator that calls generate 20 times
  â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸  ğŸ—‘ï¸ â–¶ï¸  ğŸ—‘ï¸ â–¶ï¸  ğŸ—‘ï¸ â–¶ï¸  
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ [[[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] 5 8
#+end_src

#+begin_src kcats
  [1 2 3 4 5] liberator
  [3 >]  
  [âœ‚ï¸2ï¸âƒ£ ;; â–¶ï¸ the generator below to get value v
   [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
   [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
   â†”ï¸ dump â€¢â€¢ğŸ—‘ï¸] ğŸ’ 
  [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
  â³ ;; repeat until generator below is finished
   â–¶ï¸ dump
   [ â€¢ğŸ—‘ï¸
   ] [ğŸ”³] [ ğŸ”€] ğŸª†
   ;â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸
   collect
#+end_src

#+RESULTS:
#+begin_src kcats
[âœ”ï¸ 1 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [2 3 4 5]]
[âœ”ï¸ 2 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [3 4 5]]
[âœ”ï¸ 3 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [4 5]]
[ğŸ”³ 4 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [5]]
[4 [5]]
[[actual 4]
 [asked [program?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [type error]
 [unwound [ğŸª† collect]]]
[ğŸ”€] [ğŸ”³] [â€¢ğŸ—‘ï¸] 4 [5]
#+end_src

#+begin_src kcats
  [1 2 3 4 5] liberator
  [3 >]
  [2ï¸âƒ£  ;; â–¶ï¸ the generator below to get value v
   [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
   [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
   âš–ï¸
   [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
   â³] ;; repeat until generator below is finished
  ğŸ’   â–¶ï¸ 
 ; ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸ [[3 >]
       ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸]
 [ğŸ”³ ğŸ”³]
 â†”ï¸ [ğŸ—‘ï¸ ğŸ—‘ï¸ [[ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
             ğŸ”³ â†”ï¸ [[3 >]
                   ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸]
             [ğŸ”³ ğŸ”³]
             â†”ï¸]
            [ğŸ—‘ï¸ ğŸ—‘ï¸]
            ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸]
     â–¶ï¸]
 ğŸ”³ â†”ï¸]
[1 2 3 4 5]
#+end_src

#+begin_src kcats
  [1 2 3 4 5] liberator
  [3 >]

  [2ï¸âƒ£ ;; pull the parent generator into this program
   [â–¶ï¸  ;; exec the generator below to get value v
    [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
    [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
    â†”ï¸]
   [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
   â³ â–¶ï¸ ] ;; repeat until generator below is finished
  ğŸ’
  [â€¢ğŸ—‘ï¸] [ğŸ”³] [ğŸ”€] ğŸª†
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[4 5]
#+end_src

Use normal recursive fn for generators instead of recur?
#+begin_src kcats
[1 2 3 4] liberator
#+end_src

#+RESULTS:
#+begin_src kcats
[ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸]
[1 2 3 4]
#+end_src

#+begin_src kcats
  [1 2 3 4] [ğŸ“¤ [[liberator] ğŸª„] [[]] â†”ï¸] â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
1 [ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
   ğŸ”³ â†”ï¸]
[2 3 4]
#+end_src

#+begin_src kcats
  [[lib [[ğŸ“¤ [[lib] ğŸª„] [[]] â†”ï¸]]]]
  [[1 2 3 4] lib â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸]
  let â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
2 [ğŸ“¤ [[lib] ğŸª„]
   [ğŸ”³] â†”ï¸]
[3 4]
#+end_src

#+begin_src kcats
  [[taker [[[[positive?] ğŸ›¡ï¸ ;; counter still positive?
             [ğŸ—‘ï¸ 1ï¸âƒ£ ğŸ‹]  ;; run the parent generator
             [ğŸ”³] âš–ï¸ â–¶ï¸ ] ğŸ’] ğŸ‹ 
           [[dec â€¢ğŸ—‘ï¸] ğŸª„ dump taker ğŸ”€ ]
           []
           âš–ï¸]]]
  [[1 2 3 4 5] liberator
  3 taker â–¶ï¸ ğŸ—‘ï¸]
  let â–¶ï¸ 
  ;;taker

#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 [2 3 4 5]]
[[positive?] ğŸ›¡ï¸ [ğŸ—‘ï¸ 2 ğŸ‹] [ğŸ”³] âš–ï¸ â–¶ï¸ [[dec â€¢ğŸ—‘ï¸]
                                    ğŸª„ dump taker ğŸ”€]
 ğŸ”³ â†”ï¸]
[2 3 4 5]
#+end_src

* Fold
#+begin_src kcats
    integers generator 25 taker [+]
    [â–¶ï¸] ğŸª„ ;; generate the first item below the fold program 
    [[â–¶ï¸] â€¢ğŸ‹]
    [ğŸ”€  [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸ âš“ â€¢ğŸ—‘ï¸ â€¢â€¢ğŸ—‘ï¸] [] [â–¶ï¸] ğŸª† â–¶ï¸ ğŸ—‘ï¸
    ;[[â–¶ï¸] ğŸ‹ ğŸ”³ [âœ‚ï¸1ï¸âƒ£ ğŸ‘¥] â†”ï¸] ğŸ’
    ;;; generate the first item under the loop body
    ;[â–¶ï¸] ğŸª„
   ; ğŸŒ€ ; â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
300 24
#+end_src
org-tanglesync-
* Introspection
Search the docs of emoji words to see which symbol you're looking for
#+begin_src kcats
  words [[1 doc] lookup "swap" contains?] ğŸ§² â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[ğŸ”€ [[definition builtin-function]
     [doc "The crossing arrows denote swapping the top two stack items."]
     [examples [[[1 2 3 ğŸ”€] [1 3 2] "Swap top two items"]]]
     [spec [[[item a]
             [item b]]
            [[item b]
             [item a]]]]]]
 [â€¢ğŸ”€ [[definition builtin-function]
      [doc "The crossing arrows with dot represents swapping one stack position down (2nd and 3rd items)"]
      [examples [[[1 2 3 â€¢ğŸ”€] [2 1 3] "Swap 2nd and 3rd items"]]]
      [spec [[[item a]
              [item b]
              [item c]]
             [[item a]
              [item c]
              [item b]]]]]]]
#+end_src

apropos - which functions match the stuff on the stack
#+begin_src kcats
  5
  ;; the hierarchy
  [item
   [[number [[integer []]
             [float []]]]
    [container [[disp]]]]]
  ğŸ“¸ [type] ğŸšœ â–¶ï¸
  [integer foo]


  [list?] ğŸ›¡ï¸ [ğŸ—‘ï¸ first ğŸ] when â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[integer] [number] 5
#+end_src
* Single-item generators
#+begin_src kcats
  [integers generator 100 taker [ğŸ‘¥ *] each [7 mod 0 =] keep]
  [] ğŸ”€ ğŸ’‰ â–¶ï¸ ;; encapsulate
  [[â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤] [] [] [ğŸ—‘ï¸] ğŸª† â–¶ï¸

#+end_src

#+RESULTS:
#+begin_src kcats
0 [[[â–¶ï¸ [[7 mod 0 =] ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] [ğŸ”³ ğŸ”³]
     â†”ï¸ [ğŸ—‘ï¸ ğŸ—‘ï¸ [[â–¶ï¸ [[7 mod 0 =] ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] [ğŸ”³ ğŸ”³]
                 â†”ï¸]
                [ğŸ—‘ï¸ ğŸ—‘ï¸]
                ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸]
         â–¶ï¸]
     ğŸ”³ â†”ï¸]
    ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
   [[â–¶ï¸ [ğŸ“¸ ğŸ§¦ [ğŸ‘¥ *]
         ğŸª„ ğŸ§¦ â€¢ğŸ—‘ï¸ first]
     bail]
    ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
   [[ğŸ“¸ ğŸ§¦ [positive?] ğŸª„ ğŸ§¦ first [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ğŸ”³ [ğŸ”³ ğŸ”³]
                                â†”ï¸]
     [ğŸ”³] â†”ï¸]
    [[dec] ğŸª„]
    [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
   99 [[inc ğŸ‘¥]
       ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸]
   0]
#+end_src
#+begin_src kcats
  integers generator 100 taker [ğŸ‘¥ *] each [7 mod 0 =] keep collect
#+end_src

#+RESULTS:
#+begin_src kcats
[0 49 196 441 784 1225 1764 2401 3136 3969 4900 5929 7056 8281 9604]
99
#+end_src

* Fix 'type'
#+begin_src kcats
   [[a b][c d][type foo]] association

   [[type] lookup]
   [ğŸ“ 1 =]
   [first [type] ğŸ« =]
   [ğŸ—‘ï¸ first second]
   [first first]
   âš–ï¸ 
   [ğŸ”³]
   âš–ï¸
   [[association] ğŸ«]
   triplet
  [â–¶ï¸] ğŸ“£ ; â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[ğŸ”€ [[ğŸ“¤] ğŸª„ ğŸ‘¥ [ğŸ›Ÿ [â€¢ğŸ›¡ï¸] ğŸ‹] ğŸ‹ ğŸ”³ [â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸]
    [ğŸ—‘ï¸ ğŸ“£]
    âš–ï¸]
 [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] â†”ï¸]
[â–¶ï¸] [[[type] lookup]
      [ğŸ“ 1 = [first [type] ğŸ« = [ğŸ—‘ï¸ first second] [first first]
              â†”ï¸]
       [ğŸ”³] â†”ï¸]
      [[association] ğŸ«]]
[[a b]
 [c d]
 [type foo]]
#+end_src
* Fix any
#+begin_src kcats
  ;; start with ğŸ’¯
  [[] 4 6 8 9 10] []
  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥ â˜¯ï¸] ;; more items
   [[] ğŸ”³ []] ;; empty list, return []
   â†”ï¸ ] ğŸ’
  [ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [â–¶ï¸] ğŸª† â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src
* Fix pair?
#+begin_src kcats
   [ğŸ“ 2 =] [[asked] lookup [sized?] =] [ğŸ—‘ï¸ ğŸ—‘ï¸ []] [[]] âš–ï¸  ğŸ©¹ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³
#+end_src
* fix zip
#+begin_src kcats
  "foo" "food"
  ğŸ”³ âš“ ;; save accumulator below args
  [[] both?] ğŸ›¡ï¸ ;; stop when either list is empty
  [ğŸ—‘ï¸ [ğŸ“¤] both â€¢ğŸ”€ pair ;; take from each list and pair them up
   âš“ [ğŸ“®] â€¢ğŸª„] ;; put them into the accumulator
  â³ â–¶ï¸
  ğŸ—‘ï¸ ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[\f \f]
 [\o \o]
 [\o \o]]
#+end_src
* fix 'both'
#+begin_src kcats
1 2 [inc] [pair] ğŸª„ ğŸªœ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
3 2
#+end_src
* fix starts?
#+begin_src kcats
  "food" "foo"
  [[zip [ğŸ« =] ğŸ’¯ â–¶ï¸] ;; the items at matching indexes are equal
   [[ğŸ“] both >=]] ;; the prefix is shorter than the target
  [â–¶ï¸] â€¢ğŸ›¡ï¸ ğŸ’¯ â–¶ï¸ 
  â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
["foo" "food"]
["foo" "food"]
âœ”ï¸
#+end_src
* fix type
#+begin_src kcats
  [[forp foo] [bloop toop]]
  [ğŸ“ 1 =] ğŸ›¡ï¸
  [ğŸ—‘ï¸ first first [type] ğŸ« =] ğŸ›¡ï¸
  [ğŸ—‘ï¸ ğŸ—‘ï¸ first second]
  [ğŸ—‘ï¸ first first]
  âš–ï¸
  [ğŸ”³]
  âš–ï¸ 

  [[type] lookup]
  [[association] ğŸ«]
  â€¢ğŸ”€ triplet 
  [ğŸ›¡ï¸ â–¶ï¸] ğŸ“£ â–¶ï¸ â€¢ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
association
#+end_src

#+begin_src kcats
  [[typef foo]]
  [[[ğŸ“ 1 =] [ğŸ—‘ï¸
              [first first [type] ğŸ« =] ğŸ›¡ï¸
              [ğŸ—‘ï¸ first second]
              [first first]
              âš–ï¸ â–¶ï¸]]
   [[[type] lookup] [â€¢ğŸ—‘ï¸]]
   [[âœ”ï¸] [[association] ğŸ«]]] decide
#+end_src

#+RESULTS:
#+begin_src kcats
typef
#+end_src

#+RESULTS:
#+begin_src kcats
âœ”ï¸
#+end_src

#+begin_src kcats
   ;[[type foo] [x y]] association
   ;"foo" encodestring
   [[types bar] [sdf fdsd]] association
   [[[empty?] [[nothing]]]
    [[word?] [[word]]]
    [[number?] [[number]]]
    [[string?] [[string]]]
    [[bytes?] [[bytes]]]
    [[pipe?] [[pipe]]]
    [[error?] [[error]]]
    [[environment?] [[environment]]]
    [[set?] [[set]]]
    [[association?] [ğŸ—‘ï¸ [[[ğŸ“ 1 =] [ğŸ—‘ï¸
                                   [first first [type] ğŸ« =] ğŸ›¡ï¸
                                   [ğŸ—‘ï¸ first second]
                                   [first first]
                                   âš–ï¸ â–¶ï¸]]
                      [[[type] lookup] [â€¢ğŸ—‘ï¸]]
                      [[âœ”ï¸] [[association] ğŸ« â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸ dump]]] decide
                     ğŸ [] [] ğŸ›Ÿ]]
    [[list?] [[list]]]
    [[âœ”ï¸] [[item]]]]
   decide ğŸ« â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[association]]
association
#+end_src
* book
#+begin_src kcats
  [[price 15][name foo]] [[price 10] [name bar]] pair [[price] lookup] sort reverse first
#+end_src

#+RESULTS:
#+begin_src kcats
[[price 15]
 [name foo]]
#+end_src
* loop in terms of recur
  avoids running pack each time:
  #+begin_src kcats
    10 âœ”ï¸ [ğŸ—‘ï¸ -2 * ğŸ‘¥ 50 <]
    [] ğŸ”€ [] [â–¶ï¸] ğŸª† 
    â–¶ï¸
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  160
  #+end_src
* COMMENT until
#+begin_src kcats
    2 [even?] [inc] generator
  ;[ğŸ­] ğŸª„ â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[inc [[[inc] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸]
[even?] 2
#+end_src

#+begin_src kcats
   2 [even?]  ğŸ›¡ï¸ [ğŸ—‘ï¸ inc]
   [ğŸ­] ğŸª„ ;; reverse logic of pred
   ;; run body once, with dummy pred result
   ğŸ‘¥ [[[]] ğŸ”€ ğŸ”— ğŸª„] ğŸª„ â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src
* advance
#+begin_src kcats
  [1 2 +] stage
  [[program] lookup ğŸ“] ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ;; count up the program length, we'll run until it's smaller than this

  [[[program] lookup ğŸ“] ğŸ›¡ï¸ â–¶ï¸ dump  ;; only stop if expr empty or shorter than we started off
   [[ positive?] [<=]] [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ ğŸ›¡ï¸ â–¶ï¸ ]
  [ğŸ—‘ï¸ eval-step]  ;; evaluate the environment one step
  â³ â–¶ï¸
  â€¢ğŸ—‘ï¸
#+end_src

#+begin_src kcats
  [1 2 ] stage
  ğŸ‘¥ [program] lookup ğŸ“ ğŸ”€
  [[program] lookup ğŸ“
   [[positive?] [<=]] [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ â–¶ï¸] ğŸ›¡ï¸ 
  [ğŸ—‘ï¸ eval-step]
  â³ â–¶ï¸ â€¢ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[dictionary [[modules ğŸ”³]
              [words 260_entries]]]
 [program [2]]
 [stack [1]]]
#+end_src
* using
#+begin_src kcats
  [#b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U"]
  [words [fibonacci] lookup]
  stage ğŸ”€ ;; lm env
  [[stack] [ğŸ“¸] â€¢ğŸ‹ assign] ğŸª„ ;; capture the stack at runtime
  using ;; set up the resolver 
  evaluate ;; execute the program in the inner environment
  [stack] lookup restore
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³
#+end_src

#+RESULTS:
#+begin_src kcats
Error parsing input: [[asked [read]] [reason "Invalid float"] [type error]]
#+end_src

#+begin_src kcats
  dictionary #b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U" decache
  [[hashbytes] ;; calculate module hash
   [string read  [words] ğŸ”€ dump update]] ;; install the module in the dictionary
  [â–¶ï¸] ğŸšœ â–¶ï¸ ;; fork 
  â€¢ğŸ—‘ï¸ ğŸ« â€¢ğŸ”€ ;dictmerge
#+end_src

#+RESULTS:
#+begin_src kcats
[[[[fibonacci [[definition [1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥]]]]]] ğŸ”—]
 [words] [[modules ğŸ”³]
          [words 260_entries]]]
[[modules ğŸ”³]
 [words 261_entries]]
[[modules ğŸ”³]
 [words 260_entries]]
#b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U"
#+end_src

#+begin_src kcats
words [[fibonacci [[definition [1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥]]]]]]
ğŸ”—

#+end_src

#+RESULTS:
#+begin_src kcats
261_entries
#+end_src

figure out which modules are present
#+begin_src kcats
  dictionary #b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U" decache

  inscribe
  [words [[0] lookup] ğŸšœ â–¶ï¸] [program dictionary] label evaluate
  ;[first] ğŸšœ â–¶ï¸ 
  ;first ;second inspect
#+end_src

#+RESULTS:
#+begin_src kcats
[[dictionary [[modules ğŸ”³]
              [words 261_entries]]]
 [program ğŸ”³]
 [stack [[â€¢ğŸ‹ tunnel â€¢â€¢ğŸ‹ cache > parse-utf8 emit get each cut â–¶ï¸ top ğŸ’‰ floor set use
          ğŸ©¹ file-out frequencies inspect
          â€¢ğŸ›¡ï¸ future â€¢ğŸª„ ğŸ§¹ assign walk zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U/fibonacci
          ğŸ« ğŸªœ string stepper ğŸ string? empty environment character resolve list? encodejson
          empty?
          quot ğŸ—‘ï¸ addmethod catcher evaluate ğŸ“ radix update autoformat indexed days association
          inc advance ğŸ”€ standard abs dec sqrt finished?
          pair? until ğŸ“® within? prime draft max-by using pipe? ğŸ›Ÿ reap heatmap parse >= â³ both?
          decide â€¢â€¢ğŸ‘¥ pop min-by
          first attend rest taker hours ğŸ’¯ range ğŸ§¦ under indexof starts? format number exp handoff
          set? timestamps compare-by let capture
          fail random odd? or split definition and intersection <= spit serversocket ğŸ’ tos
          slice sort-indexed encodenumber sprint confine pair lookup
          stage socket â€¢â€¢ğŸª„ timer min both = interpose assemble ğŸ‘¥ rem bail pipe-out sender repetition
          sign â€¢ğŸ”€ + * verify
          ğŸª† round association? - ğŸšœ breakpoint spawn resume last encodestring flip second ğŸª„
          dipped combinations when dump label ğŸ‹ â†”ï¸
          break ğŸ”— skipper joiner dictmerge sleep encode error? contains? â€¢â€¢ğŸ—‘ï¸ slurp print method?
          file-in keep minutes sort times fold generator
          ğŸŒ€ positive? mod bytes? words seconds bits ends? receiver animate group word? max
          â€¢â€¢ğŸ›¡ï¸ pipe-in cram handle â€¢ğŸ—‘ï¸ ğŸ›¡ï¸ dropper
          over integers log number? milliseconds liberator pad read type ğŸ“¤ even? zip triplet
          assert database environment? / close flatten butlast
          ğŸ§² xor primrec zero? prepend eval-step âš“ negative? hashbytes â˜¯ï¸ decodejson something?
          tracer restore persist value collect produce ğŸ­ ceiling
          reverse retry updates parse-edn word dictionary key compare unassign âœ”ï¸ decache select
          â€¢ğŸ‘¥ ğŸ“¸ âš–ï¸ ğŸ“£ indexer entry module inscribe
          <]]]]
#+end_src
* Fix sweep
#+begin_src kcats
  0 10 1 range liberator
  5 dropper [10 *] each []
  [[â–¶ï¸] ğŸ‹] [ğŸ“®] [â€¢ğŸ—‘ï¸] [â–¶ï¸] ğŸª† â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[50 60 70 80 90]
#+end_src
* fix group
#+begin_src kcats
  [1 2 3 4 5] liberator [odd?]
  ğŸ›¡ï¸
  [1ï¸âƒ£ â–¶ï¸ ;; k v state
   ğŸ ğŸ”€   ;;  v k state
   ğŸ [ğŸ“®] ğŸ”—  update] ğŸ’
  ğŸ”³ association ;; state f
  ğŸ”€ cram
#+end_src

#+RESULTS:
#+begin_src kcats
[[âœ”ï¸ [1 3 5]]
 [ğŸ”³ [2 4]]]
ğŸ”³
#+end_src
* fix partition
#+begin_src kcats
    [[take-chunk [[taker collect dump
                  ; â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸
                  ] ; drop the used-up taker generator
                  ğŸ”— â€¢ğŸ‹]]
     [shift [[ğŸ“ <=]
             [ğŸ”€ 0 slice]
             [ğŸ”³] âš–ï¸ ğŸ›¡ï¸ â–¶ï¸ ğŸ”€]]
     [partition [[over ğŸ take-chunk [ğŸ”— shift] bail]
                 [[over] ğŸ‹ wrap take-chunk ğŸ”€ ğŸ—‘ï¸ shift]
                 â†”ï¸]]]
     [[1 2 3 4 5 6 7] [ 2 2 partition] assemble] let â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2]
 [3 4 5 6 7]]
[[actual 2]
 [asked [sized?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [type error]
 [unwound [ğŸ”— shift ğŸ”³ ğŸ§¦ first]]]
[1 2]
2 2 [3 4 5 6 7]
#+end_src
* fix produce
#+begin_src kcats
  [integers generator
   [ğŸ‘¥ *] each
   10 dropper] [] ğŸ”€ ğŸ’‰ â–¶ï¸
  [â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤ ğŸ—‘ï¸ 
  [â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤
#+end_src

#+RESULTS:
#+begin_src kcats
121 [[[â–¶ï¸ [ğŸ“¸ ğŸ§¦ [ğŸ‘¥ *]
           ğŸª„ ğŸ§¦ â€¢ğŸ—‘ï¸ first]
       bail]
      ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
     [[inc ğŸ‘¥]
      ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
     11]
#+end_src
* fix parse
#+begin_src kcats
  [[104 101 108 108 111]              ;; "hello" (all ASCII)
   [228 189 160 229 165 189]          ;; "ä½ å¥½" (two complete Chinese chars)
   [104 105 226]                      ;; "hi" + start of "â‚¬"
   [130 172]                          ;; completion of "â‚¬"
   [240 159 145]                      ;; start of "ğŸ‘‘"
   [145]                              ;; completion of "ğŸ‘‘"
   [97 98 99 240]                     ;; "abc" + start of "ğŸŒˆ"
   [159 140 136]]                     ;; completion of "ğŸŒˆ"



  liberator
  [#b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸] each ;; convert lists of ints to byte arrays
  [parse-utf8]

  ğŸ”³ ğŸ”³ ;; state - parsed object output (on top) and unparsed input 

  [[ğŸ‘¥ â˜¯ï¸] ; there's no output
   [ğŸ—‘ï¸ [â–¶ï¸] â€¢â€¢ğŸ‹] ;; exec parent generator 
   [[]] ;; leave an empty value to be consumed by outer â³ exiting
   âš–ï¸ 
   [ğŸ”€ [ğŸ”—] ğŸª„ ;; new input to previous input
    [ğŸ‘¥] â€¢ğŸ‹ â–¶ï¸] ;; exec a copy of parser program: output input parser
   â³ â–¶ï¸] ;; leave the output on top for the recurrence condition check
  [ğŸ“¤] []
  [ğŸ”€] ğŸª† "" ğŸ§¹ â–¶ï¸ 


#+end_src

#+RESULTS:
#+begin_src kcats
"helloä½ å¥½hiâ‚¬ğŸ‘‘abcğŸŒˆ" [parse-utf8] ğŸ”³
#+end_src



byte array convert
#+begin_src kcats
  [104 101 108 108 111] #b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
#b64 "aGVsbG8"
#+end_src

#+begin_src kcats
  [] [] ["yes"] when
  ["yeswhile"] â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [consume]]
 [handled ğŸ”³]
 [reason "not enough items on stack"]
 [type error]
 [unwound [â†”ï¸]]]
ğŸ”³ ["yeswhile" [[["yes"] ğŸ”³ â†”ï¸] ["yeswhile"] ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸] â–¶ï¸]
#+end_src

* Fix every
#+begin_src kcats
  [1 2 3] [[ğŸ“¤] []] [â–¶ï¸]

  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
   [ğŸ”³ âœ”ï¸ ğŸ”³] ;; empty list, return âœ”ï¸
   â†”ï¸] ğŸ’
  [dump ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [] ğŸª† â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 [ğŸ”³] [2 3]]
[[[ğŸ“¤ ğŸ”€ [â–¶ï¸] ğŸ‹ ğŸ‘¥] [ğŸ”³ âœ”ï¸ ğŸ”³] â†”ï¸] [dump ğŸ—‘ï¸ ğŸ—‘ï¸] [â€¢ğŸ—‘ï¸] ğŸ”³ ğŸª† â–¶ï¸] [ğŸ”³] [2 3]
#+end_src

#+begin_src kcats
  [1 2 3] [[ğŸ“¤] []] [â–¶ï¸]

  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
   [ğŸ”³ âœ”ï¸ ğŸ”³] ;; empty list, return âœ”ï¸
   â†”ï¸] ğŸ’
  [dump ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [] ğŸª† â–¶ï¸ 
#+end_src

ok what we want here is not 'every' - we want call chaining like =bail= but for multiple rounds.

Let's write it! And I think we should have =every= and =any= go back to
pure logical tests and enforce the "same stack" invariant.

#+begin_src kcats
   1
   [[ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc] [ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc]]
  ; []
   [and] â€¢ğŸ›¡ï¸
   [ğŸ“¤ ğŸª„]
   â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ 2
#+end_src

#+begin_src kcats
  [2 4 6] [inc]
  ğŸ›¡ï¸ 
  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
   [ ğŸ”³ âœ”ï¸ ğŸ”³] ;; empty list, return âœ”ï¸
   â†”ï¸] ğŸ’
  [ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [â–¶ï¸] ğŸª† â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
âœ”ï¸
#+end_src
* Fix split
#+begin_src kcats
    "abddcfdedd" ;liberator
    ["dd"

    split


    parse
    collect] assemble

#+end_src

#+RESULTS:
#+begin_src kcats
["ab" "cfde"]
#+end_src

next: handle end of stream

#+RESULTS:
#+begin_src kcats
[[\a \b]
 "cfde"]
[ğŸ”³] [[ğŸ‘¥ [ğŸ“® "dd"]
      ğŸª„ [â˜¯ï¸] [ends?] ğŸ›¡ï¸ pair [â–¶ï¸] ğŸ“£ [ğŸ—‘ï¸ ğŸ“ 0 ğŸ”€ - 0 ğŸ”€ slice]
      [ğŸ—‘ï¸ ğŸ”³]
      âš–ï¸ â–¶ï¸]
     ğŸª„ ğŸ”€ [ğŸ“® "" ğŸ”€] ğŸ”³ â†”ï¸]
""
#+end_src

let's see if this version of parse works with other stuff
#+begin_src kcats
  [[104 101 108 108 111]              ;; "hello" (all ASCII)
   [228 189 160 229 165 189]          ;; "ä½ å¥½" (two complete Chinese chars)
   [104 105 226]                      ;; "hi" + start of "â‚¬"
   [130 172]                          ;; completion of "â‚¬"
   [240 159 145]                      ;; start of "ğŸ‘‘"
   [145]                              ;; completion of "ğŸ‘‘"
   [97 98 99 240]                     ;; "abc" + start of "ğŸŒˆ"
   [159 140 136]]                     ;; completion of "ğŸŒˆ"
  liberator
  [#b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸] each ;; convert lists of ints to byte arrays
  [ parse-utf8] #b64 ""
  ğŸ”³ ;; state - parsed object output buffer (on top), unparsed input 

  [] ;; there's output?
  [[]]  ;; leave an empty value to be consumed by outer â³ exiting
  [[] [â–¶ï¸] â€¢â€¢ğŸ‹] ;; exec parent generator 
  âš–ï¸ 
  [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸] ;; exec a copy of parser program: output input parser
  â³ ;; leave the output on top for the recurrence condition check
  [ğŸ“¤] [[[]] ğŸ”€]
  [ğŸ”€] ğŸª† "" ğŸ§¹ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
"helloä½ å¥½hiâ‚¬ğŸ‘‘abcğŸŒˆ" [ğŸ”³] [parse-utf8] ğŸ”³
#+end_src

* Convert number list to bytes
#+begin_src kcats
  1
  [list?]
  [number?] ğŸ’¯ pair [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ 1
#+end_src
* fix indexof
#+begin_src kcats
  [a b c] 
  [c] ğŸ«
  [[second ğŸ [1ï¸âƒ£] = â˜¯ï¸] skipper
   [indexer] â€¢ğŸª„
   â–¶ï¸ first] ğŸ’ 

  assemble
#+end_src

#+RESULTS:
#+begin_src kcats
2
#+end_src
* Fix skipper, dropper to be lazy
dropper
#+begin_src kcats
  [1 2 3 4 5] liberator
  6

  [positive?] ğŸ›¡ï¸ ;; condition
  [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ;; call parent 
   ğŸ”³ ;; if we get something, we're done
   [ğŸ—‘ï¸ ğŸ”³ ğŸ”³] ;; otherwise signal stop with empty generator
   â†”ï¸]
  [ğŸ—‘ï¸ â–¶ï¸ ğŸ”³] âš–ï¸ ;; if counter reaches zero we're done dropping 
  [ğŸ—‘ï¸ dec] â³
  [] [ğŸ”³] [ğŸ—‘ï¸] ğŸª† 
  collect

#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ ğŸ”³
#+end_src

#+begin_src kcats
   [1 2 3 4 5] liberator [10 <]

   [[â–¶ï¸] ğŸ‹] ;; get the item from parent
   [ğŸ”€ [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸] ;; run the pred on it, keep the pred
   [ğŸ—‘ï¸ ğŸ”³ ğŸ”³] âš–ï¸ ;; when parent is empty, leave negative on the stack
   [ğŸ—‘ï¸ â€¢ğŸ—‘ï¸] â³ ;; keep consuming items while they match pred
   [] [[]] [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸª†
   collect

#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ ğŸ”³
#+end_src
* Fix radix
#+begin_src kcats
  33 2

  [ğŸ—‘ï¸ 1ï¸âƒ£ [/] ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ 
   [*] â€¢ğŸ›¡ï¸ â–¶ï¸
   â€¢ğŸ”€ -
   ğŸ”€ [prepend] ğŸª„] ğŸ’

  [ğŸ”³ ğŸ”€ [positive?] ğŸ›¡ï¸] ğŸª„
  â³ â–¶ï¸ ğŸ—‘ï¸ 


#+end_src

#+RESULTS:
#+begin_src kcats
[1 0 0 0 0 1]
#+end_src

#+begin_src kcats
7 2.1 quot
#+end_src

#+RESULTS:
#+begin_src kcats
3.333333333333333
#+end_src
* fix pad
#+begin_src kcats
  [1 2 3] 5 0 
  [[[ğŸ“] ğŸ›¡ï¸ â–¶ï¸] ğŸ‹ -] ğŸª„
  ğŸ”€ repetition â–¶ï¸ 
  ğŸ”€ ğŸ”—
#+end_src

#+RESULTS:
#+begin_src kcats
[0 0 1 2 3]
#+end_src
* fix cut
#+begin_src kcats
  "abcdefghijklmnopqrstuvwxyz" 5
  [[[ğŸ“] ğŸ›¡ï¸ ğŸ‹ slice]
   [0 ğŸ”€ slice]]
  [â–¶ï¸] ğŸšœ â–¶ï¸ 
  [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸª„ ğŸ«
#+end_src

#+RESULTS:
#+begin_src kcats
"abcde" "fghijklmnopqrstuvwxyz"
#+end_src
* fix frequencies
#+begin_src kcats
  "Hello there!" liberator
  ğŸ”³ association
  [ğŸ [ğŸ”³ [inc] [1] âš–ï¸ â–¶ï¸ ] update]
  cram
#+end_src

#+RESULTS:
#+begin_src kcats
[[\space 1]
 [\! 1]
 [\H 1]
 [\e 3]
 [\h 1]
 [\l 2]
 [\o 1]
 [\r 1]
 [\t 1]]
""
#+end_src
* Fix partition
#+begin_src kcats
 [taker] definition
#+end_src

#+RESULTS:
#+begin_src kcats
[[positive?] ğŸ›¡ï¸ [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ğŸ”³ [ğŸ”³ ğŸ”³]
                 â†”ï¸]
 [ğŸ”³] âš–ï¸ [[dec] ğŸª„]
 [ğŸ—‘ï¸ ğŸ”³]
 [ğŸ”€] ğŸª†]
#+end_src

#+begin_src kcats
  integers generator 3
  [positive?] ğŸ›¡ï¸ ;; counter still positive?
  [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ;; run the parent generator
   ğŸ”³ [ğŸ”³ ğŸ”³] â†”ï¸] ;; add padding to drop later
  [ğŸ”³] âš–ï¸ ;; otherwise return nothing
  [[dec] ğŸª„] ;; decrement counter
  [ğŸ—‘ï¸ ğŸ”³] ;; discard the counter but keep parent, all done
  [ğŸ”€] ğŸª†
   collect ğŸ—‘ï¸ 3 taker collect
#+end_src


#+begin_src kcats

  [1 2 3 4 5 6] liberator 3
  [1ï¸âƒ£ taker collect] ğŸ’  [dump] [dump] [ğŸ”€] ğŸª†  â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2 3] [[ğŸ“¤] ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸] [4 5 6]]
[[4 5 6] [[ğŸ“¤] ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”³]
[3 ğŸ”³]
3 ğŸ”³
#+end_src

TODO: deal with end of stream
#+begin_src kcats

  [1 2] [] [] 
  [flip
   [[dump ğŸ”€ â˜¯ï¸] ;; end of stream?
    [ğŸ“ 3 >=]] ;; reached partition size?
   [ğŸ›¡ï¸ â–¶ï¸] ğŸ“£ â–¶ï¸]
  [ğŸ—‘ï¸ â€¢ğŸ”€ ğŸ“® [ğŸ] ğŸª„]
  [ğŸ”€ ğŸ“® ğŸ”€]
  âš–ï¸ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2]
 ğŸ”³ ğŸ”³]
[[1 2]] [ğŸ”³]
#+end_src

#+begin_src kcats
   [1 2 3 4 5 6 8 9 10] liberator 3
  [flip [ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 1ï¸âƒ£ >=] ğŸ’
   [ğŸ—‘ï¸ â€¢ğŸ”€ ğŸ“® [ğŸ] ğŸª„ ]
   [ğŸ”€ ğŸ“® ğŸ”€]
   âš–ï¸ [] parse collect
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2 3] [4 5 6] [8 9 10]] [flip [ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 3 >= [ğŸ—‘ï¸ â€¢ğŸ”€ ğŸ“® [ğŸ] ğŸª„] [ğŸ”€ ğŸ“® ğŸ”€] â†”ï¸]
ğŸ”³
#+end_src
* Test taker
#+begin_src kcats
   [1 2 3 4 5 6] liberator 3 taker collect
   [2 taker collect] ğŸ‹ pair restore
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 3] [4 5]
#+end_src
* Performance check
#+begin_src kcats
   1 100000 1 range liberator 5 partition
   0 [ğŸ—‘ï¸ inc] cram ;; count the partitions
#+end_src

#+RESULTS:
#+begin_src kcats
20000 [flip [ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 5 >= [ğŸ—‘ï¸ â€¢ğŸ”€ ğŸ“® [ğŸ] ğŸª„] [ğŸ”€ ğŸ“® ğŸ”€] â†”ï¸]
ğŸ”³
#+end_src
3s, horribly slow compared to other langs but i think for our purposes it's fine.
* Fix pairwise
#+begin_src kcats
  1 2 3 4 5 [ğŸ”€] 

  [ğŸ”³ ğŸ§¦ dump ;; capture stack
   [2 partition] assemble] ğŸª„ ;; pair up stack items
  ğŸ’‰ â–¶ï¸ ;; run the program on the pairs
 ; [[ğŸ”—] fold] assemble ;; unpair the items
 ; ğŸ« ğŸ”³ ğŸ”€ ğŸ§¦ ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[5 4 3 2 1]]
[[ğŸ”³ [â–¶ï¸] â€¢â€¢ğŸ‹] [ğŸ”³] â†”ï¸ [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸ [[[ğŸ”³] [ğŸ”³ [â–¶ï¸] â€¢â€¢ğŸ‹] â†”ï¸] [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸] ğŸ”³ [â–¶ï¸] ğŸª†
                                    â–¶ï¸]
                      â–¶ï¸]
 ğŸ”³ â†”ï¸ [ğŸ“¤ [[[ğŸ”³] [ğŸ”³ [â–¶ï¸] â€¢â€¢ğŸ‹] â†”ï¸ [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸ [[[ğŸ”³] [ğŸ”³ [â–¶ï¸] â€¢â€¢ğŸ‹] â†”ï¸] [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸]
                                              ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸]
                                â–¶ï¸]
           ğŸ”³ â†”ï¸]
          [ğŸ“¤] [[ğŸ”³] ğŸ”€]
          [ğŸ”€] ğŸª† â–¶ï¸]
       ğŸ”€]
 [[ğŸ”³] ğŸ”€]
 â†”ï¸]
#+end_src
* fix primrec
#+begin_src kcats
   5 [1] [*]

   [â–¶ï¸ âœ‚ï¸1ï¸âƒ£] ğŸ’  ;; add execute to rec1 to be recurs rec2
   [[ğŸ—‘ï¸ âœ‚ï¸1ï¸âƒ£] ğŸ’] ğŸª„  ;; add drop to exit condition
   [zero? â˜¯ï¸] ğŸ›¡ï¸ âš“ ;; put the condition check on bottom
   [ğŸ—‘ï¸ ğŸ‘¥ dec] âš“  ;; add the r1
   ğŸª†

  â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[âœ”ï¸ 5]
[âœ”ï¸ 4 5]
[âœ”ï¸ 3 4 5]
[âœ”ï¸ 2 3 4 5]
[âœ”ï¸ 1 2 3 4 5]
120
#+end_src
* fix walk
#+begin_src kcats
  [1 2 [3 [4 5] 6]] [ğŸ‘¥ inc pair]

  [âœ‚ï¸1ï¸âƒ£] ğŸ’ ;; the negative branch
  [list?] ğŸ›¡ï¸ ;; pred
  [ğŸ—‘ï¸ ğŸ”³ ğŸ”€] ğŸ›Ÿ ;; affirmative branch
  [[âœ‚ï¸1ï¸âƒ£ ğŸ”—] ğŸ’ ğŸªœ â–¶ï¸ ğŸ] ;; recur into each subitem and wrap
  ğŸª† [âœ‚ï¸1ï¸âƒ£ ğŸ«] ğŸ’ ;; unwrap at the end
  â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 2 3 [3 4 [4 5 5 6] 6 7]]
#+end_src

This is all well and good but it doesn't support the use case of converting nested lists to nested maps.

So a good impl would support:
+ user-provided traversal (what is a node vs leaf)
+ ability to process both before and after traversal (before we recurse into node and after)

#+begin_src kcats
   [[a [[b [[c d] [e [1 2 3]]]]]]]
  [list?] ğŸ›¡ï¸  ;; pred
  [ ğŸ—‘ï¸ ] ;; get-children
  [] ;; pre-traverse
  [[association] [ğŸ—‘ï¸] ğŸ©¹ â–¶ï¸] ;; post-traverse
  [] ;; reassemble


  [5ï¸âƒ£ ;; the pred remains untouched
   [âœ‚ï¸4ï¸âƒ£ âœ‚ï¸3ï¸âƒ£] ;; affirmative - run the get-children and the pre-traverse 
   [âœ‚ï¸3ï¸âƒ£ âœ‚ï¸2ï¸âƒ£] ;; negative - run the pre-traverse and post-traverse
   [ğŸšœ â–¶ï¸ âœ‚ï¸2ï¸âƒ£ âœ‚ï¸1ï¸âƒ£] ;; combinator
  ] ğŸ’ ğŸ«  ğŸª†  â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[a [[b [[c d]
         [e [1 2 3]]]]]]]
#+end_src

#+begin_src kcats
  [1 2 [3 [4 5] 6]]
  [list?] ğŸ›¡ï¸  ;; pred
  [ ğŸ—‘ï¸ ] ;; get-children
  [] ;; pre-traverse
  [] ;; post-traverse
  [] ;; reassemble


  [5ï¸âƒ£ ;; the pred remains untouched
   [âœ‚ï¸4ï¸âƒ£ âœ‚ï¸3ï¸âƒ£] ;; affirmative - run the get-children and the pre-traverse 
   [âœ‚ï¸3ï¸âƒ£ âœ‚ï¸2ï¸âƒ£] ;; negative - run the pre-traverse and post-traverse
   [ğŸšœ â–¶ï¸ âœ‚ï¸2ï¸âƒ£ âœ‚ï¸1ï¸âƒ£] ;; combinator
  ] ğŸ’ ğŸ«  ğŸª†  â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 [3 [4 5]
      6]]
#+end_src

inc all
#+begin_src kcats
  [1 [2 3 4 [6 7]] 5]
  [list?] ğŸ›¡ï¸
  [ğŸ—‘ï¸]
  [inc]
  [ğŸšœ â–¶ï¸] ğŸª† â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[2 [3 4 5 [7 8]] 6]
#+end_src

#+begin_src kcats
  [[a [[b [[c d]
           [e [1 2 3]]]]]]]
 assocify
  type
#+end_src

#+RESULTS:
#+begin_src kcats
a
#+end_src

#+RESULTS:
#+begin_src kcats
list
#+end_src

** TODO Amortization example
Let me calculate this step by step:

    (1+i)^360 â‰ˆ 4.517
    i * (1+i)^360 = 0.00416667 * 4.517 â‰ˆ 0.0188
    (1+i)^360 - 1 = 4.517 - 1 = 3.517
    0.0188/3.517 â‰ˆ 0.00536
    100000 * 0.00536 â‰ˆ 536

#+begin_src kcats
  100000
  0.05 12 /
  30 12 * 
  [[1 +] ğŸª„ exp] ğŸ›¡ï¸ â–¶ï¸ â€¢ğŸ—‘ï¸ 
  ğŸ”€ [*] â€¢ğŸ›¡ï¸ â–¶ï¸ 
  [1 -] ğŸª„ ğŸ”€ / *
  [*] ğŸ›¡ï¸ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
2.2367567625505758 536.8216230121382 0.004166666666666667
#+end_src

A=P  i(1+i)^n /  (1+i)^n -1

#+begin_src kcats
417 360 *
#+end_src

#+RESULTS:
#+begin_src kcats
150120
#+end_src
* Fix recovery
#+begin_src kcats
  [1 2 3] [ğŸ”€] [ğŸªœ â–¶ï¸] [ğŸ—‘ï¸ "oh noes"]
  [ğŸ“¸
   [âœ‚ï¸2ï¸âƒ£ handle] ğŸ’‰ â–¶ï¸
   [first error?] ğŸ›¡ï¸
   [ğŸ—‘ï¸ first âœ‚ï¸1ï¸âƒ£]
   [ğŸ§¦ ğŸ—‘ï¸]
   âš–ï¸ â–¶ï¸] ğŸ’  â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
"oh noes" [ğŸ”€] [1 2 3]
#+end_src

#+begin_src kcats
  [1 2 "oh fudge"]
  [5 +]
  [ğŸ—‘ï¸ 5]

  [ğŸ“¸
   [âœ‚ï¸2ï¸âƒ£ handle] ğŸ’‰ â–¶ï¸
   [first error?] ğŸ›¡ï¸
   [ğŸ—‘ï¸ first âœ‚ï¸1ï¸âƒ£]
   [ğŸ§¦ ğŸ—‘ï¸]
   âš–ï¸ â–¶ï¸] ğŸ’

  ;[ğŸ] ğŸª„ ğŸ”— ;; curry the mapping function too
  ğŸšœ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[6 7 5]
#+end_src
* Test networking
#+begin_src kcats
  "home.jweiss.com" 80 socket
  "GET / HTTP/1.0\n\n" encodeitem ğŸ“®
  liberator
  [parse-utf8] #b64 "" parse "" ğŸ§¹ â–¶ï¸ print
#+end_src

#+RESULTS:
#+begin_src kcats
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.26.2
Date: Tue, 06 May 2025 16:36:08 GMT
Content-Type: text/html
Content-Length: 145
Connection: close
Location: https://home.jweiss.com/

<html>
<head><title>302 Found</title></head>
<body>
<center><h1>302 Found</h1></center>
<hr><center>nginx/1.26.2</center>
</body>
</html>

[ğŸ”³] [parse-utf8] [[address "home.jweiss.com"]
                  [port "80"]
                  [realm tcp]
                  [type tunnel]]
#+end_src

* Test claude 3.7
#+begin_src kcats
1 100 1 range
[ğŸ‘¥ * odd?] ğŸ§² â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39
 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79
 81 83 85 87 89 91 93 95 97 99]
#+end_src

#+begin_src kcats
  30 [] ğŸ”€ 2
  [[sqrt] ğŸª„ >=]
  [[mod zero?] 
   [ğŸ‘¥ âš“ 
    [ğŸ“®] â€¢ğŸª„ 
    / 2]
   [inc]
   âš–ï¸ â–¶ï¸]
  â³ â–¶ï¸
  ğŸ—‘ï¸ ğŸ“®
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual âœ…]
 [asked [number?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [trace [â–¶ï¸ â–¶ï¸]]
 [type error]
 [unwound [mod zero? [ğŸ‘¥ âš“ [ğŸ“®] â€¢ğŸª„ / 2] [inc] â†”ï¸ [[[sqrt] ğŸª„ >=] [[mod zero?]
                                                               [ğŸ‘¥ âš“ [ğŸ“®] â€¢ğŸª„ / 2] [inc] âš–ï¸ â–¶ï¸]
                                                ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸]
           â–¶ï¸ ğŸ—‘ï¸ ğŸ“®]]]
âœ… ğŸ”³
#+end_src

#+begin_src kcats
  12
  [ğŸ‘¥ 2 <]
  [ğŸ—‘ï¸ ğŸ”³]
  [ğŸ—‘ï¸ ğŸ‘¥ 2 =]  ;; If number < 2, it's not prime
  [ğŸ—‘ï¸ âœ…]
  [ğŸ—‘ï¸      ;; If number = 2, it's prime

   ;; For all numbers >= 3, check divisibility
   ğŸ‘¥ 2                     ;; Create a potential divisor (starting at 2)
   [[ğŸ‘¥] ğŸ›¡ï¸ [ğŸ‘¥ ğŸ‘¥ ğŸ”€ ;; Copy both top numbers (number and divisor)
           mod zero?]      ;; Check if divisor divides number evenly
   [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³]        ;; If divisible, return false
   [ğŸ—‘ï¸               ;; Not divisible, continue checking with next divisor
    ğŸ‘¥ ğŸ‘¥ *         ;; Check if divisor^2 exceeds number
    >]
   [ğŸ—‘ï¸ ğŸ—‘ï¸ âœ…]        ;; If we've checked up to sqrt(number), it's prime
   âš–ï¸
   [inc]] â³ â–¶ï¸]
  âš–ï¸ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual 2]
 [asked [program?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [trace [[[ğŸ‘¥] ğŸ›¡ï¸ [ğŸ‘¥ ğŸ‘¥ ğŸ”€ mod zero?] [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] [ğŸ—‘ï¸ ğŸ‘¥ ğŸ‘¥ * >] [ğŸ—‘ï¸ ğŸ—‘ï¸ âœ…] âš–ï¸ [inc]]]]
 [type error]
 [unwound [â³ â–¶ï¸]]]
[[ğŸ‘¥] ğŸ›¡ï¸ [ğŸ‘¥ ğŸ‘¥ ğŸ”€ mod zero?] [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] [ğŸ—‘ï¸ ğŸ‘¥ ğŸ‘¥ * >] [ğŸ—‘ï¸ ğŸ—‘ï¸ âœ…] âš–ï¸ [inc]]
2 12 12
#+end_src
* Database
** COMMENT Links
#+begin_src kcats
  [[book? subjects love]
   [book? title title?]
   [book? author-last author-last?]
   [book? author-first author-first?]
   [author? first-name author-first?]
   [author? last-name author-last?]
   [author? sex f]
   [author? birth-year birth-year?]]

  ;; make a range of constraint numbers
  [ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 0 ğŸ”€ 1 range  ğŸ”€ 

  ;; first make each into a mapping
  [[entity attribute value] zip
   ;; then index each row
  ] ğŸšœ â–¶ï¸ indexed
  ;; for each row, move the index into each value
  [ğŸ« [ğŸ”€ ğŸ“® reverse] ğŸšœ â–¶ï¸] ğŸšœ â–¶ï¸
  ;; join the rows together now that we have indices
  [] ğŸ”€ [ğŸ”—] ğŸªœ â–¶ï¸
  ;; filter out non variables
  [2 get [[word?]
          [string last \? =]] [â–¶ï¸] ğŸ’¯ â–¶ï¸]  ğŸ§² â–¶ï¸
  ;; group by the variable
  liberator [2 get] group â€¢ğŸ—‘ï¸ 
  ;[first] sort

  [second] ğŸšœ â–¶ï¸

  ;; now go through the row indices. for each index:
  ;; for each row of links, if index not present, done. if present keep it and
  ;; everything less than it.
  ğŸ”€ [ğŸ”€ [ first =] â€¢ğŸ›¡ï¸ ğŸ“£ ğŸ§² â–¶ï¸ ] ğŸšœ â–¶ï¸ ;; filter out rows with no link to this row (matching index)
  [[] [ğŸ”—] ğŸªœ â–¶ï¸ ;; connect all items in each row

  ] ğŸšœ â–¶ï¸
  indexed
  ;; now filter any subitem where the index is > current row
  [ğŸ« [ 0 get >] ğŸ§² ğŸšœ â–¶ï¸] ğŸšœ â–¶ï¸
  ;; filter items where there is 0 or 1 subitems (no links)
  [ğŸ“ 1 >=] ğŸ§² ğŸšœ â–¶ï¸
  â€¢ğŸ—‘ï¸ ;; don't need the by-variable lookup anymore
  
#+end_src

#+RESULTS:
#+begin_src kcats
  [[book? subjects love]
   [book? title title?]
   [book? author-last author-last?]
   [book? author-first author-first?]
   [author? first-name author-first?]
   [author? last-name author-last?]
   [author? sex f]
   [author? birth-year birth-year?]]
  [ğŸ”³
   [[[0 entity book?]]]
   [[[0 entity book?] [1 entity book?]]]
   [[[0 entity book?] [1 entity book?] [2 entity book?]]]
   [[[3 value author-first?]]]
   [[[4 entity author?]] [[2 value author-last?]]]
   [[[4 entity author?] [5 entity author?]]]
   [[[4 entity author?] [5 entity author?] [6 entity author?]]]]
#+end_src

#+begin_src kcats
[a b c] 2 get
#+end_src

#+RESULTS:
#+begin_src kcats
c
#+end_src

#+begin_src kcats
  [[book? subjects love]
   [book? title title?]
   [book? author-last author-last?]
   [book? author-first author-first?]
   [author? first-name author-first?]
   [author? last-name author-last?]
   [author? sex f]
   [author? birth-year birth-year?]]

  ;; make a range of constraint numbers
  ;[ğŸ“] ğŸ›¡ï¸ â–¶ï¸ 0 ğŸ”€ 1 range  ğŸ”€ 

  ;; first make each into a mapping
  [[entity attribute value] zip
   ;; then index each row
  ] ğŸšœ â–¶ï¸ indexed
  ;; for each row, move the index into each value
  [ğŸ« [ğŸ”€ ğŸ“® reverse] ğŸšœ â–¶ï¸] ğŸšœ â–¶ï¸
  ;; join the rows together now that we have indices
  [] ğŸ”€ [ğŸ”—] ğŸªœ â–¶ï¸
  ;; filter out non variables
  [2 get [[word?]
          [string last \? =]] [â–¶ï¸] ğŸ’¯ â–¶ï¸]  ğŸ§² â–¶ï¸
  ;; group by the variable
  [liberator [2 get] group] ğŸ›¡ï¸ â–¶ï¸
  ;; group by row
  [liberator [first] group [first] sort] ğŸª„ 
  ;[first] sort
  ğŸ”€
  ;; for each row, lookup the variables in the by-variable mapping
  [ğŸ« â€¢ğŸ—‘ï¸
   ;; for each variable, do lookup
   [2 get get] ğŸšœ â–¶ï¸
  ] ğŸšœ â–¶ï¸ 
  indexed
  ;; filter entire entries where the current row doesn't appear
  [ğŸ« [first =] â€¢ğŸ›¡ï¸ ğŸ“£ ğŸ§² â–¶ï¸ pair] ğŸšœ â–¶ï¸
  ;; remove sub-entries where the current row is less than the sub-entry row

  [ğŸ« [first >=] â€¢ğŸ›¡ï¸ ğŸ§² ğŸšœ â–¶ï¸ pair] ğŸšœ â–¶ï¸
  
#+end_src

#+RESULTS:
#+begin_src kcats
[[[[0 entity book?]]] [[[0 entity book?] [1 entity book?]]
                       [[1 value title?]]]
 [[[0 entity book?] [1 entity book?] [2 entity book?]] [[2 value author-last?]]]
 [[[0 entity book?] [1 entity book?] [2 entity book?] [3 entity book?]] [[3 value
                                                                          author-first?]]]
 [[[4 entity author?]] [[3 value author-first?] [4 value author-first?]]]
 [[[4 entity author?] [5 entity author?]]
  [[2 value author-last?] [5 value author-last?]]]
 [[[4 entity author?] [5 entity author?] [6 entity author?]]] [[[4 entity author?]
                                                                [5 entity author?] [6 entity author?] [7 entity author?]]
                                                               [[7 value birth-year?]]]]
[[author-first? [[3 value author-first?] [4 value author-first?]]]
 [author-last? [[2 value author-last?] [5 value author-last?]]]
 [author? [[4 entity author?] [5 entity author?] [6 entity author?] [7 entity author?]]]
 [birth-year? [[7 value birth-year?]]]
 [book? [[0 entity book?] [1 entity book?] [2 entity book?] [3 entity book?]]]
 [title? [[1 value title?]]]]
ğŸ”³
#+end_src

#+begin_src kcats

  [[book? subjects love]
   [book? title title?]
   [book? author-last author-last?]
   [book? author-first author-first?]
   [author? first-name author-first?]
   [author? last-name author-last?]
   [author? sex f]
   [author? birth-year birth-year?]]

  [[object [[entity attribute value] ğŸ”€ zip]]
   [variable? [[[word?] [string last \? =]] [â–¶ï¸] ğŸ’¯ â–¶ï¸]]
   [val [2 get]]
   [rowindex [0 get]]
   [format-link [[ğŸ« ğŸ—‘ï¸] ğŸª„
                 [ğŸ« ğŸ—‘ï¸ [4ï¸âƒ£ 3ï¸âƒ£ 2ï¸âƒ£ 1ï¸âƒ£] ğŸ’ "c{}.{} = c{}.{}" ğŸ”€ format] ğŸšœ â–¶ï¸ ]]]
  [ğŸ‘¥  
   ;; first make each into a mapping ;; then index each row
   [object] ğŸšœ â–¶ï¸ indexed
   ;; for each row, move the index into each value
   [ğŸ« [ğŸ”€ prepend] ğŸšœ â–¶ï¸] ğŸšœ â–¶ï¸ ğŸ‘¥ ;; save this data
   ;; join the rows together now that we have indices
   [] ğŸ”€ [ğŸ”—] ğŸªœ â–¶ï¸ 
   ;; filter out non variables
   [val variable?] ğŸ§² â–¶ï¸ 
   ;; group by the variable
   liberator [val] group â€¢ğŸ—‘ï¸ 
   ğŸ”€

   ;; just test one for now
 
   [ğŸ‘¥ [ [rowindex] ğŸ›¡ï¸ â–¶ï¸ ;; extract constraint num
    [val ;; extract variable name
     ğŸ”€ [get] â€¢ğŸ›¡ï¸ ğŸª„ ;; look up in by-variable map
     remove] ;; the current link position because we don't link to ourself
    ğŸª„ ğŸ”€ 
    ;; filter out constraint nums and non-variables
    [[rowindex >] bail] ğŸ§² â–¶ï¸] â€¢ğŸ›¡ï¸ â–¶ï¸
     format-link]
   ğŸšœ ğŸšœ â–¶ï¸]
  let â–¶ï¸


#+end_src

#+RESULTS:
#+begin_src kcats
  [[ğŸ”³ ğŸ”³ ğŸ”³]
   [["c1.entity = c0.entity"] ğŸ”³ ğŸ”³]
   [["c2.entity = c0.entity" "c2.entity = c1.entity"] ğŸ”³ ğŸ”³]
   [["c3.entity = c0.entity" "c3.entity = c1.entity" "c3.entity = c2.entity"] ğŸ”³ ğŸ”³]
   [ğŸ”³ ğŸ”³ ["c4.value = c3.value"]]
   [["c5.entity = c4.entity"] ğŸ”³ ["c5.value = c2.value"]]
   [["c6.entity = c4.entity" "c6.entity = c5.entity"] ğŸ”³ ğŸ”³]
   [["c7.entity = c4.entity" "c7.entity = c5.entity" "c7.entity = c6.entity"] ğŸ”³ ğŸ”³]]
  [[author-first? [[3 value author-first?] [4 value author-first?]]]
   [author-last? [[2 value author-last?] [5 value author-last?]]]
   [author? [[4 entity author?] [5 entity author?] [6 entity author?] [7 entity author?]]]
   [birth-year? [[7 value birth-year?]]]
   [book? [[0 entity book?] [1 entity book?] [2 entity book?] [3 entity book?]]]
   [title? [[1 value title?]]]]
  [[book? subjects love] [book? title title?] [book? author-last author-last?] [book?
                                                                                author-first author-first?]
   [author? first-name author-first?] [author? last-name author-last?] [author? sex
                                                                        f]
   [author? birth-year birth-year?]]
#+end_src

We're going to need expressions. So we need to be able to convert =[100 >]= into 
* Fix filter
The problem is the result container sitting on the stack while the
predicate is running. It needs to be dipped out.

#+begin_src kcats
   33 [1 2 3] [+ odd?]
  ğŸ›¡ï¸ ;; run the predicate with no stack effect
  [ğŸ—‘ï¸ ğŸ“®] [ğŸ—‘ï¸] âš–ï¸ ;; if match, drop the pred result and put the original item in result list
  ;; if not, just drop the original
  ğŸªœ 
  [[dump 1ï¸âƒ£ â–¶ï¸] ğŸ”³ âš“ â–¶ï¸] ğŸ’
  â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2 3] ğŸ”³ 33]
[[actual ğŸ”³]
 [asked [number?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [trace [ğŸª„ â€¢ğŸª„]]
 [type error]
 [unwound [+ odd? [1 ğŸ”³ 33] ğŸ§¦ first [ğŸ—‘ï¸ ğŸ“®]
           [ğŸ—‘ï¸] â†”ï¸ [2 3]
           [ğŸ“¸ ğŸ§¦ [+ odd?]
            ğŸª„ ğŸ§¦ first [ğŸ—‘ï¸ ğŸ“®]
            [ğŸ—‘ï¸] â†”ï¸]
           ğŸªœ â–¶ï¸]]]
1 ğŸ”³ 33
#+end_src

the step fn needs to each time, run the pred dipped, then finish the if
#+begin_src kcats
   33 [1 2 3] [+ odd?]
  ğŸ›¡ï¸ ;; run the predicate with no stack effect
  [1ï¸âƒ£ â€¢ğŸ”€ ğŸ‹] ğŸ’  ;; dive the predicate under the result
  [ğŸ—‘ï¸ ğŸ”€ ğŸ“®] [â€¢ğŸ—‘ï¸] âš–ï¸ ;; if match, drop the pred result and put the original item in result list
  ;; if not, just drop the original
  ğŸªœ 
  [1ï¸âƒ£ ğŸ”³ âš“ â–¶ï¸] ğŸ’
  â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[2] 33
#+end_src
* Fix combinations
#+begin_src kcats
  [1 2 3] liberator
  [ğŸ“] ğŸ›¡ï¸ -1 ;; l idx i
  [[dump [ğŸ”€ ğŸ“ dump = ] ğŸ‹]
   [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ“¤ 0 ğŸ”€] when â–¶ï¸ 

   [[ğŸ ğŸ”] ğŸ‹ [pair] bail] ğŸ›¡ï¸ â–¶ï¸
   [inc] â€¢ğŸª„] â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[-1 [ğŸ“¸ ğŸ§¦ [ğŸ“] ğŸª„ ğŸ§¦ first] [ğŸ“¤ [[[ğŸ“¤] ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
                         [ğŸ”³] â†”ï¸]
 [1 2 3]]
[4 [ğŸ“¸ ğŸ§¦ [ğŸ“] ğŸª„ ğŸ§¦ first] [1 2 3]]
[[asked [consume]]
 [handled ğŸ”³]
 [reason "not enough items on stack"]
 [trace [ğŸ ğŸª„ ğŸ‹ ğŸª„ â–¶ï¸]]
 [type error]
 [unwound [ğŸ” -1 ğŸ”€ [pair] bail [-1 [1 2 3]]
           ğŸ§¦ first [inc] â€¢ğŸª„]]]
[[1 2 3]]
#+end_src
* Make nested map from literal
#+begin_src kcats
  b[[a [[b 12]
       [c 15]]]
   [d [[e []]
       [f [5 4 3 2 1]]]]]
  [association] walk â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual a]
 [asked [sized]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [type error]
 [unwound [association ğŸ”— [[[b 12]
                           [c 15]]] [[ğŸ“¸ ğŸ§¦ [list?] ğŸª„ ğŸ§¦ first] [ğŸ—‘ï¸ ğŸ”³ ğŸ”€] [association] [[âœ‚ï¸1ï¸âƒ£ ğŸ”—]
                                                                                     ğŸ’ ğŸªœ â–¶ï¸ ğŸ]
                                     ğŸª† â–¶ï¸ ğŸ”—]
           ğŸªœ â–¶ï¸ ğŸ ğŸ”— [[d [[e ğŸ”³]
                         [f [5 4 3 2 1]]]]] [[ğŸ“¸ ğŸ§¦ [list?] ğŸª„ ğŸ§¦ first] [ğŸ—‘ï¸ ğŸ”³ ğŸ”€] [association] [[âœ‚ï¸1ï¸âƒ£ ğŸ”—]
                                                                                             ğŸ’ ğŸªœ â–¶ï¸ ğŸ]
                                             ğŸª† â–¶ï¸ ğŸ”—]
           ğŸªœ â–¶ï¸ ğŸ ğŸ«]]]
a ğŸ”³ ğŸ”³
#+end_src

#+begin_src kcats
  [[a [[b 12]
       [c 15]]]
   [d [[e []]
       [f [5 4 3 2 1]]]]] [[association] [dump ğŸ—‘ï¸] ğŸ©¹ â–¶ï¸ ğŸ] walk â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[[actual a]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 a ğŸ”³ ğŸ”³]
[[[actual b]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 b ğŸ”³ ğŸ”³ [a] ğŸ”³]
[[[actual 12]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 12 [b] ğŸ”³ [a] ğŸ”³]
[[[actual c]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 c ğŸ”³ [[b 12]] [a] ğŸ”³]
[[[actual 15]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 15 [c] [[b 12]] [a] ğŸ”³]
[[[actual d]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 d ğŸ”³ [[a [[b 12]
          [c 15]]]]]
[[[actual e]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 e ğŸ”³ ğŸ”³ [d] [[a [[b 12]
                [c 15]]]]]
[[[actual f]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 f ğŸ”³ [[e ğŸ”³]] [d] [[a [[b 12]
                      [c 15]]]]]
[[[actual 5]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 5 ğŸ”³ [f] [[e ğŸ”³]] [d] [[a [[b 12]
                          [c 15]]]]]
[[[actual 4]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 4 [5] [f] [[e ğŸ”³]] [d] [[a [[b 12]
                            [c 15]]]]]
[[[actual 3]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 3 [5 4]
 [f] [[e ğŸ”³]] [d] [[a [[b 12]
                      [c 15]]]]]
[[[actual 2]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 2 [5 4 3] [f] [[e ğŸ”³]] [d] [[a [[b 12]
                                [c 15]]]]]
[[[actual 1]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [type error]
  [unwound [association]]]
 1 [5 4 3 2] [f] [[e ğŸ”³]] [d] [[a [[b 12]
                                  [c 15]]]]]
[[a [[b 12]
     [c 15]]]
 [d [[e ğŸ”³]
     [f [5 4 3 2 1]]]]]
#+end_src

#+begin_src kcats
  [[a b]] ğŸ [[association] [dump ğŸ—‘ï¸] ğŸ©¹ â–¶ï¸ ğŸ] walk â–¶ï¸ ğŸ«
#+end_src

#+RESULTS:
#+begin_src kcats
[[[actual a]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [trace [ğŸª„ â–¶ï¸ â–¶ï¸ â–¶ï¸ â€¢ğŸª„ â–¶ï¸ â–¶ï¸ â€¢ğŸª„ â–¶ï¸ â–¶ï¸ â€¢ğŸª„ â–¶ï¸ â†”ï¸ â–¶ï¸]]
  [type error]
  [unwound [association]]]
 a ğŸ”³ ğŸ”³ ğŸ”³]
[[[actual b]
  [asked [sized]]
  [handled âœ…]
  [reason "type mismatch"]
  [trace [ğŸª„ â–¶ï¸ â–¶ï¸ â–¶ï¸ â€¢ğŸª„ â–¶ï¸ â–¶ï¸ â€¢ğŸª„ â–¶ï¸ â–¶ï¸ â€¢ğŸª„ â–¶ï¸ â†”ï¸ â–¶ï¸]]
  [type error]
  [unwound [association]]]
 b [a] ğŸ”³ ğŸ”³]
[[a b]]
#+end_src
* Fix match
#+begin_src kcats
  [foo bar [5 6]]
  [[[foo nomatch [1ï¸âƒ£ 2ï¸âƒ£]] ["shouldn't match"]]
   [[nomatch bar [1ï¸âƒ£ quux]] ["also shouldn't match"]]
   [[foo _ [1ï¸âƒ£ 2ï¸âƒ£]] [+]]]
  [ğŸ« ;; break up pair 
   [[2ï¸âƒ£ [â›ï¸ ğŸ—‘ï¸] [ğŸ—‘ï¸ []] ğŸ©¹ â–¶ï¸]
    [â€¢ğŸ—‘ï¸ ğŸ« âœ‚ï¸1ï¸âƒ£]] ğŸ’] ;; rebuild pair with new condition and program
  ğŸšœ â–¶ï¸
  ;; now add a clause to fail if no match
  [[âœ…] [ğŸ—‘ï¸ [ğŸ§¤] "No patterns match" [reason asked actual] label fail]] ğŸ“®
  [1ï¸âƒ£ decide] ğŸ’ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
11
#+end_src
* Debug program stack issues
#+begin_src kcats
  1 2 [+] â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
3
#+end_src
* More efficient snapshot
#+begin_src kcats
  1 2 3 [] ğŸ§¦ ğŸ‘¥ [ğŸ§¦] ğŸª„ â€¢ğŸ—‘ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[3 2 1] 3 2 1
#+end_src

#+begin_src kcats
1 2 3 [] ğŸ§¦ ğŸ‘¥ ğŸ§¦ first 
#+end_src

#+RESULTS:
#+begin_src kcats
[3 2 1] 3 2 1
#+end_src
* fix interpose
#+begin_src kcats
  ["a" "b" "c"] " and " 

  ğŸ”³ flip
  [ğŸ”€ pair ğŸ”— [pop] ğŸ›¡ï¸ â–¶ï¸] ğŸªœ â–¶ï¸ 
  ğŸ—‘ï¸ pop ğŸ—‘ï¸

  [ğŸ”—] reduce â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
"a and b and c"
#+end_src
* fix match
#+begin_src kcats
  [foo]
  ;[[[bar] ["hi"]]
  ; [[foo] ["there"]]]
  [[[[bar]] ["shouldn't match"]]
   [[nomatch bar [1ï¸âƒ£ quux]] ["also shouldn't match"]]
   [[[foo]] ["match"]]]
  [ğŸ« ;; break up pair 
   [[2ï¸âƒ£
     [â›ï¸ ğŸ—‘ï¸ âœ… or] ;; use dummy value if no placeholders
     [ğŸ—‘ï¸ []] ğŸ©¹ â–¶ï¸] ;; recover from failed destructure to try next
    [[âœ… =] ğŸ›¡ï¸
     [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop dummy value 
     [â€¢ğŸ—‘ï¸ ğŸ«] ;; unwrap the destructured elements onto the stack
     âš–ï¸ â–¶ï¸ âœ‚ï¸1ï¸âƒ£]] ğŸ’] ;; rebuild pair with new condition and program
  ğŸšœ â–¶ï¸
  ;; now add a clause to fail if no match
  [[âœ…] [ğŸ—‘ï¸ [ğŸ§¤] "No patterns match" [reason asked actual] label fail]] ğŸ“®
  [1ï¸âƒ£ decide] ğŸ’ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[actual [foo]]
 [asked [ğŸ§¤]]
 [handled ğŸ”³]
 [reason "No patterns match"]
 [trace [fail]]
 [unwound ğŸ”³]]
#+end_src

#+RESULTS:
#+begin_src kcats
[foo] [[[[[foo] [â›ï¸ ğŸ—‘ï¸ âœ… or] [ğŸ—‘ï¸ ğŸ”³]
          ğŸ©¹ â–¶ï¸]
         [â€¢ğŸ—‘ï¸ ğŸ« "hi"]]
        [[âœ…] [ğŸ—‘ï¸ [ğŸ§¤] "No patterns match" [reason asked actual] label fail]]]
       decide]
#+end_src
* Load modules before 'using'
#+begin_src kcats
  ;; filter modules not loaded
  
  [#b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U"] 
  words [first unnamespace] ğŸšœ â–¶ï¸ set

#+end_src

#+RESULTS:
#+begin_src kcats
[#b64 "core" ğŸ”³]
[#b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U"]
#+end_src

list what modules are loaded
#+begin_src kcats
  words [first unnamespace] ğŸšœ â–¶ï¸ set  
#+end_src

#+RESULTS:
#+begin_src kcats
[#b64 "core" ğŸ”³]
#+end_src

#+begin_src kcats
  dictionary #b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U" module
  encode
  inscribe
  [words] ğŸ”  [first unnamespace] ğŸšœ â–¶ï¸ set 

 
#+end_src

#+RESULTS:
#+begin_src kcats
[#b64 "core" #b64 "lO96m8LQJNw5Hpv7U0iHcLZEzZ-T2NNIgVCGaiLGSlg" ğŸ”³]
#+end_src

#+begin_src kcats
  [fib] ğŸ« decache ; string read
#+end_src

#+RESULTS:
#+begin_src kcats
thread 'main' panicked at src/types/container/environment.rs:244:62:
called `Result::unwrap()` on an `Err` value: [[actual [[asked [dictionary]] [handled ğŸ”³] [reason "word is not defined"] [trace ğŸ”³] [type error] [unwound [dictionary ğŸ”€ [module [words] ğŸ”€ update] â€¢ğŸ›¡ï¸ â–¶ï¸ â€¢ğŸ—‘ï¸]]]] [asked [dictionary]] [reason "type mismatch"] [type error]]
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+end_src

#+begin_src kcats
  "123" encode dictionary [crypto] ğŸ« module  [words] ğŸ”€ update  [hash] confine
#+end_src

#+RESULTS:
#+begin_src kcats
#b64 "pmWkWSBCL51Bfkhn79xPuKBKHz__H6B-mY6G9_eieuM"
#+end_src
