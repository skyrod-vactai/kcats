#+PROPERTY: header-args:kcats :results code :exports both


* Stuff
#+begin_src kcats
  1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] generator
#+end_src

#+RESULTS:
#+begin_src kcats
[[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥ [[[[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸]
0 1
#+end_src

#+begin_src kcats
  1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] generator ;; our original generator
  [odd?] keep ;; a generator that keeps calling the one
              ;; below it until it gets something that
              ;; passes the predicate we specified
  4 taker ;; another generator that calls generate 20 times
  â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸  ğŸ—‘ï¸ â–¶ï¸  ğŸ—‘ï¸ â–¶ï¸  ğŸ—‘ï¸ â–¶ï¸  
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ [[[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] 5 8
#+end_src

#+begin_src kcats
  [1 2 3 4 5] liberator
  [3 >]  
  [âœ‚ï¸2ï¸âƒ£ ;; â–¶ï¸ the generator below to get value v
   [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
   [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
   â†”ï¸ dump â€¢â€¢ğŸ—‘ï¸] ğŸ’ 
  [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
  â³ ;; repeat until generator below is finished
   â–¶ï¸ dump
   [ â€¢ğŸ—‘ï¸
   ] [ğŸ”³] [ ğŸ”€] ğŸª†
   ;â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸
   collect
#+end_src

#+RESULTS:
#+begin_src kcats
[âœ”ï¸ 1 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [2 3 4 5]]
[âœ”ï¸ 2 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [3 4 5]]
[âœ”ï¸ 3 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [4 5]]
[ğŸ”³ 4 [[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] [5]]
[4 [5]]
[[actual 4]
 [asked [program?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [type error]
 [unwound [ğŸª† collect]]]
[ğŸ”€] [ğŸ”³] [â€¢ğŸ—‘ï¸] 4 [5]
#+end_src

#+begin_src kcats
  [1 2 3 4 5] liberator
  [3 >]
  [2ï¸âƒ£  ;; â–¶ï¸ the generator below to get value v
   [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
   [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
   âš–ï¸
   [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
   â³] ;; repeat until generator below is finished
  ğŸ’   â–¶ï¸ 
 ; ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸ [[3 >]
       ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸]
 [ğŸ”³ ğŸ”³]
 â†”ï¸ [ğŸ—‘ï¸ ğŸ—‘ï¸ [[ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
             ğŸ”³ â†”ï¸ [[3 >]
                   ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸]
             [ğŸ”³ ğŸ”³]
             â†”ï¸]
            [ğŸ—‘ï¸ ğŸ—‘ï¸]
            ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸]
     â–¶ï¸]
 ğŸ”³ â†”ï¸]
[1 2 3 4 5]
#+end_src

#+begin_src kcats
  [1 2 3 4 5] liberator
  [3 >]

  [2ï¸âƒ£ ;; pull the parent generator into this program
   [â–¶ï¸  ;; exec the generator below to get value v
    [1ï¸âƒ£ ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] ;; check if v does NOT match given pred, 
    [ğŸ”³ ğŸ”³] ;; if generator below is finished, return 2 empty values 
    â†”ï¸]
   [ğŸ—‘ï¸ ğŸ—‘ï¸] ;; drop both the value v and the result of pred
   â³ â–¶ï¸ ] ;; repeat until generator below is finished
  ğŸ’
  [â€¢ğŸ—‘ï¸] [ğŸ”³] [ğŸ”€] ğŸª†
  collect
#+end_src

#+RESULTS:
#+begin_src kcats
[4 5]
#+end_src

Use normal recursive fn for generators instead of recur?
#+begin_src kcats
[1 2 3 4] liberator
#+end_src

#+RESULTS:
#+begin_src kcats
[ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸]
[1 2 3 4]
#+end_src

#+begin_src kcats
  [1 2 3 4] [ğŸ“¤ [[liberator] ğŸª„] [[]] â†”ï¸] â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
1 [ğŸ“¤ [[[ğŸ“¤] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
   ğŸ”³ â†”ï¸]
[2 3 4]
#+end_src

#+begin_src kcats
  [[lib [[ğŸ“¤ [[lib] ğŸª„] [[]] â†”ï¸]]]]
  [[1 2 3 4] lib â–¶ï¸ ğŸ—‘ï¸ â–¶ï¸]
  let â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
2 [ğŸ“¤ [[lib] ğŸª„]
   [ğŸ”³] â†”ï¸]
[3 4]
#+end_src

#+begin_src kcats
  [[taker [[[[positive?] ğŸ›¡ï¸ ;; counter still positive?
             [ğŸ—‘ï¸ 1ï¸âƒ£ ğŸ‹]  ;; run the parent generator
             [ğŸ”³] âš–ï¸ â–¶ï¸ ] ğŸ’] ğŸ‹ 
           [[dec â€¢ğŸ—‘ï¸] ğŸª„ dump taker ğŸ”€ ]
           []
           âš–ï¸]]]
  [[1 2 3 4 5] liberator
  3 taker â–¶ï¸ ğŸ—‘ï¸]
  let â–¶ï¸ 
  ;;taker

#+end_src

#+RESULTS:
#+begin_src kcats
[1 2 [2 3 4 5]]
[[positive?] ğŸ›¡ï¸ [ğŸ—‘ï¸ 2 ğŸ‹] [ğŸ”³] âš–ï¸ â–¶ï¸ [[dec â€¢ğŸ—‘ï¸]
                                    ğŸª„ dump taker ğŸ”€]
 ğŸ”³ â†”ï¸]
[2 3 4 5]
#+end_src

* Fold
#+begin_src kcats
    integers generator 25 taker [+]
    [â–¶ï¸] ğŸª„ ;; generate the first item below the fold program 
    [[â–¶ï¸] â€¢ğŸ‹]
    [ğŸ”€  [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸ âš“ â€¢ğŸ—‘ï¸ â€¢â€¢ğŸ—‘ï¸] [] [â–¶ï¸] ğŸª† â–¶ï¸ ğŸ—‘ï¸
    ;[[â–¶ï¸] ğŸ‹ ğŸ”³ [âœ‚ï¸1ï¸âƒ£ ğŸ‘¥] â†”ï¸] ğŸ’
    ;;; generate the first item under the loop body
    ;[â–¶ï¸] ğŸª„
   ; ğŸŒ€ ; â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
300 24
#+end_src
org-tanglesync-
* Introspection
Search the docs of emoji words to see which symbol you're looking for
#+begin_src kcats
  words [[1 doc] lookup "swap" contains?] ğŸ§² â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[ğŸ”€ [[definition builtin-function]
     [doc "The crossing arrows denote swapping the top two stack items."]
     [examples [[[1 2 3 ğŸ”€] [1 3 2] "Swap top two items"]]]
     [spec [[[item a]
             [item b]]
            [[item b]
             [item a]]]]]]
 [â€¢ğŸ”€ [[definition builtin-function]
      [doc "The crossing arrows with dot represents swapping one stack position down (2nd and 3rd items)"]
      [examples [[[1 2 3 â€¢ğŸ”€] [2 1 3] "Swap 2nd and 3rd items"]]]
      [spec [[[item a]
              [item b]
              [item c]]
             [[item a]
              [item c]
              [item b]]]]]]]
#+end_src

apropos - which functions match the stuff on the stack
#+begin_src kcats
  5
  ;; the hierarchy
  [item
   [[number [[integer []]
             [float []]]]
    [container [[disp]]]]]
  ğŸ“¸ [type] ğŸšœ â–¶ï¸
  [integer foo]


  [list?] ğŸ›¡ï¸ [ğŸ—‘ï¸ first ğŸ] when â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[integer] [number] 5
#+end_src
* Single-item generators
#+begin_src kcats
  [integers generator 100 taker [ğŸ‘¥ *] each [7 mod 0 =] keep]
  [] ğŸ”€ ğŸ’‰ â–¶ï¸ ;; encapsulate
  [[â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤] [] [] [ğŸ—‘ï¸] ğŸª† â–¶ï¸

#+end_src

#+RESULTS:
#+begin_src kcats
0 [[[â–¶ï¸ [[7 mod 0 =] ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] [ğŸ”³ ğŸ”³]
     â†”ï¸ [ğŸ—‘ï¸ ğŸ—‘ï¸ [[â–¶ï¸ [[7 mod 0 =] ğŸ›¡ï¸ â–¶ï¸ â˜¯ï¸] [ğŸ”³ ğŸ”³]
                 â†”ï¸]
                [ğŸ—‘ï¸ ğŸ—‘ï¸]
                ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸]
         â–¶ï¸]
     ğŸ”³ â†”ï¸]
    ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
   [[â–¶ï¸ [ğŸ“¸ ğŸ§¦ [ğŸ‘¥ *]
         ğŸª„ ğŸ§¦ â€¢ğŸ—‘ï¸ first]
     bail]
    ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
   [[ğŸ“¸ ğŸ§¦ [positive?] ğŸª„ ğŸ§¦ first [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ğŸ”³ [ğŸ”³ ğŸ”³]
                                â†”ï¸]
     [ğŸ”³] â†”ï¸]
    [[dec] ğŸª„]
    [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
   99 [[inc ğŸ‘¥]
       ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸]
   0]
#+end_src
#+begin_src kcats
  integers generator 100 taker [ğŸ‘¥ *] each [7 mod 0 =] keep collect
#+end_src

#+RESULTS:
#+begin_src kcats
[0 49 196 441 784 1225 1764 2401 3136 3969 4900 5929 7056 8281 9604]
99
#+end_src

* Fix 'type'
#+begin_src kcats
   [[a b][c d][type foo]] association

   [[type] lookup]
   [ğŸ“ 1 =]
   [first [type] ğŸ« =]
   [ğŸ—‘ï¸ first second]
   [first first]
   âš–ï¸ 
   [ğŸ”³]
   âš–ï¸
   [[association] ğŸ«]
   triplet
  [â–¶ï¸] ğŸ“£ ; â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[ğŸ”€ [[ğŸ“¤] ğŸª„ ğŸ‘¥ [ğŸ›Ÿ [â€¢ğŸ›¡ï¸] ğŸ‹] ğŸ‹ ğŸ”³ [â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸]
    [ğŸ—‘ï¸ ğŸ“£]
    âš–ï¸]
 [ğŸ—‘ï¸ ğŸ—‘ï¸ ğŸ”³] â†”ï¸]
[â–¶ï¸] [[[type] lookup]
      [ğŸ“ 1 = [first [type] ğŸ« = [ğŸ—‘ï¸ first second] [first first]
              â†”ï¸]
       [ğŸ”³] â†”ï¸]
      [[association] ğŸ«]]
[[a b]
 [c d]
 [type foo]]
#+end_src
* Fix any
#+begin_src kcats
  ;; start with ğŸ’¯
  [[] 4 6 8 9 10] []
  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥ â˜¯ï¸] ;; more items
   [[] ğŸ”³ []] ;; empty list, return []
   â†”ï¸ ] ğŸ’
  [ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [â–¶ï¸] ğŸª† â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src
* Fix pair?
#+begin_src kcats
   [ğŸ“ 2 =] [[asked] lookup [sized?] =] [ğŸ—‘ï¸ ğŸ—‘ï¸ []] [[]] âš–ï¸  ğŸ©¹ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³
#+end_src
* fix zip
#+begin_src kcats
  "foo" "food"
  ğŸ”³ âš“ ;; save accumulator below args
  [[] both?] ğŸ›¡ï¸ ;; stop when either list is empty
  [ğŸ—‘ï¸ [ğŸ“¤] both â€¢ğŸ”€ pair ;; take from each list and pair them up
   âš“ [ğŸ“®] â€¢ğŸª„] ;; put them into the accumulator
  â³ â–¶ï¸
  ğŸ—‘ï¸ ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[\f \f]
 [\o \o]
 [\o \o]]
#+end_src
* fix 'both'
#+begin_src kcats
1 2 [inc] [pair] ğŸª„ ğŸªœ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
3 2
#+end_src
* fix starts?
#+begin_src kcats
  "food" "foo"
  [[zip [ğŸ« =] ğŸ’¯ â–¶ï¸] ;; the items at matching indexes are equal
   [[ğŸ“] both >=]] ;; the prefix is shorter than the target
  [â–¶ï¸] â€¢ğŸ›¡ï¸ ğŸ’¯ â–¶ï¸ 
  â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
["foo" "food"]
["foo" "food"]
âœ”ï¸
#+end_src
* fix type
#+begin_src kcats
  [[forp foo] [bloop toop]]
  [ğŸ“ 1 =] ğŸ›¡ï¸
  [ğŸ—‘ï¸ first first [type] ğŸ« =] ğŸ›¡ï¸
  [ğŸ—‘ï¸ ğŸ—‘ï¸ first second]
  [ğŸ—‘ï¸ first first]
  âš–ï¸
  [ğŸ”³]
  âš–ï¸ 

  [[type] lookup]
  [[association] ğŸ«]
  â€¢ğŸ”€ triplet 
  [ğŸ›¡ï¸ â–¶ï¸] ğŸ“£ â–¶ï¸ â€¢ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
association
#+end_src

#+begin_src kcats
  [[typef foo]]
  [[[ğŸ“ 1 =] [ğŸ—‘ï¸
              [first first [type] ğŸ« =] ğŸ›¡ï¸
              [ğŸ—‘ï¸ first second]
              [first first]
              âš–ï¸ â–¶ï¸]]
   [[[type] lookup] [â€¢ğŸ—‘ï¸]]
   [[âœ”ï¸] [[association] ğŸ«]]] decide
#+end_src

#+RESULTS:
#+begin_src kcats
typef
#+end_src

#+RESULTS:
#+begin_src kcats
âœ”ï¸
#+end_src

#+begin_src kcats
   ;[[type foo] [x y]] association
   ;"foo" encodestring
   [[types bar] [sdf fdsd]] association
   [[[empty?] [[nothing]]]
    [[word?] [[word]]]
    [[number?] [[number]]]
    [[string?] [[string]]]
    [[bytes?] [[bytes]]]
    [[pipe?] [[pipe]]]
    [[error?] [[error]]]
    [[environment?] [[environment]]]
    [[set?] [[set]]]
    [[association?] [ğŸ—‘ï¸ [[[ğŸ“ 1 =] [ğŸ—‘ï¸
                                   [first first [type] ğŸ« =] ğŸ›¡ï¸
                                   [ğŸ—‘ï¸ first second]
                                   [first first]
                                   âš–ï¸ â–¶ï¸]]
                      [[[type] lookup] [â€¢ğŸ—‘ï¸]]
                      [[âœ”ï¸] [[association] ğŸ« â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸ dump]]] decide
                     ğŸ [] [] ğŸ›Ÿ]]
    [[list?] [[list]]]
    [[âœ”ï¸] [[item]]]]
   decide ğŸ« â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[association]]
association
#+end_src
* book
#+begin_src kcats
  [[price 15][name foo]] [[price 10] [name bar]] pair [[price] lookup] sort reverse first
#+end_src

#+RESULTS:
#+begin_src kcats
[[price 15]
 [name foo]]
#+end_src
* loop in terms of recur
  avoids running pack each time:
  #+begin_src kcats
    10 âœ”ï¸ [ğŸ—‘ï¸ -2 * ğŸ‘¥ 50 <]
    [] ğŸ”€ [] [â–¶ï¸] ğŸª† 
    â–¶ï¸
  #+end_src

  #+RESULTS:
  #+begin_src kcats
  160
  #+end_src
* COMMENT until
#+begin_src kcats
    2 [even?] [inc] generator
  ;[ğŸ­] ğŸª„ â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[inc [[[inc] ğŸ”³ ğŸ”³ [ğŸ”€] ğŸª† â–¶ï¸] ğŸ”€]
 ğŸ”³ â†”ï¸]
[even?] 2
#+end_src

#+begin_src kcats
   2 [even?]  ğŸ›¡ï¸ [ğŸ—‘ï¸ inc]
   [ğŸ­] ğŸª„ ;; reverse logic of pred
   ;; run body once, with dummy pred result
   ğŸ‘¥ [[[]] ğŸ”€ ğŸ”— ğŸª„] ğŸª„ â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
4
#+end_src
* advance
#+begin_src kcats
  [1 2 +] stage
  [[program] lookup ğŸ“] ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ;; count up the program length, we'll run until it's smaller than this

  [[[program] lookup ğŸ“] ğŸ›¡ï¸ â–¶ï¸ dump  ;; only stop if expr empty or shorter than we started off
   [[ positive?] [<=]] [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ ğŸ›¡ï¸ â–¶ï¸ ]
  [ğŸ—‘ï¸ eval-step]  ;; evaluate the environment one step
  â³ â–¶ï¸
  â€¢ğŸ—‘ï¸
#+end_src

#+begin_src kcats
  [1 2 ] stage
  ğŸ‘¥ [program] lookup ğŸ“ ğŸ”€
  [[program] lookup ğŸ“
   [[positive?] [<=]] [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ â–¶ï¸] ğŸ›¡ï¸ 
  [ğŸ—‘ï¸ eval-step]
  â³ â–¶ï¸ â€¢ğŸ—‘ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[dictionary [[modules ğŸ”³]
              [words 260_entries]]]
 [program [2]]
 [stack [1]]]
#+end_src
* using
#+begin_src kcats
  [#b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U"]
  [words [fibonacci] lookup]
  stage ğŸ”€ ;; lm env
  [[stack] [ğŸ“¸] â€¢ğŸ‹ assign] ğŸª„ ;; capture the stack at runtime
  using ;; set up the resolver 
  evaluate ;; execute the program in the inner environment
  [stack] lookup restore
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³
#+end_src

#+RESULTS:
#+begin_src kcats
Error parsing input: [[asked [read]] [reason "Invalid float"] [type error]]
#+end_src

#+begin_src kcats
  dictionary #b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U" decache
  [[hashbytes] ;; calculate module hash
   [string read  [words] ğŸ”€ dump update]] ;; install the module in the dictionary
  [â–¶ï¸] ğŸšœ â–¶ï¸ ;; fork 
  â€¢ğŸ—‘ï¸ ğŸ« â€¢ğŸ”€ ;dictmerge
#+end_src

#+RESULTS:
#+begin_src kcats
[[[[fibonacci [[definition [1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥]]]]]] ğŸ”—]
 [words] [[modules ğŸ”³]
          [words 260_entries]]]
[[modules ğŸ”³]
 [words 261_entries]]
[[modules ğŸ”³]
 [words 260_entries]]
#b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U"
#+end_src

#+begin_src kcats
words [[fibonacci [[definition [1 0 [[+] â€¢ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ ğŸ‘¥]]]]]]
ğŸ”—

#+end_src

#+RESULTS:
#+begin_src kcats
261_entries
#+end_src

figure out which modules are present
#+begin_src kcats
  dictionary #b64 "zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U" decache

  inscribe
  [words [[0] lookup] ğŸšœ â–¶ï¸] [program dictionary] label evaluate
  ;[first] ğŸšœ â–¶ï¸ 
  ;first ;second inspect
#+end_src

#+RESULTS:
#+begin_src kcats
[[dictionary [[modules ğŸ”³]
              [words 261_entries]]]
 [program ğŸ”³]
 [stack [[â€¢ğŸ‹ tunnel â€¢â€¢ğŸ‹ cache > parse-utf8 emit get each cut â–¶ï¸ top ğŸ’‰ floor set use
          ğŸ©¹ file-out frequencies inspect
          â€¢ğŸ›¡ï¸ future â€¢ğŸª„ ğŸ§¹ assign walk zubPuf7fwUx1W6i8RJqAE8DR43dHFfnjx1xulAZ0D_U/fibonacci
          ğŸ« ğŸªœ string stepper ğŸ string? empty environment character resolve list? encodejson
          empty?
          quot ğŸ—‘ï¸ addmethod catcher evaluate ğŸ“ radix update autoformat indexed days association
          inc advance ğŸ”€ standard abs dec sqrt finished?
          pair? until ğŸ“® within? prime draft max-by using pipe? ğŸ›Ÿ reap heatmap parse >= â³ both?
          decide â€¢â€¢ğŸ‘¥ pop min-by
          first attend rest taker hours ğŸ’¯ range ğŸ§¦ under indexof starts? format number exp handoff
          set? timestamps compare-by let capture
          fail random odd? or split definition and intersection <= spit serversocket ğŸ’ tos
          slice sort-indexed encodenumber sprint confine pair lookup
          stage socket â€¢â€¢ğŸª„ timer min both = interpose assemble ğŸ‘¥ rem bail pipe-out sender repetition
          sign â€¢ğŸ”€ + * verify
          ğŸª† round association? - ğŸšœ breakpoint spawn resume last encodestring flip second ğŸª„
          dipped combinations when dump label ğŸ‹ â†”ï¸
          break ğŸ”— skipper joiner dictmerge sleep encode error? contains? â€¢â€¢ğŸ—‘ï¸ slurp print method?
          file-in keep minutes sort times fold generator
          ğŸŒ€ positive? mod bytes? words seconds bits ends? receiver animate group word? max
          â€¢â€¢ğŸ›¡ï¸ pipe-in cram handle â€¢ğŸ—‘ï¸ ğŸ›¡ï¸ dropper
          over integers log number? milliseconds liberator pad read type ğŸ“¤ even? zip triplet
          assert database environment? / close flatten butlast
          ğŸ§² xor primrec zero? prepend eval-step âš“ negative? hashbytes â˜¯ï¸ decodejson something?
          tracer restore persist value collect produce ğŸ­ ceiling
          reverse retry updates parse-edn word dictionary key compare unassign âœ”ï¸ decache select
          â€¢ğŸ‘¥ ğŸ“¸ âš–ï¸ ğŸ“£ indexer entry module inscribe
          <]]]]
#+end_src
* Fix sweep
#+begin_src kcats
  0 10 1 range liberator
  5 dropper [10 *] each []
  [[â–¶ï¸] ğŸ‹] [ğŸ“®] [â€¢ğŸ—‘ï¸] [â–¶ï¸] ğŸª† â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[50 60 70 80 90]
#+end_src
* fix group
#+begin_src kcats
  [1 2 3 4 5] liberator [odd?]
  ğŸ›¡ï¸
  [1ï¸âƒ£ â–¶ï¸ ;; k v state
   ğŸ ğŸ”€   ;;  v k state
   ğŸ [ğŸ“®] ğŸ”—  update] ğŸ’
  ğŸ”³ association ;; state f
  ğŸ”€ cram
#+end_src

#+RESULTS:
#+begin_src kcats
[[âœ”ï¸ [1 3 5]]
 [ğŸ”³ [2 4]]]
ğŸ”³
#+end_src
* fix partition
#+begin_src kcats
    [[take-chunk [[taker collect dump
                  ; â€¢ğŸ—‘ï¸ â€¢ğŸ—‘ï¸
                  ] ; drop the used-up taker generator
                  ğŸ”— â€¢ğŸ‹]]
     [shift [[ğŸ“ <=]
             [ğŸ”€ 0 slice]
             [ğŸ”³] âš–ï¸ ğŸ›¡ï¸ â–¶ï¸ ğŸ”€]]
     [partition [[over ğŸ take-chunk [ğŸ”— shift] bail]
                 [[over] ğŸ‹ wrap take-chunk ğŸ”€ ğŸ—‘ï¸ shift]
                 â†”ï¸]]]
     [[1 2 3 4 5 6 7] [ 2 2 partition] assemble] let â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
[[1 2]
 [3 4 5 6 7]]
[[actual 2]
 [asked [sized?]]
 [handled ğŸ”³]
 [reason "type mismatch"]
 [type error]
 [unwound [ğŸ”— shift ğŸ”³ ğŸ§¦ first]]]
[1 2]
2 2 [3 4 5 6 7]
#+end_src
* fix produce
#+begin_src kcats
  [integers generator
   [ğŸ‘¥ *] each
   10 dropper] [] ğŸ”€ ğŸ’‰ â–¶ï¸
  [â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤ ğŸ—‘ï¸ 
  [â–¶ï¸] ğŸ’‰ â–¶ï¸ ğŸ“¤
#+end_src

#+RESULTS:
#+begin_src kcats
121 [[[â–¶ï¸ [ğŸ“¸ ğŸ§¦ [ğŸ‘¥ *]
           ğŸª„ ğŸ§¦ â€¢ğŸ—‘ï¸ first]
       bail]
      ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
     [[inc ğŸ‘¥]
      ğŸ”³ [ğŸ”³] [ğŸ”€] ğŸª† â–¶ï¸]
     11]
#+end_src
* fix parse
#+begin_src kcats
  [[104 101 108 108 111]              ;; "hello" (all ASCII)
   [228 189 160 229 165 189]          ;; "ä½ å¥½" (two complete Chinese chars)
   [104 105 226]                      ;; "hi" + start of "â‚¬"
   [130 172]                          ;; completion of "â‚¬"
   [240 159 145]                      ;; start of "ğŸ‘‘"
   [145]                              ;; completion of "ğŸ‘‘"
   [97 98 99 240]                     ;; "abc" + start of "ğŸŒˆ"
   [159 140 136]]                     ;; completion of "ğŸŒˆ"



  liberator
  [#b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸] each ;; convert lists of ints to byte arrays
  [parse-utf8]

  ğŸ”³ ğŸ”³ ;; state - parsed object output (on top) and unparsed input 

  [[ğŸ‘¥ â˜¯ï¸] ; there's no output
   [ğŸ—‘ï¸ [â–¶ï¸] â€¢â€¢ğŸ‹] ;; exec parent generator 
   [[]] ;; leave an empty value to be consumed by outer â³ exiting
   âš–ï¸ 
   [ğŸ”€ [ğŸ”—] ğŸª„ ;; new input to previous input
    [ğŸ‘¥] â€¢ğŸ‹ â–¶ï¸] ;; exec a copy of parser program: output input parser
   â³ â–¶ï¸] ;; leave the output on top for the recurrence condition check
  [ğŸ“¤] []
  [ğŸ”€] ğŸª† "" ğŸ§¹ â–¶ï¸ 


#+end_src

#+RESULTS:
#+begin_src kcats
"helloä½ å¥½hiâ‚¬ğŸ‘‘abcğŸŒˆ" [parse-utf8] ğŸ”³
#+end_src



byte array convert
#+begin_src kcats
  [104 101 108 108 111] #b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
#b64 "aGVsbG8"
#+end_src

#+begin_src kcats
  [] [] ["yes"] when
  ["yeswhile"] â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[[asked [consume]]
 [handled ğŸ”³]
 [reason "not enough items on stack"]
 [type error]
 [unwound [â†”ï¸]]]
ğŸ”³ ["yeswhile" [[["yes"] ğŸ”³ â†”ï¸] ["yeswhile"] ğŸ”³ [â–¶ï¸] ğŸª† â–¶ï¸] â–¶ï¸]
#+end_src

* Fix every
#+begin_src kcats
  [1 2 3] [[ğŸ“¤] []] [â–¶ï¸]

  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
   [ğŸ”³ âœ”ï¸ ğŸ”³] ;; empty list, return âœ”ï¸
   â†”ï¸] ğŸ’
  [dump ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [] ğŸª† â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
[1 1 [ğŸ”³] [2 3]]
[[[ğŸ“¤ ğŸ”€ [â–¶ï¸] ğŸ‹ ğŸ‘¥] [ğŸ”³ âœ”ï¸ ğŸ”³] â†”ï¸] [dump ğŸ—‘ï¸ ğŸ—‘ï¸] [â€¢ğŸ—‘ï¸] ğŸ”³ ğŸª† â–¶ï¸] [ğŸ”³] [2 3]
#+end_src

#+begin_src kcats
  [1 2 3] [[ğŸ“¤] []] [â–¶ï¸]

  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
   [ğŸ”³ âœ”ï¸ ğŸ”³] ;; empty list, return âœ”ï¸
   â†”ï¸] ğŸ’
  [dump ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [] ğŸª† â–¶ï¸ 
#+end_src

ok what we want here is not 'every' - we want call chaining like =bail= but for multiple rounds.

Let's write it! And I think we should have =every= and =any= go back to
pure logical tests and enforce the "same stack" invariant.

#+begin_src kcats
   1
   [[ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc] [ğŸ‘¥ odd?] [ğŸ—‘ï¸ inc]]
  ; []
   [and] â€¢ğŸ›¡ï¸
   [ğŸ“¤ ğŸª„]
   â³ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ 2
#+end_src

#+begin_src kcats
  [2 4 6] [inc]
  ğŸ›¡ï¸ 
  [[ğŸ“¤ ğŸ”€ 1ï¸âƒ£ ğŸ‹ ğŸ‘¥] ;; more items
   [ ğŸ”³ âœ”ï¸ ğŸ”³] ;; empty list, return âœ”ï¸
   â†”ï¸] ğŸ’
  [ğŸ—‘ï¸ ğŸ—‘ï¸]
  [â€¢ğŸ—‘ï¸]
  [â–¶ï¸] ğŸª† â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
âœ”ï¸
#+end_src
* Fix split
#+begin_src kcats
    "abddcfdedd" ;liberator
    ["dd"

    split


    parse
    collect] assemble

#+end_src

#+RESULTS:
#+begin_src kcats
["ab" "cfde"]
#+end_src

next: handle end of stream

#+RESULTS:
#+begin_src kcats
[[\a \b]
 "cfde"]
[ğŸ”³] [[ğŸ‘¥ [ğŸ“® "dd"]
      ğŸª„ [â˜¯ï¸] [ends?] ğŸ›¡ï¸ pair [â–¶ï¸] ğŸ“£ [ğŸ—‘ï¸ ğŸ“ 0 ğŸ”€ - 0 ğŸ”€ slice]
      [ğŸ—‘ï¸ ğŸ”³]
      âš–ï¸ â–¶ï¸]
     ğŸª„ ğŸ”€ [ğŸ“® "" ğŸ”€] ğŸ”³ â†”ï¸]
""
#+end_src

let's see if this version of parse works with other stuff
#+begin_src kcats
  [[104 101 108 108 111]              ;; "hello" (all ASCII)
   [228 189 160 229 165 189]          ;; "ä½ å¥½" (two complete Chinese chars)
   [104 105 226]                      ;; "hi" + start of "â‚¬"
   [130 172]                          ;; completion of "â‚¬"
   [240 159 145]                      ;; start of "ğŸ‘‘"
   [145]                              ;; completion of "ğŸ‘‘"
   [97 98 99 240]                     ;; "abc" + start of "ğŸŒˆ"
   [159 140 136]]                     ;; completion of "ğŸŒˆ"
  liberator
  [#b64 "" ğŸ”€ [ğŸ“®] ğŸªœ â–¶ï¸] each ;; convert lists of ints to byte arrays
  [ parse-utf8] #b64 ""
  ğŸ”³ ;; state - parsed object output buffer (on top), unparsed input 

  [] ;; there's output?
  [[]]  ;; leave an empty value to be consumed by outer â³ exiting
  [[] [â–¶ï¸] â€¢â€¢ğŸ‹] ;; exec parent generator 
  âš–ï¸ 
  [ğŸ”€ [ğŸ‘¥] â€¢â€¢ğŸ‹ â–¶ï¸] ;; exec a copy of parser program: output input parser
  â³ ;; leave the output on top for the recurrence condition check
  [ğŸ“¤] [[[]] ğŸ”€]
  [ğŸ”€] ğŸª† "" ğŸ§¹ â–¶ï¸ 
#+end_src

#+RESULTS:
#+begin_src kcats
"helloä½ å¥½hiâ‚¬ğŸ‘‘abcğŸŒˆ" [ğŸ”³] [parse-utf8] ğŸ”³
#+end_src

* Convert number list to bytes
#+begin_src kcats
  1
  [list?]
  [number?] ğŸ’¯ pair [ğŸ›¡ï¸ â–¶ï¸] ğŸ’¯ â–¶ï¸
#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ 1
#+end_src
* fix indexof
#+begin_src kcats
  [a b c] 
  [c] ğŸ«
  [[second ğŸ [1ï¸âƒ£] = â˜¯ï¸] skipper
   [indexer] â€¢ğŸª„
   â–¶ï¸ first] ğŸ’ 

  assemble
#+end_src

#+RESULTS:
#+begin_src kcats
2
#+end_src
* Fix skipper, dropper to be lazy
dropper
#+begin_src kcats
  [1 2 3 4 5] liberator
  6

  [positive?] ğŸ›¡ï¸ ;; condition
  [ğŸ—‘ï¸ [â–¶ï¸] ğŸ‹ ;; call parent 
   ğŸ”³ ;; if we get something, we're done
   [ğŸ—‘ï¸ ğŸ”³ ğŸ”³] ;; otherwise signal stop with empty generator
   â†”ï¸]
  [ğŸ—‘ï¸ â–¶ï¸ ğŸ”³] âš–ï¸ ;; if counter reaches zero we're done dropping 
  [ğŸ—‘ï¸ dec] â³
  [] [ğŸ”³] [ğŸ—‘ï¸] ğŸª† 
  collect

#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ ğŸ”³
#+end_src

#+begin_src kcats
   [1 2 3 4 5] liberator [10 <]

   [[â–¶ï¸] ğŸ‹] ;; get the item from parent
   [ğŸ”€ [â–¶ï¸] ğŸ›¡ï¸ â–¶ï¸] ;; run the pred on it, keep the pred
   [ğŸ—‘ï¸ ğŸ”³ ğŸ”³] âš–ï¸ ;; when parent is empty, leave negative on the stack
   [ğŸ—‘ï¸ â€¢ğŸ—‘ï¸] â³ ;; keep consuming items while they match pred
   [] [[]] [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸª†
   collect

#+end_src

#+RESULTS:
#+begin_src kcats
ğŸ”³ ğŸ”³
#+end_src
* Fix radix
#+begin_src kcats
  33 2

  [ğŸ—‘ï¸ 1ï¸âƒ£ [/] ğŸ›¡ï¸ â–¶ï¸ ğŸ”€ 
   [*] â€¢ğŸ›¡ï¸ â–¶ï¸
   â€¢ğŸ”€ -
   ğŸ”€ [prepend] ğŸª„] ğŸ’

  [ğŸ”³ ğŸ”€ [positive?] ğŸ›¡ï¸] ğŸª„
  â³ â–¶ï¸ ğŸ—‘ï¸ 


#+end_src

#+RESULTS:
#+begin_src kcats
[1 0 0 0 0 1]
#+end_src

#+begin_src kcats
7 2.1 quot
#+end_src

#+RESULTS:
#+begin_src kcats
3.333333333333333
#+end_src
* fix pad
#+begin_src kcats
  [1 2 3] 5 0 
  [[[ğŸ“] ğŸ›¡ï¸ â–¶ï¸] ğŸ‹ -] ğŸª„
  ğŸ”€ repetition â–¶ï¸ 
  ğŸ”€ ğŸ”—
#+end_src

#+RESULTS:
#+begin_src kcats
[0 0 1 2 3]
#+end_src
* fix cut
#+begin_src kcats
  "abcdefghijklmnopqrstuvwxyz" 5
  [[[ğŸ“] ğŸ›¡ï¸ ğŸ‹ slice]
   [0 ğŸ”€ slice]]
  [â–¶ï¸] ğŸšœ â–¶ï¸ 
  [ğŸ—‘ï¸ ğŸ—‘ï¸] ğŸª„ ğŸ«
#+end_src

#+RESULTS:
#+begin_src kcats
"abcde" "fghijklmnopqrstuvwxyz"
#+end_src
* fix frequencies
#+begin_src kcats
  "Hello there!" liberator
  ğŸ”³ association
  [ğŸ [ğŸ”³ [inc] [1] âš–ï¸ â–¶ï¸ ] update]
  cram
#+end_src

#+RESULTS:
#+begin_src kcats
[[\space 1]
 [\! 1]
 [\H 1]
 [\e 3]
 [\h 1]
 [\l 2]
 [\o 1]
 [\r 1]
 [\t 1]]
""
#+end_src
