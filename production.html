<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-10-18 Wed 23:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The kcats Programming Language (Production Implementation)</title>
<meta name="author" content="Skyrod Vactai" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="docs-custom.css"/>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The kcats Programming Language (Production Implementation)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8984070">1. Production implementation</a>
<ul>
<li><a href="#org8abaa4b">1.1. Base Language</a></li>
<li><a href="#org11b9c16">1.2. Status</a></li>
<li><a href="#orgee43e71">1.3. Building</a>
<ul>
<li><a href="#org05506e3">1.3.1. Dependencies</a></li>
<li><a href="#orgbd2c488">1.3.2. Build</a></li>
</ul>
</li>
<li><a href="#using">1.4. Using</a>
<ul>
<li><a href="#orgf111ebd">1.4.1. Command line REPL</a></li>
<li><a href="#org0fd33f2">1.4.2. Command line</a></li>
<li><a href="#orge8479bf">1.4.3. Emacs Interactive REPL</a></li>
</ul>
</li>
<li><a href="#source">1.5. Source</a>
<ul>
<li><a href="#org076ffca">1.5.1. Project File</a></li>
<li><a href="#org90d4018">1.5.2. Internal data types</a>
<ul>
<li><a href="#org6e0d5e8">1.5.2.1. Basic internal types</a></li>
<li><a href="#orge85ed29">1.5.2.2. Collection types</a></li>
<li><a href="#org274ea82">1.5.2.3. Associative types</a></li>
<li><a href="#orgda3d386">1.5.2.4. Error types</a></li>
<li><a href="#org561d52d">1.5.2.5. Dictionary types</a></li>
<li><a href="#orgc6d4614">1.5.2.6. Environment types</a></li>
<li><a href="#org438b799">1.5.2.7. Cryptographic primitives</a></li>
</ul>
</li>
<li><a href="#org17e0b40">1.5.3. Serialization</a></li>
<li><a href="#org944ee6c">1.5.4. Builtin words</a></li>
<li><a href="#org89cf950">1.5.5. Top level execution</a></li>
<li><a href="#org41de729">1.5.6. Pipes (input/output)</a></li>
</ul>
</li>
<li><a href="#orga05c5e9">1.6. Issues</a>
<ul>
<li><a href="#orgb148d30">1.6.1. <span class="todo INPROGRESS">INPROGRESS</span> Interactive mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></a>
<ul>
<li><a href="#orga74379c">1.6.1.1. <span class="todo TODO">TODO</span> Only print the changed part of the stack</a></li>
<li><a href="#orgbd7b307">1.6.1.2. <span class="todo TODO">TODO</span> Emacs keybindings to send common stack ops</a></li>
</ul>
</li>
<li><a href="#org1a73261">1.6.2. <span class="done DONE">DONE</span> Install the lexicon in the proper place</a></li>
<li><a href="#org1cc9125">1.6.3. <span class="done CANCELED">CANCELED</span> Add option to read an alternative lexicon file</a></li>
<li><a href="#org89bb0e1">1.6.4. <span class="done DONE">DONE</span> Package the binary for various platforms</a></li>
<li><a href="#org17d8a75">1.6.5. <span class="done DONE">DONE</span> Optimize memory allocation</a>
<ul>
<li><a href="#org55fd328">1.6.5.1. <span class="done DONE">DONE</span> Lists</a></li>
</ul>
</li>
<li><a href="#orgc562f0d">1.6.6. <span class="done DONE">DONE</span> pack and unpack are not inverse</a></li>
<li><a href="#org0b4cbea">1.6.7. <span class="done DONE">DONE</span> true and false are not words?</a></li>
<li><a href="#org33fb40e">1.6.8. <span class="done DONE">DONE</span> Division by zero panics</a></li>
<li><a href="#org6bf1664">1.6.9. <span class="todo INPROGRESS">INPROGRESS</span> Implement pipes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#orgf62bc01">1.6.9.1. <span class="done DONE">DONE</span> Write to a file</a></li>
<li><a href="#org3203f4f">1.6.9.2. <span class="done DONE">DONE</span> Read from a file</a></li>
<li><a href="#org9b9dee4">1.6.9.3. <span class="done DONE">DONE</span> Close a pipe</a></li>
<li><a href="#orga1fedcb">1.6.9.4. <span class="done DONE">DONE</span> Serialize pipes with something sane</a></li>
<li><a href="#org2e83e9d">1.6.9.5. <span class="done DONE">DONE</span> Sockets</a></li>
<li><a href="#org3ad48dd">1.6.9.6. <span class="done DONE">DONE</span> Convert In/Out traits to enums in pipes modules</a></li>
<li><a href="#orgae33089">1.6.9.7. <span class="done DONE">DONE</span> Composable transforms</a></li>
<li><a href="#orgd740556">1.6.9.8. <span class="done CANCELED">CANCELED</span> Filled pipes</a></li>
<li><a href="#orga379d86">1.6.9.9. <span class="todo TODO">TODO</span> Object pipes</a></li>
<li><a href="#org1e3d257">1.6.9.10. <span class="done DONE">DONE</span> Time pipe</a></li>
<li><a href="#orgd57f272">1.6.9.11. <span class="done DONE">DONE</span> stdin/stdout pipes</a></li>
<li><a href="#org58c08f1">1.6.9.12. <span class="done CANCELED">CANCELED</span> Pipe take outcome</a></li>
</ul>
</li>
<li><a href="#org2e1a155">1.6.10. <span class="done DONE">DONE</span> 'Fail' is not defined</a></li>
<li><a href="#org255b29c">1.6.11. <span class="done DONE">DONE</span> 'dictionary' doesn't allow access to the data inside definitions</a></li>
<li><a href="#org36d123f">1.6.12. <span class="todo INPROGRESS">INPROGRESS</span> Use a single word for all derivation/conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a></li>
<li><a href="#org06bec69">1.6.13. <span class="done DONE">DONE</span> Change boolean operators to retain values</a></li>
<li><a href="#orga98b6ae">1.6.14. <span class="done DONE">DONE</span> 'recover' is broken</a></li>
<li><a href="#org25632a1">1.6.15. <span class="done DONE">DONE</span> Fix handle in nested env</a></li>
<li><a href="#orgf3cb4a6">1.6.16. <span class="done DONE">DONE</span> Lots of association-like objects that aren't</a></li>
<li><a href="#orgff4bb5d">1.6.17. <span class="done DONE">DONE</span> scoping of dictionary entries</a>
<ul>
<li><a href="#org6c4e2ea">1.6.17.1. What to call this word</a></li>
<li><a href="#orgffc2e81">1.6.17.2. Implementation</a></li>
</ul>
</li>
<li><a href="#org810f478">1.6.18. <span class="done DONE">DONE</span> Move environment stuff into own module</a></li>
<li><a href="#orgfa046d5">1.6.19. <span class="done DONE">DONE</span> When printing results, don't wrap the stack</a></li>
<li><a href="#org44b63e4">1.6.20. <span class="done DONE">DONE</span> Update pipes to use enums instead of traits</a></li>
<li><a href="#orge65a45c">1.6.21. <span class="done CANCELED">CANCELED</span> Recover clears the stack built up in the try program</a></li>
<li><a href="#orgb5cd7bb">1.6.22. <span class="done DONE">DONE</span> List access and update by index</a></li>
<li><a href="#org93ebbe5">1.6.23. <span class="done DONE">DONE</span> write 'let'</a></li>
<li><a href="#org1bd6ece">1.6.24. <span class="todo TODO">TODO</span> Error should have actual struct fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></a></li>
<li><a href="#org54124f6">1.6.25. <span class="todo TODO">TODO</span> Script</a>
<ul>
<li><a href="#orgadb781a">1.6.25.1. <span class="done DONE">DONE</span> Cryptographic primitives</a></li>
<li><a href="#orge769003">1.6.25.2. <span class="done DONE">DONE</span> Pure functional env</a></li>
<li><a href="#orgd79ce2b">1.6.25.3. <span class="todo TODO">TODO</span> Infinite loop protection</a></li>
</ul>
</li>
<li><a href="#org510293c">1.6.26. <span class="done DONE">DONE</span> Multithreading</a>
<ul>
<li><a href="#orga35260e">1.6.26.1. Overview</a></li>
<li><a href="#orgd2434f6">1.6.26.2. Pipes</a></li>
<li><a href="#orgee235ff">1.6.26.3. <span class="done DONE">DONE</span> Add tokio as dep</a></li>
<li><a href="#org58882c1">1.6.26.4. <span class="done DONE">DONE</span> Prepare for multithreading</a></li>
<li><a href="#orgf8f7332">1.6.26.5. <span class="done DONE">DONE</span> Update pipe types for fs and net to use tokio calls</a></li>
<li><a href="#orgd80e569">1.6.26.6. <span class="done DONE">DONE</span> Use channel type to implement handoff pipe</a></li>
<li><a href="#org870e722">1.6.26.7. <span class="done DONE">DONE</span> Implement 'spawn' or equavalent</a></li>
<li><a href="#org160be77">1.6.26.8. <span class="done DONE">DONE</span> Implement 'future' or equivalent</a></li>
</ul>
</li>
<li><a href="#org54c51c3">1.6.27. <span class="todo TODO">TODO</span> retry should have opposite argument order&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span>&#xa0;<span class="consistency">consistency</span></span></a></li>
<li><a href="#org729f574">1.6.28. <span class="todo INPROGRESS">INPROGRESS</span> Support Kademlia DHT</a>
<ul>
<li><a href="#orga77c730">1.6.28.1. <span class="done DONE">DONE</span> XOR</a></li>
<li><a href="#orge545b08">1.6.28.2. <span class="todo INPROGRESS">INPROGRESS</span> Simple API server</a></li>
<li><a href="#orgdf94c52">1.6.28.3. <span class="todo TODO">TODO</span> Kademlia functions</a></li>
</ul>
</li>
<li><a href="#org26026cf">1.6.29. <span class="done DONE">DONE</span> Implement print (opposite of read)</a></li>
<li><a href="#org3f82ca6">1.6.30. <span class="todo TODO">TODO</span> read and emit don't have quite the same semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></a></li>
<li><a href="#org2220f11">1.6.31. <span class="todo TODO">TODO</span> Inconsistent stack handling when encountering error&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></a>
<ul>
<li><a href="#org31bae1d">1.6.31.1. <span class="todo TODO">TODO</span> 'read' on invalid edn consumes the string argument</a></li>
<li><a href="#orge79559c">1.6.31.2. <span class="todo TODO">TODO</span> Division by zero consumes stack items</a></li>
</ul>
</li>
<li><a href="#orge63f18b">1.6.32. <span class="done DONE">DONE</span> Inconsistent expression handling when encountering error</a></li>
<li><a href="#orgafb7dac">1.6.33. <span class="done DONE">DONE</span> logical enum hierarchy</a>
<ul>
<li><a href="#org9aae850">1.6.33.1. <span class="done DONE">DONE</span> Collection hierarchy</a></li>
<li><a href="#org9fe7cbb">1.6.33.2. <span class="done DONE">DONE</span> pipe as list-like thing</a></li>
<li><a href="#org89c13b9">1.6.33.3. <span class="done DONE">DONE</span> Step accepts pipes</a></li>
<li><a href="#org894da15">1.6.33.4. <span class="done DONE">DONE</span> Set close = drop</a></li>
<li><a href="#orgd146702">1.6.33.5. <span class="done DONE">DONE</span> Remove closed?</a></li>
<li><a href="#orgb35b51e">1.6.33.6. <span class="done DONE">DONE</span> make a polymorphic 'join'</a></li>
<li><a href="#org0a19805">1.6.33.7. <span class="done DONE">DONE</span> Update spec types to be more abstract</a></li>
</ul>
</li>
<li><a href="#org82371ab">1.6.34. <span class="done DONE">DONE</span> Support char type</a></li>
<li><a href="#org0a305e5">1.6.35. <span class="done DONE">DONE</span> implement sleep&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a></li>
<li><a href="#org187fd08">1.6.36. <span class="done DONE">DONE</span> handoff tests</a></li>
<li><a href="#orgb3d30b5">1.6.37. <span class="todo TODO">TODO</span> Performance optimizations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></a>
<ul>
<li><a href="#orgf133942">1.6.37.1. <span class="todo TODO">TODO</span> Compile programs</a></li>
<li><a href="#org1fa93e8">1.6.37.2. <span class="todo TODO">TODO</span> Programs as their own immutable type</a></li>
</ul>
</li>
<li><a href="#org660bf25">1.6.38. <span class="todo INPROGRESS">INPROGRESS</span> Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org283ead0">1.6.38.1. <span class="done DONE">DONE</span> Basic functionality and generators</a></li>
<li><a href="#org66c367c">1.6.38.2. <span class="done DONE">DONE</span> map</a></li>
<li><a href="#org68a3591">1.6.38.3. <span class="done DONE">DONE</span> filter</a></li>
<li><a href="#org52b1620">1.6.38.4. <span class="done DONE">DONE</span> take</a></li>
<li><a href="#org168e9a5">1.6.38.5. <span class="done DONE">DONE</span> drop</a></li>
<li><a href="#org65cb5fd">1.6.38.6. <span class="done CANCELED">CANCELED</span> last</a></li>
<li><a href="#orgca1b2c4">1.6.38.7. <span class="todo TODO">TODO</span> distinct</a></li>
<li><a href="#org60399c9">1.6.38.8. <span class="todo TODO">TODO</span> partition</a></li>
<li><a href="#orgf49d6d2">1.6.38.9. <span class="done DONE">DONE</span> joiner (aka catenate)</a></li>
<li><a href="#orga17e212">1.6.38.10. <span class="todo TODO">TODO</span> groupby</a></li>
<li><a href="#org91a6983">1.6.38.11. <span class="done CANCELED">CANCELED</span> Map/filter can't access lower stack items</a></li>
<li><a href="#org75e87a8">1.6.38.12. <span class="done DONE">DONE</span> Reduce</a></li>
</ul>
</li>
<li><a href="#orgabb2341">1.6.39. <span class="done DONE">DONE</span> Investigate simpler map/filter impls</a></li>
<li><a href="#orgd8c3702">1.6.40. <span class="done DONE">DONE</span> Allow generator transforms to work on pipes</a></li>
<li><a href="#org450e2c1">1.6.41. <span class="todo INPROGRESS">INPROGRESS</span> Implement hashset&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#orgff68c51">1.6.41.1. <span class="todo INPROGRESS">INPROGRESS</span> Implement set membership check</a></li>
</ul>
</li>
<li><a href="#org05895c5">1.6.42. <span class="done DONE">DONE</span> Implement until</a></li>
<li><a href="#orgdf2ac3f">1.6.43. <span class="todo INPROGRESS">INPROGRESS</span> Implement sorting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org0e25471">1.6.43.1. <span class="todo TODO">TODO</span> Implement partialord</a></li>
<li><a href="#org82daec8">1.6.43.2. <span class="todo TODO">TODO</span> Make floats hashable</a></li>
<li><a href="#orge37c0cd">1.6.43.3. <span class="todo TODO">TODO</span> Implement compare</a></li>
</ul>
</li>
<li><a href="#org8d01655">1.6.44. <span class="done DONE">DONE</span> CI on github&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#orgaf9acab">1.6.45. <span class="done DONE">DONE</span> Add a kcats logo to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#org6526077">1.6.46. <span class="done DONE">DONE</span> Add a video snippet of repl interaction to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#org538e908">1.6.47. <span class="todo INPROGRESS">INPROGRESS</span> Write an alpha release announcement&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a></li>
<li><a href="#orge6aa5aa">1.6.48. <span class="todo INPROGRESS">INPROGRESS</span> Post announcement on various forums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></a>
<ul>
<li><a href="#orgc924f79">1.6.48.1. <span class="done DONE">DONE</span> Solve some programmer.dev challenges</a></li>
</ul>
</li>
<li><a href="#orgadd5b31">1.6.49. <span class="todo TODO">TODO</span> Stream transformation</a></li>
<li><a href="#orgaf0f338">1.6.50. <span class="done DONE">DONE</span> Auto code formatter</a></li>
<li><a href="#orga51837e">1.6.51. <span class="done DONE">DONE</span> Have eval-step return nothing when program is done</a></li>
<li><a href="#orgee586e2">1.6.52. <span class="todo INPROGRESS">INPROGRESS</span> Select from multiple pipes</a>
<ul>
<li><a href="#org203a17b">1.6.52.1. <span class="todo TODO">TODO</span> Attend should leave the pipe list argument</a></li>
<li><a href="#org2022327">1.6.52.2. <span class="todo TODO">TODO</span> Better error handling</a></li>
</ul>
</li>
<li><a href="#orgc065a63">1.6.53. <span class="done DONE">DONE</span> print</a></li>
<li><a href="#org41eb9f0">1.6.54. <span class="done DONE">DONE</span> Remove references to "expression"</a>
<ul>
<li><a href="#org522b0f3">1.6.54.1. <span class="done DONE">DONE</span> Clear up odd language</a></li>
</ul>
</li>
<li><a href="#org56fae07">1.6.55. <span class="done DONE">DONE</span> implement breakpoints</a>
<ul>
<li><a href="#orgdb2a035">1.6.55.1. <span class="done DONE">DONE</span> Fix break arg order</a></li>
<li><a href="#orgd0a807a">1.6.55.2. <span class="done DONE">DONE</span> Test breakpoint</a></li>
</ul>
</li>
<li><a href="#org36708a9">1.6.56. <span class="todo TODO">TODO</span> Monitoring tools</a>
<ul>
<li><a href="#orgec931d7">1.6.56.1. <span class="todo TODO">TODO</span> Reporting back to the mothership</a></li>
<li><a href="#org5a31308">1.6.56.2. <span class="todo TODO">TODO</span> Monitoring UI</a></li>
</ul>
</li>
<li><a href="#org523a8e7">1.6.57. <span class="done DONE">DONE</span> Rewrite future in terms of spawn</a></li>
<li><a href="#org3fd93e6">1.6.58. <span class="done DONE">DONE</span> Re-implement let</a></li>
<li><a href="#orgbd99736">1.6.59. <span class="todo INPROGRESS">INPROGRESS</span> Native REPL</a>
<ul>
<li><a href="#orgc959d4a">1.6.59.1. <span class="todo TODO">TODO</span> Main mode of reading program from cmdline or file</a></li>
<li><a href="#org80c4b7b">1.6.59.2. <span class="todo TODO">TODO</span> REPL as a kcats program</a></li>
</ul>
</li>
<li><a href="#org096c1af">1.6.60. <span class="todo TODO">TODO</span> Words that quote programs instead of executing them</a></li>
<li><a href="#org0fcadb6">1.6.61. <span class="done DONE">DONE</span> Loop combinator that has an initialization program</a></li>
<li><a href="#org75c5d7e">1.6.62. <span class="done DONE">DONE</span> startswith/endswith</a></li>
<li><a href="#org56ca522">1.6.63. <span class="done DONE">DONE</span> map doesn't handle nothing values</a></li>
<li><a href="#orge13e11d">1.6.64. <span class="todo INPROGRESS">INPROGRESS</span> Separate formatting from emitting</a></li>
<li><a href="#orgbc7c05c">1.6.65. <span class="todo TODO">TODO</span> Fix line breaks with byte literals</a></li>
<li><a href="#org237000b">1.6.66. <span class="todo INPROGRESS">INPROGRESS</span> slice ordered items</a></li>
<li><a href="#orga6b674e">1.6.67. <span class="todo INPROGRESS">INPROGRESS</span> Templating</a></li>
<li><a href="#org531f930">1.6.68. <span class="done DONE">DONE</span> Eliminate 'nothing'</a>
<ul>
<li><a href="#orgf372168">1.6.68.1. <span class="done DONE">DONE</span> Rename nothing? to empty?</a></li>
<li><a href="#orge4df895">1.6.68.2. <span class="done DONE">DONE</span> Use yes instead of true</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8984070" class="outline-2">
<h2 id="org8984070"><span class="section-number-2">1.</span> Production implementation</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org8abaa4b" class="outline-3">
<h3 id="org8abaa4b"><span class="section-number-3">1.1.</span> Base Language</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Built in Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
</p>
</div>
</div>
<div id="outline-container-org11b9c16" class="outline-3">
<h3 id="org11b9c16"><span class="section-number-3">1.2.</span> Status</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Unstable
</p>
</div>
</div>
<div id="outline-container-orgee43e71" class="outline-3">
<h3 id="orgee43e71"><span class="section-number-3">1.3.</span> Building</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org05506e3" class="outline-4">
<h4 id="org05506e3"><span class="section-number-4">1.3.1.</span> Dependencies</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>rustc</li>
<li>cargo</li>
</ul>
</div>
</div>
<div id="outline-container-orgbd2c488" class="outline-4">
<h4 id="orgbd2c488"><span class="section-number-4">1.3.2.</span> Build</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Run <code>cargo build --release</code>, the binary will be placed in <code>./target/release</code> by
default.
</p>
</div>
</div>
</div>
<div id="outline-container-using" class="outline-3">
<h3 id="using"><span class="section-number-3">1.4.</span> Using</h3>
<div class="outline-text-3" id="text-using">
</div>

<div id="outline-container-orgf111ebd" class="outline-4">
<h4 id="orgf111ebd"><span class="section-number-4">1.4.1.</span> Command line REPL</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
This is the easiest way to get started. Run <code>kcats -r</code> and it will print
a prompt and wait for you to input items (as many as you like, on a
single line). It will then evaluate all the items and print the
resulting stack. You can then enter more items. It keeps the stack
intact so you're not starting fresh with each input. If you want to
clear the stack, you can use <code>[] restore</code>.
</p>

<p>
Use Ctrl-C to quit.
</p>

<p>
Example session:
</p>
<div class="org-src-container">
<pre class="src src-fundamental">~/workspace/kcats $ kcats -r
kcats&gt; 1
1
kcats&gt; 2
2 1
kcats&gt; +
3
kcats&gt; [7 8 9] [*] step
1512
kcats&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org0fd33f2" class="outline-4">
<h4 id="org0fd33f2"><span class="section-number-4">1.4.2.</span> Command line</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Execute <code>kcats</code>. It will read a program from stdin and execute it,
then print the resulting stack to stdout. You can pass input to it via stdin via
</p>
<ul class="org-ul">
<li>interactive typing (end input with CTRL-D on most platforms): <code>kcats</code></li>
<li>Piping from a file eg: <code>kcats &lt; myprog.kcats</code></li>
<li>Using echo: <code>echo "[1 2 3] [inc] map" | kcats</code></li>
</ul>
</div>
</div>
<div id="outline-container-orge8479bf" class="outline-4">
<h4 id="orge8479bf"><span class="section-number-4">1.4.3.</span> Emacs Interactive REPL</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
See <code>emacs-ide.org</code> in the source tree. The elisp files you need to
evaluate are there. Evaluate them, then run <code>M-x kcats-repl</code>. You may
need to run <code>M-x customize-variable</code>, <code>kcats-babel-executable</code>, and enter
the location where you installed the kcats binary.
</p>
</div>
</div>
</div>
<div id="outline-container-source" class="outline-3">
<h3 id="source"><span class="section-number-3">1.5.</span> Source</h3>
<div class="outline-text-3" id="text-source">
</div>

<div id="outline-container-org076ffca" class="outline-4">
<h4 id="org076ffca"><span class="section-number-4">1.5.1.</span> Project File</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class='tangle-wrapper' data-tangle='Cargo.toml'><div class="org-src-container">
<pre class="src src-toml">[<span class="org-type">package</span>]
<span class="org-variable-name">name</span> = <span class="org-string">"kcats"</span>
<span class="org-variable-name">version</span> = <span class="org-string">"0.5.0"</span>
<span class="org-variable-name">edition</span> = <span class="org-string">"2021"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

[<span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type">dependencies</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>]
<span class="org-comment-delimiter"># </span><span class="org-comment">serialization</span>
<span class="org-variable-name">edn-format</span> = <span class="org-string">"3.3.0"</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">edn-format = { path = "../edn-format" }</span>
<span class="org-variable-name">base64</span> = <span class="org-string">"0.13.0"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">String literals</span>
<span class="org-variable-name">internment</span> = <span class="org-string">"0.6.0"</span> 
<span class="org-variable-name">lazy_static</span> = <span class="org-string">"1.4.0"</span>

<span class="org-variable-name">num-integer</span> = <span class="org-string">"0.1.44"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">crypto stuff</span>
<span class="org-variable-name">ed25519-dalek</span> = {version=<span class="org-string">"1"</span>, features=[<span class="org-string">"batch_deterministic"</span>, <span class="org-string">"std"</span>, <span class="org-string">"rand"</span>]}
<span class="org-variable-name">sha2</span> = <span class="org-string">"0.10.6"</span>
<span class="org-variable-name">rand_core</span> = <span class="org-string">"0.5.1"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">careful here, having 2 versions present will make weird compile errors</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">multithreading</span>
<span class="org-variable-name">futures</span> = <span class="org-string">"0.3"</span>
<span class="org-variable-name">tokio</span> = { version = <span class="org-string">"1"</span>, features = [<span class="org-string">"full"</span>] }
<span class="org-comment-delimiter"># </span><span class="org-comment">multiple-consumer channels</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">crossbeam-channel = "0.5" # doesn't support async send/recv</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">async-channel = "1.8.0"</span>
<span class="org-variable-name">flume</span> = <span class="org-string">"0.11.0"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">debugging</span>
<span class="org-variable-name">backtrace</span> = <span class="org-string">"0.3.61"</span>
[<span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type"><span class="org-type">dev-dependencies</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>]
<span class="org-variable-name">test-case</span> = <span class="org-string">"2.0.0"</span>
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org90d4018" class="outline-4">
<h4 id="org90d4018"><span class="section-number-4">1.5.2.</span> Internal data types</h4>
<div class="outline-text-4" id="text-1-5-2">
</div>
<div id="outline-container-org6e0d5e8" class="outline-5">
<h5 id="org6e0d5e8"><span class="section-number-5">1.5.2.1.</span> Basic internal types</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<p>
We'll start by defining the basic data structures that kcats will use
internally, to keep track of things like the stack, program, lists etc.
</p>
<div class='tangle-wrapper' data-tangle='src/types.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::dictionary <span class="org-keyword">as</span> dict;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::environment <span class="org-keyword">as</span> env;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-constant">internment</span>::<span class="org-type">Intern</span>;
<span class="org-keyword">use</span> <span class="org-constant">lazy_static</span>::lazy_static;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::{<span class="org-type">HashMap</span>, <span class="org-type">VecDeque</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::fmt;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">hash</span>::<span class="org-type">Hash</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">marker</span>::<span class="org-type">Sync</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">ops</span>::{<span class="org-type">Deref</span>, <span class="org-type">DerefMut</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">pin</span>::<span class="org-type">Pin</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">associative</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">collection</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">dictionary</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">environment</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">error</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">A generic newtype to contain various kinds</span>
<span class="org-preprocessor">#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt;(<span class="org-keyword">pub</span> <span class="org-type">T</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Access the inner value easily</span>
<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">Deref</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Target</span> = <span class="org-type">T</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">deref</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>::<span class="org-type">Target</span> {
        <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.0
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">DerefMut</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">deref_mut</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Self</span>::<span class="org-type">Target</span> {
        <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.0
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">IntoIterator</span>&gt; <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-type">T</span>::<span class="org-type">Item</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">T</span>::<span class="org-type">IntoIter</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">self</span>.0.into_iter()
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">but still clone the whole thing, not the inner part</span>
<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Clone</span>&gt; <span class="org-type">Clone</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">clone</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Newtype</span>(<span class="org-keyword">self</span>.0.clone())
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Implement Debug trait for Newtype, so it hides</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">itself and only prints the inner type.</span>
<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-constant">fmt</span>::<span class="org-type">Debug</span>&gt; <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>&lt;'<span class="org-variable-name">_</span>&gt;) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Directly print the wrapped value</span>
        <span class="org-rust-builtin-formatting-macro">write!</span>(f, <span class="org-string">"</span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, <span class="org-keyword">self</span>.0)
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Word</span> = <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt;;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Stack</span> = <span class="org-constant">collection</span>::<span class="org-type">List</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Bytes</span> = <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Int</span> = <span class="org-type">i64</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Float</span> = <span class="org-type">f64</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Char</span> = <span class="org-type">char</span>;

<span class="org-preprocessor">lazy_static!</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ASSOC</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"association"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_BOOLEAN</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"boolean"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_BYTES</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"bytes"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_CHAR</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"character"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_DISPENSER</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"dispenser"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ENVIRONMENT</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"environment"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ERROR</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"error"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_FLOAT</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"float"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_INTEGER</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"integer"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ITEM</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"item"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_LIST</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"list"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_NUMBER</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"number"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ORDERED</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"ordered"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_PIPE</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"pipe"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_PROGRAM</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"program"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_RECEPTACLE</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"receptacle"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_SIZED</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"sized"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_STRING</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"string"</span>.to_string());
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_WORD</span>: <span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-type">Intern</span>::new(<span class="org-string">"word"</span>.to_string());
}

<span class="org-comment-delimiter">// </span><span class="org-comment">#[derive(Debug, Clone)]</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">pub enum Sequence {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">Assoc(Associative),</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">List(ListContent),</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">Nothing,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Item</span> {
    <span class="org-type">Int</span>(<span class="org-type">Int</span>),
    <span class="org-type">Float</span>(<span class="org-type">Float</span>),
    <span class="org-type">Word</span>(<span class="org-type">Word</span>),
    <span class="org-type">Char</span>(<span class="org-type">Char</span>),
    <span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>),
    <span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>),
    <span class="org-type">Nothing</span>,
}

<span class="org-comment-delimiter">// </span><span class="org-comment">a const Item value for Nothing</span>
<span class="org-keyword">pub</span> <span class="org-keyword">const</span> <span class="org-variable-name">NOTHING</span>: <span class="org-type">Item</span> = <span class="org-type">Item</span>::<span class="org-type">Nothing</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Future</span>&lt;<span class="org-type">T</span>&gt; = <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">T</span>&gt; + <span class="org-type">Send</span>&gt;&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">StepFn</span> = <span class="org-keyword">dyn</span> <span class="org-type">Fn</span>(<span class="org-constant">env</span>::<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-constant">env</span>::<span class="org-type">Environment</span>&gt; + <span class="org-type">Sync</span> + <span class="org-type">Send</span>;

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">same types, just use their own eq</span>
            (<span class="org-type">Item</span>::<span class="org-type">Nothing</span>, <span class="org-type">Item</span>::<span class="org-type">Nothing</span>) =&gt; <span class="org-keyword">true</span>,
            (<span class="org-type">Item</span>::<span class="org-type">Int</span>(a), <span class="org-type">Item</span>::<span class="org-type">Int</span>(b)) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Float</span>(a), <span class="org-type">Item</span>::<span class="org-type">Float</span>(b)) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Word</span>(a), <span class="org-type">Item</span>::<span class="org-type">Word</span>(b)) =&gt; a == b,
            (
                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(a)),
                <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(b)),
            ) =&gt; a == b,
            (
                <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(a)),
                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(b)),
            ) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(a), <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(b)) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Nothing</span>, <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(b))) =&gt; b.is_empty(),
            (<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(b)), <span class="org-type">Item</span>::<span class="org-type">Nothing</span>) =&gt; b.is_empty(),
            (<span class="org-type">Item</span>::<span class="org-type">Nothing</span>, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(b))) =&gt; b.is_empty(),
            (<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(b)), <span class="org-type">Item</span>::<span class="org-type">Nothing</span>) =&gt; b.is_empty(),
            (<span class="org-type">Item</span>::<span class="org-type">Char</span>(a), <span class="org-type">Item</span>::<span class="org-type">Char</span>(b)) =&gt; a == b,
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Assoc(a), Item::Assoc(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::List(a), Item::List(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">//TODO: (Item::Collection(a), Item::Collection(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Env(a), Item::Env(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Entry(a), Item::Entry(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Dictionary(a), Item::Dictionary(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Error(a), Item::Error(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">//TODO:</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">//(Item::In(a), Item::In(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">//(Item::Out(a), Item::Out(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">//(Item::Tunnel(a), Item::Tunnel(b)) =&gt; a == b,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Nothing, Item::Nothing) =&gt; true,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">// different types, but can be converted to the same type</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Nothing, Item::List(l)) =&gt; l.is_empty(),</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::List(l), Item::Nothing) =&gt; l.is_empty(),</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Nothing, Item::Assoc(l)) =&gt; l.is_empty(),</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Assoc(l), Item::Nothing) =&gt; l.is_empty(),</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Nothing, Item::Collection(l)) =&gt; l.is_empty(),</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Collection(l), Item::Nothing) =&gt; l.is_empty(),</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::List(l), Item::Assoc(a)) =&gt; l.is_empty() &amp;&amp; a.is_empty(),</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">(Item::Assoc(a), Item::List(l)) =&gt; l.is_empty() &amp;&amp; a.is_empty(),</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">(Item::Error(i), Item::Assoc(j)) =&gt; (*i).data == *j,</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">(Item::Assoc(i), Item::Error(j)) =&gt; (*j).data == *i,</span>

            <span class="org-comment-delimiter">//</span><span class="org-comment">TODO Definition, Associative etc</span>
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">The default Item is NOTHING.</span>
<span class="org-keyword">impl</span> <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Self</span> {
        <span class="org-type">NOTHING</span>
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">wrap</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">coll</span>::<span class="org-type">List</span> {
    <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([i])
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Int</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(i),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"integer"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Float</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Float</span>(i) =&gt; <span class="org-type">Ok</span>(i),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"float"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">String</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i) =&gt; <span class="org-type">Ok</span>(i),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"string"</span>, i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(i) =&gt; <span class="org-type">Ok</span>(i),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"word"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Bytes</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; <span class="org-type">Ok</span>(b),
            b =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"bytes"</span>, b.into())),
        }
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">impl TryFrom&lt;Item&gt; for Association {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">type Error = Error;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn try_from(i: Item) -&gt; Result&lt;Self, Self::Error&gt; {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">match i {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::Assoc(a) =&gt; Ok(a),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::List(l) =&gt; Ok(to_hash(l)?),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::Nothing =&gt; Ok(Arc::new(AssociationContent::new())),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::DerivedDef(d) =&gt; Ok(Association::from(d)),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::AxiomDef(a) =&gt; Ok(Association::from(a)),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::Env(e) =&gt; Ok(Association::from(e)),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::Error(e) =&gt; Ok(Association::from(e)),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">_ =&gt; Err(Error::expected("association")),</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">As there are no real booleans, we use the word 'yes' but literally</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">any value except the empty list is truthy. If we read a value</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">'false' in edn, that's not actually a boolean, it's just the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">symbol/word false.</span>
<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">b</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">if</span> b {
            <span class="org-string">"yes"</span>.into()
        } <span class="org-keyword">else</span> {
            <span class="org-type">NOTHING</span>
        }
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">impl From&lt;Environment&gt; for Association {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn from(env: Environment) -&gt; Association {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">let mut a = AssociationContent::new();</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">a.insert(word_key("stack"), Item::List(env.stack.clone()));</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">a.insert(word_key("program"), Item::List(env.program.clone()));</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">a.insert(word_key("dictionary"), Item::Assoc(env.dictionary.clone()));</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Arc::new(a)</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">std</span>::<span class="org-constant">io</span>::<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">err</span>: <span class="org-constant">std</span>::<span class="org-constant">io</span>::<span class="org-type">Error</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(wrap(<span class="org-string">"io"</span>.into()), <span class="org-rust-ampersand">&amp;</span>err.to_string(), <span class="org-type">None</span>)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(<span class="org-type">Word</span>::from(i))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">String</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Bytes</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">b</span>: <span class="org-type">Bytes</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Char</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Char</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Char</span>(c)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Int</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Int</span>(c)
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">From</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">T</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span>
<span class="org-keyword">where</span>
    <span class="org-variable-name">Item</span>: <span class="org-type">From</span>&lt;<span class="org-type">T</span>&gt;,
{
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">opt</span>: <span class="org-type">Option</span>&lt;<span class="org-type">T</span>&gt;) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> opt {
            <span class="org-type">Some</span>(t) =&gt; <span class="org-type">Item</span>::from(t),
            <span class="org-type">None</span> =&gt; <span class="org-type">Item</span>::default(),
        }
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-orge85ed29" class="outline-5">
<h5 id="orge85ed29"><span class="section-number-5">1.5.2.2.</span> Collection types</h5>
<div class="outline-text-5" id="text-1-5-2-2">
<div class='tangle-wrapper' data-tangle='src/types/collection.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-constant">futures</span>::<span class="org-type">FutureExt</span>;

<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::pipes <span class="org-keyword">as</span> pipe;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::{<span class="org-constant">collections</span>::<span class="org-type">HashSet</span>, future, sync};

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Arc</span>&lt;<span class="org-type">T</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-constant">sync</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">T</span>&gt;&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Listy</span>&lt;<span class="org-type">I</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">I</span>&gt;&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Setty</span>&lt;<span class="org-type">I</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-type">HashSet</span>&lt;<span class="org-type">I</span>&gt;&gt;;
<span class="org-comment-delimiter">// </span><span class="org-comment">impl&lt;T: PartialEq&gt; PartialEq for Newtype&lt;Arc&lt;T&gt;&gt; {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn eq(&amp;self, other: &amp;Self) -&gt; bool {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">**self.0 == **other.0</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Clone</span>&gt; <span class="org-type">Arc</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">make_mut</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">T</span> {
        <span class="org-constant">sync</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.0)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">inner</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">T</span> {
        <span class="org-constant">sync</span>::<span class="org-type">Arc</span>::try_unwrap(<span class="org-keyword">self</span>.0.clone()).unwrap_or_else(|rc| (*rc).clone())
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">wrap</span>(<span class="org-variable-name">inner</span>: <span class="org-type">T</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Self</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(inner))
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">ListContent</span> = <span class="org-type">Listy</span>&lt;<span class="org-type">Item</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">List</span> = <span class="org-type">Arc</span>&lt;<span class="org-type">ListContent</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Set</span> = <span class="org-type">Arc</span>&lt;<span class="org-type">Setty</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;&gt;;

<span class="org-keyword">impl</span> <span class="org-type">List</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>() -&gt; <span class="org-type">List</span> {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(<span class="org-type">VecDeque</span>::new())))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Set</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">h</span>: <span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;) -&gt; <span class="org-type">Set</span> {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(h)))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>() -&gt; <span class="org-type">Set</span> {
        <span class="org-type">Set</span>::from(<span class="org-type">HashSet</span>::new())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;,
    {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;&gt;(),
        )))
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Most generic collection type, all we know is it can contain</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">multiple items.</span>
<span class="org-preprocessor">#[derive(Debug, Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Dispenser</span> {
    <span class="org-type">Sized</span>(<span class="org-type">Sized</span>),
    <span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>),
    <span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>),
}

<span class="org-preprocessor">#[derive(Debug, Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Receptacle</span> {
    <span class="org-type">Sized</span>(<span class="org-type">Sized</span>),
    <span class="org-type">In</span>(<span class="org-constant">pipe</span>::<span class="org-type">In</span>),
    <span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>),
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Collection that has a definite size that we can access. Implies</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">that it can also be appended to.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Sized</span> {
    <span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>),
    <span class="org-type">List</span>(<span class="org-type">List</span>),
    <span class="org-type">Set</span>(<span class="org-type">Set</span>),
    <span class="org-type">String</span>(<span class="org-type">String</span>),
    <span class="org-type">Bytes</span>(<span class="org-type">Bytes</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.is_empty() &amp;&amp; other.is_empty() {
            <span class="org-keyword">return</span> <span class="org-keyword">true</span>;
        }
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(a), <span class="org-type">Sized</span>::<span class="org-type">String</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Set</span>(b)) =&gt; a == b,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Future</span>&lt;(<span class="org-type">Dispenser</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;)&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; {
                <span class="org-keyword">let</span> (s, item) = s.take();

                <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready((<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s), item)))
            }
            <span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-keyword">mut</span> o) =&gt; <span class="org-type">Box</span>::pin({
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = o.take();
                i.map(|r| {
                    (
                        <span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o),
                        <span class="org-keyword">match</span> r {
                            <span class="org-type">Ok</span>(<span class="org-type">Some</span>(i)) =&gt; <span class="org-type">Some</span>(i),
                            <span class="org-type">Ok</span>(<span class="org-type">None</span>) =&gt; <span class="org-type">None</span>,
                            <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Some</span>(<span class="org-type">Item</span>::from(e)),
                        },
                    )
                })
            }),
            <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(<span class="org-keyword">mut</span> t) =&gt; <span class="org-type">Box</span>::pin({
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = t.take();
                i.map(|r| {
                    (
                        <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t),
                        <span class="org-keyword">match</span> r {
                            <span class="org-type">Ok</span>(<span class="org-type">Some</span>(i)) =&gt; <span class="org-type">Some</span>(i),
                            <span class="org-type">Ok</span>(<span class="org-type">None</span>) =&gt; <span class="org-type">None</span>,
                            <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Some</span>(<span class="org-type">Item</span>::from(e)),
                        },
                    )
                })
            }),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">self</span>.len() == 0
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; a.len(),
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(l) =&gt; l.len(),
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; s.len(),
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; b.len(),
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(s) =&gt; s.len(),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">self</span>) -&gt; (<span class="org-type">Self</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; {
                <span class="org-keyword">let</span> (a, i) = a.take();
                (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = l.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = lm.pop_front();
                (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> s) =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: this may perform badly</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">first_char</span> = s.chars().next();
                s.drain(..first_char.map(|s| s.len_utf8()).unwrap_or(0));
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = first_char.map(<span class="org-type">Item</span>::<span class="org-type">Char</span>);
                (<span class="org-type">Sized</span>::<span class="org-type">String</span>(s), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> b) =&gt; {
                <span class="org-keyword">if</span> b.is_empty() {
                    (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), <span class="org-type">None</span>)
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-type">Some</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(b[0] <span class="org-keyword">as</span> <span class="org-type">Int</span>));
                    b.drain(..1);
                    (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), i)
                }
            }
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = s.iter().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">sm</span> = s.make_mut();
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(i) = i.clone() {
                    sm.take(<span class="org-rust-ampersand">&amp;</span>i);
                }
                (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), i.map(<span class="org-type">Item</span>::from))
            }
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop</span>(<span class="org-keyword">self</span>) -&gt; (<span class="org-type">Self</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; {
                <span class="org-keyword">let</span> (a, i) = a.take();
                (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = l.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = lm.pop_back();
                (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> s) =&gt; s
                .pop()
                .map(|c| (<span class="org-type">Sized</span>::<span class="org-type">String</span>(s), <span class="org-type">Some</span>(c.into())))
                .unwrap_or((<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-type">String</span>::new()), <span class="org-type">None</span>)),
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> b) =&gt; b
                .pop()
                .map(|c| (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), <span class="org-type">Some</span>((c <span class="org-keyword">as</span> <span class="org-type">Int</span>).into())))
                .unwrap_or((<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-preprocessor">vec!</span>[]), <span class="org-type">None</span>)),
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = s.iter().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">sm</span> = s.make_mut();
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(i) = i.clone() {
                    sm.take(<span class="org-rust-ampersand">&amp;</span>i);
                }
                (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), i.map(<span class="org-type">Item</span>::from))
            }
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Sized</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> c), i) =&gt; {
                c.make_mut().push_back(i);
                <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(c))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), l) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a.put(l)<span class="org-rust-question-mark">?</span>)),
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s), i) =&gt; {
                s.make_mut().insert(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(i)<span class="org-rust-question-mark">?</span>);
                <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> b), <span class="org-type">Item</span>::<span class="org-type">Int</span>(i)) =&gt; {
                b.push(i <span class="org-keyword">as</span> <span class="org-type">u8</span>);
                <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_), i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"integer"</span>, i)),
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> s), <span class="org-type">Item</span>::<span class="org-type">Char</span>(c)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">String</span>({
                s.push(c);
                s
            })),
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(_), i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"char"</span>, i)),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">join</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Sized</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-type">Ok</span>(<span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(l)) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Associative</span>({
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span> = a.into();
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">more</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::try_from_iter(l.clone().inner().into_iter())<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                am.extend(more.inner().into_iter());
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a)
            }),
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span> = a.into();
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">la</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::try_from_iter(l.clone().inner().into_iter())<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">lam</span> = la.make_mut();
                lam.extend(a.inner().into_iter());
                <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(la))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(b)) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a.join(b)),
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                am.extend(b.inner());
                <span class="org-type">Sized</span>::<span class="org-type">List</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                am.extend(b.inner());
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">bm</span> = b.make_mut();

                bm.extend(
                    a.inner()
                        .into_iter()
                        .map(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from)
                        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>
                        .into_iter(),
                );
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(b)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();

                am.extend(
                    b.inner()
                        .into_iter()
                        .map(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from)
                        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>
                        .into_iter(),
                );
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">String</span>(b)) =&gt; {
                a.push_str(<span class="org-rust-ampersand">&amp;</span>b);
                <span class="org-type">Sized</span>::<span class="org-type">String</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)) =&gt; {
                a.extend(b);
                <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(a)
            }
            <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: not every combination makes sense, return error here, don't panic</span>
            (s, other) =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"Cannot join {:?} and {:?}"</span>, s, other),
        })
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), other) =&gt; {
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(other.clone()).map_or(<span class="org-keyword">false</span>, |k| a.contains_key(<span class="org-rust-ampersand">&amp;</span>k))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), other) =&gt; l.contains(other),
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), other) =&gt; {
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(other.clone()).map_or(<span class="org-keyword">false</span>, |k| s.contains(<span class="org-rust-ampersand">&amp;</span>k))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(container), other) =&gt; <span class="org-keyword">match</span> other {
                <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; container.contains(*c),
                i =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">String</span>::try_from(i.clone());
                    <span class="org-keyword">match</span> s {
                        <span class="org-type">Ok</span>(s) =&gt; container.contains(<span class="org-rust-ampersand">&amp;</span>s),
                        <span class="org-type">Err</span>(_) =&gt; <span class="org-keyword">false</span>,
                    }
                }
            },
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Sized</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_) =&gt; {
                <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new()))
            }
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-type">List</span>::new()),
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-type">Set</span>::new()),
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-type">String</span>::new()),
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-preprocessor">vec!</span>[]),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Receptacle</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Receptacle</span>, <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(s.put(i).map(<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>))),
            <span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-keyword">mut</span> p) =&gt; <span class="org-type">Box</span>::pin(p.put(i).map(|r| r.map(|_| <span class="org-type">Receptacle</span>::<span class="org-type">In</span>(p)))),
            <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(<span class="org-keyword">mut</span> t) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = t.put(i);
                <span class="org-type">Box</span>::pin(p.map(|r| r.map(|_| <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t))))
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-type">Item</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(map) =&gt; <span class="org-type">Box</span>::new(map.into_iter().map(|kv| kv.into())),
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> list) =&gt; <span class="org-type">Box</span>::new(list.inner().into_iter()),
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">chars</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">char</span>&gt; = s.chars().collect();
                <span class="org-type">Box</span>::new(chars.into_iter().map(|c| c.into()))
            }
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">vec</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt; = b.into_iter().map(|byte| <span class="org-type">Item</span>::from(byte <span class="org-keyword">as</span> <span class="org-type">Int</span>)).collect();
                <span class="org-type">Box</span>::new(vec.into_iter())
            }
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s) =&gt; <span class="org-type">Box</span>::new(s.inner().into_iter().map(|i| i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Dispenser</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Dispenser</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("from iterable {:?}", c);</span>
        <span class="org-keyword">match</span> c {
            <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(s),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Receptacle</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Receptacle</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> c {
            <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(s),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(i))),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> s {
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(l) =&gt; <span class="org-type">Ok</span>(l),
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; <span class="org-type">Ok</span>(<span class="org-type">List</span>::from_iter(a.into_iter().map(<span class="org-type">Item</span>::from))),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"list"</span>, i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">v</span>: <span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">List</span>::from_iter(v.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(l) =&gt; <span class="org-type">Sized</span>::try_from(l).and_then(<span class="org-type">List</span>::try_from),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(l) =&gt; <span class="org-type">Sized</span>::try_from(l).and_then(<span class="org-type">List</span>::try_from),
            <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-type">List</span>::new()),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"list"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> item {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c) =&gt; c.try_into(),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p) =&gt; <span class="org-type">Dispenser</span>::try_from(p)<span class="org-rust-question-mark">?</span>.try_into(),
            <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-type">List</span>::new())),
            i =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">let bt = backtrace::Backtrace::new();</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">println!("try from item {:?},\n {:?}", i, bt);</span>
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, i))
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Receptacle</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> item {
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c) =&gt; c.try_into(),
            <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-type">List</span>::new()))),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"packable"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Dispenser</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Receptacle</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Dispenser</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> c {
            <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s)),
            <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"packable"</span>, i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Receptacle</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Receptacle</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> c {
            <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)),
            <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"iterable"</span>, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(i))),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::try_from(item)<span class="org-rust-question-mark">?</span>.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">sized</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Box</span>::new(sized.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">List</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">List</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Sized</span>::<span class="org-type">List</span>(l)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">List</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">List</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(l)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Dispenser</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Dispenser</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> item {
            <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-type">List</span>::new()))),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c) =&gt; <span class="org-type">Ok</span>(c),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::try_from(p)<span class="org-rust-question-mark">?</span>),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"iterable"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Set</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">Sized</span>::try_from(item)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">hs</span>: <span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt; = s
            .into_iter()
            .map(|i| i.try_into())
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(<span class="org-type">Set</span>::from(hs))
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org274ea82" class="outline-5">
<h5 id="org274ea82"><span class="section-number-5">1.5.2.3.</span> Associative types</h5>
<div class="outline-text-5" id="text-1-5-2-3">
<div class='tangle-wrapper' data-tangle='src/types/associative.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::dictionary <span class="org-keyword">as</span> dict;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::environment <span class="org-keyword">as</span> env;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">iter</span>::<span class="org-type">FromIterator</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::sync;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Associationy</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt;&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">AssociationContent</span> = <span class="org-type">Associationy</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Association</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">AssociationContent</span>&gt;;

<span class="org-preprocessor">#[derive(Debug, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">KeyItem</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Order matters here, for comparison purposes - changing the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">order will change the result of how eg int compares to word.</span>
    <span class="org-type">Nothing</span>,
    <span class="org-type">Int</span>(<span class="org-type">Int</span>),
    <span class="org-type">Char</span>(<span class="org-type">Char</span>),
    <span class="org-type">Word</span>(<span class="org-type">Word</span>),
    <span class="org-type">Bytes</span>(<span class="org-type">Bytes</span>),
    <span class="org-type">String</span>(<span class="org-type">String</span>),
    <span class="org-type">List</span>(<span class="org-type">KeyList</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">KeyList</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">try_from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">l</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt;
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;,
    {
        <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            l.into_iter()
                .map(<span class="org-type">KeyItem</span>::try_from)
                .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">KeyItem</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> i {
            <span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Item</span>::<span class="org-type">Int</span>(i),
            <span class="org-type">KeyItem</span>::<span class="org-type">String</span>(i) =&gt; i.into(),
            <span class="org-type">KeyItem</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l) =&gt; {
                <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(l.inner().into_iter().map(<span class="org-type">Item</span>::from)).into()
            }
            <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Item</span>::<span class="org-type">Word</span>(w),
            <span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(bs) =&gt; bs.into(),
            <span class="org-type">KeyItem</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-type">Item</span>::<span class="org-type">Char</span>(c),
            <span class="org-type">KeyItem</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">NOTHING</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(<span class="org-type">Word</span>::from(i))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Word</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(i)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(i)),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">String</span>(i))
            }
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">String</span>(i))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(i)),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(i))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">List</span>(
                <span class="org-type">KeyList</span>::try_from_iter(l.inner().into_iter())<span class="org-rust-question-mark">?</span>,
            )),

            <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Nothing</span>),

            <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w)),
            <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Char</span>(c)),

            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"KeyItem"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">k</span>: <span class="org-type">KeyItem</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> k {
            <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Ok</span>(w),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"word"</span>, i.into())),
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Entry</span> = (<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>);

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">KeyListContent</span> = <span class="org-constant">coll</span>::<span class="org-type">Listy</span>&lt;<span class="org-type">KeyItem</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">KeyList</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">KeyListContent</span>&gt;;

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Associative</span> {
    <span class="org-type">Assoc</span>(<span class="org-type">Association</span>),
    <span class="org-type">DictEntry</span>(<span class="org-constant">dict</span>::<span class="org-type">Entry</span>),
    <span class="org-type">Env</span>(<span class="org-constant">env</span>::<span class="org-type">Environment</span>),
    <span class="org-type">Error</span>(<span class="org-type">Error</span>),
    <span class="org-type">Dictionary</span>(<span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>),
    <span class="org-type">Nothing</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(a), <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Env</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Env</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Error</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Error</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Nothing</span>, <span class="org-type">Associative</span>::<span class="org-type">Nothing</span>) =&gt; <span class="org-keyword">true</span>,
            <span class="org-comment-delimiter">//</span><span class="org-comment">(Associative::Assoc(a), b) =&gt; Association::from(a) == Association::from(b),</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">(a, Associative::Assoc(b)) =&gt; Association::from(a) == Association::from(b),</span>
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a.len(),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(a) =&gt; a.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; d.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; 0,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">self</span>.len() == 0
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-type">KeyItem</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; (<span class="org-type">Associative</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> a);
                <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = am.insert(k, v);
                (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), e)
            }
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; <span class="org-keyword">match</span> (k, v) {
                (<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w), e) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">e2</span> = e.clone();
                    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Ok</span>(e) = <span class="org-constant">dict</span>::<span class="org-type">Entry</span>::try_from(e) {
                        <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> d);
                        <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = dm.insert(w, e).map(<span class="org-type">Item</span>::from);
                        (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), e)
                    } <span class="org-keyword">else</span> {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO silently failing to insert here is bad</span>
                        <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Warning, failed to insert into dictionary: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e2);
                        (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), <span class="org-type">None</span>)
                    }
                }
                _ =&gt; (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), <span class="org-type">None</span>),
            },
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.insert(k, v),
            _ =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"insert Implementations for error, env etc"</span>),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Associative</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">entry</span>: (<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = other.try_into()<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(<span class="org-keyword">self</span>.insert(entry.0, entry.1).0)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">join</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Associative</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">same type means 2nd one wins.</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: a little more complex for types that can be extended</span>
            (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(_), <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(other)) =&gt; {
                <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(other)
            }
            (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> this), <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> other)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">thism</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> this);
                thism.extend(other.inner().into_iter());
                <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(this)
            }
            (<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_), <span class="org-type">Associative</span>::<span class="org-type">Error</span>(other)) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Error</span>(other),
            (<span class="org-type">Associative</span>::<span class="org-type">Env</span>(_), <span class="org-type">Associative</span>::<span class="org-type">Env</span>(other)) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Env</span>(other),
            (<span class="org-type">Associative</span>::<span class="org-type">Nothing</span>, <span class="org-type">Associative</span>::<span class="org-type">Nothing</span>) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Nothing</span>,
            (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> this), other) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">thism</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> this);
                thism.extend(other.into_iter());
                <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(this)
            }
            (this, other) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">thisa</span>: <span class="org-type">Association</span> = this.into();
                (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(thisa)).join(other)
            }
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">KeyItem</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a.get(k).cloned(),
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.data.get(k).cloned(),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(s) =&gt; e.get(s.as_str()),
                _ =&gt; <span class="org-type">None</span>,
            },
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(d) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(s) =&gt; d.get(s.as_str()),
                _ =&gt; <span class="org-type">None</span>,
            },
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; d.get(w).map(|x| x.clone().into()),
                _ =&gt; <span class="org-type">None</span>,
            },
            <span class="org-rust-ampersand">&amp;</span><span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">None</span>,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains_key</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">KeyItem</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.data.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(d) =&gt; d.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; d.contains_key(w),
                _ =&gt; <span class="org-keyword">false</span>,
            },
            <span class="org-rust-ampersand">&amp;</span><span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-keyword">false</span>,
        }
    }

    <span class="org-comment-delimiter">//</span><span class="org-comment">TODO remove</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">remove</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">KeyItem</span>) -&gt; (<span class="org-type">Associative</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> a);
                <span class="org-keyword">let</span> <span class="org-variable-name">v</span> = am.remove(k);
                (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), v)
            }
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> d);
                <span class="org-keyword">let</span> <span class="org-variable-name">v</span> = dm.remove(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Word</span>::try_from(k.clone()).unwrap_or_default());
                (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), v.map(|v| v.into()))
            }
            _ =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"Removing from other associative types"</span>),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">self</span>) -&gt; (<span class="org-type">Self</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_key</span> = a.inner().keys().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_value</span> = maybe_key.as_ref().and_then(|key| am.remove(key));
                (
                    <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a),
                    maybe_key.map(|key| {
                        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
                            <span class="org-preprocessor">vec!</span>[<span class="org-type">Item</span>::from(key), maybe_value.unwrap_or_default()].into_iter(),
                        )
                        .into()
                    }),
                )
            }
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_key</span> = d.inner().keys().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = d.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_value</span> = maybe_key.and_then(|key| dm.remove(<span class="org-rust-ampersand">&amp;</span>key));
                (
                    <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d),
                    maybe_key.map(|key| {
                        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
                            <span class="org-preprocessor">vec!</span>[
                                <span class="org-type">Item</span>::<span class="org-type">Word</span>(key),
                                maybe_value.map(<span class="org-type">Item</span>::from).unwrap_or(<span class="org-type">NOTHING</span>),
                            ]
                            .into_iter(),
                        )
                        .into()
                    }),
                )
            }
            _ =&gt; <span class="org-preprocessor">unimplemented!</span>(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>&lt;'<span class="org-variable-name">a</span>&gt;(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; <span class="org-type">Box</span>::new(a.inner().into_iter()),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(e) =&gt; <span class="org-type">Box</span>::new(e.into_iter()),
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; {
                <span class="org-type">Box</span>::new(d.inner().into_iter().map(|(k, v)| (k.into(), v.into())))
            }
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.into_iter(),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.into_iter(),
            <span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Box</span>::new(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::empty()),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">coll</span>::<span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(a.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">s</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; <span class="org-type">Ok</span>(a),
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"associative"</span>, i.into())),
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"associative"</span>, i.into())),
            s =&gt; <span class="org-type">Ok</span>(<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-type">Association</span>::try_from_iter(s)<span class="org-rust-question-mark">?</span>)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Associative</span>::try_from(s)
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Convert anything that can be iterated over as Items, to an</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Association. The items must be pairs that are</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">convertable to Entry, otherwise it will return an error.</span>
<span class="org-keyword">impl</span> <span class="org-type">Association</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>() -&gt; <span class="org-type">Association</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(<span class="org-type">HashMap</span>::new()))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">try_from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">l</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt;
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;,
    {
        <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            l.into_iter()
                .map(|i| <span class="org-type">Entry</span>::try_from(i.clone()))
                .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Entry</span>&gt;,
    {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;&gt;(),
        ))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">coll</span>::<span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Entry</span>&gt;,
    {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            iter.into_iter()
                .map(|e| e.into())
                .collect::&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;&gt;(),
        ))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyList</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">KeyItem</span>&gt;,
    {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">KeyItem</span>&gt;&gt;(),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Entry</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-type">Item</span>::from(e.0), e.1]).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> s.len() != 2 {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pair"</span>, s.into()))
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">iter</span> = s.into_iter();
            <span class="org-keyword">let</span> <span class="org-variable-name">key</span>: <span class="org-type">KeyItem</span> = iter.next().unwrap().try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">value</span> = iter.next().unwrap();
            <span class="org-type">Ok</span>((key, value))
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Association</span> {
        <span class="org-keyword">match</span> a {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a,
            a =&gt; a.into_iter().collect::&lt;<span class="org-type">Association</span>&gt;(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">AssociationContent</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">AssociationContent</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(a).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Association</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Association</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a).into()
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-orgda3d386" class="outline-5">
<h5 id="orgda3d386"><span class="section-number-5">1.5.2.4.</span> Error types</h5>
<div class="outline-text-5" id="text-1-5-2-4">
<div class='tangle-wrapper' data-tangle='src/types/error.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::types;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-type">Int</span>, <span class="org-type">Item</span>, <span class="org-type">Word</span>};

<span class="org-preprocessor">#[derive(Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Error</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">data</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">is_handled</span>: <span class="org-type">bool</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">Error</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">create</span>(<span class="org-variable-name">asked</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">reason</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">actual</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Error</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">let bt = backtrace::Backtrace::new();</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">data</span>: <span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt; = <span class="org-preprocessor">vec!</span>[
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"error"</span>.into()),
            (<span class="org-string">"asked"</span>.into(), asked.into()),
            (<span class="org-string">"reason"</span>.into(), reason.to_string().into()),
            <span class="org-comment-delimiter">//</span><span class="org-comment">("backtrace".into(), Item::String(format!("{:?}", bt))),</span>
        ];
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(actual) = actual {
            data.push((<span class="org-string">"actual"</span>.into(), actual));
        }
        <span class="org-type">Error</span> {
            <span class="org-variable-name">is_handled</span>: <span class="org-keyword">false</span>,

            <span class="org-variable-name">data</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(data),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">stack_underflow</span>() -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-constant">types</span>::wrap(<span class="org-string">"consume"</span>.into()),
            <span class="org-string">"not enough items on stack"</span>,
            <span class="org-type">None</span>,
        )
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">undefined</span>(<span class="org-variable-name">w</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-constant">types</span>::wrap(<span class="org-type">Item</span>::<span class="org-type">Word</span>(w)), <span class="org-string">"word is not defined"</span>, <span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">type_mismatch</span>(<span class="org-variable-name">asked</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">actual</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(asked, <span class="org-string">"type mismatch"</span>, actual)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">division_by_zero</span>() -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-constant">types</span>::wrap(<span class="org-string">"/"</span>.into()), <span class="org-string">"division by zero"</span>, <span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">expected</span>(<span class="org-variable-name">typestr</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">actual</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::type_mismatch(<span class="org-constant">types</span>::wrap(typestr.into()), <span class="org-type">Some</span>(actual))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">short_list</span>(<span class="org-variable-name">expected</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-string">"count"</span>.into(), <span class="org-type">Item</span>::<span class="org-type">Int</span>(expected), <span class="org-string">"&gt;="</span>.into()]),
            <span class="org-string">"list had too few items"</span>,
            <span class="org-type">None</span>,
        )
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">list_count</span>(<span class="org-variable-name">expected</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-string">"count"</span>.into(), <span class="org-type">Item</span>::<span class="org-type">Int</span>(expected), <span class="org-string">"="</span>.into()]),
            <span class="org-string">"list had wrong number of items"</span>,
            <span class="org-type">None</span>,
        )
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">parse</span>(<span class="org-variable-name">reason</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-constant">types</span>::wrap(<span class="org-string">"read"</span>.into()), reason, <span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">test_assertion</span>(<span class="org-variable-name">program</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">expected</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">actual</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">e</span> = <span class="org-type">Error</span>::create(program, <span class="org-string">"assertion failed"</span>, <span class="org-type">Some</span>(actual.into()));
        <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = e.data.make_mut();
        d.insert(<span class="org-string">"expected-program"</span>.into(), expected.into());
        e
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        <span class="org-keyword">self</span>.data.len()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">assoc</span>::<span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Error</span>) -&gt; <span class="org-constant">assoc</span>::<span class="org-type">Association</span> {
        e.data
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e),
            ))) =&gt; <span class="org-type">Ok</span>(e),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_))) =&gt; {
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, <span class="org-type">Default</span>::default()))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(c)) =&gt; c.into_iter().try_into(),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: this can't fail, can just be a From.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Really though, Error should have predefined fields like Environment.</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">data</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::try_from_iter(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(<span class="org-type">Error</span> {
            data,
            <span class="org-variable-name">is_handled</span>: <span class="org-keyword">false</span>,
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> a {
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; <span class="org-type">Ok</span>(e),
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; {
                <span class="org-keyword">if</span> a.get(<span class="org-rust-ampersand">&amp;</span><span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::from(<span class="org-string">"type"</span>)) != <span class="org-type">Some</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-string">"error"</span>)) {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, a.into()))
                } <span class="org-keyword">else</span> {
                    <span class="org-type">Ok</span>(<span class="org-type">Error</span> {
                        <span class="org-variable-name">data</span>: a.clone(),
                        <span class="org-variable-name">is_handled</span>: <span class="org-keyword">true</span>,
                    })
                }
            }
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Error</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-type">Box</span>::new(
            <span class="org-keyword">self</span>.data
                .inner()
                .into_iter()
                .chain(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::once((<span class="org-string">"handled"</span>.into(), <span class="org-keyword">self</span>.is_handled.into()))),
        )
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org561d52d" class="outline-5">
<h5 id="org561d52d"><span class="section-number-5">1.5.2.5.</span> Dictionary types</h5>
<div class="outline-text-5" id="text-1-5-2-5">
<div class='tangle-wrapper' data-tangle='src/types/dictionary.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">examples</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">spec</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">definition</span>: <span class="org-type">Definition</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        3 <span class="org-comment-delimiter">// </span><span class="org-comment">3 fields</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">match</span> key {
            <span class="org-string">"spec"</span> =&gt; <span class="org-keyword">self</span>.spec.clone().map(|x| x.into()),
            <span class="org-string">"examples"</span> =&gt; <span class="org-keyword">self</span>.examples.clone().map(|x| x.into()),
            <span class="org-string">"definition"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">match</span> <span class="org-keyword">self</span>.definition.clone() {
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(_) =&gt; <span class="org-string">"builtin"</span>.into(),
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; d.into(),
            }),
            _ =&gt; <span class="org-type">None</span>,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains_key</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-type">Word</span>::try_from(key.clone()).map_or(<span class="org-keyword">false</span>, |w| {
            <span class="org-preprocessor">matches!</span>(w.as_str(), <span class="org-string">"examples"</span> | <span class="org-string">"spec"</span> | <span class="org-string">"definition"</span>)
        })
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Dictionary</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">Word</span>, <span class="org-type">Entry</span>&gt;&gt;;

<span class="org-preprocessor">#[derive(Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Definition</span> {
    <span class="org-type">Axiom</span>(<span class="org-rust-ampersand">&amp;</span>'<span class="org-keyword">static</span> <span class="org-type">StepFn</span>),
    <span class="org-type">Derived</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Definition</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">_</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO actually implement this</span>
        <span class="org-keyword">true</span>
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">dictionary entries are equal if they have the same function reference,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">no need to compare the function values</span>
<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">self</span>.definition == other.definition
            &amp;&amp; <span class="org-keyword">self</span>.examples == other.examples
            &amp;&amp; <span class="org-keyword">self</span>.spec == other.spec
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Definition</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(_) =&gt; f.write_str(<span class="org-string">"Builtin"</span>),
            <span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ds</span> = f.debug_list();
                ds.entries(d.iter());
                ds.finish()
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt; = <span class="org-preprocessor">vec!</span>[(<span class="org-string">"definition"</span>.into(), {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span>.definition {
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(l) =&gt; l.into(),
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(_) =&gt; <span class="org-string">"builtin-function"</span>.into(),
            }
        })];
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(e) = <span class="org-keyword">self</span>.examples {
            v.push((<span class="org-string">"examples"</span>.into(), e.into()));
        }
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(s) = <span class="org-keyword">self</span>.spec {
            v.push((<span class="org-string">"spec"</span>.into(), s.into()))
        }
        <span class="org-type">Box</span>::new(v.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">examples</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">definition</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Definition</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">spec</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> iter {
            <span class="org-keyword">let</span> (k, v): (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = i.try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("k: {:?}, v: {:?}", k, v);</span>
            <span class="org-keyword">if</span> k == <span class="org-string">"examples"</span>.into() {
                examples = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>);
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"definition"</span>.into() {
                definition = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>);
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"spec"</span>.into() {
                spec = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>);
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">continue</span>;
            }
        }
        <span class="org-type">Ok</span>(<span class="org-type">Entry</span> {
            examples,
            <span class="org-variable-name">definition</span>: definition.unwrap_or(<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::new())),
            spec,
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Dictionary</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        iter.map(&lt;(<span class="org-type">Word</span>, <span class="org-type">Entry</span>)&gt;::try_from)
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">Word</span>, <span class="org-type">Entry</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()
            .map(<span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Definition</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i).map(<span class="org-type">Definition</span>::<span class="org-type">Derived</span>)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(d)) =&gt; <span class="org-type">Ok</span>(d),
            c =&gt; c.into_iter().try_into(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">assoc</span>::<span class="org-type">Associative</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">d</span>: <span class="org-type">Entry</span>) -&gt; <span class="org-constant">assoc</span>::<span class="org-type">Associative</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">assoc</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new();
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = assoc.make_mut();
        d.examples
            .and_then(|l| a.insert(<span class="org-string">"examples"</span>.into(), l.into()));
        d.spec.and_then(|l| a.insert(<span class="org-string">"spec"</span>.into(), l.into()));

        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) = d.definition {
            a.insert(<span class="org-string">"definition"</span>.into(), d.into());
        }

        <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(assoc)
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">impl TryFrom&lt;Associative&gt; for Entry {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">type Error = Error;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn try_from(d: Associative) -&gt; Result&lt;Self, Error&gt; {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">// TODO: This should handle cases where there's no def present</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">// and return error</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">let (d, def) = d.remove(&amp;"definition".into());</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">let (d, examples) = d.remove(&amp;"examples".into());</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">let (_, spec) = d.remove(&amp;"spec".into());</span>

<span class="org-comment-delimiter">//         </span><span class="org-comment">Ok(Entry {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">definition: if let Some(d) = def {</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">Definition::Derived(List::try_from(d).unwrap())</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">} else {</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">//Err(Error::expected("definition field"))?  use a</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">// dummy value, presumably if this is during</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">// bootstrap,the definition will be replaced later.</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">Definition::Derived(Arc::new(ListContent::new()))</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">},</span>

<span class="org-comment-delimiter">//             </span><span class="org-comment">// {Box::leak(Box::new(move |env: Environment| {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">//    env.push(Item::Error(Error::undefined(w)))</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">//}))}</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">examples: examples.and_then(|i| List::try_from(i).ok()),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">spec: spec.and_then(|i| List::try_from(i).ok()),</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">})</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">impl TryFrom&lt;List&gt; for Entry {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">type Error = Error;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn try_from(l: List) -&gt; Result&lt;Self, Error&gt; {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">let a: Associative = l.try_into()?;</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">a.try_into()</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">impl TryFrom&lt;assoc::Associative&gt; for Dictionary {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">type Error = Error;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn try_from(a: assoc::Associative) -&gt; Result&lt;Self, Self::Error&gt; {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">match a {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">assoc::Associative::Dictionary(e) =&gt; Ok(e),</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">assoc::Associative::Assoc(a) =&gt; {</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">let h = rc_inner(&amp;a)</span>
<span class="org-comment-delimiter">//                     </span><span class="org-comment">.into_iter()</span>
<span class="org-comment-delimiter">//                     </span><span class="org-comment">.map(|(k, v)| {</span>
<span class="org-comment-delimiter">//                         </span><span class="org-comment">let e: (Word, Entry) = (k.try_into()?, v.try_into()?);</span>
<span class="org-comment-delimiter">//                         </span><span class="org-comment">Ok(e)</span>
<span class="org-comment-delimiter">//                     </span><span class="org-comment">})</span>
<span class="org-comment-delimiter">//                     </span><span class="org-comment">.collect::&lt;Result&lt;HashMap&lt;Word, Entry&gt;, Error&gt;&gt;()?;</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">Ok(Arc::new(h))</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">_ =&gt; Err(Error::expected("dictionary")),</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">impl From&lt;Dictionary&gt; for assoc::Associative {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">fn from(d: Dictionary) -&gt; Self {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Associative::Assoc(Arc::new(</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">rc_inner(&amp;d)</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">.into_iter()</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">.map(|(k, v)| (assoc::KeyItem::Word(k), Item::Entry(v)))</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">.collect(),</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">))</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dictionary</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d)) =&gt; <span class="org-type">Ok</span>(d),
            c =&gt; c.into_iter().try_into(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Entry</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(e),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Dictionary</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">d</span>: <span class="org-type">Dictionary</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;(<span class="org-type">Word</span>, <span class="org-type">Entry</span>)&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>((k, v): (<span class="org-type">Word</span>, <span class="org-type">Entry</span>)) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-type">Item</span>::<span class="org-type">Word</span>(k), <span class="org-type">Item</span>::from(v.clone())]).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> (<span class="org-type">Word</span>, <span class="org-type">Entry</span>) {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> s.len() != 2 {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pair"</span>, s.into()))
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">iter</span> = s.into_iter();
            <span class="org-keyword">let</span> <span class="org-variable-name">key</span>: <span class="org-type">Word</span> = iter.next().unwrap().try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">value</span>: <span class="org-type">Entry</span> = iter.next().unwrap().try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>((key, value))
        }
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-orgc6d4614" class="outline-5">
<h5 id="orgc6d4614"><span class="section-number-5">1.5.2.6.</span> Environment types</h5>
<div class="outline-text-5" id="text-1-5-2-6">
<div class='tangle-wrapper' data-tangle='src/types/environment.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::axiom;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::serialize;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{associative <span class="org-keyword">as</span> assoc, collection <span class="org-keyword">as</span> coll, dictionary <span class="org-keyword">as</span> dict};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;

<span class="org-preprocessor">#[derive(Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">stack</span>: <span class="org-type">Stack</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">program</span>: <span class="org-type">Stack</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">dictionary</span>: <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">push</span>(<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Environment</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.stack).push_front(i);
        <span class="org-keyword">self</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.stack).pop_front().unwrap()
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">push_expr</span>(<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Environment</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.program).push_front(i);
        <span class="org-keyword">self</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop_expr</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.program).pop_front().unwrap()
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">append_program</span>(<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-keyword">mut</span> <span class="org-variable-name">items</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">Environment</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">self</span>.program.make_mut();
        <span class="org-keyword">let</span> <span class="org-variable-name">ct</span> = expr.len();
        expr.append(items.make_mut());
        expr.rotate_left(ct);
        <span class="org-keyword">self</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">tos</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>&gt; {
        <span class="org-keyword">self</span>.stack.front()
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        3 <span class="org-comment-delimiter">// </span><span class="org-comment">3 fields</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">match</span> key {
            <span class="org-string">"stack"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">self</span>.stack.clone().into()),
            <span class="org-string">"program"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">self</span>.program.clone().into()),
            <span class="org-string">"dictionary"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">self</span>.dictionary.clone().into()),
            _ =&gt; <span class="org-type">None</span>,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains_key</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-type">Word</span>::try_from(key.clone()).map_or(<span class="org-keyword">false</span>, |w| {
            <span class="org-preprocessor">matches!</span>(w.as_str(), <span class="org-string">"stack"</span> | <span class="org-string">"program"</span> | <span class="org-string">"dictionary"</span>)
        })
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert</span>(<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> k {
            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-keyword">match</span> w.as_str() {
                <span class="org-string">"stack"</span> =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v.clone());
                    <span class="org-keyword">match</span> l {
                        <span class="org-type">Ok</span>(l) =&gt; {
                            <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = <span class="org-keyword">self</span>.stack.clone();
                            <span class="org-keyword">self</span>.stack = l;
                            (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(<span class="org-keyword">self</span>), <span class="org-type">Some</span>(old.into()))
                        }
                        <span class="org-type">Err</span>(_) =&gt; {
                            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                            <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                            (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                        }
                    }
                }
                <span class="org-string">"program"</span> =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v.clone());
                    <span class="org-keyword">match</span> l {
                        <span class="org-type">Ok</span>(l) =&gt; {
                            <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = <span class="org-keyword">self</span>.program.clone();
                            <span class="org-keyword">self</span>.program = l;
                            (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(<span class="org-keyword">self</span>), <span class="org-type">Some</span>(old.into()))
                        }
                        <span class="org-type">Err</span>(_) =&gt; {
                            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                            <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                            (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                        }
                    }
                }
                <span class="org-string">"dictionary"</span> =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>::try_from(v.clone());
                    <span class="org-keyword">match</span> d {
                        <span class="org-type">Ok</span>(d) =&gt; {
                            <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = <span class="org-keyword">self</span>.dictionary.clone();
                            <span class="org-keyword">self</span>.dictionary = d;
                            (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(<span class="org-keyword">self</span>), <span class="org-type">Some</span>(old.into()))
                        }
                        <span class="org-type">Err</span>(_) =&gt; {
                            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                            <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                            (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                        }
                    }
                }
                k =&gt; {
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                    <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k.into(), v);
                    (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                }
            },
            _ =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">stack</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">program</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">dictionary</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> iter {
            <span class="org-keyword">let</span> (k, v): (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = i.try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">if</span> k == <span class="org-string">"stack"</span>.into() {
                stack = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>)
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"program"</span>.into() {
                program = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>)
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"dictionary"</span>.into() {
                dictionary = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>)
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">continue</span>;
            }
        }
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-constant">axiom</span>::standard_env(program, stack);
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(<span class="org-keyword">mut</span> d) = dictionary {
            <span class="org-keyword">let</span> <span class="org-variable-name">edmut</span> = env.dictionary.make_mut();
            edmut.extend(d.inner().into_iter());
        }
        <span class="org-type">Ok</span>(env)
    }
}
<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;

        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(e)) =&gt; <span class="org-type">Ok</span>(e),
            l =&gt; l.into_iter().try_into(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Environment</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(env).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Environment</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
        <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(env))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt; = <span class="org-preprocessor">vec!</span>[
            (<span class="org-string">"stack"</span>.into(), <span class="org-keyword">self</span>.stack.into()),
            (<span class="org-string">"program"</span>.into(), <span class="org-keyword">self</span>.program.into()),
            (<span class="org-string">"dictionary"</span>.into(), <span class="org-keyword">self</span>.dictionary.into()),
        ];
        <span class="org-type">Box</span>::new(v.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">assoc</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>.clone());
        <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = assoc.make_mut();
        am.remove(<span class="org-rust-ampersand">&amp;</span>(<span class="org-string">"dictionary"</span>.into()));
        assoc.into()
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org438b799" class="outline-5">
<h5 id="org438b799"><span class="section-number-5">1.5.2.7.</span> Cryptographic primitives</h5>
<div class="outline-text-5" id="text-1-5-2-7">
<p>
We'll implement certain cryptography functions in rust and make kcats
words for them (hashing, encryption, signing)
</p>
<div class='tangle-wrapper' data-tangle='src/crypto.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{associative <span class="org-keyword">as</span> assoc, <span class="org-constant">error</span>::<span class="org-type">Error</span>, <span class="org-type">Bytes</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">core</span>::<span class="org-constant">ops</span>::<span class="org-type">Deref</span>;
<span class="org-keyword">use</span> <span class="org-constant">ed25519_dalek</span> <span class="org-keyword">as</span> signing;
<span class="org-keyword">use</span> <span class="org-constant">ed25519_dalek</span>::{<span class="org-type">Signer</span>, <span class="org-type">Verifier</span>};
<span class="org-keyword">use</span> <span class="org-constant">rand_core</span>::{<span class="org-type">CryptoRng</span>, <span class="org-type">RngCore</span>};
<span class="org-keyword">use</span> <span class="org-constant">sha2</span>::{<span class="org-keyword">self</span>, <span class="org-type">Digest</span>};

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">hash</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = <span class="org-type">Bytes</span>::try_from(i).unwrap();
    <span class="org-type">Ok</span>(<span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>::digest(b).deref().to_vec().into())
}

<span class="org-keyword">type</span> <span class="org-type">Value</span> = <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;;

<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">SeededRNG</span> {
    <span class="org-variable-name">seed</span>: <span class="org-type">Value</span>,
    <span class="org-variable-name">salt</span>: <span class="org-type">Value</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">SeededRNG</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Hash of seed|value</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">hash</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">v</span> = <span class="org-keyword">self</span>.seed.clone();
        v.extend(<span class="org-keyword">self</span>.salt.clone());
        <span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>::digest(v.as_slice()).deref().to_vec()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">RngCore</span> <span class="org-keyword">for</span> <span class="org-type">SeededRNG</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">next_u32</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">u32</span> {
        <span class="org-constant">rand_core</span>::<span class="org-constant">impls</span>::next_u32_via_fill(<span class="org-keyword">self</span>)
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">next_u64</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">u64</span> {
        <span class="org-constant">rand_core</span>::<span class="org-constant">impls</span>::next_u64_via_fill(<span class="org-keyword">self</span>)
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">fill_bytes</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">dest</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> [<span class="org-type">u8</span>]) {
        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = dest.len();
        dest.copy_from_slice(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.hash()[..l]);
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">try_fill_bytes</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">dest</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> [<span class="org-type">u8</span>]) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-constant">rand_core</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">self</span>.fill_bytes(dest);
        <span class="org-type">Ok</span>(())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">CryptoRng</span> <span class="org-keyword">for</span> <span class="org-type">SeededRNG</span> {}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">key</span>(<span class="org-variable-name">seed</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">sbs</span>: <span class="org-type">Bytes</span> = seed.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">kp</span> = <span class="org-constant">signing</span>::<span class="org-type">Keypair</span>::generate(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">SeededRNG</span> {
        <span class="org-variable-name">seed</span>: <span class="org-preprocessor">vec!</span>[],
        <span class="org-variable-name">salt</span>: sbs,
    });
    <span class="org-type">Ok</span>(<span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
        (<span class="org-string">"type"</span>.into(), <span class="org-string">"elliptic-curve-key"</span>.into()),
        (<span class="org-string">"secret"</span>.into(), kp.secret.as_ref().to_vec().into()),
        (<span class="org-string">"public"</span>.into(), kp.public.as_ref().to_vec().into()),
    ])
    .into())
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">signing</span>::<span class="org-type">Keypair</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">sk</span>: <span class="org-constant">signing</span>::<span class="org-type">SecretKey</span> = i.try_into()<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">pk</span>: <span class="org-constant">signing</span>::<span class="org-type">PublicKey</span> = (<span class="org-rust-ampersand">&amp;</span>sk).into();
        <span class="org-type">Ok</span>(<span class="org-constant">signing</span>::<span class="org-type">Keypair</span> {
            <span class="org-variable-name">secret</span>: sk,
            <span class="org-variable-name">public</span>: pk,
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">signing</span>::<span class="org-type">SecretKey</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> a.get(&amp;<span class="org-string">"type"</span>.into()) == <span class="org-type">Some</span>(<span class="org-string">"elliptic-curve-key"</span>.into()) {
            <span class="org-keyword">let</span> <span class="org-variable-name">sk</span> = <span class="org-constant">signing</span>::<span class="org-type">SecretKey</span>::from_bytes(
                <span class="org-rust-ampersand">&amp;</span><span class="org-type">Bytes</span>::try_from(
                    a.get(&amp;<span class="org-string">"secret"</span>.into())
                        .ok_or_else(|| <span class="org-type">Error</span>::expected(<span class="org-string">"secret"</span>, <span class="org-type">Default</span>::default()))<span class="org-rust-question-mark">?</span>,
                )<span class="org-rust-question-mark">?</span>[..],
            )
            .map_err(|_e| <span class="org-type">Error</span>::expected(<span class="org-string">"valid-secret-key"</span>, <span class="org-type">Default</span>::default()))<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(sk)
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"keypair"</span>, a.clone().into()))
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">signing</span>::<span class="org-type">PublicKey</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> a.get(&amp;<span class="org-string">"type"</span>.into()) == <span class="org-type">Some</span>(<span class="org-string">"elliptic-curve-key"</span>.into()) {
            <span class="org-keyword">let</span> <span class="org-variable-name">pk</span> = <span class="org-constant">signing</span>::<span class="org-type">PublicKey</span>::from_bytes(
                <span class="org-rust-ampersand">&amp;</span><span class="org-type">Bytes</span>::try_from(
                    a.get(&amp;<span class="org-string">"public"</span>.into())
                        .ok_or_else(|| <span class="org-type">Error</span>::expected(<span class="org-string">"public"</span>, <span class="org-type">Default</span>::default()))<span class="org-rust-question-mark">?</span>,
                )<span class="org-rust-question-mark">?</span>[..],
            )
            .map_err(|_e| <span class="org-type">Error</span>::expected(<span class="org-string">"valid-public-key"</span>, <span class="org-type">Default</span>::default()))<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(pk)
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"public-key"</span>, a.clone().into()))
        }
    }
}
<span class="org-comment-delimiter">//</span><span class="org-comment">TODO: we can only call sign from a keypair, so we may want to assume</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">that we have either the kp, or just the secret key.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sign</span>(<span class="org-variable-name">k</span>: <span class="org-type">Item</span>, <span class="org-variable-name">m</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">kp</span>: <span class="org-constant">signing</span>::<span class="org-type">Keypair</span> = k.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">message</span>: <span class="org-type">Bytes</span> = m.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">signature</span>: <span class="org-constant">signing</span>::<span class="org-type">Signature</span> = kp.sign(<span class="org-rust-ampersand">&amp;</span>message);
    <span class="org-type">Ok</span>(signature.as_ref().to_vec().into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">verify</span>(<span class="org-variable-name">k</span>: <span class="org-type">Item</span>, <span class="org-variable-name">m</span>: <span class="org-type">Item</span>, <span class="org-variable-name">s</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">mret</span> = m.clone();
    <span class="org-keyword">let</span> <span class="org-variable-name">pk</span>: <span class="org-constant">signing</span>::<span class="org-type">PublicKey</span> = k.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">mbs</span>: <span class="org-type">Bytes</span> = m.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">sbs</span>: <span class="org-type">Bytes</span> = s.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">sig</span> = <span class="org-constant">signing</span>::<span class="org-type">Signature</span>::from_bytes(<span class="org-rust-ampersand">&amp;</span>sbs)
        .map_err(|_e| <span class="org-type">Error</span>::expected(<span class="org-string">"signature"</span>, <span class="org-type">Default</span>::default()))<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(pk.verify(<span class="org-rust-ampersand">&amp;</span>mbs, <span class="org-rust-ampersand">&amp;</span>sig).map(|_| mret).unwrap_or_default())
}
</pre>
</div></div>
</div>
</div>
</div>
<div id="outline-container-org17e0b40" class="outline-4">
<h4 id="org17e0b40"><span class="section-number-4">1.5.3.</span> Serialization</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
We'll define how kcats data structure are parsed and written (for
example, in order to read/write to/from disk).
</p>
<div class='tangle-wrapper' data-tangle='src/serialize.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">extern</span> <span class="org-keyword">crate</span> edn_format;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">environment</span>::<span class="org-type">Environment</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-type">NOTHING</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{associative <span class="org-keyword">as</span> assoc, collection <span class="org-keyword">as</span> coll, <span class="org-constant">error</span>::<span class="org-type">Error</span>, *};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">VecDeque</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::fmt;

<span class="org-keyword">pub</span> <span class="org-keyword">trait</span> <span class="org-type">Display</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span>;
}

<span class="org-keyword">const</span> <span class="org-variable-name">BYTE_TAG</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span> = <span class="org-string">"b64"</span>;

<span class="org-keyword">fn</span> <span class="org-function-name">to_item</span>(<span class="org-variable-name">item</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">edn_format</span>::<span class="org-type">Value</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("to item {:?}", item);</span>
    <span class="org-keyword">match</span> item {
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Integer</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(*i)),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(v) =&gt; <span class="org-type">Ok</span>({
            <span class="org-keyword">if</span> v.is_empty() {
                <span class="org-type">NOTHING</span>
            } <span class="org-keyword">else</span> {
                <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
                    v.iter()
                        .map(to_item)
                        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
                )
                .into()
            }
        }),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Symbol</span>(s) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Word</span>(s.to_string().into())),
        <span class="org-comment-delimiter">// </span><span class="org-comment">we don't have booleans in kcats, so if we see 'false' that</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is the word false which is not defined in the base</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">language, but might be user-defined later.</span>
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Boolean</span>(b) =&gt; <span class="org-type">Ok</span>(<span class="org-keyword">if</span> *b { <span class="org-string">"yes"</span>.into() } <span class="org-keyword">else</span> { <span class="org-string">"false"</span>.into() }),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s) =&gt; <span class="org-type">Ok</span>(s.to_string().into()),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Float</span>(f) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(f.into_inner())),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">TaggedElement</span>(tag, e) =&gt; {
            <span class="org-keyword">if</span> *tag == <span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(<span class="org-type">BYTE_TAG</span>) {
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-variable-name">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s) = <span class="org-rust-ampersand">&amp;</span>**e {
                    <span class="org-type">Ok</span>(<span class="org-constant">base64</span>::decode(s).unwrap().into())
                } <span class="org-keyword">else</span> {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::parse(<span class="org-string">"Invalid tag datatype for byte literal"</span>))
                }
            } <span class="org-keyword">else</span> {
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::parse(<span class="org-string">"Unsupported tag"</span>))
            }
        }
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Character</span>(c) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Char</span>(*c)),
        _ =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::parse(<span class="org-string">"Unsupported data literal"</span>)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">from_item</span>(<span class="org-variable-name">item</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>) -&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span> {
    <span class="org-keyword">match</span> item {
        <span class="org-comment-delimiter">// </span><span class="org-comment">dictionaries are big and it's ugly to print them for</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">environments.</span>
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(e),
        ))) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>e.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(<span class="org-preprocessor">vec!</span>[]),
        <span class="org-type">Item</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Integer</span>(*i),
        <span class="org-type">Item</span>::<span class="org-type">Float</span>(f) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::from(*f),
        <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Character</span>(*c),
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s))) =&gt; {
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s.to_string())
        }
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(bs))) =&gt; {
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">TaggedElement</span>(
                <span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(<span class="org-string">"b64"</span>),
                <span class="org-type">Box</span>::new(<span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(<span class="org-constant">base64</span>::encode(bs))),
            )
        }
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s))) =&gt; {
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s.to_string())
        }
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(bs))) =&gt; {
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">TaggedElement</span>(
                <span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(<span class="org-string">"b64"</span>),
                <span class="org-type">Box</span>::new(<span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(<span class="org-constant">base64</span>::encode(bs))),
            )
        }
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(v)) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(
            v.clone()
                .into_iter()
                .map(|i| from_item(<span class="org-rust-ampersand">&amp;</span>i))
                .collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">edn_format</span>::<span class="org-type">Value</span>&gt;&gt;(),
        ),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(v)) =&gt; {
            from_item(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(v.clone())))
        }
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Symbol</span>(<span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(w)),
        <span class="org-comment-delimiter">//</span><span class="org-comment">Item::Entry(w) =&gt; edn_format::Value::Symbol(edn_format::Symbol::from_name(&amp;w.word)),</span>
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>o.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>t.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(i)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>i.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>t.representation()),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">parse</span>(<span class="org-variable-name">s</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">parser</span> = <span class="org-constant">edn_format</span>::<span class="org-type">Parser</span>::from_iter(s.chars(), <span class="org-constant">edn_format</span>::<span class="org-type">ParserOptions</span>::default());
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
        parser
            .map(<span class="org-keyword">move</span> |r| <span class="org-keyword">match</span> r {
                <span class="org-type">Ok</span>(expr) =&gt; <span class="org-type">Ok</span>(to_item(<span class="org-rust-ampersand">&amp;</span>expr)<span class="org-rust-question-mark">?</span>),
                <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::from(e)),
            })
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
    ))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">emit</span>(<span class="org-variable-name">item</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-constant">edn_format</span>::emit_str(<span class="org-rust-ampersand">&amp;</span>from_item(item))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">emit_all</span>(<span class="org-variable-name">items</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">s</span>: <span class="org-type">String</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> items {
        s.push_str(<span class="org-constant">edn_format</span>::emit_str(<span class="org-rust-ampersand">&amp;</span>from_item(i)).as_str());
        s.push(<span class="org-string">' '</span>);
    }
    s.pop();
    s.to_string()
}

<span class="org-comment-delimiter">// </span><span class="org-comment">print out envs in error messages</span>
<span class="org-keyword">impl</span> <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-preprocessor">write!</span>(
            f,
            <span class="org-string">"{{ stack: {}, program: {} }}"</span>,
            emit(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-keyword">self</span>.stack.clone())),
            emit(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-keyword">self</span>.program.clone())),
        )
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-rust-builtin-formatting-macro">write!</span>(f, <span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, emit(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-keyword">self</span>.data.clone())))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">edn_format</span>::<span class="org-type">ParserError</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-constant">edn_format</span>::<span class="org-type">ParserError</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Error</span>::parse(e.to_string().as_str())
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">insert_line_breaks</span>(<span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">max_items</span>: <span class="org-type">usize</span>, <span class="org-variable-name">max_chars</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">result</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">current_line_length</span> = 0;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">open_list_stack</span>: <span class="org-type">Vec</span>&lt;(<span class="org-type">usize</span>, <span class="org-type">usize</span>)&gt; = <span class="org-type">Vec</span>::new();
    open_list_stack.push((0, 0));
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">last_char</span>: <span class="org-type">char</span> = <span class="org-string">'\n'</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">in_string</span>: <span class="org-type">bool</span> = <span class="org-keyword">false</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">chars</span> = input.chars().peekable(); <span class="org-comment-delimiter">// </span><span class="org-comment">Convert to a Peekable iterator</span>

    <span class="org-keyword">while</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(c) = chars.next() {
        current_line_length += 1;

        <span class="org-keyword">match</span> c {
            <span class="org-string">'"'</span> =&gt; {
                <span class="org-keyword">if</span> last_char != <span class="org-string">'\\'</span> {
                    in_string = !in_string;
                }
                result.push(c);
            }
            <span class="org-string">'['</span> =&gt; {
                <span class="org-keyword">if</span> !in_string &amp;&amp; last_char != <span class="org-string">'\\'</span> {
                    open_list_stack.push((0, 0)); <span class="org-comment-delimiter">// </span><span class="org-comment">Start a new list</span>
                }
                result.push(c);
            }
            <span class="org-string">']'</span> =&gt; {
                result.push(c);
                <span class="org-keyword">if</span> !in_string &amp;&amp; last_char != <span class="org-string">'\\'</span> {
                    <span class="org-keyword">let</span> (last_count, break_count) = open_list_stack.pop().unwrap();
                    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("items, breaks: {}, {}", last_count, break_count);</span>
                    <span class="org-keyword">if</span> (last_count == 1 || last_count &gt;= 6 || break_count &gt; 0)
                        &amp;&amp; chars.peek() != <span class="org-type">Some</span>(&amp;<span class="org-string">']'</span>)
                    {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">Only add a newline if the next character is not a closing bracket</span>
                        result.push(<span class="org-string">'\n'</span>);
                        <span class="org-keyword">let</span> (_, break_count) = open_list_stack.last_mut().unwrap();
                        *break_count += 1;
                        current_line_length = 0;
                    }
                }
            }
            <span class="org-string">' '</span> =&gt; {
                <span class="org-keyword">if</span> !in_string {
                    <span class="org-keyword">let</span> (last_count, break_count) = open_list_stack.last_mut().unwrap();
                    *last_count += 1;
                    <span class="org-keyword">if</span> (*last_count % max_items) == 0 || current_line_length &gt; max_chars {
                        result.push(<span class="org-string">'\n'</span>);
                        *break_count += 1;
                        current_line_length = 0;
                        <span class="org-comment-delimiter">//</span><span class="org-comment">*last_count = 0;</span>
                    }
                }
                result.push(c);
            }
            _ =&gt; {
                result.push(c);
            }
        }
        last_char = c;
    }
    <span class="org-keyword">if</span> result.ends_with(<span class="org-string">'\n'</span>) {
        result.pop();
    }
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("broken output: {:?}", result);</span>
    result
}

<span class="org-keyword">fn</span> <span class="org-function-name">parse_indent</span>(<span class="org-variable-name">stack</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Vec</span>&lt;<span class="org-type">usize</span>&gt;, <span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">in_string</span> = <span class="org-keyword">false</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">escaped</span> = <span class="org-keyword">false</span>;

    <span class="org-keyword">for</span> (idx, c) <span class="org-keyword">in</span> input.chars().enumerate() {
        <span class="org-keyword">if</span> in_string {
            <span class="org-keyword">match</span> c {
                <span class="org-string">'"'</span> <span class="org-keyword">if</span> !escaped =&gt; in_string = <span class="org-keyword">false</span>,
                <span class="org-comment-delimiter">// </span><span class="org-comment">TODO handle \\ (escaped backslash char)</span>
                <span class="org-string">'\\'</span> <span class="org-keyword">if</span> !escaped =&gt; escaped = <span class="org-keyword">true</span>,
                _ =&gt; escaped = <span class="org-keyword">false</span>,
            }
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">match</span> c {
                <span class="org-string">'['</span> <span class="org-keyword">if</span> !escaped =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                    stack.push(idx);
                }
                <span class="org-string">']'</span> <span class="org-keyword">if</span> !escaped =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                    stack.pop();
                }
                <span class="org-string">'"'</span> =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                    in_string = <span class="org-keyword">true</span>;
                }
                <span class="org-string">';'</span> =&gt; {
                    <span class="org-keyword">break</span>;
                }
                <span class="org-string">'\\'</span> =&gt; {
                    escaped = <span class="org-keyword">true</span>;
                }
                _ =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                }
            }
        }
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">format_indentation</span>(<span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">result</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">indentations</span> = <span class="org-type">Vec</span>::&lt;<span class="org-type">usize</span>&gt;::new();

    <span class="org-keyword">for</span> <span class="org-variable-name">line</span> <span class="org-keyword">in</span> input.lines() {
        <span class="org-keyword">let</span> <span class="org-variable-name">trimmed</span> = line.trim();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Deduce the new indentation based on the last item in the indentations stack</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">new_indent</span> = indentations.last().copied().map(|x| x + 1).unwrap_or(0);
        <span class="org-keyword">let</span> <span class="org-variable-name">padded_line</span> = <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}{}</span><span class="org-string">\n"</span>, <span class="org-string">" "</span>.repeat(new_indent), trimmed);
        result.push_str(padded_line.as_str());
        parse_indent(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> indentations, <span class="org-rust-ampersand">&amp;</span>padded_line);
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("indentations: {:?}: {:?}", padded_line, indentations);</span>
    }
    result.pop(); <span class="org-comment-delimiter">// </span><span class="org-comment">Remove the last newline</span>
    result
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">auto_format</span>(<span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">max_items</span>: <span class="org-type">usize</span>, <span class="org-variable-name">max_chars</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">with_breaks</span> = insert_line_breaks(input, max_items, max_chars);
    format_indentation(<span class="org-rust-ampersand">&amp;</span>with_breaks)
}

<span class="org-preprocessor">#[cfg(test)]</span>
<span class="org-keyword">mod</span> <span class="org-constant">tests</span> {
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::*;

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_insert_line_breaks</span>() {
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[foo bar][baz [[quux floop][toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[foo bar]\n[baz [[quux floop]\n[toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = insert_line_breaks(input, 6, 80);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);

        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[[1 2 3] b][c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[[1 2 3] b]\n[c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = insert_line_breaks(input, 6, 80);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);

        <span class="org-comment-delimiter">// </span><span class="org-comment">multiline list</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[a b] [c d]] 5"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[a b]\n [c d]]\n 5"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = insert_line_breaks(input, 6, 80);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);
    }

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_indentation</span>() {
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[foo bar]\n[baz [[quux floop]\n[toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[foo bar]\n [baz [[quux floop]\n       [toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = format_indentation(input);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);

        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"\"hello\" [[a b]\n[c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"\"hello\" [[a b]\n         [c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = format_indentation(input);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org944ee6c" class="outline-4">
<h4 id="org944ee6c"><span class="section-number-4">1.5.4.</span> Builtin words</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
We'll define some words as axioms (not in terms of other words, only defined in Rust). 
</p>
<div class='tangle-wrapper' data-tangle='src/axiom.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">super</span>::serialize;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::pipes;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::dictionary <span class="org-keyword">as</span> dict;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">environment</span>::<span class="org-type">Environment</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">futures</span>::<span class="org-constant">future</span>::<span class="org-type">FutureExt</span>;
<span class="org-keyword">use</span> <span class="org-constant">num_integer</span>::<span class="org-type">Roots</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashMap</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">VecDeque</span>;
<span class="org-comment-delimiter">//</span><span class="org-comment">use std::future::Future;</span>
<span class="org-keyword">use</span> <span class="org-constant">std</span>::mem;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">ops</span>::<span class="org-type">Range</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">ItemResult</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt;;

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">ItemResult</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">ItemResult</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Ok</span>(i) =&gt; i,
            <span class="org-type">Err</span>(e) =&gt; e.into(),
        }
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">f_stack1</span>(<span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span>) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = f(x);
        <span class="org-keyword">if</span> res.is_ok() {
            env.pop_expr();
        }
        env.push(<span class="org-type">Item</span>::from(res)).into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">f_stack2</span>(<span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">Item</span>, <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span>) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = f(y, x);
        <span class="org-keyword">if</span> res.is_ok() {
            env.pop_expr();
        }
        env.push(<span class="org-type">Item</span>::from(res)).into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">f_stack3</span>(<span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">Item</span>, <span class="org-type">Item</span>, <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span>) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">z</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = f(z, y, x);
        <span class="org-keyword">if</span> res.is_ok() {
            env.pop_expr();
        }
        env.push(<span class="org-type">Item</span>::from(res)).into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">f_stack2_async</span>(
    <span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">Item</span>, <span class="org-type">Item</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">ItemResult</span>&gt;,
) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = env.pop();
        <span class="org-type">Box</span>::pin(f(x, y).map(|r| {
            <span class="org-keyword">if</span> r.is_ok() {
                env.pop_expr();
            }
            env.push(<span class="org-type">Item</span>::from(r))
        }))
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">update_axiom_entries</span>(
    <span class="org-keyword">mut</span> <span class="org-variable-name">d</span>: <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>,
    <span class="org-variable-name">updates</span>: <span class="org-type">Vec</span>&lt;(<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-rust-ampersand">&amp;</span>'<span class="org-keyword">static</span> <span class="org-type">StepFn</span>)&gt;,
) -&gt; <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> d);
    <span class="org-keyword">for</span> (w, f) <span class="org-keyword">in</span> updates {
        dm.entry(<span class="org-type">Word</span>::from(w)).and_modify(|e| {
            e.definition = <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(f);
        });
    }
    d
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">add_builtins</span>(<span class="org-variable-name">d</span>: <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>) -&gt; <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span> {
    update_axiom_entries(
        d,
        <span class="org-preprocessor">vec!</span>[
            (<span class="org-string">"*"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(mult)))),
            (<span class="org-string">"+"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(plus)))),
            (<span class="org-string">"get"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(lookup)))),
            (<span class="org-string">"sort-indexed"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(sort_by_key)))),
            (<span class="org-string">"-"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(minus)))),
            (<span class="org-string">"/"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(div)))),
            (<span class="org-string">"&lt;"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(lt)))),
            (<span class="org-string">"&lt;="</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(lte)))),
            (<span class="org-string">"="</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(eq)))),
            (<span class="org-string">"&gt;"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(gt)))),
            (<span class="org-string">"&gt;="</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(gte)))),
            (<span class="org-string">"abs"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(abs)))),
            (<span class="org-string">"and"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(and)))),
            (<span class="org-string">"animate"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(animate))),
            (<span class="org-string">"assign"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(assign)))),
            (<span class="org-string">"association"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(association)))),
            (
                <span class="org-string">"association?"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_association))),
            ),
            (
                <span class="org-string">"attend"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">channel</span>::select))),
            ),
            (<span class="org-string">"autoformat"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(autoformat)))),
            (<span class="org-string">"branch"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(branch))),
            (<span class="org-string">"bytes"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(bytes)))),
            (<span class="org-string">"bytes?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_bytes)))),
            (<span class="org-string">"clone"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(clone))),
            (<span class="org-string">"contains?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(contains)))),
            (<span class="org-string">"ceil"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(ceil)))),
            (<span class="org-string">"compare"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(compare)))),
            (<span class="org-string">"count"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(count)))),
            (<span class="org-string">"dec"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(dec)))),
            (<span class="org-string">"decide"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(decide))),
            (<span class="org-string">"dip"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(dip))),
            (<span class="org-string">"dictionary"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(dictionary))),
            (<span class="org-string">"dipdown"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(dipdown))),
            (<span class="org-string">"drop"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(drop))),
            (<span class="org-string">"emit"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(emit)))),
            (<span class="org-string">"empty"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(empty)))),
            (<span class="org-string">"empty?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_empty)))),
            (<span class="org-string">"environment"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(environment)))),
            (<span class="org-string">"error?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_error)))),
            (<span class="org-string">"eval-step"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(eval_step_outer))),
            (<span class="org-string">"evaluate"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(evaluate))),
            (<span class="org-string">"even?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_even)))),
            (<span class="org-string">"evert"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(evert))),
            (<span class="org-string">"execute"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(execute))),
            (<span class="org-string">"fail"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(fail)))),
            (
                <span class="org-string">"file-in"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">fs</span>::file_in))),
            ),
            (
                <span class="org-string">"file-out"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">fs</span>::file_out))),
            ),
            (<span class="org-string">"first"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(first)))),
            (<span class="org-string">"float"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(float))),
            (<span class="org-string">"handle"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(handle)))),
            (
                <span class="org-string">"handoff"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">channel</span>::handoff)),
            ),
            (<span class="org-string">"hash"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::hash)))),
            (<span class="org-string">"inc"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(inc)))),
            (<span class="org-string">"inspect"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(inspect)))),
            (<span class="org-string">"join"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(join)))),
            (<span class="org-string">"key"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::key)))),
            (<span class="org-string">"last"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(last)))),
            (<span class="org-string">"list?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_list)))),
            (<span class="org-string">"loop"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(loop_))),
            (<span class="org-string">"mod"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(mod_)))),
            (<span class="org-string">"not"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(not)))),
            (<span class="org-string">"number?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_number)))),
            (<span class="org-string">"odd?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_odd)))),
            (<span class="org-string">"or"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(or)))),
            (<span class="org-string">"pop"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(pop))),
            (<span class="org-string">"put"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(put))),
            (<span class="org-string">"pipe?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_pipe)))),
            (<span class="org-string">"range"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(range))),
            (<span class="org-string">"read"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(read))),
            (
                <span class="org-string">"receiver"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">channel</span>::receiver))),
            ),
            (<span class="org-string">"recur"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(recur))),
            (<span class="org-string">"redefine"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(redefine))),
            (<span class="org-string">"resume"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(identity))),
            (<span class="org-string">"reverse"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(reverse)))),
            (<span class="org-string">"second"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(second)))),
            (
                <span class="org-string">"sender"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">channel</span>::sender))),
            ),
            (
                <span class="org-string">"serversocket"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2_async(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">net</span>::server_socket))),
            ),
            (<span class="org-string">"set"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(set)))),
            (<span class="org-string">"set?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_set)))),
            (<span class="org-string">"sign"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::sign)))),
            (<span class="org-string">"sink"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(sink))),
            (<span class="org-string">"slice"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(slice)))),
            (
                <span class="org-string">"socket"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2_async(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">net</span>::socket))),
            ),
            (<span class="org-string">"sqrt"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(sqrt)))),
            (<span class="org-string">"standard"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(standard))),
            (<span class="org-string">"step"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(step))),
            (<span class="org-string">"string"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(string)))),
            (<span class="org-string">"string?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_string)))),
            (<span class="org-string">"swap"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(swap))),
            (<span class="org-string">"swapdown"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(swapdown))),
            (
                <span class="org-string">"timer"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">pipes</span>::<span class="org-constant">channel</span>::timer))),
            ),
            (<span class="org-string">"timestamps"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(timestamps))),
            (<span class="org-string">"unassign"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(unassign)))),
            (<span class="org-string">"take"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(take))),
            (<span class="org-string">"unwrap"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(unwrap))),
            (
                <span class="org-string">"verify"</span>,
                <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::verify))),
            ),
            (<span class="org-string">"word?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_word)))),
            (<span class="org-string">"wrap"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(wrap))),
            (<span class="org-string">"xor"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(xor)))),
            (<span class="org-string">"yes"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(yes))),
            (<span class="org-string">"zero?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_zero)))),
        ],
    )
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">read_lexicon</span>(<span class="org-variable-name">lexicon</span>: <span class="org-type">String</span>, <span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">items</span> = <span class="org-constant">serialize</span>::parse(lexicon).unwrap();
    <span class="org-keyword">for</span> <span class="org-variable-name">r</span> <span class="org-keyword">in</span> <span class="org-type">Box</span>::new(items.inner().into_iter()) {
        <span class="org-keyword">let</span> (k, def): (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = r.try_into().unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">word</span>: <span class="org-type">Word</span> = k.try_into().unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt; = def.try_into().unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">new_entry</span>: <span class="org-constant">dict</span>::<span class="org-type">Entry</span> = iter.try_into().unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">new_entry2</span> = new_entry.clone();
        <span class="org-keyword">let</span> <span class="org-variable-name">dict</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.dictionary);
        dict.entry(word)
            .and_modify(|e| {
                e.examples = new_entry.examples;
                e.spec = new_entry.spec;
                e.definition = new_entry.definition;
            })
            .or_insert(new_entry2);
    }
    env
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">add_standard_dictionary</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Environment</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">read builtins</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">builtins</span> = <span class="org-type">String</span>::from_utf8(<span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"kcats/builtins.kcats"</span>).to_vec()).unwrap();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = read_lexicon(builtins, env);
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("with builtins {:?}", env.dictionary);</span>
    env.dictionary = add_builtins(env.dictionary);
    <span class="org-comment-delimiter">//</span><span class="org-comment">env = add_derivations(env);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">lexicon</span> = <span class="org-type">String</span>::from_utf8(<span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"kcats/lexicon.kcats"</span>).to_vec()).unwrap();
    read_lexicon(lexicon, env)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">invalid_type_error</span>(<span class="org-variable-name">asked</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">actual</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Err</span>(<span class="org-type">Error</span>::type_mismatch(asked, <span class="org-type">Some</span>(actual)))
}

<span class="org-keyword">fn</span> <span class="org-function-name">number_type_error</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    invalid_type_error(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::wrap(<span class="org-type">Item</span>::<span class="org-type">Word</span>(*<span class="org-type">S_NUMBER</span>)), i)
}

<span class="org-keyword">fn</span> <span class="org-function-name">pair</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Item</span> {
    <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([i, j]).into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">plus</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i + j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i + j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i <span class="org-keyword">as</span> <span class="org-type">Float</span> + j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i + j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">minus</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i - j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i - j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i <span class="org-keyword">as</span> <span class="org-type">Float</span> - j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i - j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">mult</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i * j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i * j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i <span class="org-keyword">as</span> <span class="org-type">Float</span> * j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(i * j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">divide</span>(<span class="org-variable-name">i</span>: <span class="org-type">Float</span>, <span class="org-variable-name">j</span>: <span class="org-type">Float</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">q</span> = i / j;
    <span class="org-keyword">if</span> q.is_nan() {
        <span class="org-type">Err</span>(<span class="org-type">Error</span>::division_by_zero())
    } <span class="org-keyword">else</span> {
        <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(q))
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">div</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; i
            .checked_div(j)
            .ok_or_else(<span class="org-type">Error</span>::division_by_zero)
            .map(<span class="org-type">Item</span>::<span class="org-type">Int</span>),

        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; divide(i, j),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; divide(i <span class="org-keyword">as</span> <span class="org-type">Float</span>, j),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; divide(i, j <span class="org-keyword">as</span> <span class="org-type">Float</span>),
        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">mod_</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = <span class="org-type">Int</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i % j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">inc</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(<span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span> + 1))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dec</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(<span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span> - 1))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_zero</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i == 0)),
        <span class="org-type">Item</span>::<span class="org-type">Float</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i == 0.0)),
        i =&gt; number_type_error(i),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-keyword">true</span>,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)) =&gt; s.is_empty(),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s)) =&gt; s.is_empty(),
        _ =&gt; <span class="org-keyword">false</span>,
    }))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">gt</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &gt; j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &gt; j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i <span class="org-keyword">as</span> <span class="org-type">Float</span> &gt; j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &gt; j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">lt</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &lt; j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &lt; j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from((i <span class="org-keyword">as</span> <span class="org-type">Float</span>) &lt; j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &lt; j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">gte</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &gt;= j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &gt;= j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i <span class="org-keyword">as</span> <span class="org-type">Float</span> &gt;= j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &gt;= j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">lte</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &lt;= j)),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &lt;= j)),
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from((i <span class="org-keyword">as</span> <span class="org-type">Float</span>).le(<span class="org-rust-ampersand">&amp;</span>j))),
        (<span class="org-type">Item</span>::<span class="org-type">Float</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &lt;= j <span class="org-keyword">as</span> <span class="org-type">Float</span>)),

        (i, j) =&gt; number_type_error(pair(i, j)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">join</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(i.join(j)<span class="org-rust-question-mark">?</span>.into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
    <span class="org-keyword">let</span> <span class="org-variable-name">pr</span> = <span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::try_from(i);
    <span class="org-keyword">match</span> pr {
        <span class="org-type">Ok</span>(p) =&gt; <span class="org-type">Box</span>::pin(p.put(j).map(|f| <span class="org-keyword">match</span> f {
            <span class="org-type">Ok</span>(p) =&gt; {
                env.pop_expr();
                env.push(<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p))
            }
            <span class="org-type">Err</span>(e) =&gt; env.push(i2).push(e.into()),
        })),
        <span class="org-type">Err</span>(e) =&gt; env.push(i2).push(e.into()).into(),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">clone</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">clone</span> = env.stack.front().unwrap().clone();
    env.pop_expr();
    env.push(clone).into()
}

<span class="org-keyword">fn</span> <span class="org-function-name">swap2</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>, <span class="org-variable-name">offset</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack).swap(offset, offset + 1);
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">swap</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_expr();
    swap2(env, 0)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">swapdown</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_expr();
    swap2(env, 1)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sink</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack);
    s.swap(0, 2);
    s.swap(0, 1);
    env.pop_expr();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">float</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack);
    s.swap(0, 2);
    s.swap(1, 2);
    env.pop_expr();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">drop</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop();
    env.pop_expr();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i == j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">count</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(i)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i.len() <span class="org-keyword">as</span> <span class="org-type">Int</span>)),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(i)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i.len() <span class="org-keyword">as</span> <span class="org-type">Int</span>)),
        i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, i)),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_string</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_bytes</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_error</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_),
        )))
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_word</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(_) =&gt; <span class="org-keyword">true</span>,
        <span class="org-comment-delimiter">//</span><span class="org-comment">Item::Iterable(Item(_)) =&gt; true,</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO maybe also check if it's an associative that looks like a Def?</span>
        _ =&gt; <span class="org-keyword">false</span>,
    }))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_pipe</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(_))
    )))
}
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_number</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-preprocessor">matches!</span>(i, <span class="org-type">Item</span>::<span class="org-type">Int</span>(_) | <span class="org-type">Item</span>::<span class="org-type">Float</span>(_))))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_list</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-keyword">true</span>.into()),
        i =&gt; <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)
            .map(|s| <span class="org-preprocessor">matches!</span>(s, <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(_)))
            .unwrap_or(<span class="org-keyword">false</span>)
            .into()),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">first</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> (_, i) = s.take();
    <span class="org-type">Ok</span>(i.into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">second</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(l.get(1).cloned().unwrap_or_default())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">last</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(s.into_iter().last().unwrap_or_default())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">loop_</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop());
    <span class="org-keyword">match</span> p {
        <span class="org-type">Ok</span>(<span class="org-keyword">mut</span> p) =&gt; {
            env.pop_expr();
            <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = env.pop();
            <span class="org-keyword">if</span> is_truthy(f) {
                <span class="org-keyword">let</span> <span class="org-variable-name">p2</span> = p.clone();
                <span class="org-keyword">let</span> <span class="org-variable-name">pm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> p);
                pm.push_back(<span class="org-type">Item</span>::from(p2));
                pm.push_back(<span class="org-string">"loop"</span>.into());
                env.append_program(p)
            } <span class="org-keyword">else</span> {
                env
            }
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(<span class="org-type">Item</span>::from(e)),
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">execute</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop();
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i) {
        <span class="org-type">Ok</span>(program) =&gt; {
            env.pop_expr();
            env.append_program(program)
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()),
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">wrap</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">item</span> = env.pop();
    env.pop_expr();
    env.push(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([item]).into()).into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">unwrap</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("unwrapping");</span>
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()) {
        <span class="org-type">Ok</span>(l) =&gt; {
            env.pop_expr();
            <span class="org-keyword">let</span> <span class="org-variable-name">len</span> = l.len();
            <span class="org-keyword">let</span> <span class="org-variable-name">l2</span> = (0..len).map(<span class="org-keyword">move</span> |i| l[i].clone());
            <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> l2 {
                env = env.push(i);
            }
            env
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()),
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dip</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()) {
        <span class="org-type">Ok</span>(program) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">item</span> = env.pop();
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = env.program.make_mut();
            expr.pop_front();
            expr.push_front(<span class="org-string">"unwrap"</span>.into());
            expr.push_front(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([item]).into());
            env.append_program(program)
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()),
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dipdown</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()) {
        <span class="org-type">Ok</span>(program) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">item1</span> = env.pop();
            <span class="org-keyword">let</span> <span class="org-variable-name">item2</span> = env.pop();
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = env.program.make_mut();
            expr.pop_front();
            expr.push_front(<span class="org-string">"unwrap"</span>.into());
            expr.push_front(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([item2, item1]).into());
            env.append_program(program)
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()),
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: handle Nothing case</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">coll</span> = {
        <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
        stack.pop_front()
    };
    <span class="org-keyword">match</span> coll {
        <span class="org-type">Some</span>(i) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
            <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = <span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::try_from(i);
            <span class="org-keyword">match</span> r {
                <span class="org-type">Ok</span>(it) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = it.take();
                    <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                        <span class="org-keyword">let</span> (c, i) = f.<span class="org-keyword">await</span>;
                        env.pop_expr();
                        <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
                        stack.push_front(c.into());
                        stack.push_front(i.unwrap_or_default());
                        env
                    })
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
                    stack.push_front(i2);
                    stack.push_front(e.into());
                    env.into()
                }
            }
        }
        <span class="org-type">None</span> =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
            stack.push_front(<span class="org-type">Error</span>::stack_underflow().into());
            env.into()
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">coll</span> = {
        <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
        stack.pop_front()
    };
    <span class="org-keyword">match</span> coll {
        <span class="org-type">Some</span>(i) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
            <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i);

            <span class="org-keyword">match</span> s {
                <span class="org-type">Ok</span>(it) =&gt; {
                    <span class="org-keyword">let</span> (c, i) = it.pop();
                    env.pop_expr();
                    <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
                    stack.push_front(c.into());
                    stack.push_front(i.unwrap_or_default());
                    env.into()
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
                    stack.push_front(i2);
                    stack.push_front(e.into());
                    env.into()
                }
            }
        }
        <span class="org-type">None</span> =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
            stack.push_front(<span class="org-type">Error</span>::stack_underflow().into());
            env.into()
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_truthy</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">bool</span> {
    <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i).map_or(<span class="org-keyword">true</span>, |s| !s.is_empty())
}

<span class="org-comment-delimiter">// </span><span class="org-comment">fn boolean_value(b: bool) -&gt; Item {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">if b {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">"true".into()</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">} else {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">coll::NOTHING</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">branch</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> (
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()),
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()),
    ) {
        (<span class="org-type">Ok</span>(false_branch), <span class="org-type">Ok</span>(true_branch)) =&gt; {
            env.pop_expr();
            <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = env.pop();

            env.append_program(<span class="org-keyword">if</span> is_truthy(b) {
                true_branch
            } <span class="org-keyword">else</span> {
                false_branch
            })
        }
        (<span class="org-type">Err</span>(e), _) =&gt; env.push(e.into()),
        (_, <span class="org-type">Err</span>(e)) =&gt; env.push(e.into()),
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">step</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">it</span> = <span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::try_from(env.pop()).unwrap();
    <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> (it, <span class="org-type">Some</span>(litem)) = it.take().<span class="org-keyword">await</span> {
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = env.program.make_mut();
            <span class="org-comment-delimiter">// </span><span class="org-comment">prepare the next iteration, even if the iterator is now</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">empty. step is still the next instruction.</span>
            expr.push_front(p.clone().into());
            expr.push_front(it.into());
            expr.push_front(<span class="org-string">"execute"</span>.into());

            env.push(litem).push(p.into())
        } <span class="org-keyword">else</span> {
            env.pop_expr();
            env
        }
    })
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">range</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">stepby</span> = <span class="org-type">Int</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">to</span> = <span class="org-type">Int</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">from</span> = <span class="org-type">Int</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> =
        env.push(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter((from..to).step_by(stepby <span class="org-keyword">as</span> <span class="org-type">usize</span>).map(<span class="org-type">Item</span>::<span class="org-type">Int</span>)).into());
    env.pop_expr();
    env.into()
}

<span class="org-comment-delimiter">// </span><span class="org-comment">(effect [rec2 rec1 then pred]</span>
<span class="org-comment-delimiter">//                   </span><span class="org-comment">['[if]</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">[(concat rec1</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">[[pred then rec1 rec2 'recur]] rec2)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">then pred]])</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">recur</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">rec2</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">rec1</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">then</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">pred</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    env.pop_expr();
    env = env.push_expr(<span class="org-string">"if"</span>.into());
    <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([
        <span class="org-type">Item</span>::from(pred.clone()),
        then.clone().into(),
        rec1.clone().into(),
        rec2.clone().into(),
        <span class="org-string">"recur"</span>.into(),
    ])
    .into();
    <span class="org-comment-delimiter">// </span><span class="org-comment">I think i did this right - used to create a new list and extend</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">it with rec1, then push r, then extend again with rec2. now</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">start with rec1 (copied on write), then push r, then extend</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">with rec2.  That should be equivalent.</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">rm</span> = rec1.make_mut();
    rm.push_back(r);
    rm.extend(rec2.make_mut().drain(..));
    <span class="org-comment-delimiter">//</span><span class="org-comment">env.pop_expr();</span>
    env.push(pred.into())
        .push(then.into())
        .push(rec1.into())
        .into()
}

<span class="org-comment-delimiter">//</span><span class="org-comment">(fn [{[l &amp; others] 'stack :as env}]</span>
<span class="org-comment-delimiter">//            </span><span class="org-comment">(assoc env 'stack (apply list (vec others) l)))</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">evert</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-constant">mem</span>::swap(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
    env.pop_expr();
    env.push(l.into()).into()
}

<span class="org-keyword">fn</span> <span class="org-function-name">assoc_in</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-rust-ampersand">&amp;</span>[<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>], <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">if</span> <span class="org-keyword">let</span> [k, ks @ ..] = ks {
        <span class="org-keyword">if</span> ks.is_empty() {
            <span class="org-keyword">match</span> (i, k) {
                (
                    <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">vector set by index</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
                    <span class="org-keyword">let</span> <span class="org-variable-name">idx</span> = *k <span class="org-keyword">as</span> <span class="org-type">usize</span>;
                    <span class="org-comment-delimiter">// </span><span class="org-comment">extend the size of the vector to be big enough to set</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">the given index, pad with 'nothing' values.</span>
                    <span class="org-keyword">if</span> lm.len() &lt;= idx {
                        lm.resize(idx + 1, <span class="org-type">NOTHING</span>);
                    }
                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = v;
                    <span class="org-type">Ok</span>(l.into())
                }
                (
                    <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">vector set by index</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
                    <span class="org-keyword">let</span> <span class="org-variable-name">idx</span> = *k <span class="org-keyword">as</span> <span class="org-type">usize</span>;
                    <span class="org-comment-delimiter">// </span><span class="org-comment">extend the size of the vector to be big enough to set</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">the given index, pad with 'nothing' values.</span>
                    <span class="org-keyword">if</span> lm.len() &lt;= idx {
                        lm.resize(idx + 1, <span class="org-type">NOTHING</span>);
                    }
                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = v;
                    <span class="org-type">Ok</span>(l.into())
                }
                (i, k) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
                    <span class="org-type">Ok</span>(a.insert(k.clone(), v).0.into())
                }
            }
            <span class="org-comment-delimiter">//</span><span class="org-comment">hm.insert(k.clone(), v);</span>
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">match</span> (i, k) {
                (
                    <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
                    <span class="org-keyword">let</span> <span class="org-variable-name">idx</span> = *k <span class="org-keyword">as</span> <span class="org-type">usize</span>;
                    <span class="org-comment-delimiter">// </span><span class="org-comment">extend the size of the vector to be big enough to set</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">the given index, pad with 'nothing' values.</span>
                    <span class="org-keyword">if</span> lm.len() &lt;= idx {
                        lm.resize(idx + 1, <span class="org-type">NOTHING</span>);
                    }
                    <span class="org-keyword">let</span> <span class="org-variable-name">inner</span> = <span class="org-rust-ampersand">&amp;</span>lm[idx];

                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = <span class="org-keyword">if</span> <span class="org-keyword">let</span> [nextk, ..] = ks {
                        <span class="org-keyword">let</span> <span class="org-variable-name">i</span>: <span class="org-type">Item</span> = <span class="org-keyword">match</span> (inner, nextk) {
                            (
                                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
                            ) =&gt; l.clone().into(),
                            (_, <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_)) =&gt; <span class="org-constant">coll</span>::<span class="org-type">List</span>::new().into(),
                            _ =&gt; <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new().into(),
                        };
                        assoc_in(i, ks, v)<span class="org-rust-question-mark">?</span>
                    } <span class="org-keyword">else</span> {
                        v
                    };

                    <span class="org-comment-delimiter">//</span><span class="org-comment">if the inner value isn't a list, overwrite it</span>
                    <span class="org-type">Ok</span>(l.into())
                }
                (i, k) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">let</span> <span class="org-variable-name">inner</span> = a.get(k).unwrap_or_default().clone();

                    <span class="org-comment-delimiter">// </span><span class="org-comment">if the inner value is a map, recurse. If it's a</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">list and the next key is a number,</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">recurse. Otherwise, overwrite the value with a new map.</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">next_key</span> = ks[0].clone();
                    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-keyword">match</span> (next_key, inner) {
                        (
                            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
                            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                        ) =&gt; l.clone().into(),
                        (
                            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
                            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                        ) =&gt; l.clone().into(),
                        (
                            _,
                            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a))),
                        ) =&gt; a.clone().into(),
                        (
                            _,
                            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a))),
                        ) =&gt; a.clone().into(),
                        _ =&gt; <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new().into(),
                    };
                    <span class="org-type">Ok</span>(a.insert(k.clone(), assoc_in(i, ks, v)<span class="org-rust-question-mark">?</span>).0.into())
                }
            }
        }
    } <span class="org-keyword">else</span> {
        <span class="org-type">Ok</span>(i)
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">unassoc_in</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-rust-ampersand">&amp;</span>[<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>]) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">if</span> <span class="org-keyword">let</span> [k, ks @ ..] = ks {
        <span class="org-keyword">if</span> ks.is_empty() {
            <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(a.remove(k).0.into())
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">match</span> (i, k) {
                (
                    <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = l.make_mut();
                    <span class="org-keyword">let</span> <span class="org-variable-name">old_value</span> = <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(item) = lm.get_mut(*k <span class="org-keyword">as</span> <span class="org-type">usize</span>) {
                        <span class="org-constant">mem</span>::replace(item, <span class="org-type">NOTHING</span>)
                    } <span class="org-keyword">else</span> {
                        <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::short_list(*k)); <span class="org-comment-delimiter">// </span><span class="org-comment">replace with your error</span>
                    };
                    <span class="org-keyword">let</span> <span class="org-variable-name">new_value</span> = unassoc_in(old_value, ks)<span class="org-rust-question-mark">?</span>;
                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = new_value;
                    <span class="org-type">Ok</span>(l.into())
                }
                (a, k) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Associative</span> = a.try_into()<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span> = a.into_iter().collect();
                    <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">res</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Result</span>&lt;_, <span class="org-type">Error</span>&gt;&gt; = <span class="org-type">None</span>;
                    am.entry(k.clone()).and_modify(|v| {
                        <span class="org-keyword">let</span> <span class="org-variable-name">new_value</span> = unassoc_in(v.clone(), ks);
                        res = <span class="org-type">Some</span>(new_value.map(|nv| {
                            *v = nv;
                        }));
                    });
                    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(<span class="org-type">Err</span>(e)) = res {
                        <span class="org-keyword">return</span> <span class="org-type">Err</span>(e);
                    }
                    <span class="org-type">Ok</span>(a.into())
                }
            }
        }
    } <span class="org-keyword">else</span> {
        <span class="org-type">Ok</span>(i)
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">assign</span>(<span class="org-variable-name">m</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-type">Item</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">kit</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(ks)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ksvec</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span>::try_from_iter(kit.inner().into_iter())<span class="org-rust-question-mark">?</span>;
    ksvec.make_mut().make_contiguous();
    <span class="org-keyword">let</span> (ks, _) = ksvec.as_slices();
    assoc_in(m, ks, v)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">unassign</span>(<span class="org-variable-name">m</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">kit</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(ks)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ksvec</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span>::try_from_iter(kit.inner().into_iter())<span class="org-rust-question-mark">?</span>;
    ksvec.make_mut().make_contiguous();
    <span class="org-keyword">let</span> (ks, _) = ksvec.as_slices();
    unassoc_in(m, ks)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">association</span>(<span class="org-variable-name">m</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(m) {
        <span class="org-type">Ok</span>(m) =&gt; <span class="org-type">Ok</span>(m.into()),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(e),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">lookup</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">k</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("lookup {:?} \n {:?}", i, k);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">k</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(k)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">match</span> (i, k) {
        (<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k)) =&gt; {
            <span class="org-type">Ok</span>(l.get(k <span class="org-keyword">as</span> <span class="org-type">usize</span>).cloned().unwrap_or_default())
        }
        (i, k) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">m</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(m.get(<span class="org-rust-ampersand">&amp;</span>k).unwrap_or_default())
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains</span>(<span class="org-variable-name">c</span>: <span class="org-type">Item</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(c)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(s.contains(<span class="org-rust-ampersand">&amp;</span>i).into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">or</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-keyword">if</span> is_truthy(i.clone()) {
        i
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> is_truthy(j.clone()) {
        j
    } <span class="org-keyword">else</span> {
        <span class="org-type">NOTHING</span>
    })
    <span class="org-comment-delimiter">//</span><span class="org-comment">Ok(Item::from(is_truthy(i) || is_truthy(j)))</span>
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">and</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-keyword">if</span> is_truthy(i) &amp;&amp; is_truthy(j.clone()) {
        j
    } <span class="org-keyword">else</span> {
        <span class="org-type">NOTHING</span>
    })
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">not</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(!is_truthy(i)))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_association</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-keyword">true</span>.into()),
        i =&gt; <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)
            .map(|s| <span class="org-preprocessor">matches!</span>(s, <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_)))
            .unwrap_or(<span class="org-keyword">false</span>)
            .into()),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_set</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Ok</span>(<span class="org-keyword">true</span>.into()),
        i =&gt; <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)
            .map(|s| <span class="org-preprocessor">matches!</span>(s, <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Set</span>(_)))
            .unwrap_or(<span class="org-keyword">false</span>)
            .into()),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_odd</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &amp; 1 == 1))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_even</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(i &amp; 1 == 0))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">decide</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">clauses</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">clauses_data</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> clauses);
    <span class="org-keyword">let</span> <span class="org-variable-name">clause</span> = clauses_data.pop_front();

    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(clause) = clause {
        <span class="org-keyword">let</span> <span class="org-variable-name">clause</span>: <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; = clause.try_into();
        <span class="org-keyword">match</span> clause {
            <span class="org-type">Ok</span>(<span class="org-keyword">mut</span> clause) =&gt; {
                <span class="org-keyword">if</span> clause.len() != 2 {
                    env.push(<span class="org-type">Error</span>::list_count(2).into()).into()
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">clause_data</span> = clause.make_mut();
                    <span class="org-keyword">let</span> <span class="org-variable-name">test</span>: <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; = clause_data
                        .pop_front()
                        .ok_or(<span class="org-type">Error</span>::list_count(2))
                        .and_then(|i| i.try_into());
                    <span class="org-keyword">let</span> <span class="org-variable-name">expr</span>: <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; = clause_data
                        .pop_front()
                        .ok_or(<span class="org-type">Error</span>::list_count(2))
                        .and_then(|i| i.try_into());

                    <span class="org-keyword">match</span> (test, expr) {
                        (<span class="org-type">Ok</span>(test), <span class="org-type">Ok</span>(expr)) =&gt; {
                            <span class="org-comment-delimiter">// </span><span class="org-comment">construct if</span>
                            <span class="org-keyword">let</span> <span class="org-variable-name">testp</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-type">Item</span>::from(test), <span class="org-string">"shield"</span>.into()]);
                            <span class="org-keyword">let</span> <span class="org-variable-name">elsep</span> =
                                <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-type">Item</span>::from(clauses), <span class="org-string">"decide"</span>.into()]);
                            <span class="org-keyword">let</span> <span class="org-variable-name">newexpr</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([
                                <span class="org-type">Item</span>::from(testp),
                                expr.into(),
                                elsep.into(),
                                <span class="org-string">"if"</span>.into(),
                            ]);
                            env.pop_expr();
                            env.append_program(newexpr).into()
                        }
                        (<span class="org-type">Err</span>(test), _) =&gt; env.push(test.into()).into(),
                        (_, <span class="org-type">Err</span>(expr)) =&gt; env.push(expr.into()).into(),
                    }
                }
            }
            <span class="org-type">Err</span>(e) =&gt; env.push(e.into()).into(),
        }
    } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">clauses empty, return nothing</span>
        env.pop_expr();
        env.push(<span class="org-type">NOTHING</span>).into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">read</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">String</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">parsed</span> = <span class="org-constant">serialize</span>::parse(s);
    <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = <span class="org-keyword">match</span> parsed {
        <span class="org-type">Ok</span>(l) =&gt; {
            env.pop_expr();
            l.into()
        }
        <span class="org-type">Err</span>(e) =&gt; e.into(),
    };
    env.push(r).into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">emit</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>i)),
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">autoformat</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">String</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">serialize</span>::auto_format(s.as_str(), 20, 80)),
    )))
}

<span class="org-keyword">fn</span> <span class="org-function-name">check_type</span>(<span class="org-variable-name">i</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>, <span class="org-variable-name">w</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">match</span> (w, i) {
        (w, <span class="org-type">Item</span>::<span class="org-type">Nothing</span>)
            <span class="org-keyword">if</span> w == *<span class="org-type">S_DISPENSER</span>
                || w == *<span class="org-type">S_RECEPTACLE</span>
                || w == *<span class="org-type">S_LIST</span>
                || w == *<span class="org-type">S_ASSOC</span>
                || w == *<span class="org-type">S_SIZED</span>
                || w == *<span class="org-type">S_ORDERED</span> =&gt;
        {
            <span class="org-type">Ok</span>(())
        }
        (w, _) <span class="org-keyword">if</span> w == *<span class="org-type">S_ITEM</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(_) | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(_)) <span class="org-keyword">if</span> w == *<span class="org-type">S_DISPENSER</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(_) | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(_)) <span class="org-keyword">if</span> w == *<span class="org-type">S_RECEPTACLE</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Int</span>(_)) <span class="org-keyword">if</span> w == *<span class="org-type">S_INTEGER</span> || w == *<span class="org-type">S_NUMBER</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Float</span>(_)) <span class="org-keyword">if</span> w == *<span class="org-type">S_FLOAT</span> || w == *<span class="org-type">S_NUMBER</span> =&gt; <span class="org-type">Ok</span>(()),
        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: also handle cases where bytes/string is a list</span>
        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_))),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_BYTES</span> || w == *<span class="org-type">S_ORDERED</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_))),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_STRING</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Word</span>(_)) <span class="org-keyword">if</span> w == *<span class="org-type">S_WORD</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(_)),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_PIPE</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Nothing</span>,
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_LIST</span> || w == *<span class="org-type">S_PROGRAM</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_))),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_ASSOC</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_),
            )))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_),
            ))),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_ERROR</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(_)),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_SIZED</span> || w == *<span class="org-type">S_ORDERED</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(_),
            )))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(_),
            ))),
        ) <span class="org-keyword">if</span> w == *<span class="org-type">S_ENVIRONMENT</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, i) =&gt; {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Type check failed! wanted {} got {:?}", w, i);</span>
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-rust-ampersand">&amp;</span>w, i.clone()))
        }
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">check_stack_depth</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>, <span class="org-variable-name">min_depth</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Checking stack has at least {} items", min_depth);</span>
    <span class="org-keyword">if</span> env.stack.len() &lt; min_depth {
        <span class="org-type">Err</span>(<span class="org-type">Error</span>::stack_underflow())
    } <span class="org-keyword">else</span> {
        <span class="org-type">Ok</span>(())
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">check_input_spec</span>(<span class="org-variable-name">spec</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">specs</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span> = spec
        .front()
        .ok_or_else(|| <span class="org-type">Error</span>::expected(<span class="org-string">"specs"</span>, <span class="org-type">Default</span>::default()))
        .and_then(|i| i.clone().try_into())<span class="org-rust-question-mark">?</span>;

    check_stack_depth(env, specs.len())<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">indexes</span> = <span class="org-type">Range</span> {
        <span class="org-variable-name">start</span>: 0,
        <span class="org-variable-name">end</span>: specs.len(),
    };

    indexes.into_iter().try_for_each(|i| {
        <span class="org-keyword">let</span> <span class="org-variable-name">item</span> = env.stack.get(i).unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">spec</span> = specs.get(i).unwrap();

        <span class="org-keyword">match</span> spec {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(named))) =&gt; {
                <span class="org-keyword">match</span> named.get(0).unwrap() {
                    <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; check_type(item, *w),
                    i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"list"</span>, i.clone())),
                }
            }
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; check_type(item, *w),
            <span class="org-comment-delimiter">// </span><span class="org-comment">the type might happen to also be a defined</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">word, like 'association'</span>
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"list"</span>, i.clone())),
        }
    })
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">eval_step</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("{:?}", env);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">next_item</span> = env.program.front();

    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(val) = next_item {
        <span class="org-keyword">match</span> val {
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(word) =&gt; {
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(dfn) = env.dictionary.get(word) {
                    {
                        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(spec) = <span class="org-rust-ampersand">&amp;</span>dfn.spec {
                            <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Err</span>(e) = check_input_spec(spec, <span class="org-rust-ampersand">&amp;</span>env) {
                                env = env.push(e.into());
                                <span class="org-keyword">return</span> env.into();
                            }
                        } <span class="org-keyword">else</span> {
                            <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"No spec for </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">!"</span>, word);
                        }
                        <span class="org-keyword">match</span> <span class="org-rust-ampersand">&amp;</span>dfn.definition {
                            <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(a) =&gt; {
                                <span class="org-comment-delimiter">// </span><span class="org-comment">we can't keep borrowing the env, so</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">we clone the axiom def to release</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">it and then we can pass the env to</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">the axiom def fn. Also, the axiom fn</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">is responsible for popping the</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">instruction off the program, in</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">case of error it needs access to it</span>
                                ((*a).clone())(env)
                            }
                            <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">items</span> = d.clone();
                                env.pop_expr();
                                env.append_program(items).into()
                            }
                        }
                    }
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">w</span> = *word;
                    env.push(<span class="org-type">Error</span>::undefined(w).into()).into()
                }
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(entry),
            ))) =&gt; {
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(spec) = <span class="org-rust-ampersand">&amp;</span>entry.spec {
                    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Err</span>(e) = check_input_spec(spec, <span class="org-rust-ampersand">&amp;</span>env) {
                        env = env.push(e.into());
                        <span class="org-keyword">return</span> env.into();
                    }
                }
                <span class="org-comment-delimiter">//</span><span class="org-comment">let expr = coll::Arc::make_mut(&amp;mut env.program);</span>
                <span class="org-comment-delimiter">//</span><span class="org-comment">let e: dict::Entry = expr.front().clone().unwrap().try_into().unwrap();</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">e</span>: <span class="org-constant">dict</span>::<span class="org-type">Entry</span> = env.program.front().unwrap().clone().try_into().unwrap();
                <span class="org-keyword">match</span> e.definition {
                    <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(builtin) =&gt; (builtin)(env),
                    <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = d.clone();
                        env.pop_expr();
                        env.append_program(d).into()
                    }
                }
            }
            _ =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">not a word, just push onto stack</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop_expr();
                env.push(i).into()
            }
        }
    } <span class="org-keyword">else</span> {
        env.push(<span class="org-type">Error</span>::short_list(1).into()).into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">reverse</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">match</span> s {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l) =&gt; <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(l.inner().into_iter().rev()).into()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; <span class="org-type">Ok</span>(s.chars().rev().collect::&lt;<span class="org-type">String</span>&gt;().into()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; <span class="org-type">Ok</span>(b.into_iter().rev().collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;&gt;().into()),
        s =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"ordered"</span>, s.into())),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">bytes</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s))) =&gt; {
            <span class="org-type">Ok</span>(s.as_bytes().to_vec().into())
        }
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s))) =&gt; {
            <span class="org-type">Ok</span>(s.as_bytes().to_vec().into())
        }
        i =&gt; <span class="org-type">Ok</span>(<span class="org-type">Bytes</span>::from(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>i)).into()),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">string</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
                <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">std</span>::<span class="org-type">str</span>::from_utf8(<span class="org-rust-ampersand">&amp;</span>b).unwrap().to_string()),
            )))
        }
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(
                <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">std</span>::<span class="org-type">str</span>::from_utf8(<span class="org-rust-ampersand">&amp;</span>b).unwrap().to_string()),
            )))
        }
        i =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>i)),
        ))),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">get_error</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Error</span>&gt; {
    env.stack.front().and_then(|i| <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e),
        ))) =&gt; <span class="org-type">Some</span>(e.clone()),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e),
        ))) =&gt; <span class="org-type">Some</span>(e.clone()),
        _ =&gt; <span class="org-type">None</span>,
    })
}

<span class="org-keyword">fn</span> <span class="org-function-name">unwind</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">err</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">w</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span> = &amp;<span class="org-string">"handle"</span>.into();

    <span class="org-keyword">let</span> <span class="org-variable-name">err</span> = <span class="org-keyword">match</span> err {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(<span class="org-keyword">mut</span> e),
        ))) =&gt; {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">next</span> = env.program.front();
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">unwound</span> = <span class="org-type">Vec</span>::&lt;<span class="org-type">Item</span>&gt;::new();
            <span class="org-keyword">while</span> next.is_some() &amp;&amp; next.unwrap() != w {
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop_expr();
                unwound.push(i);
                next = env.program.front();
            }
            <span class="org-keyword">if</span> next.is_some() {
                env.pop_expr();
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">set the is_handled bit</span>
            e.is_handled = <span class="org-keyword">true</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">em</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> e.data);
            em.insert(<span class="org-string">"unwound"</span>.into(), <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(unwound).into());
            e.into()
        }
        i =&gt; i,
    };
    env = env.push(err);
    env
}

<span class="org-keyword">pub</span> <span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">eval</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">loop</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(err) = get_error(<span class="org-rust-ampersand">&amp;</span>env) {
            <span class="org-keyword">if</span> !err.is_handled {
                env = unwind(env); <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: this should be done in eval_step</span>
            };
        }
        <span class="org-keyword">if</span> !env.program.is_empty() {
            env = eval_step(env).<span class="org-keyword">await</span>;
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">break</span>;
        }
    }
    env
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">standard_env</span>(<span class="org-variable-name">program</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt;, <span class="org-variable-name">stack</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt;) -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">prog_expr</span> = <span class="org-keyword">match</span> program {
        <span class="org-type">Some</span>(p) =&gt; <span class="org-type">Stack</span>::from(p),
        _ =&gt; <span class="org-type">Stack</span>::new(),
    };

    <span class="org-keyword">let</span> <span class="org-variable-name">env</span> = <span class="org-type">Environment</span> {
        <span class="org-variable-name">stack</span>: stack.unwrap_or(<span class="org-type">Stack</span>::new()),
        <span class="org-variable-name">program</span>: prog_expr,
        <span class="org-variable-name">dictionary</span>: <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">HashMap</span>::&lt;<span class="org-type">Word</span>, <span class="org-constant">dict</span>::<span class="org-type">Entry</span>&gt;::new()),
    };
    add_standard_dictionary(env)
}

<span class="org-keyword">fn</span> <span class="org-function-name">environment</span>(<span class="org-variable-name">p</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Environment</span>::try_from(p).map(|e| e.into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">eval_step_outer</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">tos</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">inner_env</span> = <span class="org-type">Environment</span>::try_from(tos);

    <span class="org-keyword">match</span> inner_env {
        <span class="org-type">Ok</span>(inner) =&gt; {
            env.pop_expr();
            <span class="org-keyword">if</span> inner.program.is_empty() {
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { env.push(<span class="org-type">NOTHING</span>) })
            } <span class="org-keyword">else</span> {
                <span class="org-type">Box</span>::pin(eval_step(inner).map(|inner_next| env.push(inner_next.into())))
            }
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()).into(),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">evaluate</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">tos</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">inner_env</span> = <span class="org-type">Environment</span>::try_from(tos);
    <span class="org-keyword">match</span> inner_env {
        <span class="org-type">Ok</span>(inner) =&gt; <span class="org-type">Box</span>::pin(eval(inner).map(|inner_done| {
            env.pop_expr();
            env.push(inner_done.into())
        })),
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()).into(),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">identity</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_expr();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dictionary</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = env.dictionary.clone();
    env.pop_expr();
    env.push(d.into()).into()
}

<span class="org-keyword">fn</span> <span class="org-function-name">ceil</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = <span class="org-type">Float</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(f.ceil()))
}

<span class="org-keyword">fn</span> <span class="org-function-name">sqrt</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i.sqrt())),
        <span class="org-type">Item</span>::<span class="org-type">Float</span>(f) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(f.sqrt())),
        i =&gt; number_type_error(i),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">abs</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i.abs())),
        <span class="org-type">Item</span>::<span class="org-type">Float</span>(f) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Float</span>(f.abs())),
        i =&gt; number_type_error(i),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">handle</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(<span class="org-keyword">mut</span> e),
        ))) =&gt; <span class="org-type">Ok</span>({
            e.is_handled = <span class="org-keyword">true</span>;
            e.into()
        }),
        i =&gt; <span class="org-type">Ok</span>(i),
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">fn inscription(env: &amp;mut Environment) -&gt; Result&lt;(Word, dict::Entry), Error&gt; {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let d = env.pop();</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let mut wl = coll::List::try_from(env.pop())?;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let w1 = coll::Arc::make_mut(&amp;mut wl).pop_front();</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let x = w1.ok_or(Error::short_list(1))?;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let w = Word::try_from(x.clone())?;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">Ok((w, dict::Entry::try_from(d)?))</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">pub fn inscribe(mut env: Environment) -&gt; Environment {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let r = inscription(&amp;mut env);</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">match r {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Ok((w, def)) =&gt; {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let d = coll::Arc::make_mut(&amp;mut env.dictionary);</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">d.insert(assoc::KeyItem::Word(w), Item::Entry(def));</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">env</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Err(e) =&gt; env.push(e.into()),</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">make 'yes' a word that doesn't have to be quoted, just pushes</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">itself onto the stack.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">yes</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = env.pop_expr();
    env.push(t).into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">fail</span>(<span class="org-variable-name">e</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">e</span>: <span class="org-type">Error</span> = e.try_into().unwrap();
    e.is_handled = <span class="org-keyword">false</span>;
    <span class="org-type">Err</span>(e)
}

<span class="org-comment-delimiter">// </span><span class="org-comment">fn normalize_dictionary(mut d: dict::Dictionary) -&gt; Result&lt;dict::Dictionary, Error&gt; {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let dm = coll::Arc::make_mut(&amp;mut d);</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">for (k, v) in dm.iter_mut() {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">match v {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::Assoc(a) =&gt; {</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">let aa = a.clone();</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">let (aa, _) = aa.insert("word".into(), Item::try_from(k.clone()).unwrap());</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">*v = Item::Entry(aa.try_into()?)</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::List(l) =&gt; {</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">let a: assoc::Associative = l.clone().try_into()?;</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">let (a, _) = a.insert("word".into(), Item::try_from(k.clone()).unwrap());</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">*v = Item::Entry(a.try_into()?)</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">Item::Entry(_) =&gt; {}</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">_ =&gt; {</span>
<span class="org-comment-delimiter">//                 </span><span class="org-comment">return Err(Error::expected("dictionary"));</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">Ok(d)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">redefine</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>::try_from(env.pop());
    <span class="org-keyword">match</span> d {
        <span class="org-type">Ok</span>(d) =&gt; {
            env.dictionary = d;
            env.pop_expr();
            env
        }
        <span class="org-type">Err</span>(e) =&gt; {
            env = env.push(e.into());
            env
        }
    }
    .into()
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Takes an inner environment from the top of the stack, and spawns a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">tokio task to evaluate that environment.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">animate</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">tos</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">inner_env</span> = <span class="org-type">Environment</span>::try_from(tos);
    <span class="org-keyword">match</span> inner_env {
        <span class="org-type">Ok</span>(inner) =&gt; {
            env.pop_expr();
            <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { eval(inner).<span class="org-keyword">await</span> });
            env.into()
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e.into()).into(),
    }
}
<span class="org-keyword">fn</span> <span class="org-function-name">xor_</span>(<span class="org-variable-name">i</span>: <span class="org-type">Bytes</span>, <span class="org-variable-name">j</span>: <span class="org-type">Bytes</span>) -&gt; <span class="org-type">Bytes</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">len</span> = <span class="org-constant">std</span>::<span class="org-constant">cmp</span>::max(i.len(), j.len());
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">result</span> = <span class="org-type">Vec</span>::with_capacity(len);
    <span class="org-keyword">for</span> (byte_i, byte_j) <span class="org-keyword">in</span> i
        .iter()
        .chain(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::repeat(<span class="org-rust-ampersand">&amp;</span>0).take(len - i.len()))
        .zip(j.iter().chain(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::repeat(<span class="org-rust-ampersand">&amp;</span>0).take(len - j.len())))
    {
        result.push(byte_i ^ byte_j);
    }
    result
}
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">xor</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Int</span>(i), <span class="org-type">Item</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(i ^ j)),
        (
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(j))),
        ) =&gt; <span class="org-type">Ok</span>(xor_(i, j).into()),
        (
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(j))),
        ) =&gt; <span class="org-type">Ok</span>(xor_(i, j).into()),
        (i, j) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"integers"</span>, pair(i, j))),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">inspect</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, i);
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s),
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">timestamps</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_expr();
    env.push(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipes</span>::<span class="org-type">Out</span>::<span class="org-type">Time</span>)))
        .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">standard</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_expr();
    env.push(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(
        <span class="org-constant">pipes</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Standard</span>,
    )))
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">set</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-constant">coll</span>::<span class="org-type">Set</span>::try_from(i).map(|s| <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s))))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">compare</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">ki</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">kj</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">match</span> ki.partial_cmp(<span class="org-rust-ampersand">&amp;</span>kj) {
        <span class="org-type">Some</span>(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Less</span>) =&gt; <span class="org-type">Ok</span>(<span class="org-string">"less"</span>.into()),
        <span class="org-type">Some</span>(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Equal</span>) =&gt; <span class="org-type">Ok</span>(<span class="org-string">"equal"</span>.into()),
        <span class="org-type">Some</span>(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Greater</span>) =&gt; <span class="org-type">Ok</span>(<span class="org-string">"greater"</span>.into()),
        <span class="org-type">None</span> =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"comparable"</span>, pair(ki.into(), kj.into()))),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">as_pair</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;(<span class="org-type">Item</span>, <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>), <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">i</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">im</span> = i.make_mut();
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = im.pop_front().ok_or(<span class="org-type">Error</span>::short_list(1))<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">k</span> = im
        .pop_front()
        .ok_or(<span class="org-type">Error</span>::short_list(2))
        .and_then(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>((j, k))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sort_by_key</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">it</span> = l.inner().into_iter().map(as_pair);
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">it</span> = it.collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;(<span class="org-type">Item</span>, <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>)&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;
    it.sort_unstable_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Less</span>));
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(it.into_iter().map(|(k, _)| k)).into())
}

<span class="org-keyword">fn</span> <span class="org-function-name">slice</span>(<span class="org-variable-name">arr</span>: <span class="org-type">Item</span>, <span class="org-variable-name">start</span>: <span class="org-type">Item</span>, <span class="org-variable-name">end</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">arr</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(arr)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">match</span> arr {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(arr) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">start</span> = <span class="org-type">Int</span>::try_from(start)<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">end</span> = <span class="org-type">Int</span>::try_from(end)<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(arr
                .get(start <span class="org-keyword">as</span> <span class="org-type">usize</span>..end <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .map(|a| a.to_vec())
                .into())
        }
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(arr) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">start</span> = <span class="org-type">Int</span>::try_from(start)<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">end</span> = <span class="org-type">Int</span>::try_from(end)<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(arr
                .get(start <span class="org-keyword">as</span> <span class="org-type">usize</span>..end <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .map(|a| a.to_string())
                .into())
        }
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(arr) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">start</span> = <span class="org-type">Int</span>::try_from(start)<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">end</span> = <span class="org-type">Int</span>::try_from(end)<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">owned_subset</span>: <span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt; = arr
                .iter()
                .skip(start <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .take(end <span class="org-keyword">as</span> <span class="org-type">usize</span> - start <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .cloned()
                .collect();
            <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from(owned_subset).into())
        }
        i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"ordered"</span>, i.into())),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">empty</span>(<span class="org-variable-name">s</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(s)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(s.empty().into())
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org89cf950" class="outline-4">
<h4 id="org89cf950"><span class="section-number-4">1.5.5.</span> Top level execution</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
We'll define the main module which reads input for the kcats
interpreter process, and prints output.
</p>

<p>
We'll also define how to run unit tests.
</p>
<div class='tangle-wrapper' data-tangle='src/main.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">mod</span> <span class="org-constant">axiom</span>;
<span class="org-keyword">mod</span> <span class="org-constant">crypto</span>;
<span class="org-keyword">mod</span> <span class="org-constant">pipes</span>;
<span class="org-keyword">mod</span> <span class="org-constant">serialize</span>;
<span class="org-keyword">mod</span> <span class="org-constant">types</span>;

<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-constant">environment</span>::<span class="org-type">Environment</span>, error};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">io</span>::{<span class="org-keyword">self</span>, <span class="org-type">BufRead</span>, <span class="org-type">Read</span>, <span class="org-type">Write</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;

<span class="org-keyword">fn</span> <span class="org-function-name">print_result</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) {
    <span class="org-keyword">if</span> env.program.is_empty() {
        <span class="org-rust-builtin-formatting-macro">println!</span>(
            <span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
            <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80)
        );
    } <span class="org-keyword">else</span> {
        <span class="org-rust-builtin-formatting-macro">println!</span>(
            <span class="org-string">"stack: </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">\nprogram: </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
            <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80),
            <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.program).as_str(), 20, 80)
        )
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">get_stdin</span>() -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">for</span> <span class="org-variable-name">line</span> <span class="org-keyword">in</span> <span class="org-constant">io</span>::stdin().lock().lines() {
        buf.push_str(<span class="org-rust-ampersand">&amp;</span>line.unwrap());
        buf.push(<span class="org-string">'\n'</span>);
    }
    buf
}

<span class="org-comment-delimiter">// </span><span class="org-comment">A function that takes a handle to stdin. It reads a length from</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">stdin, then reads that many bytes and returns a string.</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">read_input</span>() -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">String</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">spawn a thread to read from stdin</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Reading input");</span>
    <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">stdin</span> = <span class="org-constant">io</span>::stdin().lock();
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-type">String</span>::new();
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Err</span>(e) = stdin.read_line(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf) {
            <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error reading content length </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
            <span class="org-keyword">return</span> <span class="org-type">None</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">parse an integer from buf</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">read_len</span> = buf.trim();
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Read length {}", read_len);</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">len</span> = read_len.parse::&lt;<span class="org-type">usize</span>&gt;().unwrap_or_default();
        <span class="org-keyword">if</span> len == 0 {
            <span class="org-keyword">return</span> <span class="org-type">None</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">read len bytes from stdin</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-preprocessor">vec!</span>[0; len];
        stdin.read_exact(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf).unwrap();

        <span class="org-comment-delimiter">// </span><span class="org-comment">convert the bytes to a string</span>
        <span class="org-type">Some</span>(<span class="org-type">String</span>::from_utf8(buf).unwrap())
    })
    .<span class="org-keyword">await</span>
    .unwrap()
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">print_with_length</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) {
    <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80);

    <span class="org-comment-delimiter">// </span><span class="org-comment">first print the length of the result</span>
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">\n</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, result.len(), result);
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">print</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) {
    <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80);
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, result);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">a function that takes an env, and an input string. Parses the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">string, if it parses, returns the env with the input added to the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">program. Otherwise returns Error.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">parse_input</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>, <span class="org-variable-name">input</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Environment</span>, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">parsed</span> = <span class="org-constant">serialize</span>::parse(input)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = <span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.program);
    expr.extend(<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> parsed).drain(..));
    <span class="org-type">Ok</span>(env)
}

<span class="org-comment-delimiter">//</span><span class="org-comment">It converts the bytes to a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">string, and then evaluates that string as a kcats program. It then</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">prints the length of the result, and then the result itself.</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">interactive_mode</span>() {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-constant">axiom</span>::standard_env(<span class="org-type">None</span>, <span class="org-type">None</span>);

    <span class="org-keyword">loop</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(program) = read_input().<span class="org-keyword">await</span> {
            <span class="org-keyword">match</span> parse_input(env, program) {
                <span class="org-type">Ok</span>(parsed_env) =&gt; {
                    env = <span class="org-constant">axiom</span>::eval(parsed_env).<span class="org-keyword">await</span>;
                    print_with_length(<span class="org-rust-ampersand">&amp;</span>env).<span class="org-keyword">await</span>;
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
                    <span class="org-keyword">break</span>;
                }
            }
        } <span class="org-keyword">else</span> {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Blank input received, exiting");</span>
            <span class="org-keyword">continue</span>;
        }
    }
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">repl</span>() {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-constant">axiom</span>::standard_env(<span class="org-type">None</span>, <span class="org-type">None</span>);

    <span class="org-keyword">loop</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Print the prompt and flush it to stdout immediately</span>
        <span class="org-rust-builtin-formatting-macro">print!</span>(<span class="org-string">"kcats&gt; "</span>);
        <span class="org-constant">io</span>::stdout().flush().unwrap();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Read a line from stdin</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">line</span> = <span class="org-type">String</span>::new();
        <span class="org-constant">io</span>::stdin().read_line(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> line).unwrap();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the input is empty, if so, continue to the next loop iteration</span>
        <span class="org-keyword">if</span> line.trim().is_empty() {
            <span class="org-keyword">continue</span>;
        }

        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse and evaluate the input, then print the result</span>
        <span class="org-keyword">match</span> parse_input(env, line) {
            <span class="org-type">Ok</span>(parsed_env) =&gt; {
                env = <span class="org-constant">axiom</span>::eval(parsed_env).<span class="org-keyword">await</span>;
                print(<span class="org-rust-ampersand">&amp;</span>env).<span class="org-keyword">await</span>;
            }
            <span class="org-type">Err</span>(e) =&gt; {
                <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
                <span class="org-keyword">break</span>;
            }
        }
    }
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">read_eval_print</span>(<span class="org-variable-name">program</span>: <span class="org-type">String</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">otherwise, read from stdin</span>
    <span class="org-keyword">match</span> parse_input(<span class="org-constant">axiom</span>::standard_env(<span class="org-type">None</span>, <span class="org-type">None</span>), program) {
        <span class="org-type">Ok</span>(env) =&gt; {
            print_result(<span class="org-constant">axiom</span>::eval(env).<span class="org-keyword">await</span>);
        }
        <span class="org-type">Err</span>(e) =&gt; {
            <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error parsing input: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
        }
    }
}

<span class="org-preprocessor">#[tokio::main]</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">read command line options, to look for -i switch</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">args</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-constant">std</span>::<span class="org-constant">env</span>::args().collect();
    <span class="org-comment-delimiter">// </span><span class="org-comment">if args contains "-i", read via handle_stdin</span>
    <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-i"</span>.to_string()) {
        interactive_mode().<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-r"</span>.to_string()) {
        repl().<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-f"</span>.to_string()) {
        <span class="org-keyword">let</span> <span class="org-variable-name">filename</span> = args.get(2).unwrap();
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">file</span> = <span class="org-constant">std</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>::open(filename).unwrap();
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-type">String</span>::new();
        file.read_to_string(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf).unwrap();
        read_eval_print(buf).<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-p"</span>.to_string()) {
        <span class="org-keyword">let</span> <span class="org-variable-name">program</span> = args.get(2).unwrap();
        read_eval_print(program.clone()).<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">otherwise, read from stdin</span>
        read_eval_print(get_stdin()).<span class="org-keyword">await</span>;
    }
}

<span class="org-preprocessor">#[cfg(test)]</span>
<span class="org-keyword">mod</span> <span class="org-constant">tests</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note this useful idiom: importing names from outer (for mod tests) scope.</span>
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::*;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-type">Item</span>, <span class="org-type">Word</span>};
    <span class="org-keyword">use</span> <span class="org-constant">internment</span>::<span class="org-type">Intern</span>;
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">borrow</span>::<span class="org-type">Borrow</span>;
    <span class="org-keyword">use</span> <span class="org-constant">test_case</span>::test_case;

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get_item</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">index</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)
            .ok()
            .and_then(|l| l.get(index).cloned())
    }

    <span class="org-preprocessor">#[tokio::main]</span>
    <span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">test_example</span>(
        <span class="org-keyword">mut</span> <span class="org-variable-name">prog_env</span>: <span class="org-type">Environment</span>,
        <span class="org-variable-name">program</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>,
        <span class="org-variable-name">expected</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>,
    ) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">exp_env</span> = prog_env.clone();
        prog_env = prog_env.append_program(program.clone());
        exp_env = exp_env.append_program(expected.clone());

        <span class="org-keyword">let</span> <span class="org-variable-name">p_fut</span> = <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-constant">axiom</span>::eval(prog_env).<span class="org-keyword">await</span> });

        <span class="org-keyword">let</span> <span class="org-variable-name">exp_fut</span> = <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-constant">axiom</span>::eval(exp_env).<span class="org-keyword">await</span> });
        <span class="org-keyword">let</span> (prog_env, exp_env) = <span class="org-constant">tokio</span>::<span class="org-preprocessor">join!</span>(p_fut, exp_fut);
        <span class="org-keyword">let</span> <span class="org-variable-name">prog_env</span> = prog_env.unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">exp_env</span> = exp_env.unwrap();

        <span class="org-keyword">if</span> prog_env.stack == exp_env.stack {
            <span class="org-rust-builtin-formatting-macro">println!</span>(
                <span class="org-string">"Nice expected </span><span class="org-rust-string-interpolation">{}</span><span class="org-string"> got </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
                <span class="org-constant">serialize</span>::emit_all(exp_env.stack.borrow()),
                <span class="org-constant">serialize</span>::emit_all(prog_env.stack.borrow())
            );
            <span class="org-type">None</span>
        } <span class="org-keyword">else</span> {
            <span class="org-rust-builtin-formatting-macro">println!</span>(
                <span class="org-string">"uh oh expected </span><span class="org-rust-string-interpolation">{}</span><span class="org-string"> got </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
                <span class="org-constant">serialize</span>::emit_all(exp_env.stack.borrow()),
                <span class="org-constant">serialize</span>::emit_all(prog_env.stack.borrow())
            );
            <span class="org-comment-delimiter">// </span><span class="org-comment">println!(</span>
            <span class="org-comment-delimiter">//     </span><span class="org-comment">"Debug: expected {:?} got {:?}",</span>
            <span class="org-comment-delimiter">//     </span><span class="org-comment">exp_env.stack, prog_env.stack</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">);</span>
            <span class="org-type">Some</span>(<span class="org-type">Error</span>::test_assertion(program, expected, prog_env.stack))
        }
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">test_word</span>(<span class="org-variable-name">standard_env</span>: <span class="org-type">Environment</span>, <span class="org-variable-name">w</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Vec</span>&lt;<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(d) = standard_env.dictionary.get(<span class="org-rust-ampersand">&amp;</span>w) {
            d.examples
                .clone()
                .unwrap()
                .iter()
                .filter_map(|ex| {
                    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(get_item(ex.clone(), 0).unwrap());
                    <span class="org-keyword">let</span> <span class="org-variable-name">exp</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(get_item(ex.clone(), 1).unwrap());
                    <span class="org-keyword">match</span> (p, exp) {
                        (<span class="org-type">Ok</span>(p), <span class="org-type">Ok</span>(exp)) =&gt; {
                            test_example(standard_env.clone(), p.clone(), exp.clone())
                        }
                        (<span class="org-type">Err</span>(e), _) =&gt; <span class="org-type">Some</span>(e),
                        (_, <span class="org-type">Err</span>(e)) =&gt; <span class="org-type">Some</span>(e),
                    }
                })
                .collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">Error</span>&gt;&gt;()
        } <span class="org-keyword">else</span> {
            <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Empty!"</span>);
            <span class="org-type">Vec</span>::new()
        }
    }

    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"+"</span><span class="org-preprocessor"> ; </span><span class="org-string">"plus"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"-"</span><span class="org-preprocessor"> ; </span><span class="org-string">"minus"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"="</span><span class="org-preprocessor"> ; </span><span class="org-string">"eq"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&gt;"</span><span class="org-preprocessor"> ; </span><span class="org-string">"gt"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&gt;="</span><span class="org-preprocessor"> ; </span><span class="org-string">"gte"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&lt;"</span><span class="org-preprocessor"> ; </span><span class="org-string">"lt"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&lt;="</span><span class="org-preprocessor"> ; </span><span class="org-string">"lte"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"*"</span><span class="org-preprocessor"> ; </span><span class="org-string">"mult"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"/"</span><span class="org-preprocessor"> ; </span><span class="org-string">"divide"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"abs"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"and"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"any?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_any"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"assign"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"association"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"association?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_association"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"bail"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"both?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_both"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"branch"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"breaker"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"bytes"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"bytes?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_bytes"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"ceil"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"clone"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"collect"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"compare"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"contains?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"contains"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"count"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"cram"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dec"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decide"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decorate"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decorated"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dip"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dipdown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dipdeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dive"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"divedown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"divedeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"drop"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dropper"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"each"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"emit"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"ends?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_ends"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"environment"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"evaluate"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"eval-step"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"even?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_even"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"evert"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"every?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_every"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"execute"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"filter"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"first"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"float"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"fold"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"functional"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"future"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"generate"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"group"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"if"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"inc"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"indexed"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"inject"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"inscribe"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"into"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"join"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"joiner"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"keep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"let"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"lingo"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"list?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_list"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"lookup"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"loop"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"map"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"max"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"min"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"mod"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"not"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"empty?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_empty"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"number?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_number"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"odd?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_odd"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"or"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"pop"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"put"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"prepend"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"primrec"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"range"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"recover"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"recur"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"repeat"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"rest"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"restore"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"retry"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"reverse"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"set"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"set?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_set"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"shield"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"shielddown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"shielddowndown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"sink"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"siphon"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"slice"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"snapshot"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"something?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_something"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"sqrt"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"starts?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_starts"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"step"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"string"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"string?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_string"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"spawn"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"split"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"swap"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"swapdown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"take"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"taker"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"template"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"times"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"type"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"unassign"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"until"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"unwrap"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"update"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"value"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"when"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"while"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"within?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_within"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"word?"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"wrap"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"xor"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"zero?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_zero"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"zip"</span><span class="org-preprocessor">)]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_lexicon</span>(<span class="org-variable-name">word</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) {
        <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = <span class="org-constant">axiom</span>::standard_env(<span class="org-type">None</span>, <span class="org-type">None</span>);

        <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = test_word(e.clone(), <span class="org-type">Intern</span>::new(word.to_string()));
        <span class="org-preprocessor">assert!</span>(r.is_empty(), <span class="org-string">"{:?}"</span>, r);
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">if let (Item::List(program), Item::List(expected)) = (program, expected) {</span>

<span class="org-comment-delimiter">//     </span><span class="org-comment">} else {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Err(Error::from("Example should be a pair"))</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">for ex in d.examples().iter() {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let e = List::try_from(*ex).ok().unwrap();</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();</span>

<span class="org-comment-delimiter">//             </span><span class="org-comment">test_example(axiom::standard_env.clone(), w, p,exp)</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">}.retain(|i| i.is_some()).collect::&lt;Vec&lt;Error&gt;&gt;()</span>
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org41de729" class="outline-4">
<h4 id="org41de729"><span class="section-number-4">1.5.6.</span> Pipes (input/output)</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
Kcats will confine all i/o to pipes. You can put values into pipes and
they emerge elsewhere. Words that act on pipes are the only ones that
can be impure. Everything else is a value.
</p>
</div>
<ol class="org-ol">
<li><a id="org9ff5041"></a>Basic Types<br />
<div class="outline-text-6" id="text-1-5-6-0-1">
<p>
The basic pipe contracts.
</p>
<div class='tangle-wrapper' data-tangle='src/pipes.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">sync</span>::<span class="org-type">RwLock</span>;

<span class="org-keyword">use</span> <span class="org-constant">futures</span>::executor;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">channel</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">fs</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">net</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">standard</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">time</span>;

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">In</span> {
    <span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">fs</span>::<span class="org-type">StaticFile</span>&gt;&gt;),
    <span class="org-type">Socket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">Socket</span>&gt;&gt;),
    <span class="org-type">Handoff</span>(<span class="org-constant">channel</span>::<span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-type">Standard</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">In</span>::<span class="org-type">StaticFile</span>(s1), <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">In</span>::<span class="org-type">Socket</span>(s1), <span class="org-type">In</span>::<span class="org-type">Socket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">In</span>::<span class="org-type">Handoff</span>(h1), <span class="org-type">In</span>::<span class="org-type">Handoff</span>(h2)) =&gt; h1 == h2,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Out</span> {
    <span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">fs</span>::<span class="org-type">StaticFile</span>&gt;&gt;),
    <span class="org-type">Socket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">Socket</span>&gt;&gt;),
    <span class="org-type">ServerSocket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">ServerSocket</span>&gt;&gt;),
    <span class="org-type">Handoff</span>(<span class="org-constant">channel</span>::<span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-type">Timer</span>(<span class="org-constant">channel</span>::<span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-type">Time</span>,
    <span class="org-type">Standard</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(s1), <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Out</span>::<span class="org-type">Socket</span>(s1), <span class="org-type">Out</span>::<span class="org-type">Socket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(s1), <span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h1), <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h2)) =&gt; h1 == h2,
            (<span class="org-type">Out</span>::<span class="org-type">Time</span>, <span class="org-type">Out</span>::<span class="org-type">Time</span>) =&gt; <span class="org-keyword">true</span>,
            (<span class="org-type">Out</span>::<span class="org-type">Standard</span>, <span class="org-type">Out</span>::<span class="org-type">Standard</span>) =&gt; <span class="org-keyword">true</span>,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Tunnel</span> {
    <span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">fs</span>::<span class="org-type">StaticFile</span>&gt;&gt;),
    <span class="org-type">Socket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">Socket</span>&gt;&gt;),
    <span class="org-type">Handoff</span>(<span class="org-constant">channel</span>::<span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-type">Standard</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Tunnel</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(s1), <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s1), <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h1), <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h2)) =&gt; h1 == h2,
            (<span class="org-type">Tunnel</span>::<span class="org-type">Standard</span>, <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span>) =&gt; <span class="org-keyword">true</span>,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Tunnel</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Tunnel</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> t {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(f),
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s) =&gt; <span class="org-type">Out</span>::<span class="org-type">Socket</span>(s),
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h) =&gt; <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-type">Out</span>::<span class="org-type">Standard</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Tunnel</span>&gt; <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Tunnel</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> t {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(f),
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s) =&gt; <span class="org-type">In</span>::<span class="org-type">Socket</span>(s),
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h) =&gt; <span class="org-type">In</span>::<span class="org-type">Handoff</span>(h),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-type">In</span>::<span class="org-type">Standard</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">In</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">In</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">In</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.put(i)), <span class="org-comment-delimiter">//</span><span class="org-comment">_ =&gt; Err(Error::expected("foo")),</span>
            <span class="org-type">In</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::put(i),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Tunnel</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.put(i)),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::put(i),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.take()),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::take(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Out</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Out</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.take()),
            <span class="org-type">Out</span>::<span class="org-type">Timer</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">t</span>) =&gt; <span class="org-type">Box</span>::pin(t.take()),
            <span class="org-type">Out</span>::<span class="org-type">Time</span> =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">time</span>::take()),
            <span class="org-type">Out</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::take(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">In</span>::<span class="org-type">Socket</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">In</span>::<span class="org-type">Handoff</span>(h) =&gt; h.representation(),
            <span class="org-type">In</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::representation(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() })
            }
            <span class="org-type">Out</span>::<span class="org-type">Socket</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(f) =&gt; {
                <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() })
            }
            <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h) =&gt; h.representation(),
            <span class="org-type">Out</span>::<span class="org-type">Timer</span>(t) =&gt; t.representation(),
            <span class="org-type">Out</span>::<span class="org-type">Time</span> =&gt; <span class="org-constant">time</span>::representation(),
            <span class="org-type">Out</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::representation(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Tunnel</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h) =&gt; h.representation(),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::representation(),
        }
    }
}
<span class="org-comment-delimiter">/* </span><span class="org-comment">Pipes can be "closed", from either end to signal that either the</span>
<span class="org-comment"> * putter or taker has gone away. Sometimes the type of pipe</span>
<span class="org-comment"> * may not really support this concept but an implementation is</span>
<span class="org-comment"> * required.  For example, files. When you open a file for writing and</span>
<span class="org-comment"> * then "close" it, that doesn't really do anything. Rust doesn't have</span>
<span class="org-comment"> * an explicit file close. You have to drop the reference to it, which</span>
<span class="org-comment"> * in kcats you can do by popping the pipe off the stack. Rust will</span>
<span class="org-comment"> * clean up automatically, other impls might have to reference count.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * The contract here is as follows:</span>
<span class="org-comment"> * 1. After calling close, put on the pipe returns an error</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * 2. After calling close, take on the pipe will return still-buffered</span>
<span class="org-comment"> * items (if the pipe has a buffer), but once buffer is exhausted it</span>
<span class="org-comment"> * will return error.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * 2. Errors cannot be put into a pipe (the taker can't distinguish</span>
<span class="org-comment"> * between io error and an error value). To work around this, wrap the</span>
<span class="org-comment"> * error value in a list to quote it. Putting error into a pipe will</span>
<span class="org-comment"> * return an io error.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * 3. Once closed pipes cannot be ever be put into again. closed? will always</span>
<span class="org-comment"> * return true thereafter.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * One use case that has to be handled specially is a file we've fully</span>
<span class="org-comment"> * read but later someone else might write more bytes to the end. Does</span>
<span class="org-comment"> * the pipe close when we reach EOF? I think we might need to support</span>
<span class="org-comment"> * both types (a type that closes when hitting eof and one that</span>
<span class="org-comment"> * doesn't). The former is the "normal" use case, which will be the</span>
<span class="org-comment"> * default.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * These two types are basically static vs dynamic content. Either all</span>
<span class="org-comment"> * the content is known now, or it isn't.</span>
<span class="org-comment"> *</span>
<span class="org-comment">*/</span>

<span class="org-keyword">fn</span> <span class="org-function-name">closed_error</span>(<span class="org-variable-name">on_take</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Error</span> {
    <span class="org-type">Error</span>::create(
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([
            <span class="org-type">Item</span>::from(<span class="org-string">"close"</span>),
            <span class="org-keyword">if</span> on_take { <span class="org-string">"take"</span> } <span class="org-keyword">else</span> { <span class="org-string">"put"</span> }.into(),
        ]),
        <span class="org-string">"attempt to use closed pipe"</span>,
        <span class="org-type">None</span>,
    )
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Tunnel</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Tunnel</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Out</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Out</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(t))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">In</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">In</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(t))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(i)) =&gt; <span class="org-type">Ok</span>(i),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pipe"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o)) =&gt; <span class="org-type">Ok</span>(o),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pipe"</span>, i)),
        }
    }
}
</pre>
</div></div>
</div>
</li>
<li><a id="orge50ad31"></a>Files<br />
<div class="outline-text-6" id="text-1-5-6-0-2">
<p>
How to interact with files on disk
</p>
<div class='tangle-wrapper' data-tangle='src/pipes/fs.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">pin</span>::<span class="org-type">Pin</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">io</span>::{<span class="org-type">AsyncReadExt</span>, <span class="org-type">AsyncWriteExt</span>};
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">sync</span>::<span class="org-type">RwLock</span>;

<span class="org-keyword">use</span> <span class="org-keyword">super</span>::closed_error;

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">file</span>: <span class="org-type">Option</span>&lt;<span class="org-type">File</span>&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">path</span>: <span class="org-type">String</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the 'file' fields of both structs are the same by reference</span>
        <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.file, <span class="org-rust-ampersand">&amp;</span>other.file)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
        <span class="org-variable-name">i</span>: <span class="org-type">Item</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span>.file.as_mut() {
            <span class="org-type">Some</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = <span class="org-type">Bytes</span>::try_from(i);

                <span class="org-keyword">match</span> b {
                    <span class="org-type">Ok</span>(bs) =&gt; <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write_all(<span class="org-rust-ampersand">&amp;</span>bs).<span class="org-keyword">await</span>.map_err(|e| e.into()) }),
                    <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
                }
            }
            <span class="org-type">None</span> =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(closed_error(<span class="org-keyword">false</span>)))),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span>.file.as_mut() {
            <span class="org-type">Some</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">bs</span> = [0<span class="org-type">u8</span>; 1024];
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">ct</span> = f.read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> bs).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">if</span> ct == 0 {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">EOF, no more takes since it's static</span>
                        <span class="org-type">Ok</span>(<span class="org-type">None</span>)
                    } <span class="org-keyword">else</span> {
                        <span class="org-type">Ok</span>(<span class="org-type">Some</span>(bs[0..ct].to_vec().into()))
                    }
                })
            }
            <span class="org-type">None</span> =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(closed_error(<span class="org-keyword">false</span>)))),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"tunnel"</span>.into()),
            (
                <span class="org-string">"values"</span>.into(),
                <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([(<span class="org-string">"type"</span>.into(), <span class="org-string">"bytes"</span>.into())]).into(),
            ),
            (
                <span class="org-string">"to"</span>.into(),
                <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([(<span class="org-string">"file"</span>.into(), <span class="org-keyword">self</span>.path.clone().into())]).into(),
            ),
        ])
        .into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">file_in</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">path</span> = <span class="org-type">String</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = <span class="org-constant">std</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>::options()
        .read(<span class="org-keyword">true</span>)
        .write(<span class="org-keyword">true</span>)
        .create_new(<span class="org-keyword">true</span>)
        .open(path.clone())<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">In</span>::<span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">StaticFile</span> {
        <span class="org-variable-name">file</span>: <span class="org-type">Some</span>(<span class="org-type">File</span>::from_std(file)),
        path,
    })))
    .into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">file_out</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">path</span> = <span class="org-type">String</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = <span class="org-constant">std</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>::open(path.clone())<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">StaticFile</span> {
        <span class="org-variable-name">file</span>: <span class="org-type">Some</span>(<span class="org-type">File</span>::from_std(file)),
        path,
    })))
    .into())
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">StaticFile</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">f</span>: <span class="org-type">StaticFile</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">super</span>::<span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(f))).into()
    }
}
</pre>
</div></div>
</div>
</li>
<li><a id="org49e248a"></a>Network<br />
<div class="outline-text-6" id="text-1-5-6-0-3">
<p>
How to interact with the network (TCP/IP sockets)
</p>
<div class='tangle-wrapper' data-tangle='src/pipes/net.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, wrap, <span class="org-type">Int</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">futures</span>::<span class="org-constant">future</span>::<span class="org-type">FutureExt</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::{<span class="org-keyword">self</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">net</span>::{<span class="org-type">Ipv4Addr</span>, <span class="org-type">SocketAddrV4</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">pin</span>::<span class="org-type">Pin</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-type">str</span>::<span class="org-type">FromStr</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">io</span>::{<span class="org-type">AsyncReadExt</span>, <span class="org-type">AsyncWriteExt</span>};
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">net</span>::{<span class="org-type">TcpListener</span>, <span class="org-type">TcpStream</span>};
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">sync</span>::<span class="org-type">RwLock</span>;

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">socket</span>: <span class="org-type">TcpStream</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">addr</span>: (<span class="org-type">String</span>, <span class="org-type">u16</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the 'socket' fields of both structs are the same by reference</span>
        <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.socket, <span class="org-rust-ampersand">&amp;</span>other.socket)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
        <span class="org-variable-name">i</span>: <span class="org-type">Item</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Putting </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, i);
        <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = <span class="org-constant">types</span>::<span class="org-type">Bytes</span>::try_from(i);
        <span class="org-keyword">match</span> b {
            <span class="org-type">Ok</span>(bs) =&gt; {
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-keyword">self</span>.socket.write_all(<span class="org-rust-ampersand">&amp;</span>bs).<span class="org-keyword">await</span>.map_err(|e| e.into()) })
            }
            <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">bs</span> = [0<span class="org-type">u8</span>; 1024];
        <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
            <span class="org-keyword">let</span> <span class="org-variable-name">n</span> = <span class="org-keyword">self</span>.socket.read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> bs).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">if</span> n == 0 {
                <span class="org-type">Ok</span>(<span class="org-type">None</span>)
            } <span class="org-keyword">else</span> {
                <span class="org-type">Ok</span>(<span class="org-type">Some</span>(bs[..n].to_vec().into()))
            }
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"tunnel"</span>.into()),
            (<span class="org-string">"realm"</span>.into(), <span class="org-string">"tcp"</span>.into()),
            (<span class="org-string">"address"</span>.into(), <span class="org-keyword">self</span>.addr.0.to_string().into()),
            (<span class="org-string">"port"</span>.into(), <span class="org-keyword">self</span>.addr.1.to_string().into()),
        ])
        .into()
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Server sockets</span>
<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">socket</span>: <span class="org-type">TcpListener</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the 'socket' fields of both structs are the same by reference</span>
        <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.socket, <span class="org-rust-ampersand">&amp;</span>other.socket)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
            <span class="org-keyword">let</span> (socket, addr) = <span class="org-keyword">self</span>.socket.accept().<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;

            <span class="org-type">Ok</span>(<span class="org-type">Some</span>(
                <span class="org-keyword">super</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">Socket</span> {
                    socket,
                    <span class="org-variable-name">addr</span>: (addr.ip().to_string(), addr.port()),
                })))
                .into(),
            ))
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"pipe"</span>.into()),
            (
                <span class="org-string">"serversocket"</span>.into(),
                <span class="org-string">"todo: fix serversocket local addr async issue"</span>.into(), <span class="org-comment-delimiter">//</span><span class="org-comment">Item::String(self.socket.lock().await.local_addr().unwrap().to_string()),</span>
            ),
        ])
        .into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">socket_addr</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">SocketAddrV4</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"socket: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string"> </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, i, j);
    <span class="org-keyword">let</span> <span class="org-variable-name">addr</span> = <span class="org-type">Ipv4Addr</span>::from_str(<span class="org-type">String</span>::try_from(j)<span class="org-rust-question-mark">?</span>.as_str())<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">port</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span> <span class="org-keyword">as</span> <span class="org-type">u16</span>;
    <span class="org-type">Ok</span>(<span class="org-type">SocketAddrV4</span>::new(addr, port))
}

<span class="org-keyword">fn</span> <span class="org-function-name">host_addr</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;(<span class="org-type">String</span>, <span class="org-type">u16</span>), <span class="org-type">Error</span>&gt; {
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"socket: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string"> </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, i, j);
    <span class="org-keyword">let</span> <span class="org-variable-name">addr</span> = <span class="org-type">String</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">port</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span> <span class="org-keyword">as</span> <span class="org-type">u16</span>;
    <span class="org-type">Ok</span>((addr, port))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">server_socket</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">ItemResult</span>&gt; {
    <span class="org-keyword">match</span> socket_addr(i, j) {
        <span class="org-type">Ok</span>(addr) =&gt; {
            <span class="org-type">Box</span>::pin(<span class="org-type">TcpListener</span>::bind(addr).map(|l| {
                <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">ServerSocket</span> {
                    <span class="org-variable-name">socket</span>: l.unwrap(),
                })))
                .into())
            }))
        }
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">socket</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">ItemResult</span>&gt; {
    <span class="org-keyword">match</span> host_addr(i, j) {
        <span class="org-type">Ok</span>(addr) =&gt; <span class="org-type">Box</span>::pin(<span class="org-type">TcpStream</span>::connect(addr.clone()).map(<span class="org-keyword">move</span> |s| {
            <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">Socket</span> {
                <span class="org-variable-name">socket</span>: s.unwrap(),
                addr,
            })))
            .into())
        })),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">pub fn server_socket(env: Environment) -&gt; environment::Future {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let addr = env.pop();</span>

<span class="org-comment-delimiter">//     </span><span class="org-comment">let inner_env = Environment::try_from(tos);</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">match inner_env {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Ok(inner) =&gt; Box::pin(eval_step(inner).map(|inner_next| env.push(Item::Env(inner_next)))),</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Err(e) =&gt; env.push(Item::Error(e)).into(),</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">std</span>::<span class="org-constant">net</span>::<span class="org-type">AddrParseError</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">err</span>: <span class="org-constant">std</span>::<span class="org-constant">net</span>::<span class="org-type">AddrParseError</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(wrap(<span class="org-string">"addrparse"</span>.into()), <span class="org-rust-ampersand">&amp;</span>err.to_string(), <span class="org-type">None</span>)
    }
}
</pre>
</div></div>
</div>
</li>
<li><a id="org1a275d0"></a>Time<br />
<div class="outline-text-6" id="text-1-5-6-0-4">
<div class='tangle-wrapper' data-tangle='src/pipes/time.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::{
    future,
    <span class="org-constant">time</span>::{<span class="org-type">SystemTime</span>, <span class="org-type">UNIX_EPOCH</span>},
};

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>() -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = <span class="org-type">SystemTime</span>::now()
        .duration_since(<span class="org-type">UNIX_EPOCH</span>)
        .unwrap()
        .as_millis() <span class="org-keyword">as</span> <span class="org-type">Int</span>;
    <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Ok</span>(<span class="org-type">Some</span>(<span class="org-type">Item</span>::<span class="org-type">Int</span>(t)))))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>() -&gt; <span class="org-type">Item</span> {
    <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
        (<span class="org-string">"type"</span>.into(), <span class="org-string">"out"</span>.into()),
        (<span class="org-string">"from"</span>.into(), <span class="org-string">"systemtime"</span>.into()),
        (
            <span class="org-string">"values"</span>.into(),
            <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
                (<span class="org-string">"type"</span>.into(), <span class="org-string">"integer"</span>.into()),
                (<span class="org-string">"units"</span>.into(), <span class="org-string">"milliseconds"</span>.into()),
            ])
            .into(),
        ),
    ])
    .into()
}
</pre>
</div></div>
</div>
</li>
<li><a id="orgd035f6a"></a>Standard in/out<br />
<div class="outline-text-6" id="text-1-5-6-0-5">
<div class='tangle-wrapper' data-tangle='src/pipes/standard.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, *};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">io</span>::{<span class="org-keyword">self</span>, <span class="org-type">Read</span>, <span class="org-type">Write</span>};

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>() -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = [0<span class="org-type">u8</span>];
    <span class="org-keyword">let</span> <span class="org-variable-name">n</span> = <span class="org-constant">io</span>::stdin().read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf);
    <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = <span class="org-keyword">match</span> n {
        <span class="org-type">Ok</span>(0) =&gt; <span class="org-type">Ok</span>(<span class="org-type">None</span>),
        <span class="org-type">Ok</span>(n) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Some</span>(buf[..n].to_vec().into())),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(e.into()),
    };
    <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(f))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">bs</span> = <span class="org-type">Bytes</span>::try_from(i);
    <span class="org-keyword">match</span> bs {
        <span class="org-type">Ok</span>(bs) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = <span class="org-constant">io</span>::stdout().write(<span class="org-rust-ampersand">&amp;</span>bs);
            <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(f.map_err(|e| e.into()).map(|_| ())))
        }
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>() -&gt; <span class="org-type">Item</span> {
    <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
        (<span class="org-string">"type"</span>.into(), <span class="org-string">"tunnel"</span>.into()),
        (<span class="org-string">"peer"</span>.into(), <span class="org-string">"standard"</span>.into()),
    ])
    .into()
}
</pre>
</div></div>
</div>
</li>
<li><a id="org9d14c41"></a>Channels<br />
<div class="outline-text-6" id="text-1-5-6-0-6">
<p>
Implement the <code>handoff</code> type
</p>
<div class='tangle-wrapper' data-tangle='src/pipes/channel.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::axiom;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::pipes;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::collection <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">environment</span>::<span class="org-type">Environment</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::error;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, <span class="org-type">Int</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">flume</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-constant">atomic</span>::{<span class="org-type">AtomicUsize</span>, <span class="org-type">Ordering</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">task</span>::<span class="org-type">JoinHandle</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">time</span>::{sleep, <span class="org-type">Duration</span>};

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Use Option because we want to be able to drop senders/receivers to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">close the channel</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">pub</span> <span class="org-variable-name">receiver</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Receiver</span>&lt;<span class="org-type">T</span>&gt;&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">sender</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Sender</span>&lt;<span class="org-type">T</span>&gt;&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">bidirectional</span>: <span class="org-type">bool</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">id</span>: <span class="org-type">usize</span>,
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.receiver, <span class="org-rust-ampersand">&amp;</span>other.receiver, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.sender, <span class="org-rust-ampersand">&amp;</span>other.sender) {
            (<span class="org-type">Some</span>(sr), <span class="org-type">Some</span>(or), <span class="org-type">Some</span>(ss), <span class="org-type">Some</span>(os)) =&gt; <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span>sr, <span class="org-rust-ampersand">&amp;</span>or) &amp;&amp; <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span>ss, <span class="org-rust-ampersand">&amp;</span>os),
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">static</span> <span class="org-variable-name">ID</span>: <span class="org-type">AtomicUsize</span> = <span class="org-type">AtomicUsize</span>::new(0);

<span class="org-keyword">impl</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>(<span class="org-variable-name">bidirectional</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">let</span> (sender, receiver) = <span class="org-constant">flume</span>::bounded::&lt;<span class="org-type">Item</span>&gt;(0);
        <span class="org-keyword">let</span> <span class="org-variable-name">id</span> = <span class="org-type">ID</span>.fetch_add(1, <span class="org-type">Ordering</span>::<span class="org-type">Relaxed</span>);
        <span class="org-type">Handoff</span>::&lt;<span class="org-type">Item</span>&gt; {
            <span class="org-variable-name">sender</span>: <span class="org-type">Some</span>(sender),
            <span class="org-variable-name">receiver</span>: <span class="org-type">Some</span>(receiver),
            bidirectional,
            id,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt; {
        <span class="org-comment-delimiter">// </span><span class="org-comment">println!(</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">"Putting into channel: {} into {:?} on {:?}",</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">i.clone(),</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">self,</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">thread::current().id()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">);</span>
        <span class="org-keyword">if</span> !<span class="org-keyword">self</span>.bidirectional {
            <span class="org-keyword">self</span>.close_take()
        };
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(ch) = <span class="org-keyword">self</span>.sender.clone() {
            <span class="org-keyword">if</span> <span class="org-constant">axiom</span>::is_truthy(i.clone()) {
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                    ch.send_async(i)
                        .<span class="org-keyword">await</span>
                        .map_err(|_| <span class="org-constant">pipes</span>::closed_error(<span class="org-keyword">false</span>))
                })
            } <span class="org-keyword">else</span> {
                <span class="org-comment-delimiter">// </span><span class="org-comment">If we're putting 'nothing', that indicates end of</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">input, so we drop the sender.</span>
                <span class="org-keyword">self</span>.close_put();
                <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Ok</span>(())))
            }
        } <span class="org-keyword">else</span> {
            <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(<span class="org-constant">pipes</span>::closed_error(<span class="org-keyword">false</span>))))
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt; {
        <span class="org-comment-delimiter">// </span><span class="org-comment">println!(</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">"Taking from channel: {:?} on {:?}",</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">self,</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">thread::current().id()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">);</span>
        <span class="org-keyword">if</span> !<span class="org-keyword">self</span>.bidirectional {
            <span class="org-keyword">self</span>.close_put();
        }
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(ch) = <span class="org-keyword">self</span>.receiver.clone() {
            <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { ch.recv_async().<span class="org-keyword">await</span>.map(<span class="org-type">Some</span>).or_else(|_| <span class="org-type">Ok</span>(<span class="org-type">None</span>)) })
        } <span class="org-keyword">else</span> {
            <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Ok</span>(<span class="org-type">None</span>)))
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">close_take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.receiver.is_some() {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Dropping receiver");</span>
            <span class="org-keyword">self</span>.receiver = <span class="org-type">None</span>;
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">close_put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.sender.is_some() {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Dropping sender");</span>
            <span class="org-keyword">self</span>.sender = <span class="org-type">None</span>;
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = <span class="org-keyword">match</span> (<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.sender, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.receiver) {
            (<span class="org-type">Some</span>(_), <span class="org-type">Some</span>(_)) =&gt; <span class="org-string">"tunnel"</span>,
            (<span class="org-type">Some</span>(_), <span class="org-type">None</span>) =&gt; <span class="org-string">"in"</span>,
            (<span class="org-type">None</span>, <span class="org-type">Some</span>(_)) =&gt; <span class="org-string">"out"</span>,
            (<span class="org-type">None</span>, <span class="org-type">None</span>) =&gt; <span class="org-string">"closed"</span>,
        };
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), t.into()),
            (<span class="org-string">"handoff"</span>.into(), (<span class="org-keyword">self</span>.id <span class="org-keyword">as</span> <span class="org-type">Int</span>).into()),
        ])
        .into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">handoff</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_expr();
    env.push(<span class="org-constant">pipes</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(<span class="org-type">Handoff</span>::new(<span class="org-keyword">false</span>)).into())
        .into()
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">RecvError</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">error</span>::<span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">_</span>: <span class="org-constant">flume</span>::<span class="org-type">RecvError</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">pipes</span>::closed_error(<span class="org-keyword">false</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">todo fix this</span>
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">SendError</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-variable-name">error</span>::<span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">_</span>: <span class="org-constant">flume</span>::<span class="org-type">SendError</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">pipes</span>::closed_error(<span class="org-keyword">false</span>)
    }
}

<span class="org-keyword">enum</span> <span class="org-type">ChannelOp</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-type">Send</span>(<span class="org-type">Arc</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Sender</span>&lt;<span class="org-type">T</span>&gt;&gt;, <span class="org-type">usize</span>, <span class="org-type">T</span>),
    <span class="org-type">Receive</span>(<span class="org-type">Arc</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Receiver</span>&lt;<span class="org-type">T</span>&gt;&gt;, <span class="org-type">usize</span>),
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Given a list of pipes (channels) on top of stack, use flume's</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">selector to choose the next ready pipe.  A pipe means it's a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">receive, a pipe/item pair means it's a send.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">select</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">original</span> = l.clone();

    <span class="org-comment-delimiter">//</span><span class="org-comment">Create references out of any [pipe item] pairs</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">lr</span> = l
        .inner()
        .into_iter()
        .enumerate()
        .map(<span class="org-keyword">move</span> |(idx, i)| <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipes</span>::<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(p))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(<span class="org-type">Arc</span>::new(p.receiver.unwrap()), idx))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipes</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(<span class="org-type">Arc</span>::new(p.receiver.unwrap()), idx))
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">Handle timeout channels - start the timer and add receive op</span>
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipes</span>::<span class="org-type">Out</span>::<span class="org-type">Timer</span>(t))) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">t</span> = t.clone();
                t.start();
                <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(<span class="org-type">Arc</span>::new(t.receiver.unwrap()), idx))
            }
            i =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i.clone())<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = l.get(0);
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = l.get(1);
                <span class="org-keyword">match</span> (p, i) {
                    (<span class="org-type">Some</span>(p), <span class="org-type">Some</span>(i)) =&gt; <span class="org-keyword">match</span> (p, i) {
                        (<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-constant">pipes</span>::<span class="org-type">In</span>::<span class="org-type">Handoff</span>(p))), i) =&gt; <span class="org-type">Ok</span>(
                            <span class="org-type">ChannelOp</span>::<span class="org-type">Send</span>(<span class="org-type">Arc</span>::new(p.sender.clone().unwrap()), idx, i.clone()),
                        ),
                        (
                            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipes</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))),
                            i,
                        ) =&gt; <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Send</span>(
                            <span class="org-type">Arc</span>::new(p.sender.clone().unwrap()),
                            idx,
                            i.clone(),
                        )),
                        (p, _i) =&gt; <span class="org-type">Err</span>(<span class="org-constant">error</span>::<span class="org-type">Error</span>::expected(<span class="org-string">"handoff"</span>, p.clone())),
                    },
                    _ =&gt; <span class="org-type">Err</span>(<span class="org-constant">error</span>::<span class="org-type">Error</span>::short_list(2)),
                }
            }
        })
        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">ChannelOp</span>&lt;<span class="org-type">Item</span>&gt;&gt;, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;

    <span class="org-keyword">let</span> (res, idx) = {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">selector</span> = <span class="org-constant">flume</span>::<span class="org-type">Selector</span>::new();

        <span class="org-comment-delimiter">// </span><span class="org-comment">loop over the operations and add them to the selector. Each one</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">returns the original index in the list, so we can use that to</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">fetch the original item from the list.</span>
        <span class="org-keyword">for</span> (idx, item) <span class="org-keyword">in</span> lr.iter().enumerate() {
            <span class="org-keyword">let</span> <span class="org-variable-name">idx_clone</span> = idx;
            <span class="org-keyword">match</span> <span class="org-rust-ampersand">&amp;</span>item {
                <span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(r, _) =&gt; {
                    selector = selector.recv(<span class="org-rust-ampersand">&amp;</span>**r, <span class="org-keyword">move</span> |i| {
                        (i.map(<span class="org-type">Some</span>).map_err(<span class="org-constant">error</span>::<span class="org-type">Error</span>::from), idx_clone)
                    });
                }
                <span class="org-type">ChannelOp</span>::<span class="org-type">Send</span>(s, _, i) =&gt; {
                    selector = selector.send(<span class="org-rust-ampersand">&amp;</span>**s, i.clone(), <span class="org-keyword">move</span> |i| {
                        (i.map(|_| <span class="org-type">None</span>).map_err(<span class="org-constant">error</span>::<span class="org-type">Error</span>::from), idx)
                    });
                }
            }
        }

        selector.wait()
    };
    <span class="org-keyword">let</span> <span class="org-variable-name">selected</span> = original.get(idx).unwrap().clone();
    <span class="org-keyword">match</span> res {
        <span class="org-type">Ok</span>(<span class="org-type">Some</span>(i)) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">l</span>: <span class="org-type">Item</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(<span class="org-preprocessor">vec!</span>[selected, i]).into();
            <span class="org-type">Ok</span>(l)
        }
        <span class="org-type">Ok</span>(<span class="org-type">None</span>) =&gt; <span class="org-type">Ok</span>(selected),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(e),
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-constant">error</span>::<span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipes</span>::<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-constant">pipes</span>::<span class="org-type">In</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipes</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipes</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            i =&gt; <span class="org-type">Err</span>(<span class="org-constant">error</span>::<span class="org-type">Error</span>::expected(<span class="org-string">"handoff"</span>, i)),
        }
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">drop the receiver side of the handoff and return the handoff item</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sender</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span> = <span class="org-type">Handoff</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    h.close_take();
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-constant">pipes</span>::<span class="org-type">In</span>::<span class="org-type">Handoff</span>(
        h,
    ))))
}

<span class="org-comment-delimiter">// </span><span class="org-comment">drop the sender side of the handoff and return the handoff item</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">receiver</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span> = <span class="org-type">Handoff</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    h.close_put();
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipes</span>::<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(
        h,
    ))))
}

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Timer</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-variable-name">receiver</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Receiver</span>&lt;<span class="org-type">T</span>&gt;&gt;,
    <span class="org-variable-name">handle</span>: <span class="org-type">Option</span>&lt;<span class="org-type">JoinHandle</span>&lt;()&gt;&gt;,
    <span class="org-variable-name">duration</span>: <span class="org-type">Duration</span>,
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Cloning a timeout makes a new one, clears state</span>
<span class="org-keyword">impl</span> <span class="org-type">Clone</span> <span class="org-keyword">for</span> <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">clone</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Self</span> {
            <span class="org-variable-name">receiver</span>: <span class="org-type">None</span>,
            <span class="org-variable-name">handle</span>: <span class="org-type">None</span>,
            <span class="org-variable-name">duration</span>: <span class="org-keyword">self</span>.duration,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">new</span>(<span class="org-variable-name">duration</span>: <span class="org-type">Duration</span>) -&gt; <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-type">Timer</span> {
            <span class="org-variable-name">receiver</span>: <span class="org-type">None</span>,
            <span class="org-variable-name">handle</span>: <span class="org-type">None</span>,
            duration,
        }
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">start</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.handle.is_none() {
            <span class="org-keyword">let</span> (sender, receiver) = <span class="org-constant">flume</span>::bounded(1);
            <span class="org-keyword">let</span> <span class="org-variable-name">duration</span> = <span class="org-keyword">self</span>.duration;
            <span class="org-keyword">self</span>.receiver = <span class="org-type">Some</span>(receiver);
            <span class="org-keyword">self</span>.handle = <span class="org-type">Some</span>(<span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                sleep(duration).<span class="org-keyword">await</span>;
                <span class="org-comment-delimiter">//</span><span class="org-comment">TODO handle error condition on send</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">_</span> = sender.send(<span class="org-constant">types</span>::<span class="org-type">NOTHING</span>);
            }));
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">self</span>.start();
        <span class="org-keyword">let</span> <span class="org-variable-name">receiver</span> = <span class="org-keyword">self</span>.receiver.clone().unwrap();
        <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Receiving");</span>
            receiver.recv_async().<span class="org-keyword">await</span>.map(<span class="org-type">Some</span>).or_else(|_| <span class="org-type">Ok</span>(<span class="org-type">None</span>))
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipes</span>::<span class="org-type">Out</span>::<span class="org-type">Timer</span>(t)))
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"pipe"</span>.into()),
            (<span class="org-string">"timeout"</span>.into(), (<span class="org-keyword">self</span>.duration.as_millis() <span class="org-keyword">as</span> <span class="org-type">Int</span>).into()),
        ])
        .into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">timer</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">ms</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: check for negative values</span>
    <span class="org-type">Ok</span>(<span class="org-type">Timer</span>::new(<span class="org-type">Duration</span>::from_millis(ms <span class="org-keyword">as</span> <span class="org-type">u64</span>)).into())
}
</pre>
</div></div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orga05c5e9" class="outline-3">
<h3 id="orga05c5e9"><span class="section-number-3">1.6.</span> Issues</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-orgb148d30" class="outline-4">
<h4 id="orgb148d30"><span class="section-number-4">1.6.1.</span> <span class="todo INPROGRESS">INPROGRESS</span> Interactive mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
run with <code>kcats -i</code> for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
</p>
</div>
<div id="outline-container-orga74379c" class="outline-5">
<h5 id="orga74379c"><span class="section-number-5">1.6.1.1.</span> <span class="todo TODO">TODO</span> Only print the changed part of the stack</h5>
</div>
<div id="outline-container-orgbd7b307" class="outline-5">
<h5 id="orgbd7b307"><span class="section-number-5">1.6.1.2.</span> <span class="todo TODO">TODO</span> Emacs keybindings to send common stack ops</h5>
<div class="outline-text-5" id="text-1-6-1-2">
<ul class="org-ul">
<li>swap / swapdown</li>
<li>clear ([] evert drop)</li>
<li>clone</li>
<li>snapshot?</li>
<li>drop</li>
<li>sink / float</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1a73261" class="outline-4">
<h4 id="org1a73261"><span class="section-number-4">1.6.2.</span> <span class="done DONE">DONE</span> Install the lexicon in the proper place</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
Right now it's assumed to be in the src dir, but if we move the binary
it won't be able to find the lexicon file. The build process should be
able to place it in <code>/usr/share/kcats</code> or <code>~/.local/share/kcats</code> or
whatever the proper place is. Will have to look into how cargo
normally does this sort of thing.
</p>
</div>
</div>

<div id="outline-container-org1cc9125" class="outline-4">
<h4 id="org1cc9125"><span class="section-number-4">1.6.3.</span> <span class="done CANCELED">CANCELED</span> Add option to read an alternative lexicon file</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
The builtins can stay inside the binary, but we should have a cmdline
option to start without the usual lexicon. Should probably add a word
'lexicon' to add a parsed object as the lexicon.
</p>
</div>
</div>
<div id="outline-container-org89bb0e1" class="outline-4">
<h4 id="org89bb0e1"><span class="section-number-4">1.6.4.</span> <span class="done DONE">DONE</span> Package the binary for various platforms</h4>
<div class="outline-text-4" id="text-1-6-4">
<p>
Would be nice to build rpms/debs etc so users can skip the nasty build
process.
</p>
</div>
</div>
<div id="outline-container-org17d8a75" class="outline-4">
<h4 id="org17d8a75"><span class="section-number-4">1.6.5.</span> <span class="done DONE">DONE</span> Optimize memory allocation</h4>
<div class="outline-text-4" id="text-1-6-5">
</div>
<div id="outline-container-org55fd328" class="outline-5">
<h5 id="org55fd328"><span class="section-number-5">1.6.5.1.</span> <span class="done DONE">DONE</span> Lists</h5>
<div class="outline-text-5" id="text-1-6-5-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<pre class="example">
b
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc562f0d" class="outline-4">
<h4 id="orgc562f0d"><span class="section-number-4">1.6.6.</span> <span class="done DONE">DONE</span> pack and unpack are not inverse</h4>
<div class="outline-text-4" id="text-1-6-6">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> unpack pack
</pre>
</div>

<pre class="example">

[[2 3 1]]
</pre>


<p>
It should result in [1 2 3], since people would assume unpack just
does the opposite of pack. But it doesn't, it takes items from the
front and pack puts them on the end.
</p>

<p>
Solution: rename to put take
</p>
</div>
</div>
<div id="outline-container-org0b4cbea" class="outline-4">
<h4 id="org0b4cbea"><span class="section-number-4">1.6.7.</span> <span class="done DONE">DONE</span> true and false are not words?</h4>
<div class="outline-text-4" id="text-1-6-7">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> word?
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span>
</pre>
</div>

<p>
If you didn't know <code>true</code> was a boolean you would think it was a
word. In the general sense it is a word. Should it be one technically
as well? I lean towards yes (return true if word or boolean).
</p>

<p>
It's messy because true/false are the only "words" you can put onto
the stack without wrapping.
</p>

<p>
There are several ways to deal with this:
</p>

<ul class="org-ul">
<li>just leave as is (these look like words but don't act like them)</li>

<li>Use something else for boolean values, like 0b 1b or something (ugly, no)</li>

<li>Revert to allowing bare words (that aren't actions) to go onto the
stack unwrapped, so that true/false aren't different</li>
</ul>

<p>
Right now I'm inclined to leave as-is, as it's the least bad
solution. Allowing undefined words to just go onto the stack is going
to mask all kinds of errors and will cause untold headaches.
</p>
</div>
</div>
<div id="outline-container-org33fb40e" class="outline-4">
<h4 id="org33fb40e"><span class="section-number-4">1.6.8.</span> <span class="done DONE">DONE</span> Division by zero panics</h4>
</div>
<div id="outline-container-org6bf1664" class="outline-4">
<h4 id="org6bf1664"><span class="section-number-4">1.6.9.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement pipes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-6-9">
</div>
<div id="outline-container-orgf62bc01" class="outline-5">
<h5 id="orgf62bc01"><span class="section-number-5">1.6.9.1.</span> <span class="done DONE">DONE</span> Write to a file</h5>
<div class="outline-text-5" id="text-1-6-9-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar4"</span><span class="org-kcats-brackets">]]</span> pipe-in

<span class="org-kcats-brackets">[</span><span class="org-string">"hello world!"</span>
 <span class="org-string">"Nice to meet you!"</span>
 <span class="org-string">"My name is kcats"</span><span class="org-kcats-brackets">]</span>

<span class="org-kcats-brackets">[</span><span class="org-string">"\n"</span> <span class="org-function-name">join</span> bytes <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span>

<span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
[[asked [pipe]] [unwound [["Nice to meet you!" "My name is kcats"] ["\n" join bytes put] step]] [type error] [reason "type mismatch"]] [[type pipe] [file "/tmp/bar4"]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar101r7"</span><span class="org-kcats-brackets">]]</span> pipe-in

<span class="org-string">"hello world!"</span>

bytes <span class="org-function-name">put</span>

</pre>
</div>

<pre class="example">
[[type pipe] [file "/tmp/bar101r7"]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar101r7"</span><span class="org-kcats-brackets">]]</span> pipe-out

<span class="org-function-name">take</span>

string

</pre>
</div>

<pre class="example">
"hello world!" [[type pipe] [file "/tmp/bar101r7"]]
</pre>
</div>
</div>

<div id="outline-container-org3203f4f" class="outline-5">
<h5 id="org3203f4f"><span class="section-number-5">1.6.9.2.</span> <span class="done DONE">DONE</span> Read from a file</h5>
<div class="outline-text-5" id="text-1-6-9-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">""</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar2"</span><span class="org-kcats-brackets">]]</span> pipe-out

collect 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
stack: <span class="org-kcats-brackets">[[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar2"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type pipe<span class="org-kcats-brackets">]]</span> <span class="org-string">""</span><span class="org-kcats-brackets">]</span>
program: <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span>closed? not<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span>closed? not<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>collect spec<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
<span class="org-kcats-brackets">[[[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>reason <span class="org-string">"word is not defined"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>fail<span class="org-kcats-brackets">]]]</span>
 <span class="org-string">"Lookup attempted on non association value"</span>
 <span class="org-kcats-brackets">[</span>spec<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[</span>closed? not<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>pipe program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org9b9dee4" class="outline-5">
<h5 id="org9b9dee4"><span class="section-number-5">1.6.9.3.</span> <span class="done DONE">DONE</span> Close a pipe</h5>
<div class="outline-text-5" id="text-1-6-9-3">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/foopytoop"</span><span class="org-kcats-brackets">]]</span> pipe-in <span class="org-string">"foo"</span> bytes <span class="org-function-name">put</span> close <span class="org-string">"bar"</span> bytes <span class="org-function-name">put</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>file <span class="org-string">"/tmp/foopytoop"</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga1fedcb" class="outline-5">
<h5 id="orga1fedcb"><span class="section-number-5">1.6.9.4.</span> <span class="done DONE">DONE</span> Serialize pipes with something sane</h5>
<div class="outline-text-5" id="text-1-6-9-4">
<p>
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
</p>
</div>
</div>
<div id="outline-container-org2e83e9d" class="outline-5">
<h5 id="org2e83e9d"><span class="section-number-5">1.6.9.5.</span> <span class="done DONE">DONE</span> Sockets</h5>
<div class="outline-text-5" id="text-1-6-9-5">
</div>
<ol class="org-ol">
<li><a id="org76c1fd1"></a><span class="done DONE">DONE</span> Server Sockets<br />
<div class="outline-text-6" id="text-1-6-9-5-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type ip-host<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>address <span class="org-string">"127.0.0.1"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>port 11211<span class="org-kcats-brackets">]]</span> pipe-out 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">socket: Int(11211) String(<span class="org-string">"127.0.0.1"</span>)
<span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>serversocket todo: fix serversocket local addr async issue<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"127.0.0.1"</span> 12345 serversocket 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">socket: Int(12345) String(<span class="org-string">"127.0.0.1"</span>)
<span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>serversocket todo: fix serversocket local addr async issue<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type ip-host<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>address <span class="org-string">"127.0.0.1"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>port 11211<span class="org-kcats-brackets">]]</span> pipe-out <span class="org-comment-delimiter">;; </span><span class="org-comment">server socket</span>
<span class="org-function-name">take</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">accept connection by taking a socket out of the pipe</span>
<span class="org-string">"foo\n"</span> bytes <span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">write a message to the socket</span>
<span class="org-function-name">take</span> string <span class="org-comment-delimiter">;; </span><span class="org-comment">get a message from the socket</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">close the socket</span>
 <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">close the server socket</span>
<span class="org-preprocessor">dip</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>asked <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-string">"foo\n"</span> bytes <span class="org-function-name">put</span> <span class="org-function-name">take</span> string <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</li>

<li><a id="org0abeb9d"></a><span class="done DONE">DONE</span> Sockets<br /></li>

<li><a id="org432e09a"></a><span class="todo INPROGRESS">INPROGRESS</span> Assemble is broken when reading files<br />
<div class="outline-text-6" id="text-1-6-9-5-3">
<p>
I think it's because <code>closed?</code> is broken.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">""</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"bar"</span><span class="org-kcats-brackets">]]</span> pipe-out assemble
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">""</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"bar"</span><span class="org-kcats-brackets">]]</span> pipe-out <span class="org-function-name">take</span> <span class="org-builtin">drop</span> <span class="org-function-name">take</span> <span class="org-builtin">drop</span> closed? 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">checking file closed <span class="org-keyword">false</span>
Got 3 bytes
checking file closed <span class="org-keyword">false</span>
Got 0 bytes
Closing!
checking file closed <span class="org-keyword">false</span>
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-string">""</span>
</pre>
</div>

<p>
I see the problem. When we clone the pipe, we also clone the <code>closed</code>
boolean and we shouldn't be doing that. There should only be one copy
of that. The entire struct should be in an Arc&lt;Mutex&gt; and not just the
file field. And when we modify the boolean, we shouldn't 
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3ad48dd" class="outline-5">
<h5 id="org3ad48dd"><span class="section-number-5">1.6.9.6.</span> <span class="done DONE">DONE</span> Convert In/Out traits to enums in pipes modules</h5>
<div class="outline-text-5" id="text-1-6-9-6">
<p>
Enums seem to work well elsewhere, and since pipes are also a closed
set, we can use them here too.
</p>

<p>
I don't think there will ever be user-created pipe types as it would
have to be done in rust and not in kcats.
</p>
</div>
</div>

<div id="outline-container-orgae33089" class="outline-5">
<h5 id="orgae33089"><span class="section-number-5">1.6.9.7.</span> <span class="done DONE">DONE</span> Composable transforms</h5>
<div class="outline-text-5" id="text-1-6-9-7">
<p>
There should be some way to compose transforms in a pipe. For example,
we can have a pipe that when you put bytes in it, it gets written to a
certain file on disk. But what we really want is that we put bytes
into it, and they get compressed with lz4 before being written to
disk.
</p>

<p>
I suppose pump could take an optional transducer-like thing, and <b>those</b>
could be composable. The transformations I'm thinking of generally
aren't going to be i/o, it's pure computation. Actually I guess any
pipe could take an optional transform. Clojure.core.async channels do this.
</p>

<p>
Maybe the first thing to do is implement transducers?
</p>
</div>
<ol class="org-ol">
<li><a id="orgd3d755d"></a><span class="done DONE">DONE</span> Siphon from one pipe to another<br />
<div class="outline-text-6" id="text-1-6-9-7-1">
<p>
A nice primitive would be a word that takes a program (the program
should expect an item on ToS and it should leave a transformed item)
and two pipes, and takes from one pipe, runs the program, and puts the
result back into the 2nd pipe. It should close the output pipe when
the input pipe closes. Should work with generators as input.
</p>

<p>
This should all work ok except for when programs somewhere in the
generator stack need access to items beneath the generator and we
don't know how to get to them.
</p>

<p>
The obvious solution to that is to include the needed values in the
program before giving it to the generator. Then the values will be in
a known place on the stack.
</p>

<p>
This little program will siphon directly from a generator to a
receptacle:
</p>
<div class="org-src-container">
<pre class="src src-kcats">integers 5 taker

<span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">receptacle</span>
<span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">placeholder that gets dropped (next iteration it will hold a</span>
   <span class="org-comment-delimiter">;; </span><span class="org-comment">copy of the last element which is only needed to check if the</span>
   <span class="org-comment-delimiter">;; </span><span class="org-comment">loop continues and can be dropped after)</span>
<span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">stop when generator returns nothing</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the last value</span>
 <span class="org-kcats-brackets">[</span>generate <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
 <span class="org-builtin">sink</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
<span class="org-preprocessor">until</span>
<span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">drop the now-empty dispenser</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>0 1 2 3 4 <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
4
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">integers 5 taker <span class="org-kcats-brackets">[]</span> siphon
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>actual <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>generator<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>siphon<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 5 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
-1
</pre>
</div>

<p>
And since pipes can have generator layers put on top of them, I think we're done. 
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgd740556" class="outline-5">
<h5 id="orgd740556"><span class="section-number-5">1.6.9.8.</span> <span class="done CANCELED">CANCELED</span> Filled pipes</h5>
<div class="outline-text-5" id="text-1-6-9-8">
<p>
Mostly for testing purposes, takes a list and creates a buffered pipe
that offers list items until the list is exhausted and then returns pipe closed errors.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> filled <span class="org-function-name">take</span>
</pre>
</div>

<pre class="example">
1 [[type pipe] [filled todo: id-or-hash here]]
</pre>
</div>
</div>

<div id="outline-container-orga379d86" class="outline-5">
<h5 id="orga379d86"><span class="section-number-5">1.6.9.9.</span> <span class="todo TODO">TODO</span> Object pipes</h5>
<div class="outline-text-5" id="text-1-6-9-9">
<p>
These pipes should send serialized kcats objects and each put/take
should transfer 1 object. Maybe use protocol buffers or similar
</p>

<p>
This could be done using a network pipe, and an assemble function that
pulls byte chunks and builds objects when there are enough bytes for
one object, and puts them into a handoff pipe.
</p>

<p>
This should be possible to do entirely in kcats, similar to how the
interactive mode works. Send a length, then send that number of
bytes. Then the receiving transform can track how many bytes it has
left to receive and the partial encoded item it's got so far. It takes
the next chunk, knocks off that many bytes (if it's more than needed
for that item), and calls <code>read</code>. If it's still not enough for the full
item, append to the partial encoded item and decrease the 'bytes
needed' number.
</p>

<p>
This mechanism of using kcats serialization means we can't send
associations and sets over the wire as-is. We'd have to send them as a
list and convert them at the other end.
</p>

<p>
Let's see if we can make an object serializer that sends the length
first (separated by \n).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> emit bytes
<span class="org-kcats-brackets">[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
string <span class="org-string">"\n"</span> <span class="org-function-name">join</span> bytes
<span class="org-builtin">swap</span> <span class="org-function-name">join</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"NwpbMSAyIDNd"</span>
</pre>
</div>

<p>
That's pretty easy! The trickier part is a deserializer where we don't
know how many bytes we're going to get in a chunk.
</p>

<p>
First we might need a generator that divides into lines.
A generic splitter generator would do most of the work.
</p>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo\nbar\nbaz\n\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-string">"\n"</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">\f</span>
<span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
<span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span> ends? not<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> prime
 <span class="org-builtin">drop</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> ends?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> 
  <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-builtin">swap</span> - <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> slice<span class="org-kcats-brackets">]</span>
 when
 <span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span>
                                                                        ends? not<span class="org-kcats-brackets">]]</span>
                                                                   <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> prime <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> ends?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-builtin">swap</span> - <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> slice<span class="org-kcats-brackets">]</span>
                     when <span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">""</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo\nbar\nbaz\n\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
  <span class="org-string">"\n"</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">\f</span>
 split collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span>
                                                                        ends? not<span class="org-kcats-brackets">]]</span>
                                                                   <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> prime <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> ends?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-builtin">swap</span> - <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> slice<span class="org-kcats-brackets">]</span>
                     when <span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">""</span>
</pre>
</div>

<p>
Ok this works but ultimately what we need is <code>resplit</code> which takes a
list of sized (all the same type presumably) and joins and splits
piece by piece.
</p>

<p>
We could just create something like <code>atomize</code> that takes a generator of
lists, and emits single items.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo\n"</span> <span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> generate <span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"foo\nbar\nbaz\n\n"</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> generate <span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Ok the <code>atomize</code> is still handy but what I'm going to do is implement
splitter, that takes a string and emits fields. Then i can use that
generator <b>within</b> a re-split chunks generator, that keeps partial
content as state.
</p>

<p>
So here's that split gen:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;</span><span class="org-comment">"foo\nbar\nbaz\n\n" [take] "\n"</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">[1 2 3 2 5] [take] [2]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"foo\nbeep"</span> <span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">"\n"</span>
<span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">"foo\nbeep"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">while the state has no separator, pull chunks into it</span>
<span class="org-kcats-brackets">[</span>dump <span class="org-keyword">true</span>
 <span class="org-kcats-brackets">[[[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span>  contains? not<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">state doesn't have sep?</span>
   <span class="org-kcats-brackets">[</span>something?<span class="org-kcats-brackets">]]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">last item still something</span>
  <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> 
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the previous chunk</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">while</span>
 <span class="org-builtin">drop</span> 
 <span class="org-comment-delimiter">;; </span><span class="org-comment">now call the split generator internally</span>
 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">put</span> <span class="org-function-name">reverse</span>
 <span class="org-kcats-brackets">[</span>split <span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> 3 <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span> 
 <span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span> dump

<span class="org-kcats-brackets">]</span>

collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"foo\nbeep"</span> <span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"beep"</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"beep"</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"beepbar"</span> <span class="org-string">"ba"</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"ba"</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"baz"</span> <span class="org-string">"\n"</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"\n"</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">""</span> <span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"beepbar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dump <span class="org-keyword">true</span> <span class="org-kcats-brackets">[[[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span> contains? not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>something?<span class="org-kcats-brackets">]]</span>
                                    <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
                         <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
                          bail<span class="org-kcats-brackets">]</span>
                         <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">put</span> <span class="org-function-name">reverse</span> <span class="org-kcats-brackets">[</span>split <span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> 3
                                                                              <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span>
                         <span class="org-preprocessor">inject</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span> dump<span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org1e3d257" class="outline-5">
<h5 id="org1e3d257"><span class="section-number-5">1.6.9.10.</span> <span class="done DONE">DONE</span> Time pipe</h5>
<div class="outline-text-5" id="text-1-6-9-10">
<p>
Each take from the pipe return the current unix time in ms.  Should be
a "singleton" - probably using Box::leak, so that we can insert a copy
of this pipe whenever we want and it's always a reference to the same
object. Might be an Arc for compatibility even though we don't need to
ref count. (But I suspect we don't need the Arc).
</p>

<div class="org-src-container">
<pre class="src src-kcats">timestamps <span class="org-function-name">take</span>
</pre>
</div>

<pre class="example">
1687273991929 [[from systemtime] [values [[type integer] [units milliseconds]]] [type out]]
</pre>
</div>
</div>

<div id="outline-container-orgd57f272" class="outline-5">
<h5 id="orgd57f272"><span class="section-number-5">1.6.9.11.</span> <span class="done DONE">DONE</span> stdin/stdout pipes</h5>
<div class="outline-text-5" id="text-1-6-9-11">
<p>
Should also be singleton. Should it always be a tunnel or should we
allow separate access to in or out?
</p>

<div class="org-src-container">
<pre class="src src-kcats">standard <span class="org-string">"foo"</span> bytes <span class="org-function-name">put</span>
</pre>
</div>

<pre class="example">
foo[[type tunnel] [peer standard]]
</pre>


<p>
Stdin is not tested, since currently the interpreter reads the program
from stdin. May need to change that (read the program from filesystem
and let the program itself access stdin).
</p>
</div>
</div>
<div id="outline-container-org58c08f1" class="outline-5">
<h5 id="org58c08f1"><span class="section-number-5">1.6.9.12.</span> <span class="done CANCELED">CANCELED</span> Pipe take outcome</h5>
<div class="outline-text-5" id="text-1-6-9-12">
<ul class="org-ul">
<li><p>
State "CANCELED"   from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-09-22 Fri 09:14] </span></span> <br />
I don't think there's any glaring inconsistency here - indefinite (or
i guess I might call them 'unsized') dispensers will dispense <code>nothing</code>
when there's nothing left. That means that when you are using one of
these, <code>nothing</code> is not a valid value you can use in the sequence.
</p>

<p>
That means, for example, that if you wanted to print whether integers
are odd or not, you can't quite do that. You'd need to use pairs (the
original value and true/[] for whether it's odd).
</p>

<p>
Perhaps later we can think about signaling end-of-stream out of
band. One way to do that is to use an unhandled error value that
unwinds the stack, and you have to recover to catch it. But that
introduces a lot of complexity and I think it may be easier to just
work around the fact that you can't use <code>nothing</code> in the data. It's
possible that maybe the complexity in the out-of-band impl could be
abstracted away, so it's worth revisiting later.
</p></li>
</ul>
<p>
There is some inconsistency with what happens when there's nothing
left - empty lists just return nothing on take, but closed pipes
return an error. May need to resolve this inconsistency.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">List</th>
<th scope="col" class="org-left">Handoff</th>
<th scope="col" class="org-left">Socket</th>
<th scope="col" class="org-left">StaticFile</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">take Items</td>
<td class="org-left">Item</td>
<td class="org-left">Item</td>
<td class="org-left">Bytes</td>
<td class="org-left">Bytes</td>
</tr>

<tr>
<td class="org-left">take Past EOF</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
</tr>

<tr>
<td class="org-left">step Past EOF</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org2e1a155" class="outline-4">
<h4 id="org2e1a155"><span class="section-number-4">1.6.10.</span> <span class="done DONE">DONE</span> 'Fail' is not defined</h4>
<div class="outline-text-4" id="text-1-6-10">
<p>
We need to be able to throw our own errors (eg lookup tries to do this)
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 2 <span class="org-kcats-brackets">[</span>1 <span class="org-string">"two"</span> +<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>fail<span class="org-kcats-brackets">]</span> recover 3 4 
</pre>
</div>

<pre class="example">
converting to error: Error([[type error] [asked [number]] [unwound [+]] [reason "type mismatch"]])
[[type error] [asked [number]] [unwound [3 4]] [reason "type mismatch"]] 2 1
</pre>
</div>
</div>

<div id="outline-container-org255b29c" class="outline-4">
<h4 id="org255b29c"><span class="section-number-4">1.6.11.</span> <span class="done DONE">DONE</span> 'dictionary' doesn't allow access to the data inside definitions</h4>
<div class="outline-text-4" id="text-1-6-11">
<p>
The definition is just shown as the word itself and we can't access
spec, definition etc.
</p>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> spec<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]]]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org36d123f" class="outline-4">
<h4 id="org36d123f"><span class="section-number-4">1.6.12.</span> <span class="todo INPROGRESS">INPROGRESS</span> Use a single word for all derivation/conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-6-12">
<p>
Right now there's different words for converting bytes to string
(string) or string to bytes (bytes). Proposing a more composable
mechanism here, where there's a single action word that derives one
data structure from another.
</p>

<p>
Here we use the association shorthand for <code>[[type bytes]]</code>
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> <span class="org-kcats-brackets">[</span>bytes<span class="org-kcats-brackets">]</span> derive
</pre>
</div>

<pre class="example">
No spec for derive!

[[] [bytes] "foo"]
</pre>


<p>
Here's a typical invocation
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> <span class="org-kcats-brackets">[[</span>type bytes<span class="org-kcats-brackets">]]</span> derive
</pre>
</div>

<pre class="example">
No spec for derive!

[[] [[type bytes]] "foo"]
</pre>


<p>
Here's a derivation with two steps: convert string to bytes, then use
the bytes as entropy to generate an AES encryption key.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span>
<span class="org-kcats-brackets">[[</span>bytes<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>type aes-key<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>length 128<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>derive<span class="org-kcats-brackets">]</span>
<span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
No spec for derive!
No spec for derive!

[[] [[type aes-key] [length 128]] [] [bytes] "foo"]
</pre>


<p>
This seems like a pretty straightforward syntax and should eliminate
an explosion of new words that just convert one type to another.
</p>

<p>
The difficulty is how to implement it. A naive way would just make
<code>derive</code> a multimethod and add lots of methods. The problem is the
<code>decide</code> based multimethods aren't really intended to have lots of
methods because it's inefficient - all the conditions are checked
until one is true. In this case, we can just do a straight lookup by
destination type (if we have different methods depending on input
type, THEN we can use <code>decide</code> internally).
</p>

<p>
But maybe even that isn't ideal - we could also lookup by <code>[sourcetype
destinationtype]</code> pairs. However we don't have explicit source
types. We just have a list that may or may not also act as a set or
association.
</p>

<p>
It should be possible to implement the <code>destinationtype</code> based lookup
pretty easily. Make <code>derive</code> a lexicon entry but insert it earlier so
that it will have an actual association object. It'll be refcounted or
possibly even static (if we don't care about leaking these - but that
would fail if we run through many envs in the same process).
</p>

<p>
Actually we can do this in kcats itself but it requires executing
arbitrary code. The lexicon doesn't really do that - it's just a data
file. 
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>derive<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>bytes string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]]</span> association <span class="org-function-name">wrap</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> type <span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">1 [string] =&gt; [number string]</span>
 lookup <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span>definition<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span>
<span class="org-function-name">wrap</span>
inscribe

<span class="org-string">"foo"</span> bytes <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> 
derive 
</pre>
</div>

<pre class="example">
No spec for derive!

stack: [[[reason "type mismatch"] [asked [[[list?] [string?]] [execute] any?]] [type error]] [string]]
program: [lookup execute]
</pre>



<p>
Ok here's the basic impl. Afterward, should change <code>string</code> to
<code>++string</code> to make them non-public, should use <code>[string] derive</code>
instead. The issue here is how do we add new conversions? We could
make the conversions a separate word, like <code>derivations</code>, but that
sticks out as different - it's a data structure and not an action
word.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">add some conversions</span>
derivations <span class="org-kcats-brackets">[[</span>bytes string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]</span> assign
<span class="org-comment-delimiter">;; </span><span class="org-comment">the list of conversions</span>
<span class="org-kcats-brackets">[[[</span>bytes string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]]</span> association

<span class="org-string">"foo"</span> bytes <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span>


<span class="org-comment-delimiter">;; </span><span class="org-comment">determine the current type and look up the conversion</span>
<span class="org-kcats-brackets">[[</span>type<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> 
<span class="org-builtin">swap</span> lookup <span class="org-preprocessor">execute</span>
</pre>
</div>

<pre class="example">

["foo"]
</pre>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>assign spec<span class="org-kcats-brackets">]</span> lookup 
</pre>
</div>

<pre class="example">

[[[type error] [reason "word is not defined"] [asked [fail]]] "Lookup attempted on non association value" [spec] assign]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>a b<span class="org-kcats-brackets">]</span> c<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]]</span> lookup
</pre>
</div>

<pre class="example">

[c]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>string <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>
<pre class="example">

[[foo]]
</pre>


<p>
Experiment with whether we can easily determine the 'from' type so
that we can dispatch on both 'from' and 'to'.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> type
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
<span class="org-kcats-brackets">[[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 1 = <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[[[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>type<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">branch</span> <span class="org-kcats-brackets">[[[[</span><span class="org-function-name">count</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>type<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> +<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[[[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-function-name">unwrap</span> or <span class="org-kcats-brackets">[[[[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>or<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> or<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">recur</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">execute</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> +<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>default<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span>
</pre>
</div>

<pre class="example">

[default]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>bar 12<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span>
<span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>5<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">]</span>
<span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
<span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">sink drop drop</span>
</pre>
</div>

<pre class="example">

[[[bar 12]] [[[foo] lookup] [[bar] lookup] [5] [6]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>bar 12<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[[[</span>foo<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> any?
</pre>
</div>

<pre class="example">

[12 [[bar 12]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 2 or
</pre>
</div>

<pre class="example">

[1]
</pre>


<p>
Now that we have a fairly reliable <code>type</code> implementation, we can
dispatch on both <code>to</code> and <code>from</code> types for <code>derive</code>.
</p>

<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org06bec69" class="outline-4">
<h4 id="org06bec69"><span class="section-number-4">1.6.13.</span> <span class="done DONE">DONE</span> Change boolean operators to retain values</h4>
<div class="outline-text-4" id="text-1-6-13">
<p>
<code>or</code> and <code>and</code> should return the actual value if it is truthy, instead
of <code>true</code>. But neither should ever return <code>[]</code>, but use <code>false</code>
instead.
</p>
<div class="org-src-container">
<pre class="src src-kcats">2 <span class="org-kcats-brackets">[]</span> or
</pre>
</div>

<pre class="example">
2
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 10 inc 1 range <span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
3628800
</pre>


<p>
This does bring up the question of whether the boolean type is really
needed. It may be possible to use <code>[]</code> as <code>false</code> and anything else as
<code>true</code> (<code>1</code> for example, or maybe the bare word <code>true</code> which then
wouldn't carry any other meaning). Or possible use some other word
than <code>true</code>, eg <code>something</code>.
</p>

<p>
Does this make sense when applied to boolean logic?
</p>

<pre class="example" id="org27b2eb6">
something or nothing = something ?
something and something = something ?

"sky is blue" or "moon is made of cheese" = true
</pre>

<p>
I think it doesn't make sense.
</p>

<p>
Maybe yes/no?
</p>

<pre class="example" id="orgae90ff5">
yes or no = yes ?
</pre>
<div class="org-src-container">
<pre class="src src-kcats">5 3 =
</pre>
</div>

<pre class="example">

[[]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">5 <span class="org-kcats-brackets">[[[</span>3 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"three"</span><span class="org-kcats-brackets">]]</span>
                         <span class="org-kcats-brackets">[[</span>5 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"five"</span><span class="org-kcats-brackets">]]</span>
                         <span class="org-kcats-brackets">[[</span>7 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"seven"</span><span class="org-kcats-brackets">]]</span>
                         <span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"something else"</span><span class="org-kcats-brackets">]]]</span>
                      decide
</pre>
</div>

<pre class="example">

["five" 5]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>3 5 7<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> any? <span class="org-keyword">false</span> =
</pre>
</div>

<pre class="example">

stack: [[[reason "word is not defined"] [type error] [asked [false]]] []]
program: [false =]
</pre>
</div>
</div>
<div id="outline-container-orga98b6ae" class="outline-4">
<h4 id="orga98b6ae"><span class="section-number-4">1.6.14.</span> <span class="done DONE">DONE</span> 'recover' is broken</h4>
<div class="outline-text-4" id="text-1-6-14">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 1
 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 2 +<span class="org-kcats-brackets">]</span>
 recover<span class="org-kcats-brackets">]</span>
recover
</pre>
</div>

<pre class="example">

[3]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]</span> recover<span class="org-kcats-brackets">]]]</span> environment advance advance
eval-<span class="org-function-name">step</span>
advance
advance
advance
advance
advance
eval-<span class="org-function-name">step</span>
advance
advance
advance
</pre>
</div>
</div>
</div>

<div id="outline-container-org25632a1" class="outline-4">
<h4 id="org25632a1"><span class="section-number-4">1.6.15.</span> <span class="done DONE">DONE</span> Fix handle in nested env</h4>
<div class="outline-text-4" id="text-1-6-15">
<p>
<code>handle</code> doesn't work properly in a nested environment. That is
because <code>eval</code> has some logic to check for uncaught exceptions, but
the <code>advance</code> self-hosted evaluator doesn't.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 + handle error?
</pre>
</div>

<pre class="example">
Env: [Word(0x5d29b8fb5b00 : "handle"), Entry(Entry { word: 0x5d29b8fc2600 : "error?", examples: None, spec: Some([List([Word(0x5d29b8fb6c00 : "item")]), List([Word(0x5d29b8fb6820 : "boolean")])]), serialize: false, definition: Builtin })]
handle is Word(0x5d29b8fb5b00 : "handle") Word(0x5d29b8fb5b00 : "handle")
expr contains handle? true
Word(0x5d29b8fb5b00 : "handle") vs Word(0x5d29b8fb5b00 : "handle")

[true 1]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">+ handle type
</pre>
</div>

<p>
Looks like the word <code>error?</code> is shadowed - there's a builtin that's
overwritten by a definition that depends on the builtin (via calling
<code>type</code>, which expects the builtin version of <code>error?</code>).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]]</span> environment eval-<span class="org-function-name">step</span> 
</pre>
</div>

<pre class="example">

[[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]]]] [program []]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 +<span class="org-kcats-brackets">]]]</span> environment advance advance advance 
</pre>
</div>

<pre class="example">

[[[stack [[[asked [consume]] [reason "not enough items on stack"] [type error]] 1]] [program [+]]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>+ handle<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]]]</span> environment advance advance advance
</pre>
</div>

<pre class="example">

[[[stack [[[asked [+_handle]] [reason "word is not defined"] [type error]]]] [program [+_handle [[[3]]] unwrap]]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>+ handle<span class="org-kcats-brackets">]]]</span> environment eval-<span class="org-function-name">step</span> eval-<span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
{ stack: [], program: [[[program [+ handle]]] environment eval-step eval-step] }
{ stack: [[[program [+ handle]]]], program: [environment eval-step eval-step] }
{ stack: [[[stack []] [program [+ handle]]]], program: [eval-step eval-step] }
{ stack: [], program: [+ handle] }
{ stack: [[[stack [[[asked [consume]] [type error] [reason "not enough items on stack"]]]] [program [+ handle]]]], program: [eval-step] }
{ stack: [[[asked [consume]] [type error] [reason "not enough items on stack"]]], program: [+ handle] }

[[[stack [[[reason "not enough items on stack"] [type error] [asked [consume]]] [[asked [consume]] [type error] [reason "not enough items on stack"]]]] [program [+ handle]]]]
</pre>


<p>
There is a problem in the design where an error (with no <code>handle</code>) is
supposed to halt execution, but later we want to do things with the
environment (like examine objects etc). For example, if we're
executing a nested env and it has an error, we can't even natively
examine it, because as soon as we retrieve it from the inner env, it
is an unhandled error on ToS and it halts the outer env. This is not
what I intended.
</p>

<p>
A possible solution is to have whatever <code>eval</code> we're using halt but
remove the <code>halt</code> bit (in the current design it's the <code>is_handled</code>
field of the error) on its way out. So that whatever executes next is
presumed to be after some manual intervention has taken place.
</p>

<p>
Also for nested envs we need several words to help deal with errors:
</p>

<ul class="org-ul">
<li>a word that tells whether the env will halt: that there's an error
on ToS with halt bit set, and <code>handle</code> does not appear in the
program. The word can efficiently return <code>false</code> if ToS isn't an
Error.</li>

<li>A word that removes the halt bit - as the last thing to do before
exiting.</li>
</ul>

<p>
So what about the word <code>advance</code> that completely executes a word -
let's say the word errors out and halts. We removed the halt bit first
but how do we know what happened? In <code>eval</code> it's pretty obvious if we
halted on error - the program isn't empty (that's the only other
reason to stop). We could see in <code>advance</code> that the program got
longer, but isn't very obvious in many cases.
</p>

<p>
Another possibility is letting the program unwind until it's empty,
which would also halt execution. That's not ideal because we're giving
up the possibility of manually fixing it and continuing. On the other
hand, real programs are probably not going to have universal error
handlers (eg like java's 'catch Exception e'. In other words, the
<code>recover</code> is often going to examine the error, see that it's not one
that it knows how to deal with, and re-throw it hoping there's a
recovery further down the program that will know what to do. But
there may not be, and the end result is a major unwind of the
program, at least, all the way to the deepest <code>recover</code>. At that
point it's likely too far unwound to do any manual
interventions. We're just not going to know at 'throw time' whether
any of the recoveries can really help. It's possible they'll all look
at the error and pass it on. 
</p>

<p>
But there's no denying that halting when there's no recovery, is
better than unwinding everything - you find out what went wrong <b>and</b>
you get the possibility of continuing. It's just a matter of providing
this feature without making other things more difficult.
</p>

<p>
Maybe another possibility is unwinding the program <b><b>into</b></b> the
error object. In other words, whatever program items we lop off, we
save them in the error object, in a field named, say, <code>unwound</code> or
something like that. Then the runtime can just exit with the error on
ToS, and if the user wants to manually intervene they can copy the
program from that field. This doesn't solve the problem of 'just
examining an error causes unwind' but it saves us from having to
special case unhandlable errors. Perhaps we could have a word called
<code>rewind</code> or something, that restores the program from the error on
ToS and clears the halt bit.
</p>

<p>
I like this idea more and more - it opens up the possibility of
common-lisp's retry, where you can catch an error thrown from deep
within nested code, twiddle the stack a bit and retry the code
again. We already retain the program item that threw the error so
we would still have it to retry. I'm thinking syntax like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 1<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> retry<span class="org-kcats-brackets">]</span> recover
</pre>
</div>

<p>
In this case we try to add, but there's no numbers on the stack. So we
enter the recovery program that finds the env like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[[[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>consume<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[[</span>1 1<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> retry<span class="org-kcats-brackets">]]]]</span>
</pre>
</div>

<p>
So we <code>dip</code> the numbers underneath the error, then calling <code>retry</code> on
an error will extract the <code>unwound</code> field (discarding the rest of the
error) and <code>execute</code> it. So then we end up with <code>1 1 +</code>.
</p>

<p>
Ok i actually implemented this (and I don't think it was difficult)
but i don't know what I did with it. I know it worked quite well and I
wanted to keep it. Need to do it again.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">there needs to be 3 numbers here to add/mult but we forgot!</span>
+ * 1 2 3
handle <span class="org-comment-delimiter">;; </span><span class="org-comment">catch the error here, stack is empty except the error</span>
<span class="org-kcats-brackets">[</span>5 6 7<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">put numbers underneath</span>
retry <span class="org-comment-delimiter">;; </span><span class="org-comment">rerun what failed before</span>
</pre>
</div>

<pre class="example">

[3 2 1 65]
</pre>


<p>
Now put it together using the higher-level <code>recover</code>
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>+ *<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>5 6 7<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> retry<span class="org-kcats-brackets">]</span> recover
</pre>
</div>

<pre class="example">

[65]
</pre>
</div>
</div>

<div id="outline-container-orgf3cb4a6" class="outline-4">
<h4 id="orgf3cb4a6"><span class="section-number-4">1.6.16.</span> <span class="done DONE">DONE</span> Lots of association-like objects that aren't</h4>
<div class="outline-text-4" id="text-1-6-16">
<p>
Environment and Error, for example. We can't just treat it like an
assoc, even though it is. I'm not quite sure how to solve this. I
don't think I can make a trait <b>and</b> make the trait object part of the
Item enum.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">trait</span> <span class="org-type">Foo</span> {};

<span class="org-keyword">struct</span> <span class="org-type">Quux</span> { }

<span class="org-keyword">impl</span> <span class="org-type">Foo</span> <span class="org-keyword">for</span> <span class="org-type">Quux</span> {}

<span class="org-keyword">enum</span> <span class="org-type">Bar</span> { <span class="org-type">Int</span>(<span class="org-type">i32</span>), <span class="org-type">Foo</span>(<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Foo</span>&gt;), <span class="org-type">Quux</span>(<span class="org-type">Quux</span>) }
</pre>
</div>

<p>
Rust doesn't complain if you have an object that can match the enum in
more than one way. I think that's because one is boxed and the other isn't.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">trait</span> <span class="org-type">Foo</span> {};

<span class="org-keyword">struct</span> <span class="org-type">Quux</span> { }

<span class="org-keyword">impl</span> <span class="org-type">Foo</span> <span class="org-keyword">for</span> <span class="org-type">Quux</span> {}

<span class="org-keyword">enum</span> <span class="org-type">Bar</span>&lt;'<span class="org-variable-name">a</span>&gt; { <span class="org-type">Int</span>(<span class="org-type">i32</span>), <span class="org-type">Foo</span>(<span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">dyn</span> <span class="org-type">Foo</span>), <span class="org-type">Quux</span>(<span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-type">Quux</span>) }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>advance definition<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
<span class="org-kcats-brackets">[[[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>&lt;=<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 1 +<span class="org-kcats-brackets">]]]</span> environment eval-<span class="org-function-name">step</span> <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> environment association?
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>fail<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<pre class="example">
[[spec [[string] [*]]] [definition []]]
</pre>
</div>
</div>

<div id="outline-container-orgff4bb5d" class="outline-4">
<h4 id="orgff4bb5d"><span class="section-number-4">1.6.17.</span> <span class="done DONE">DONE</span> scoping of dictionary entries</h4>
<div class="outline-text-4" id="text-1-6-17">
<p>
The original design was to have the dictionary be a single atomic data
structure that code could modify basically at will, with words like
<code>inscribe</code> (to add words) etc.
</p>

<p>
However I think a better design would be something like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>add1 <span class="org-kcats-brackets">[</span>1 +<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>3 add1<span class="org-kcats-brackets">]</span> augment
</pre>
</div>

<p>
Where the word <code>augment</code> takes an association (more specifically, a
dictionary) and overlays that on top of the builtin dictionary. Then
those new words become accessible just as if they were built in, then
the 2nd argument (a program) is executed as usual. After execution,
the learned words are no longer accessible.
</p>

<p>
It would be possible to nest calls to <code>augment</code> (where the program has
its own call to <code>augment</code>).
</p>

<p>
As for implementation, it may be possible to do a kcats-only impl, but
I don't think it's going to perform well. This is going to be the
normal mode of execution. Very few programs will run with only the
builtin words. In fact, it may be a good idea to break up the lexicon
into components - have pipes be a separate library that has to be
loaded with <code>augment</code>.
</p>

<p>
There is some overlap in functionality here, between <code>decide</code> and
<code>augment</code> - both are designed to provide context. Maybe <code>decide</code> provides
context on how a given word (whose overall meaning doesn't change)
applies to a given piece of data. And <code>augment</code> provides completely new
words, or provides a new meaning. Probably it's not going to be common
to replace meanings - maybe for security reasons. For example, when
running untrusted code, you may want to eliminate certain words (like
those that have side effects like writing to disk or the
network). That brings up the possible feature of not just merging new
items into the dictionary but doing arbitrary combinators, where <code>join</code>
is just a common use case. In that case, maybe <code>augment</code> isn't the right
word because you might be actually restricting the dictionary. So we
need a more generic term for "changing the language". Garble? babel?
I like <code>babel</code> - it captures the fact that we're moving from one
language (the set of builtin words) to lots of different languages. I also like <code>lingo</code>.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>square<span class="org-kcats-brackets">]</span> assign<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">operate on the dictionary - add word 'square'</span>
<span class="org-kcats-brackets">[</span>3 square<span class="org-kcats-brackets">]</span>
lingo
</pre>
</div>

<p>
would print 9.
</p>

<p>
The idea here is to have local lingo, possibly down to quite small
pieces of code. I'm thinking on the order of 10 words is probably
enough to have certain words added or changed.
</p>

<p>
Special care will need to be taken, if you want to change the meaning
of the word, but re-use the old meaning as part of the new
meaning. You can't just overwrite the definition with a new one that
contains the word itself, expecting <b>that</b> word to refer to the old
meaning. You'll have to capture the old definition and incorporate
it. <code>update</code> should help.
</p>
</div>
<div id="outline-container-org6c4e2ea" class="outline-5">
<h5 id="org6c4e2ea"><span class="section-number-5">1.6.17.1.</span> What to call this word</h5>
<div class="outline-text-5" id="text-1-6-17-1">
<ul class="org-ul">
<li>learn (but unlearn after?)</li>
<li>specialize</li>
<li>extend</li>
<li>adapt</li>
<li>augment</li>
<li>refine</li>
<li>supplement</li>
<li>babel</li>
<li>lingo &lt;= front runner.</li>
</ul>
</div>
</div>
<div id="outline-container-orgffc2e81" class="outline-5">
<h5 id="orgffc2e81"><span class="section-number-5">1.6.17.2.</span> Implementation</h5>
<div class="outline-text-5" id="text-1-6-17-2">
<p>
It seems viable that we could use the stack to hold dictionary changes.
</p>

<p>
We'd have to retain a copy of the original dictionary to restore later.
</p>

<p>
An axiom word like <code>definitions</code> or something that sets the dictionary
to ToS would help. I think the rest could be pure kcats.
</p>

<p>
it'd be something like:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
          <span class="org-comment-delimiter">; </span><span class="org-comment">[word square]</span>
           <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]</span> assign<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">ops-dict</span>
<span class="org-kcats-brackets">[</span>9 square<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">program-to-run</span>
dictionary <span class="org-comment-delimiter">;; </span><span class="org-comment">fetch the dictionary</span>
<span class="org-builtin">sink</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">p o d</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">p o d d</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n=new-dict p n d</span>
<span class="org-builtin">float</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">d p n</span>
<span class="org-builtin">swapdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">d n p</span>
<span class="org-kcats-brackets">[</span>redefine <span class="org-comment-delimiter">;; </span><span class="org-comment">p</span>
 <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span>
<span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">d</span>
redefine
</pre>
</div>

<pre class="example">
81
</pre>


<p>
A few problems remaining above:
</p>
<ul class="org-ul">
<li class="on"><code>[X]</code> Need to specify the word inside the definition.</li>
<li class="on"><code>[X]</code> Need to explicitly convert the definition to an association.</li>
</ul>

<p>
But I think this proves the concept.
</p>

<p>
Probably want to eventually make a rust implementation.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
          <span class="org-comment-delimiter">; </span><span class="org-comment">[word square]</span>
           <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]</span> assign<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">ops-dict</span>
<span class="org-kcats-brackets">[</span>9 square<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">program-to-run</span>
dictionary <span class="org-comment-delimiter">;; </span><span class="org-comment">fetch the dictionary</span>
<span class="org-builtin">sink</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">p o d</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">p o d d</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n=new-dict p n d</span>
<span class="org-builtin">float</span>
<span class="org-builtin">swapdown</span>
<span class="org-kcats-brackets">[</span>redefine<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> dictionary <span class="org-kcats-brackets">[</span>square<span class="org-kcats-brackets">]</span> lookup

</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
          <span class="org-comment-delimiter">; </span><span class="org-comment">[word square]</span>
           <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]</span> assign<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">ops-dict</span>
<span class="org-kcats-brackets">[</span>9 square<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">program-to-run</span>
lingo 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>square<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
                     <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]</span> assign
<span class="org-kcats-brackets">[</span>square<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<pre class="example">
Warning, failed to insert into dictionary: List([List([Word(0x5dcc4c2878e0 : "definition"), List([Entry(Entry { word: 0x5dcc4c26dea0 : "clone", examples: Some([List([List([Int(1), Int(2), Int(3), Word(0x5dcc4c26dea0 : "clone")]), List([Int(1), Int(2), Int(3), Int(3)])])]), spec: Some([List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])]), List([List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")]), List([Word(0x5dcc4c25ad70 : "item"), Word(0x5dcc4c26d4d0 : "a")])])]), serialize: false, definition: Builtin }), Entry(Entry { word: 0x5dcc4c2579c0 : "*", examples: None, spec: Some([List([Word(0x5dcc4c258ab0 : "number"), Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])]), serialize: false, definition: Builtin })])]), List([Word(0x5dcc4c25a6a0 : "spec"), List([List([Word(0x5dcc4c258ab0 : "number")]), List([Word(0x5dcc4c258ab0 : "number")])])])])
[]
</pre>
</div>
</div>
</div>

<div id="outline-container-org810f478" class="outline-4">
<h4 id="org810f478"><span class="section-number-4">1.6.18.</span> <span class="done DONE">DONE</span> Move environment stuff into own module</h4>
<div class="outline-text-4" id="text-1-6-18">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]]</span> environment 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">{ stack: <span class="org-kcats-brackets">[]</span>, program: <span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]]</span> environment<span class="org-kcats-brackets">]</span> }
{ stack: <span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]]]</span>, program: <span class="org-kcats-brackets">[</span>environment<span class="org-kcats-brackets">]</span> }

<span class="org-kcats-brackets">[[[</span>stack <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 2 +
</pre>
</div>

<pre class="example">

[3]
</pre>
</div>
</div>

<div id="outline-container-orgfa046d5" class="outline-4">
<h4 id="orgfa046d5"><span class="section-number-4">1.6.19.</span> <span class="done DONE">DONE</span> When printing results, don't wrap the stack</h4>
<div class="outline-text-4" id="text-1-6-19">
<p>
Evaling <code>1 1 +</code> should print <code>2</code>, not <code>[2]</code>. We don't have to wrap the
input, so why wrap the output.
</p>
</div>
</div>

<div id="outline-container-org44b63e4" class="outline-4">
<h4 id="org44b63e4"><span class="section-number-4">1.6.20.</span> <span class="done DONE">DONE</span> Update pipes to use enums instead of traits</h4>
<div class="outline-text-4" id="text-1-6-20">
<p>
It's worked out well for everything else, and I don't think anyone
else will be implementing these traits.
</p>

<p>
Looking at this I am not in that big a hurry to change it, with traits
at least I can spread out the impls into different modules. with enums
that'd be awkward.
</p>
</div>
</div>

<div id="outline-container-orge65a45c" class="outline-4">
<h4 id="orge65a45c"><span class="section-number-4">1.6.21.</span> <span class="done CANCELED">CANCELED</span> Recover clears the stack built up in the try program</h4>
<div class="outline-text-4" id="text-1-6-21">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>2 3 <span class="org-string">"four"</span> * +<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> recover
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>* +<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<p>
Apparently this was my design. I am not so sure about it now, that we
have <code>retry</code>. If an error occurs in the middle of a program, what do we
do with the stack? If the recovery is meant to be "try something else
instead of the entire program" then restoring the stack makes
sense. However then that breaks use of <code>retry</code> because the recovery
can't pick up where the program left off.
</p>

<p>
Maybe <code>recover</code> and <code>retry</code> are mutually exclusive.
</p>

<p>
We could also use <code>retry</code> with <code>handle</code>:
</p>

<div class="org-src-container">
<pre class="src src-kcats">2 3 <span class="org-string">"four"</span> * + handle <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 4<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> retry
</pre>
</div>

<pre class="example">
14
</pre>


<p>
To make this work you have to know which item is the potential problem.
</p>

<p>
Specifying alternates seems useful, such that it will keep retrying
until it hits an empty alternates object or the program finishes. Each
time an alternate is tried it is removed from the list.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>2 3 <span class="org-kcats-brackets">[</span><span class="org-string">"four"</span> 4<span class="org-kcats-brackets">]</span> alternates * +<span class="org-kcats-brackets">]</span> retry 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5cd7bb" class="outline-4">
<h4 id="orgb5cd7bb"><span class="section-number-4">1.6.22.</span> <span class="done DONE">DONE</span> List access and update by index</h4>
<div class="outline-text-4" id="text-1-6-22">
<p>
I think re-using <code>lookup</code> and <code>assign</code> for lists, using their index, makes sense here:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>5 10 15 20<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>
<p>
should print 10.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>5 10 15 20<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> 30 assign
</pre>
</div>

<pre class="example">
[5 30 15 20]
</pre>


<p>
would leave <code>[5 30 15 20]</code>.
</p>

<p>
The problem here is that this is ambiguous:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d e<span class="org-kcats-brackets">]</span> assign

<span class="org-comment-delimiter">;; </span><span class="org-comment">is it (assigned as a hashmap by key)</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[[a b] [c d] [0 [d e]]]</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">or is it (assigned as a vector by index)</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[[d e] [c d]]</span>
</pre>
</div>

<pre class="example">
[[d e] [c d]]
</pre>


<p>
We could clear up the ambiguity by saying that int keys on a list mean
vector behavior. If you want the other you have to specify <code>association</code>
first.
</p>

<p>
lets check some corner cases - creating nested lists
</p>
<div class="org-src-container">
<pre class="src src-kcats">  <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 0 0<span class="org-kcats-brackets">]</span> <span class="org-string">"foo"</span> assign
<span class="org-comment-delimiter">;; </span><span class="org-comment">should be [1 [[foo]] 3]</span>
</pre>
</div>

<pre class="example">
[1 [["foo"]] 3]
</pre>


<p>
What do we do when we're requested to assign beyond the end of the
list? We can extend the list and pad it with <code>Nothing</code>, although this
seems maybe going a bit too far to honor the user's request that maybe
doesn't make sense.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2<span class="org-kcats-brackets">]</span> <span class="org-string">"foo"</span> assign
</pre>
</div>

<pre class="example">
[1 [[] [] "foo"] 3]
</pre>


<p>
Now let's test mixed list/assoc
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 foo baz 0<span class="org-kcats-brackets">]</span> <span class="org-string">"bar"</span> assign
</pre>
</div>

<pre class="example">
[1 [[foo [[baz [[0 "bar"]]]]]] 3]
</pre>


<p>
Note that here, the last 0 index inserts as a map key because the
object is already an assoc. The contract is basically that once you're
in assoc-land you stay there.
</p>

<p>
Now check the changes for <code>lookup</code>
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 4 <span class="org-kcats-brackets">[</span>34 6 45<span class="org-kcats-brackets">]</span> 99 23<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 2<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<pre class="example">
45
</pre>


<p>
make sure update works too
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 4 <span class="org-kcats-brackets">[</span>34 6 45<span class="org-kcats-brackets">]</span> 99 23<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 2<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> update
</pre>
</div>

<pre class="example">
[1 4 [34 6 46] 99 23]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-keyword">true</span> not
</pre>
</div>

<pre class="example">
[]
</pre>
</div>
</div>

<div id="outline-container-org93ebbe5" class="outline-4">
<h4 id="org93ebbe5"><span class="section-number-4">1.6.23.</span> <span class="done DONE">DONE</span> write 'let'</h4>
<div class="outline-text-4" id="text-1-6-23">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a <span class="org-kcats-brackets">[</span>1 1 1<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>b <span class="org-kcats-brackets">[</span>6 7 *<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>a b +<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span>
 <span class="org-kcats-brackets">[[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span>
        <span class="org-function-name">wrap</span>
        <span class="org-kcats-brackets">[[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]</span>
         <span class="org-kcats-brackets">[</span>definition<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span>
        assign<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">build a full entry</span>
   update<span class="org-kcats-brackets">]</span>
  <span class="org-function-name">map</span> association <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span>
 <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
lingo
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">43
</pre>
</div>

<p>
i am not sure if just taking the top value is correct here.
</p>


<div class="org-src-container">
<pre class="src src-kcats">dictionary
<span class="org-kcats-brackets">[[</span>a <span class="org-kcats-brackets">[</span>1 1 1<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>b <span class="org-kcats-brackets">[</span>6 7 *<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> association <span class="org-function-name">join</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>lingo<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>program<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>a b +<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>- <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>2 1 -<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1.1 2.2 -<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>-1.1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>2.2 1 -<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1.2<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>read <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span><span class="org-string">"[1 [2] 3]"</span> read<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 <span class="org-kcats-brackets">[</span>2<span class="org-kcats-brackets">]</span> 3<span class="org-kcats-brackets">]]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>close <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>pipe p<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>pipe p<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">if</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>program <span class="org-keyword">false</span>-<span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program <span class="org-keyword">true</span>-<span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program condition<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>5 <span class="org-kcats-brackets">[</span>5 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 *<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 +<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>15<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>6 <span class="org-kcats-brackets">[</span>5 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 *<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 +<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>10<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>assemble <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[</span>closed? not<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>pipe program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 8 <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 8<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 2 <span class="org-kcats-brackets">[</span>dec<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 dec<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item a<span class="org-kcats-brackets">]</span> *<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>empty? <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[]</span> empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">false</span> empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[]</span> =<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>sqrt <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>lookup <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>b<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>e<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[[[</span>outer <span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>outer c<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>d<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>list keys<span class="org-kcats-brackets">]</span> list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[[</span><span class="org-builtin">swap</span> list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>something?<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>get<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span> <span class="org-kcats-brackets">[</span>something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>reason <span class="org-string">"Lookup attempted on non-associative value"</span><span class="org-kcats-brackets">]]</span> fail<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>filled <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span>assign <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>item value<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list keys<span class="org-kcats-brackets">]</span> association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>association<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a<span class="org-kcats-brackets">]</span> 5 assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>e<span class="org-kcats-brackets">]</span> 5 assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>e 5<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c <span class="org-kcats-brackets">[[</span>d e<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]</span> 5 assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c <span class="org-kcats-brackets">[[</span>d 5<span class="org-kcats-brackets">]]]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c <span class="org-kcats-brackets">[[</span>d e<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>1 0<span class="org-kcats-brackets">]</span> 5 assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c <span class="org-kcats-brackets">[</span>5<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 0 0<span class="org-kcats-brackets">]</span> <span class="org-string">"foo"</span> assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 <span class="org-kcats-brackets">[[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span> 3<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2<span class="org-kcats-brackets">]</span> <span class="org-string">"foo"</span> assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-string">"foo"</span><span class="org-kcats-brackets">]</span> 3<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 foo baz 0<span class="org-kcats-brackets">]</span> <span class="org-string">"bar"</span> assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 <span class="org-kcats-brackets">[[</span>foo <span class="org-kcats-brackets">[[</span>baz <span class="org-kcats-brackets">[[</span>0 <span class="org-string">"bar"</span><span class="org-kcats-brackets">]]]]]]</span> 3<span class="org-kcats-brackets">]]]]]]]</span> <span class="org-kcats-brackets">[</span>pipe-out <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[[</span>type <span class="org-kcats-brackets">[</span>file<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>value file-out<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>ip-host<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span>address<span class="org-kcats-brackets">]</span> lookup <span class="org-kcats-brackets">[[</span>port<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> serversocket<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+kcats.pipe/-&gt;filled<span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>association <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>association<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> association <span class="org-kcats-brackets">[[</span>c d<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>a b<span class="org-kcats-brackets">]]</span> association =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>c d<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>a b<span class="org-kcats-brackets">]]</span> association =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> association =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-kcats-brackets">[</span>=<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3 <span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>pair <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 pair<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 2<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[</span><span class="org-string">"hi"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"there"</span> <span class="org-string">"foo"</span><span class="org-kcats-brackets">]</span> pair<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span><span class="org-string">"hi"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"there"</span> <span class="org-string">"foo"</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>buffer <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>integer<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swapdown</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">swapdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 1 3<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item c<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>string <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"1"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>1 2 3<span class="org-kcats-brackets">]</span> string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"[1 2 3]"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"[]"</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>program <span class="org-kcats-brackets">[</span>1 inc<span class="org-kcats-brackets">]]]</span> environment eval-<span class="org-function-name">step</span> eval-<span class="org-function-name">step</span> <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>2<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>* +<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3 <span class="org-kcats-brackets">[</span>26<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-builtin">evert</span> <span class="org-function-name">take</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">evert</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>association? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> association?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>b 42<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>serversocket <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>string integer<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>every? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program list<span class="org-kcats-brackets">]</span> boolean<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> prepend <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> not<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> or<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[[[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>or<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>not<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">recur</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>2 4 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>2 4 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>2 4 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>11 <span class="org-kcats-brackets">[</span>2 4 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+ odd?<span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> 11<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>12 <span class="org-kcats-brackets">[[</span>even?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 rem 0 =<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> 12<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>both? <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">sink</span> pair <span class="org-builtin">swap</span> every?<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> both?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 3 <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> both?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program item item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">filter</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">clone</span> <span class="org-function-name">wrap</span> <span class="org-builtin">swapdown</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">branch</span> <span class="org-builtin">swapdown</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">step</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 3<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[</span>2 4 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[</span>33 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+ odd?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>2<span class="org-kcats-brackets">]</span> 33<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>file-in <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>shielddowndown <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>program p<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item consumed<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item consumed<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item result<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-kcats-brackets">[</span>+ +<span class="org-kcats-brackets">]</span> shielddowndown<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 6<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3 <span class="org-kcats-brackets">[</span>3 2 1<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>* <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>dictionary <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>word? <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>foo word?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> word?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span> word?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item <span class="org-kcats-brackets">[</span>pipe in<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>pipe in<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>max <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span>positive? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>0 &gt;<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">float</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 3 1<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item c<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>zip <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[</span>a b c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> zip<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c 3<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>list values<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list keys<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>association<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[]]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">put</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>quot <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">reverse</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>3 2 1<span class="org-kcats-brackets">]]]]]]]</span> <span class="org-kcats-brackets">[</span>string? <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span><span class="org-string">"hi"</span> string?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">""</span> string?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span><span class="org-string">"hi"</span><span class="org-kcats-brackets">]</span> string?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span> string?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>disassemble <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[</span>empty? not<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program item <span class="org-kcats-brackets">[</span>pipe in<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>pipe in<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">step</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 <span class="org-kcats-brackets">[</span>2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>24<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[</span>1 2<span class="org-kcats-brackets">]</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>1 2<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>&gt; <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>2 1 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1.1 2.2 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>2.2 1 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>zero? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>0 =<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>0 zero?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>0 zero?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>-0.00001 zero?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1.1 zero?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>addmethod <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>pair condition<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program combinator<span class="org-kcats-brackets">]</span> word<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> dictionary <span class="org-builtin">swap</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-builtin">float</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-preprocessor">inject</span> <span class="org-builtin">swap</span> inscribe<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>lingo <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span>dictionary <span class="org-builtin">sink</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">float</span> <span class="org-builtin">swapdown</span> <span class="org-kcats-brackets">[</span>redefine <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> redefine<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>square<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]</span> assign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>9 square<span class="org-kcats-brackets">]</span> lingo<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>81<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>program enriched-lexicon<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program dictionary-modifier<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>redefine <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]]]</span> <span class="org-kcats-brackets">[</span>unassign <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>item key<span class="org-kcats-brackets">]</span> association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>association<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> unassign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>c d<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>e<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> unassign<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 3 2<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>prepend <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1 2<span class="org-kcats-brackets">]</span> 3 prepend<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>3 1 2<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spawn <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">recur</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>program rec2<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program rec1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program <span class="org-keyword">true</span>-<span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program pred<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>3 <span class="org-kcats-brackets">[</span>1 &lt;=<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> dec<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span> *<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">recur</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>closed? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">sink</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item c<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">sink</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 1 2<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>negative? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>0 &lt;<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>evaluate <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>program <span class="org-kcats-brackets">[</span>1 2 3 4 + *<span class="org-kcats-brackets">]]]</span> environment evaluate <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>14 1<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>not <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 even? not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">false</span> not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span> not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>timeout <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>integer<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>environment <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>program <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]]</span> environment eval-<span class="org-function-name">step</span> <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>bytes? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>update <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>a 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b 3<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a <span class="org-kcats-brackets">[[</span>c 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a <span class="org-kcats-brackets">[[</span>c 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a <span class="org-kcats-brackets">[[</span>c 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 10 15<span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a <span class="org-kcats-brackets">[[</span>c 15<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>d<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5<span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>a <span class="org-kcats-brackets">[[</span>c 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>a e<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 6 +<span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>a <span class="org-kcats-brackets">[[</span>c 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>d 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>e 11<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>b 2<span class="org-kcats-brackets">]]</span> association<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[</span>lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">shielddown</span> assign<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>list keys<span class="org-kcats-brackets">]</span> association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>association<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>tunnel <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[[[</span>type <span class="org-kcats-brackets">[</span>ip-host<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span>port<span class="org-kcats-brackets">]</span> lookup <span class="org-kcats-brackets">[[</span>address<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> !**java.net.Socket.<span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>number? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1<span class="org-kcats-brackets">]</span> number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>5 number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>5.01 number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">loop</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>item flag<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>10 <span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span>-2 * <span class="org-builtin">clone</span> 50 &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>160<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>select <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>list pipes<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>item pipe <span class="org-kcats-brackets">[</span>list pipes<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list *<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-builtin">evert</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>6 5 4 <span class="org-kcats-brackets">[</span>3 2 1<span class="org-kcats-brackets">]]]]]]]</span> <span class="org-kcats-brackets">[</span>advance <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>environment<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>environment<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>&lt;=<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item b<span class="org-kcats-brackets">]</span> *<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 2 3<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">map</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>2 3 4<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[</span>1 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>2 3 4<span class="org-kcats-brackets">]</span> 1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>7 9 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+ *<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>70 77 84<span class="org-kcats-brackets">]</span> 9 7<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>7 9 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> 9 7<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-builtin">clone</span> <span class="org-builtin">float</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">step</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>primrec <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>5 <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]</span> primrec<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>120<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>program rec1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program exit<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number data<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[[</span>zero?<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> dec<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">recur</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1 2 +<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>2 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> 4 <span class="org-builtin">swap</span> <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3 3<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>item a<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>item a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item a<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>or <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 odd? 3 even? or<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 2 or<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> 2 or<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[]</span> or<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>= <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[</span>1 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[]</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[[</span>1 <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>1 <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>1 <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>1 <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"hi"</span> <span class="org-string">"hi"</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"hi"</span> <span class="org-string">"there"</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-keyword">true</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[[</span>1 <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>1 <span class="org-kcats-brackets">[</span><span class="org-string">"bar"</span><span class="org-kcats-brackets">]]</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[[[[]</span> <span class="org-kcats-brackets">[]</span> association =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>pipe out<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>item <span class="org-kcats-brackets">[</span>pipe out<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>something? <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span>empty? not<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">false</span> something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>type <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>foo 1<span class="org-kcats-brackets">]]</span> type<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">nothing</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"foo"</span> bytes<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>bytes<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>type foo<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[[</span>type foo<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>attr <span class="org-string">"blah"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[[</span>attr1 foo<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>attr2 <span class="org-string">"blah"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[[</span>foo 1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[[</span>type url<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>value <span class="org-string">"http://foo.com"</span><span class="org-kcats-brackets">]]</span> type<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>url<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">nothing</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>association?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[[</span>type<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>type<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>word?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>word<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>bytes?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>bytes<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>string?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>pipe?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>pipe<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>error?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>error<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> decide <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>fail <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>decide <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>5 <span class="org-kcats-brackets">[[[</span>3 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"three"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>5 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"five"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>7 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"seven"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"something else"</span><span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 <span class="org-string">"five"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>9 <span class="org-kcats-brackets">[[[</span>3 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"three"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>5 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"five"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>7 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"seven"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"something else"</span><span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>9 <span class="org-string">"something else"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>9 <span class="org-kcats-brackets">[[[</span>3 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"three"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>5 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"five"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>7 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"seven"</span><span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>9 <span class="org-kcats-brackets">[]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>association test-expr-pairs<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>break <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>environment <span class="org-kcats-brackets">[</span>program condition<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>environment <span class="org-kcats-brackets">[</span>program condition<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[[[</span>program<span class="org-kcats-brackets">]</span> lookup something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-preprocessor">execute</span> not<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>handoff <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span>even? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>assert <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string <span class="org-kcats-brackets">[</span><span class="org-string">"assertion failed "</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">join</span> fail<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">rest</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-function-name">rest</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>2 3<span class="org-kcats-brackets">]]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-keyword">nothing</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>pump <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>pipe in<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe out<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>pipe in<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe out<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">sink</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swapdown</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[[</span>closed?<span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">branch</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>5 <span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span>3 *<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 +<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>15<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>6 <span class="org-keyword">false</span> <span class="org-kcats-brackets">[</span>3 *<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 +<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>10<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>program <span class="org-keyword">false</span>-<span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program <span class="org-keyword">true</span>-<span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item condition<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>rem <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span>/ <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>value <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>value<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>foo 1<span class="org-kcats-brackets">]]</span> value<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[[</span>type url<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>value <span class="org-string">"http://foo.com"</span><span class="org-kcats-brackets">]]</span> value<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"http://foo.com"</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>any? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program list<span class="org-kcats-brackets">]</span> boolean<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> prepend <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> or<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[[[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>or<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">recur</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>2 4 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>3 5 7<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>2 4 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>11 <span class="org-kcats-brackets">[</span>3 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+ odd?<span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> 11<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>-15 <span class="org-kcats-brackets">[[</span>even?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 rem 0 =<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> -15<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>and <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 odd? 2 even? and<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>pipe-in <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[[</span>type <span class="org-kcats-brackets">[</span>file<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>value file-in<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>stdout<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>stdout<span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">nothing</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>range <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 5 range<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 2 3 4<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>integer integer<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item list<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"b"</span> <span class="org-string">"c"</span><span class="org-kcats-brackets">]</span> <span class="org-string">"a"</span><span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>list? <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[</span>1<span class="org-kcats-brackets">]</span> list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[]</span> list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>5 list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>retry <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>2 3 <span class="org-string">"four"</span> * + handle <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 4<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> retry<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>14<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span>unwound<span class="org-kcats-brackets">]</span> lookup <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>min <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[]]]]</span> <span class="org-kcats-brackets">[</span>spit <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span>pipe-in<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> bytes <span class="org-function-name">put</span> close <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item <span class="org-kcats-brackets">[</span>item target<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[]]]]]</span> <span class="org-kcats-brackets">[</span>ceil <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>integer<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>atom <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"c"</span> <span class="org-string">"d"</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span> <span class="org-string">"d"</span><span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"ab"</span> <span class="org-string">"cd"</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"abcd"</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"ab"</span> bytes <span class="org-string">"cd"</span> bytes <span class="org-function-name">join</span> <span class="org-string">"abcd"</span> bytes =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>odd? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>file-out <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 2 3 <span class="org-kcats-brackets">[</span>a b c<span class="org-kcats-brackets">]</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>tos <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>stack <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span> tos<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span>stack<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">first</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>environment<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>+ <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 +<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1.1 2.2 +<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3.3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 2.2 +<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3.2<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5<span class="org-kcats-brackets">]]]]]]</span> <span class="org-kcats-brackets">[</span>recover <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 1 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 2 +<span class="org-kcats-brackets">]</span> recover<span class="org-kcats-brackets">]</span> recover<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>5 <span class="org-kcats-brackets">[</span>1 2 <span class="org-string">"oh fudge"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> recover<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 <span class="org-kcats-brackets">[</span>6 7 5<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> recover<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[[</span>handle<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-builtin">sink</span> <span class="org-preprocessor">inject</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> error?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-builtin">swap</span> <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>inc <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 inc<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>-1 inc<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>99 inc<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>100<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[]</span> 1 <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[[</span>1 2 3<span class="org-kcats-brackets">]</span> 4 <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>1 2 3 4<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[</span><span class="org-string">"foo"</span> bytes 32 <span class="org-function-name">put</span> string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"foo "</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>item list<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>word<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>pipe? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>error? <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>bytes <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>bytes<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>a 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">while</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>3 <span class="org-kcats-brackets">[</span>0 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> dec<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 2 1 0<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>program body<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program pred<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-builtin">clone</span> <span class="org-preprocessor">dipdown</span> <span class="org-function-name">join</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>&gt;= <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shielddown</span> <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[</span>1 2 3 <span class="org-kcats-brackets">[</span>=<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 <span class="org-keyword">false</span><span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>program item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>derivations <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[]]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">times</span> <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>dec<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[</span>0 &gt;<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[[</span>integer howmany<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program body<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>get <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item association<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>mod <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>&lt;= <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>number number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>boolean<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>toe <span class="org-kcats-brackets">[[</span>examples <span class="org-kcats-brackets">[[[[[</span>stack <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span> toe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">first</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>environment<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]]</span>
</pre>
</div>

<p>
Need a way of converting an item to an entry that just pushes that item.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[[[</span>spec <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span> <span class="org-kcats-brackets">[</span>definition<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> assign 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary
<span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>23<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>fooptoopy<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> assign
<span class="org-kcats-brackets">[</span>fooptoopy<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>23<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a <span class="org-kcats-brackets">[</span>1 1 1<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>b <span class="org-kcats-brackets">[</span>6 7 *<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>a b +<span class="org-kcats-brackets">]</span> let
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bd6ece" class="outline-4">
<h4 id="org1bd6ece"><span class="section-number-4">1.6.24.</span> <span class="todo TODO">TODO</span> Error should have actual struct fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></h4>
<div class="outline-text-4" id="text-1-6-24">
<p>
It's still implemented as generic Hashmap data field. 
</p>
</div>
</div>

<div id="outline-container-org54124f6" class="outline-4">
<h4 id="org54124f6"><span class="section-number-4">1.6.25.</span> <span class="todo TODO">TODO</span> Script</h4>
<div class="outline-text-4" id="text-1-6-25">
</div>
<div id="outline-container-orgadb781a" class="outline-5">
<h5 id="orgadb781a"><span class="section-number-5">1.6.25.1.</span> <span class="done DONE">DONE</span> Cryptographic primitives</h5>
<div class="outline-text-5" id="text-1-6-25-1">
</div>
<ol class="org-ol">
<li><a id="orga47c86e"></a><span class="done DONE">DONE</span> SHA256<br />
<div class="outline-text-6" id="text-1-6-25-1-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes hash <span class="org-string">"fop"</span> bytes hash =
</pre>
</div>

<pre class="example">
[]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> bytes key<span class="org-kcats-brackets">]</span> 2 <span class="org-preprocessor">times</span> =
</pre>
</div>

<pre class="example">
true
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key
</pre>
</div>

<pre class="example">
[[public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="] [type elliptic-curve-key] [secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="]]
</pre>
</div>
</li>

<li><a id="org0afd848"></a><span class="done DONE">DONE</span> Signing<br />
<div class="outline-text-6" id="text-1-6-25-1-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dawn"</span> bytes <span class="org-kcats-brackets">[</span>sign<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> verify
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dawn"</span> bytes <span class="org-kcats-brackets">[</span>sign<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">now change the message</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-string">"we attack at dawn"</span> bytes<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
verify
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span>
</pre>
</div>

<p>
We need to be able to construct scripts and their hash. What is the
public key format? We can sort the assoc so that the serialization is
always the same.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-comment-delimiter">;; </span><span class="org-comment">new key</span>
<span class="org-kcats-brackets">[</span>secret<span class="org-kcats-brackets">]</span> unassign <span class="org-comment-delimiter">;; </span><span class="org-comment">discard the secret portion</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> sort <span class="org-comment-delimiter">;; </span><span class="org-comment">make sure the assoc is always serialized the same way</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">sink</span> verify<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> 
emit<span class="org-comment-delimiter">; </span><span class="org-comment">bytes hash </span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"[[[public #b64 \"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA=\"] [type elliptic-curve-key]] sink verify]"</span>
</pre>
</div>

<p>
So this is the script data. Then the high level script (that's always
the same) is: we've got inputs, a script, and a script hash. If the
hash of the script is equal the given hash, execute the program on the
given input.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"[[[public #b64 \"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA=\"] [type elliptic-curve-key]] sink verify]"</span> bytes <span class="org-kcats-brackets">[</span>hash<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> #b64 <span class="org-string">"W1tbcHVibGljICNiNjQgIk5OSmxlZHUwVm1rK1ZBWnl6NUl2VXQzZzFsTXVOYjhHdmdFNmZGTXZJT0E9Il0gW3R5cGUgZWxsaXB0aWMtY3VydmUta2V5XV0gc2luayB2ZXJpZnld"</span>
</pre>
</div>

<p>
Now let's make a signature with that same key
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dawn"</span> bytes <span class="org-kcats-brackets">[</span>sign<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
#b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span> <span class="org-kcats-brackets">[[</span>type elliptic-curve-key<span class="org-kcats-brackets">]</span>
                                 <span class="org-kcats-brackets">[</span>secret #b64 <span class="org-string">"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>public #b64 <span class="org-string">"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
Now use that data and execute the script on it
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
 #b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span><span class="org-kcats-brackets">]</span> emit
read <span class="org-function-name">first</span> 
<span class="org-string">"[[[public #b64 \"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA=\"] [type elliptic-curve-key]] sink verify]"</span> read <span class="org-function-name">first</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> string
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"we attack at dawn"</span>
</pre>
</div>

<p>
Now let's make a word 'authenticate', that takes a script hash, a
script, and its args, and returns true if it's the right script and it
validates. Important: check the hash before attempting to execute or
even read the script. That ensures that it's what the sender intended
(doesn't protect against malicious real sender, just malicious impostors).
</p>

<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script hash</span>
#b64 <span class="org-string">"W1tbcHVibGljICNiNjQgIk5OSmxlZHUwVm1rK1ZBWnl6NUl2VXQzZzFsTXVOYjhHdmdFNmZGTXZJT0E9Il0gW3R5cGUgZWxsaXB0aWMtY3VydmUta2V5XV0gc2luayB2ZXJpZnld"</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">"foo"</span>
<span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
 #b64 <span class="org-string">"d2UgYXR1YWNrIGF0IGRhd24="</span>
 <span class="org-kcats-brackets">]</span> emit bytes <span class="org-comment-delimiter">;; </span><span class="org-comment">the proof (key) as serialized bytes list - the sig and message</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">first check hash</span>
<span class="org-kcats-brackets">[[[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>string read <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> both functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover
 <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> bail <span class="org-comment-delimiter">;; </span><span class="org-comment">gives the message and who it's from</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span>
</pre>
</div>

<p>
Try where the actual script is not what the hash requires, should return <code>nothing</code>
</p>
<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script hash</span>
<span class="org-string">"[true]"</span> emit bytes
<span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
 #b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span>
 <span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">data as list</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">first check hash</span>
<span class="org-kcats-brackets">[[[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> string read <span class="org-function-name">first</span> functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span>
</pre>
</div>

<p>
Try where the signature is invalid by substituting a sig from a different message - same key.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dusk"</span> bytes sign
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"XtOnDCT9+iiHV0BElSAckjo76e2yY3swEOOWo0FfstHgukymw9XXHm7+jLtEBsBjJzo5kyo6058WJ/XPpAe1Aw=="</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script hash</span>
#b64 <span class="org-string">"W1tbcHVibGljICNiNjQgIk5OSmxlZHUwVm1rK1ZBWnl6NUl2VXQzZzFsTXVOYjhHdmdFNmZGTXZJT0E9Il0gW3R5cGUgZWxsaXB0aWMtY3VydmUta2V5XV0gc2luayB2ZXJpZnld"</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">lock</span>
<span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"XtOnDCT9+iiHV0BElSAckjo76e2yY3swEOOWo0FfstHgukymw9XXHm7+jLtEBsBjJzo5kyo6058WJ/XPpAe1Aw=="</span>
 #b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span>
 <span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">data as list</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">first check hash</span>
<span class="org-kcats-brackets">[[[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> string read <span class="org-function-name">first</span> functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span>
</pre>
</div>

<p>
try a dummy script that really does always validate
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> emit bytes hash
<span class="org-string">"[true]"</span> bytes <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[</span>dump <span class="org-kcats-brackets">[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> string read <span class="org-function-name">first</span> functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[]</span> #b64 <span class="org-string">"W3RydWVd"</span> #b64 <span class="org-string">"HCjy6wlYw9FdsfDw5/K4mYyiuPZ6tCah+7PVYf52+tk="</span><span class="org-kcats-brackets">]</span>
<span class="org-keyword">true</span> #b64 <span class="org-string">"HCjy6wlYw9FdsfDw5/K4mYyiuPZ6tCah+7PVYf52+tk="</span>
</pre>
</div>
</div>
</li>

<li><a id="org5f8317b"></a><span class="done DONE">DONE</span> Make verify return the message<br />
<div class="outline-text-6" id="text-1-6-25-1-3">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-09-28 Thu 10:43]</span></span></li>
</ul>
<p>
one thing I hadn't considered before. We receive this package of
"proof" - proof of what? That this message is from the party
represented by the given script hash. What message?  It's contained in
the proof. The important thing is that if the proof is good <b>we return
the message</b>. I think a good contract is that we return the message (as
bytes) if it's valid proof, otherwise <code>nothing</code>.  If we only return <code>true</code>
on valid proof then we have to embark on digging out the message from
potentially nested proofs. If we just return the message from each
layer (on success) then we don't have to have this separate logic.
</p>

<p>
I think it's best to just have the contract of the word <code>verify</code> do this
for us - there's no reason to just return the truthy value <code>true</code> when
the message is a perfectly good truthy value. I suppose signing an
empty byte array could cause confusion (if that were considered
"nothing" which I suppose it should, but currently isn't). But I can't
think of any valid reason to sign 'nothing'.
</p>
</div>
</li>
<li><a id="org724fe91"></a><span class="todo TODO">TODO</span> AES Encryption<br /></li>
<li><a id="org4f11b52"></a><span class="todo TODO">TODO</span> Random<br /></li>
</ol>
</div>
<div id="outline-container-orge769003" class="outline-5">
<h5 id="orge769003"><span class="section-number-5">1.6.25.2.</span> <span class="done DONE">DONE</span> Pure functional env</h5>
<div class="outline-text-5" id="text-1-6-25-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>pipe-in pipe-out channel timeout handoff file-in file-out timestamps standard serversocket animate future spit tunnel <span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> unassign<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> lingo
</pre>
</div>

<pre class="example">
1 2
</pre>
</div>
</div>
<div id="outline-container-orgd79ce2b" class="outline-5">
<h5 id="orgd79ce2b"><span class="section-number-5">1.6.25.3.</span> <span class="todo TODO">TODO</span> Infinite loop protection</h5>
<div class="outline-text-5" id="text-1-6-25-3">
<p>
We need to prevent an attacker presenting <code>true [clone] loop</code> as their
identity proof, which would never halt. It may be easiest to just
remove all the looping words from the dictionary, but that seems
overly restrictive, when the point is just to limit the resources an
attacker can consume, and we already have a direct solution for that:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]]</span> environment
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org510293c" class="outline-4">
<h4 id="org510293c"><span class="section-number-4">1.6.26.</span> <span class="done DONE">DONE</span> Multithreading</h4>
<div class="outline-text-4" id="text-1-6-26">
</div>
<div id="outline-container-orga35260e" class="outline-5">
<h5 id="orga35260e"><span class="section-number-5">1.6.26.1.</span> Overview</h5>
<div class="outline-text-5" id="text-1-6-26-1">
<p>
There are a few major components here:
</p>
<ul class="org-ul">
<li>Be able to tell whether an environment can advance. It's basically
"if there's nothing in the program, it's done, otherwise it can
run unless it's currently putting/taking from a pipe"</li>
</ul>
</div>
</div>
<div id="outline-container-orgd2434f6" class="outline-5">
<h5 id="orgd2434f6"><span class="section-number-5">1.6.26.2.</span> Pipes</h5>
<div class="outline-text-5" id="text-1-6-26-2">
<p>
It's not clear to me what to do about pipes. As soon as we call <code>take</code>
(for example) we're going to block the rust thread. In order to use
lightweight "threads" we're going to need a non-blocking check to see
if something can come out (or fit in) the pipe. For things like files
and sockets, it looks like we will need <code>tokio</code>.
</p>

<p>
tokio has Task which can manage this. It looks like tokio has file io
and network io that will automatically yield and allow other tasks to
run.
</p>

<p>
So then another question is, how to use something like <code>select</code> in
kcats. It might be possible to pass in a list of pipes to select and
then return the item that came out (along with the pipe itself i
guess). But this is advanced functionality that probably isn't a high
priority.
</p>

<p>
I think the basic design here is that each environment is a single
"thread" of execution, and that will map to a tokio Task. Pipe
operations within an env will call the async functions but will
immediately <code>await</code>. That should yield to allow other envs to run.
</p>

<p>
It looks like the <code>async</code> will creep all the way up to <code>axiom::eval</code>. If
the criteria is that anything we want to be able to pre-empt (if it's
waiting on i/o) needs to be labeled async, then everything up to <code>eval</code>
is going to be <code>async</code>.
</p>

<p>
I think that means fns like <code>f_stack1</code> etc will need to be async because
the <code>f</code> it calls can potentially call i/o. Actually it's probably best
to make new async versions of these so we don't have to make all the
Item fns async too.
</p>

<p>
We'll also need to think about what to do about dangling
environments - let's say we have the main env, and it spawns env e,
which will feed values back to main. But let's say main is done and
doesn't want any more values from e. Is the entire program done and we
can garbage collect e? My first instinct here is to blow everything
away as soon as main is done. If we don't want to exit we should be
taking from a pipe that won't produce anything until we're ready to
exit. So we're not going to <code>join</code> with other environment's tasks.
</p>
</div>
</div>
<div id="outline-container-orgee235ff" class="outline-5">
<h5 id="orgee235ff"><span class="section-number-5">1.6.26.3.</span> <span class="done DONE">DONE</span> Add tokio as dep</h5>
</div>
<div id="outline-container-org58882c1" class="outline-5">
<h5 id="org58882c1"><span class="section-number-5">1.6.26.4.</span> <span class="done DONE">DONE</span> Prepare for multithreading</h5>
<div class="outline-text-5" id="text-1-6-26-4">
</div>
<ol class="org-ol">
<li><a id="org2ea20e4"></a><span class="done DONE">DONE</span> Use Arc instead of Rc<br />
<div class="outline-text-6" id="text-1-6-26-4-1">
<p>
Does Arc have <code>make_mut</code>?  Yes! So hopefully it will be a drop-in
replacement.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgf8f7332" class="outline-5">
<h5 id="orgf8f7332"><span class="section-number-5">1.6.26.5.</span> <span class="done DONE">DONE</span> Update pipe types for fs and net to use tokio calls</h5>
<div class="outline-text-5" id="text-1-6-26-5">
<p>
One problem here is that we don't have a trivial way to mix step
functions that are pure vs involving pipes.
</p>

<p>
If we don't know until runtime what it is, we have to assume async and
there's probably a huge performance hit.
</p>

<p>
Maybe one way to proceed is to make an <code>Item</code> variant <code>Future</code>. So if
we're taking from a pipe, we can just put the <code>Future</code> on the stack and
continue. Of course, very soon we'll need to access the value and call
<code>await</code> on it. 
</p>

<p>
What then, do we do about <code>put</code>? Let's say the pipe is full and the put
needs to wait. We can return the Env but we still need to await sometime.
</p>

<p>
Maybe in eval-step, we can check if the top item is a Future. If so,
await it. If it returns another Item, replace it. If it returns Unit,
just drop it. Somewhere we'd need a type <code>Option&lt;Item&gt;</code> for what the
futures return (None if we're just waiting on a value to put into a
pipe, Item if we're taking)
</p>

<p>
So will this work in nested envs? I am not sure but I can't think of
why it wouldn't.
</p>

<p>
If this works then only eval/eval-step will need <code>async</code>.
</p>
</div>
</div>
<div id="outline-container-orgd80e569" class="outline-5">
<h5 id="orgd80e569"><span class="section-number-5">1.6.26.6.</span> <span class="done DONE">DONE</span> Use channel type to implement handoff pipe</h5>
<div class="outline-text-5" id="text-1-6-26-6">
</div>
<ol class="org-ol">
<li><a id="org8f5044f"></a><span class="done DONE">DONE</span> Use crossbeam channels<br />
<div class="outline-text-6" id="text-1-6-26-6-1">
<p>
mpsc doesn't allow us to clone the receiver (Out) end of the pipe, and
that would seem like a rather sharp corner to users of kcats who
generally aren't too performance sensitive and want simple programs to
"just work".
</p>

<div class="org-src-container">
<pre class="src src-kcats">handoff <span class="org-builtin">clone</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>5 <span class="org-function-name">put</span> <span class="org-string">"hello"</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> assign environment animate <span class="org-function-name">take</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">5 <span class="org-string">"hello"</span> <span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>handoff todo: id-or-hash here<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<pre class="example">

</pre>


<p>
One issue here is that we accidentally made a bidirectional channel. I
don't know if that should be the default mode of operation. When we
create a handoff maybe we should really create two stack items: the in
and out. 
</p>

<p>
The question is, what should be a tunnel? I am not sure single stack
items really should allow both put and take.
</p>

<p>
The problem with splitting them is it can exascerbate the already
difficult problem of stack manipulation (if indeed you actually need
to read from a file and then write to the same spot&#x2026; is that
common?)
</p>

<p>
The benefit is that a process that's supposed to be reading can't
accidentally write, if it doesn't have the In part of the pipe.
</p>

<p>
For now I think I'm inclined to leave it as-is and see how it goes.
</p>
</div>
</li>
<li><a id="org4380d95"></a><span class="todo TODO">TODO</span> Nonblocking eval-step (for inner envs)<br />
<div class="outline-text-6" id="text-1-6-26-6-2">
<p>
It would be nice if calling eval-step on an inner env and having it
block, wouldn't block the outer env (or at least it would be nice if
it were an option not to wait). Maybe <code>try_eval_step</code> which tries to
make progress immediately and if it can't, just returns as-is.
</p>

<p>
There's probably a way to do this by polling the future. using <code>select!</code>
with a short timeout future would do it but there's probably a better
way.
</p>
</div>
</li>
<li><a id="orgba83d60"></a><span class="todo TODO">TODO</span> Combine implementations for net and fs<br />
<div class="outline-text-6" id="text-1-6-26-6-3">
<p>
They're both using AsyncReadExt and AsyncWriteExt methods. The only
difference between them is how the pipes are created. It would be
easier to make pipes for stdin/stdout this way.  I tried it but the
compiler complained about not being able to make trait objects out of
them. Will revisit later.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org870e722" class="outline-5">
<h5 id="org870e722"><span class="section-number-5">1.6.26.7.</span> <span class="done DONE">DONE</span> Implement 'spawn' or equavalent</h5>
<div class="outline-text-5" id="text-1-6-26-7">
<p>
Can probably think of a better name. What we're doing is taking an
environment that's a local piece of data on the stack and spitting it
out to make it its own autonomous thing.
<code>animate</code> seems rather fitting.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>+ 1 1<span class="org-kcats-brackets">]]]</span> environment animate 
</pre>
</div>

<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org160be77" class="outline-5">
<h5 id="org160be77"><span class="section-number-5">1.6.26.8.</span> <span class="done DONE">DONE</span> Implement 'future' or equivalent</h5>
<div class="outline-text-5" id="text-1-6-26-8">
<p>
The idea here is to take an program and run it in its own spawned
env, and when it's done, snapshot the stack and put it into a
pipe and close it. The original env gets the other end of the pipe.
</p>

<p>
I think the new env should probably inherit the current env's stack.
</p>
<div class="org-src-container">
<pre class="src src-kcats">1 2 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> 
<span class="org-comment-delimiter">;; </span><span class="org-comment">make a pipe</span>
handoff <span class="org-builtin">swap</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">save the stack, including pipe</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">prepare the program for the new env</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">end up with [[+ snapshot] dip swap put]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">;; now we have expr stack</span>
pair
<span class="org-kcats-brackets">[</span>stack program<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> zip environment
animate <span class="org-function-name">take</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>handoff todo: id-or-hash here<span class="org-kcats-brackets">]]</span> 2 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]</span> future <span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span>
</pre>
</div>

<pre class="example">
[3] 1
</pre>
</div>
</div>
</div>
<div id="outline-container-org54c51c3" class="outline-4">
<h4 id="org54c51c3"><span class="section-number-4">1.6.27.</span> <span class="todo TODO">TODO</span> retry should have opposite argument order&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span>&#xa0;<span class="consistency">consistency</span></span></h4>
<div class="outline-text-4" id="text-1-6-27">
<p>
Currently it expects an error on ToS and then a program beneath. But
it seems like we'd nearly always have to <code>dip</code> the program beneath the
error. I think it would be better if <code>retry</code> expected the program to fix
the issue on top, and the error beneath.
</p>
</div>
</div>
<div id="outline-container-org729f574" class="outline-4">
<h4 id="org729f574"><span class="section-number-4">1.6.28.</span> <span class="todo INPROGRESS">INPROGRESS</span> Support Kademlia DHT</h4>
<div class="outline-text-4" id="text-1-6-28">
</div>
<div id="outline-container-orga77c730" class="outline-5">
<h5 id="orga77c730"><span class="section-number-5">1.6.28.1.</span> <span class="done DONE">DONE</span> XOR</h5>
<div class="outline-text-5" id="text-1-6-28-1">
<p>
We have a node id (maybe just the i2p destination address?) and we
want to calculate the distance to another node as the XOR
</p>
</div>
</div>
<div id="outline-container-orge545b08" class="outline-5">
<h5 id="orge545b08"><span class="section-number-5">1.6.28.2.</span> <span class="todo INPROGRESS">INPROGRESS</span> Simple API server</h5>
<div class="outline-text-5" id="text-1-6-28-2">
<p>
Construct a socket listener, and serve something from a trivial local
database. Disable exploitable words. Catch errors and return to the user.
</p>

<div class='tangle-wrapper' data-tangle='examples/api.kcats'><div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">create an API service</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Takes from the stack:</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* a Database (can be a regular data structure for read-only apis),</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">or a pipe to an actual (sql or other) database that accepts queries for</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">read/write ops</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* a program that modifies the dictionary that clients can</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">access. It should add words to make interaction easier (for</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">example, you might provide a word 'customers' that gets the customers</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">db table). It should also remove words that the clients should not be able</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">to use - for example, they shouldn't be able to create file or network pipes. </span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* a server socket pipe to serve from</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">The client sends a program to run in a fresh environment where he</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">can expect to find:</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* The database (either a pipe or data structure)</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">His program runs and then the resulting stack is returned to him.</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">socket listener</span>
<span class="org-kcats-brackets">[[</span>type ip-host<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>port 12121<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>address <span class="org-string">"127.0.0.1"</span><span class="org-kcats-brackets">]]</span> pipe-out

<span class="org-comment-delimiter">;; </span><span class="org-comment">book db</span>
<span class="org-string">"examples/books.kcats"</span> file-out slurp read

functional <span class="org-comment-delimiter">;; </span><span class="org-comment">dictionary modifications, removes any io access </span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">API Server code begins here</span>

dictionary <span class="org-builtin">swap</span> <span class="org-preprocessor">execute</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; new-dict db sock</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">start building the environment</span>
<span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the request as bytes</span>
              <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">we want the pipe on top so we can dip the user's program under it -&gt; pipe req db</span>
              <span class="org-kcats-brackets">[</span>string <span class="org-comment-delimiter">;; </span><span class="org-comment">translate to a string -&gt; req-str db</span>
               read <span class="org-comment-delimiter">;; </span><span class="org-comment">the request program into a data structure -&gt; prog db</span>
               <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> recover <span class="org-comment-delimiter">;; </span><span class="org-comment">the program -&gt; items*</span>
               <span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">under the pipe so the user's code has no access</span>
              <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; response pipe</span>
              emit <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; response-str pipe</span>
              bytes <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; response-bytes pipe</span>
              <span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the response into the pipe</span>
              <span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">close the connection</span>
             <span class="org-kcats-brackets">]]]</span> environment <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; env new-dict db sock </span>
<span class="org-kcats-brackets">[</span>dictionary<span class="org-kcats-brackets">]</span> <span class="org-builtin">float</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; new-dict [dictionary] env db sock</span>
assign  <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; env db sock</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">now just need to assign the stack, which is [pipe db] </span>
<span class="org-builtin">float</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; sock env db</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">loop to accept connections and start new env with the db and a pipe</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">to take requests and reply</span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">float</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; pipe db env</span>
  pair <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; stack env</span>
  <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; stack ks env</span>
  assign <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; env</span>
  environment
  animate <span class="org-comment-delimiter">;; </span><span class="org-comment">let it fly  </span>
 <span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">shielded so as not to consume the db each time</span>
 <span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">drop whatever the result is of this iteration, we don't need it</span>
<span class="org-kcats-brackets">]</span>

<span class="org-function-name">step</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">accepts incoming connections until killed</span>
</pre>
</div></div>
</div>
</div>
<div id="outline-container-orgdf94c52" class="outline-5">
<h5 id="orgdf94c52"><span class="section-number-5">1.6.28.3.</span> <span class="todo TODO">TODO</span> Kademlia functions</h5>
</div>
</div>
<div id="outline-container-org26026cf" class="outline-4">
<h4 id="org26026cf"><span class="section-number-4">1.6.29.</span> <span class="done DONE">DONE</span> Implement print (opposite of read)</h4>
<div class="outline-text-4" id="text-1-6-29">
<p>
We don't have a way to convert objects to their string serialization
Completed as the word emit
</p>
</div>
</div>
<div id="outline-container-org3f82ca6" class="outline-4">
<h4 id="org3f82ca6"><span class="section-number-4">1.6.30.</span> <span class="todo TODO">TODO</span> read and emit don't have quite the same semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></h4>
<div class="outline-text-4" id="text-1-6-30">
<p>
read will read all the bytes and return however many objects were read.
emit will take an object and return its serialization.
</p>

<p>
There should be some way of round tripping here, maybe a word <code>read1</code> or
something that just reads one object. 
</p>
</div>
</div>
<div id="outline-container-org2220f11" class="outline-4">
<h4 id="org2220f11"><span class="section-number-4">1.6.31.</span> <span class="todo TODO">TODO</span> Inconsistent stack handling when encountering error&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></h4>
<div class="outline-text-4" id="text-1-6-31">
<p>
Some words pop the arguments off the stack, then if an error is
encountered, throws the error without the args on the stack. Others
leave the args intact. This needs to be consistent.
</p>

<p>
I would lean towards leaving the args intact so that <code>retry</code> is easily applied.
</p>
</div>
<div id="outline-container-org31bae1d" class="outline-5">
<h5 id="org31bae1d"><span class="section-number-5">1.6.31.1.</span> <span class="todo TODO">TODO</span> 'read' on invalid edn consumes the string argument</h5>
<div class="outline-text-5" id="text-1-6-31-1">
<p>
It should attempt to parse before popping the item off the stack.
</p>
</div>
</div>
<div id="outline-container-orge79559c" class="outline-5">
<h5 id="orge79559c"><span class="section-number-5">1.6.31.2.</span> <span class="todo TODO">TODO</span> Division by zero consumes stack items</h5>
<div class="outline-text-5" id="text-1-6-31-2">
<p>
<code>5 0 /</code> shouldn't consume the <code>5</code> and <code>0</code> - compare to <code>1 "2" +</code> behavior
(which leaves items on stack).
</p>
</div>
</div>
</div>
<div id="outline-container-orge63f18b" class="outline-4">
<h4 id="orge63f18b"><span class="section-number-4">1.6.32.</span> <span class="done DONE">DONE</span> Inconsistent expression handling when encountering error</h4>
<div class="outline-text-4" id="text-1-6-32">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-15 Sun 15:24]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-15 Sun 15:20]</span></span></li>
</ul>
<p>
Some errors lose the word on which they occurred. They should be in
the expression still.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[]]</span> <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> get
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>pair<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>actual <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>get<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
The word <code>get</code> should still be in the <code>unwound</code> field.
</p>

<p>
I think this only works correctly when the invalid argument is caught
by spec checking and not in the actual axiom function.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-string">""</span> +
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>actual <span class="org-string">""</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
<span class="org-string">""</span> 1
</pre>
</div>

<p>
Here's an example where the spec is too permissive and the actual
function throws the error.
</p>
<div class="org-src-container">
<pre class="src src-kcats">1 set
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>sized<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>set<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>actual 1<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
The question then is how to fix this? Hopefully this can be fixed
inside <code>eval_step</code>. After the function completes, we can check if there
was an error on top (if there wasn't before), and if so, we can replace the 
</p>
</div>
</div>
<div id="outline-container-orgafb7dac" class="outline-4">
<h4 id="orgafb7dac"><span class="section-number-4">1.6.33.</span> <span class="done DONE">DONE</span> logical enum hierarchy</h4>
<div class="outline-text-4" id="text-1-6-33">
</div>
<div id="outline-container-org9aae850" class="outline-5">
<h5 id="org9aae850"><span class="section-number-5">1.6.33.1.</span> <span class="done DONE">DONE</span> Collection hierarchy</h5>
<div class="outline-text-5" id="text-1-6-33-1">
<p>
There are read (peek/first) and write operations (pack/put/conj).
</p>

<p>
Then there are read/write ops like (take/unpack) that mutate the coll
and also return a value.
</p>

<p>
An In pipe supports only write. An Out pipe supports only
read-write. Pipes in general do not support peeking.
</p>

<p>
Collections (lists, maps, sets etc) support all of them.
</p>

<p>
It's not clear how to support overlapping functionality in an enum.
</p>
</div>
</div>
<div id="outline-container-org9fe7cbb" class="outline-5">
<h5 id="org9fe7cbb"><span class="section-number-5">1.6.33.2.</span> <span class="done DONE">DONE</span> pipe as list-like thing</h5>
<div class="outline-text-5" id="text-1-6-33-2">
<p>
Are both words <code>put</code> and <code>pack</code> needed (similarly <code>take</code> and <code>unpack</code>)? Seems
like the former should be all that's needed. That starts to address
that pack/unpack aren't inverse (they shouldn't be because it's really
put/take, and whether you get the last item back or not depends on the
underlying impl - a stack you would, a queue you wouldn't).
</p>

<p>
Also take in other langs takes a number arg (how many to take). You
could do this as <code>[take] 5 times</code>, but that's less efficient. Could
maybe create a new word like <code>split</code> or <code>unload</code> or something.
</p>

<p>
The possibility that these words might block, and you don't know
except by the argument type, is a bit off-putting, and maybe these
should be different words? I don't know, the contract is to "take
thing out of other thing" and sometimes that's instant and sometimes
it isn't. (You can ask if the object is a pipe before taking)
</p>

<p>
<code>step</code> should work on pipes. It continues until the pipe closes. How do
we write step in terms of take? The problem is we don't know when to
stop. We know if a collection is empty, but we need to know if a pipe
is closed. The way pipes work now is that if something goes wrong, it
produces an error from the pipe. That's ok for pipes, where we're ok
with the limitation that you can't tell whether the error was
generated during the take or was the actual data sent. However when
dealing with lists, errors are never generated, they're always the
item in the list. We want step to treat both errors and <code>nothing</code> as
actual items and not a flag value for error conditions
</p>

<p>
OK here's a plan: Result&lt;Option&lt;Item&gt;&gt;.  If the pipe is closed, return
Ok(None), if error return Err. The way we differentiate between Errors
in a list and Errors that just happened, is already implemented: via
the 'handled' field of the Error. So if there's a error in the list,
it'll have handled=true and it won't cause the program to
unwind. If it's an actual error reading from the underlying data,
it'll have handled=false and unwind. This will also allow us to
support Nothing in lists and pipes, we won't reserve it as a sentinel
value.
</p>
</div>
</div>
<div id="outline-container-org89c13b9" class="outline-5">
<h5 id="org89c13b9"><span class="section-number-5">1.6.33.3.</span> <span class="done DONE">DONE</span> Step accepts pipes</h5>
</div>
<div id="outline-container-org894da15" class="outline-5">
<h5 id="org894da15"><span class="section-number-5">1.6.33.4.</span> <span class="done DONE">DONE</span> Set close = drop</h5>
</div>
<div id="outline-container-orgd146702" class="outline-5">
<h5 id="orgd146702"><span class="section-number-5">1.6.33.5.</span> <span class="done DONE">DONE</span> Remove closed?</h5>
<div class="outline-text-5" id="text-1-6-33-5">
</div>
<ol class="org-ol">
<li><a id="org7bec011"></a><span class="done DONE">DONE</span> Write assemble in terms of step<br />
<div class="outline-text-6" id="text-1-6-33-5-1">
<p>
I don't think we actually need assemble anymore, since this is just a
regular <code>step</code> (same as reducing any other iterable).
</p>
</div>
</li>
<li><a id="orgfdd2aec"></a><span class="done DONE">DONE</span> Do something with network pipes<br />
<div class="outline-text-6" id="text-1-6-33-5-2">
<p>
I think this does have a notion of closing.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgb35b51e" class="outline-5">
<h5 id="orgb35b51e"><span class="section-number-5">1.6.33.6.</span> <span class="done DONE">DONE</span> make a polymorphic 'join'</h5>
<div class="outline-text-5" id="text-1-6-33-6">
<p>
The problem is that it's not symmetrical. If you have two different
types, whose semantics do you use? Sometimes it's obvious regardless
of order. Other times I suppose it's ok to use the first one (the
deeper in the stack).
</p>

<ul class="org-ul">
<li>list assoc -&gt; list</li>
<li>assoc list -&gt; list</li>
<li>list string -&gt; list</li>
<li>assoc string -&gt; error</li>
<li><p>
assoc assoc -&gt; assoc (merge top into 2nd)
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>e f<span class="org-kcats-brackets">]]</span> <span class="org-function-name">join</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>e f<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> association <span class="org-kcats-brackets">[[</span>a f<span class="org-kcats-brackets">]]</span> association <span class="org-function-name">join</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a f<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org0a19805" class="outline-5">
<h5 id="org0a19805"><span class="section-number-5">1.6.33.7.</span> <span class="done DONE">DONE</span> Update spec types to be more abstract</h5>
<div class="outline-text-5" id="text-1-6-33-7">
<p>
For example, <code>step</code> now accepts not only lists but also out-pipes. So
really the spec type for this argument should be <code>iterable</code> or
something.
</p>

<p>
For ideas of what to call these types, how about <code>in</code> and <code>out</code>? So eg
step takes a program and an out. <code>put</code> takes an <code>in</code>, <code>take</code> takes an <code>out</code>. I
am not sure if the <code>tunnel</code> concept will be necessary.
</p>
</div>
</div>
</div>
<div id="outline-container-org82371ab" class="outline-4">
<h4 id="org82371ab"><span class="section-number-4">1.6.34.</span> <span class="done DONE">DONE</span> Support char type</h4>
<div class="outline-text-4" id="text-1-6-34">
<p>
If we don't support char, that breaks the abstraction of a String as a
sort of collection. A collection of what? Characters, not 1-length
strings.
</p>

<p>
Might have to do something similar with byte, but a byte array can
also be thought of as an array of ints (8 bit unsigned), and we
already have an integer type (even though it holds more bits).
</p>
</div>
</div>
<div id="outline-container-org0a305e5" class="outline-4">
<h4 id="org0a305e5"><span class="section-number-4">1.6.35.</span> <span class="done DONE">DONE</span> implement sleep&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-6-35">
<p>
helps with debugging multithreading
</p>

<div class="org-src-container">
<pre class="src src-kcats">1000 sleep
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">timestamps <span class="org-function-name">take</span> <span class="org-kcats-brackets">[</span>1000 timer <span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> 1000 - 100 within? 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span> <span class="org-kcats-brackets">[[</span>type out<span class="org-kcats-brackets">]</span>
      <span class="org-kcats-brackets">[</span>from systemtime<span class="org-kcats-brackets">]</span>
      <span class="org-kcats-brackets">[</span>values <span class="org-kcats-brackets">[[</span>type integer<span class="org-kcats-brackets">]</span>
               <span class="org-kcats-brackets">[</span>units milliseconds<span class="org-kcats-brackets">]]]]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org187fd08" class="outline-4">
<h4 id="org187fd08"><span class="section-number-4">1.6.36.</span> <span class="done DONE">DONE</span> handoff tests</h4>
<div class="outline-text-4" id="text-1-6-36">
<p>
This should block, not error
</p>
<div class="org-src-container">
<pre class="src src-kcats">handoff <span class="org-function-name">take</span>
</pre>
</div>

<pre class="example">
[[reason "type mismatch"] [unwound [unpack]] [type error] [asked [list]] [actual [[type pipe] [handoff todo: id-or-hash here]]] [handled true]] [[handoff todo: id-or-hash here] [type pipe]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">handoff <span class="org-kcats-brackets">[</span>1 2 +<span class="org-kcats-brackets">]</span> future <span class="org-function-name">take</span> 
</pre>
</div>

<pre class="example">
[3 [[type pipe] [handoff todo: id-or-hash here]]] [[handoff todo: id-or-hash here] [type pipe]] [[handoff todo: id-or-hash here] [type pipe]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">handoff <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>1 <span class="org-function-name">put</span> 2 <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>program<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> assign environment animate <span class="org-function-name">take</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> +
</pre>
</div>

<pre class="example">
3 [[type pipe] [handoff todo: id-or-hash here]] [[type pipe] [handoff todo: id-or-hash here]]
</pre>


<p>
Should make a word that creates an inner env with access to a handoff also present in the outer env.
</p>
<div class="org-src-container">
<pre class="src src-kcats">  <span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span> close<span class="org-kcats-brackets">]</span> handoff <span class="org-builtin">clone</span> <span class="org-comment-delimiter">; </span><span class="org-comment">p h h</span>
  <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>program<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> assign environment animate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
  0 <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[snapshot] dip swap  join [[] [program]] dip assign environment animate take [take] dip +</span>
</pre>
</div>

<pre class="example">
6
</pre>


<div class="org-src-container">
<pre class="src src-kcats">  <span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span> close<span class="org-kcats-brackets">]</span> handoff <span class="org-builtin">clone</span> <span class="org-comment-delimiter">; </span><span class="org-comment">p h h</span>
  <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>program<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> assign environment animate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
  0 <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[snapshot] dip swap  join [[] [program]] dip assign environment animate take [take] dip +</span>
</pre>
</div>

<p>
Read from one file and write to another 
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar"</span><span class="org-kcats-brackets">]]</span> pipe-in
<span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/foo"</span><span class="org-kcats-brackets">]]</span> pipe-out 
<span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
[[type pipe] [file "/tmp/bar"]]
</pre>


<p>
As a library function
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"/tmp/bar"</span> <span class="org-string">"/tmp/foo"</span> file-out <span class="org-kcats-brackets">[</span>file-in<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span> close
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">Closing In
<span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type pipe<span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3d30b5" class="outline-4">
<h4 id="orgb3d30b5"><span class="section-number-4">1.6.37.</span> <span class="todo TODO">TODO</span> Performance optimizations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></h4>
<div class="outline-text-4" id="text-1-6-37">
</div>
<div id="outline-container-orgf133942" class="outline-5">
<h5 id="orgf133942"><span class="section-number-5">1.6.37.1.</span> <span class="todo TODO">TODO</span> Compile programs</h5>
<div class="outline-text-5" id="text-1-6-37-1">
<p>
Here is how it could maybe be done. We already have a type StepFn
(which takes an env and returns a new one, in a future).
</p>

<p>
So let's say we have a program [1 2 +], and we want to convert that
into a StepFn. We could have a function <code>compose</code> and another
<code>self_insert</code>, and then call compose([self<sub>insert</sub>(1), self<sub>insert</sub>(2),
plus]), which would return a StepFn.
</p>

<p>
Let's look at something more complex:
</p>

<p>
<code>1 2 3 4 [+ *] dip</code>
</p>

<p>
In this case, the program is the composition of the 5 self-inserts and
dip. But what is self-inserted as the 5th item in this case could be
compiled because we know <code>dip</code> follows it. How we know in advance a list
can be compiled is difficult.
</p>

<p>
Let's try this:
</p>

<p>
<code>0 1 [2 3 4] [[+] dip] step</code>
</p>

<p>
In this case, the program for <code>step</code> is easy to spot, and in turn <code>dip</code>.
</p>

<p>
How about this:
</p>

<p>
<code>[+ *] [2 3 4] swap join execute</code>
</p>

<p>
We can't know the first two programs can be compiled until later on,
unless we look ahead in the program. Even then we can only know
what arguments end up being passed to join and execute by examining
the words' specs, and even that is not foolproof, as we have wildcard
specs like dip where the stack change is arbitrary.
</p>

<p>
One major issue with this optimization is that it will stop the
debugger from working properly, unless special care is taken: with the
debugger we can go step by step, but if the function composition is
bundled up, we can only "step over" that function and not "into" it. I
am not sure if it's possible to build this such that we preserve
stepping ability and increase performance substantially.
</p>
</div>
</div>
<div id="outline-container-org1fa93e8" class="outline-5">
<h5 id="org1fa93e8"><span class="section-number-5">1.6.37.2.</span> <span class="todo TODO">TODO</span> Programs as their own immutable type</h5>
<div class="outline-text-5" id="text-1-6-37-2">
<p>
Programs executing in a loop are generally not modified (exception -
the <code>recur</code> word, which can modify but usually just calls <code>execute</code>)- so
when we execute a program with <code>loop</code> we don't want to have to clone it
each time through the loop.
</p>

<p>
Instead we'll do the following: when <code>loop</code> places a program into the
program, instead of joining it, it's just going to put it right on
top as a <code>program</code> - we may need to differentiate programs that are
active vs meant to be run later. When <code>eval-step</code> runs, it sees an
active program on the top of the program, so it calls <code>next</code> and gets
a reference to the next word (or None if it's at the end, drop the
program). Then we lookup that word. If it's an axiom, we call it. If
it's derived, we place a new program on the top of the program,
with its PC set to 0. The actual programs are immutable, and behind an
Rc. Each "copy" of the program is just an Rc and a counter. Then all
programs are references except the counter.
</p>


<p>
example program:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>flip <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">0 </span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-builtin">swapdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>flip <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">0 1</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pc 0</span>
<span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pc 1 </span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pc 0 1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">etc</span>
</pre>
</div>

<p>
So when printing out the program, we could cheat and only show the
remaining program (instead of a stack of partially executed programs).
</p>
</div>
</div>
</div>

<div id="outline-container-org660bf25" class="outline-4">
<h4 id="org660bf25"><span class="section-number-4">1.6.38.</span> <span class="todo INPROGRESS">INPROGRESS</span> Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-6-38">
</div>
<div id="outline-container-org283ead0" class="outline-5">
<h5 id="org283ead0"><span class="section-number-5">1.6.38.1.</span> <span class="done DONE">DONE</span> Basic functionality and generators</h5>
<div class="outline-text-5" id="text-1-6-38-1">
<p>
There's the concept of "lazy sequence" that I think maps nicely to
pipes - you can keep calling 'take' and it keeps calculating new
values. Everything it needs is contained in the object, it's not like
a network or filesystem pipe where the data is coming from somewhere
external. But it acts like a pipe.
</p>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">the producer - infinite seq of integers</span>
<span class="org-kcats-brackets">[[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; [1] 1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">the filter condition</span>
<span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">divisible by 3</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">filter-xf</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">pop</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>  

<span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">[generation filtration] [] 0 </span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
</pre>
</div>

<p>
The problem above is <code>generate</code> will not produce a value until one
passes the filter. I think filter needs to keep calling <code>generate</code> on the xf below it?
</p>
<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-function-name">pop</span> <span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]</span> 4
</pre>
</div>

<pre class="example">
1 [[unwound [[[[inc clone] dip swap put [pop [3 mod 0 =]] [put] [drop] if]] unwrap]] [type error] [asked [packable]] [actual 1] [reason "type mismatch"] [handled true]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">the impl of filter-xf</span>
<span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">pop</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>  
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-function-name">pop</span> <span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span>
<span class="org-builtin">drop</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span>
</pre>
</div>

<pre class="example">
2 [inc clone] 2
</pre>


<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">]</span>
</pre>
</div>

<pre class="example">
[[generate] dip] [] [inc] 1
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[1 2 3 4 6 9] liberate ;; produce from list</span>
1 <span class="org-kcats-brackets">[</span>2 * <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">infinite list</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">increment each</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[3 * 3 -] each</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">drop the first few</span>
5 dropper
<span class="org-comment-delimiter">;; </span><span class="org-comment">limit the list</span>
10 taker
<span class="org-comment-delimiter">;; </span><span class="org-comment">collect into list</span>
collect
<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>64 128 256 512 1024 2048 4096 8192
 16384 32768<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> generate
</pre>
</div>

<pre class="example">
1 [inc clone] 1
</pre>


<p>
Now express the debugger interface in terms of generated environment states!
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">the steps of execution</span>
<span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>0 0 10 1 range <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span> environment
<span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup something?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[]]</span>
 <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the generator, which needs to emit 'nothing' once the program is empty</span>
<span class="org-kcats-brackets">[[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> each
50 taker
laster
generate
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason word is not defined<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>laster generate<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>laster<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 50 <span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
           bail<span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>0 0 10 1 range <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<p>
implement 'laster' which returns only the last in the seq
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 100 1 range liberate
laster
generate
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> traversal <span class="org-comment-delimiter">;; </span><span class="org-comment">a generator for the list</span>
<span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> each
collect
</pre>
</div>
<pre class="example">
99 [generate [] swap [] [swap drop [generate] dip swap] while drop] liberate []
</pre>


<p>
Now implement 'keep' which returns only an item that passes the filter
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 
<span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> keep
1 dropper
10 taker
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]</span> each
collect
</pre>
</div>

<pre class="example">
[9 25 49 81 121 169 225 289 361 441] [generate [[clone *] bail] shielddown] [[positive?] [dec [generate] dip swap] [drop []] if] [[[positive?] [[generate drop] dip dec] while [generate swap] dip swapdown swap] bail] 0 [clone [[generate] dip [drop generate] while] dip swap] [[[something?] [odd? not]] [execute] every?] [inc clone] 21
</pre>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>something?<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> pair <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>every?<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">[odd? not]</span>

</pre>
</div>

<pre class="example">
[[[something?] [odd?]] every?]
</pre>


<p>
dropper (almost got it, doesn't detect end of parent stream yet)
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>0 20 1 range liberate
 5 dropper
 10 taker
 <span class="org-kcats-brackets">[</span>5 *<span class="org-kcats-brackets">]</span> each
 <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> keep
 collect<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>25 35 45 55 65<span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
Collect fix
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate

generate <span class="org-comment-delimiter">;; </span><span class="org-comment">n</span>
<span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span> <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n n r</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">r</span>
 <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">r n</span>
 <span class="org-builtin">swap</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">n n r </span>
<span class="org-preprocessor">loop</span> <span class="org-builtin">drop</span>
</pre>
</div>

<pre class="example">
[1 2 3] liberate []
</pre>


<div class="org-src-container">
<pre class="src src-kcats">integers 10 taker collect <span class="org-builtin">drop</span> generate 
</pre>
</div>

<pre class="example">
[] [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 9
</pre>
</div>
</div>

<div id="outline-container-org66c367c" class="outline-5">
<h5 id="org66c367c"><span class="section-number-5">1.6.38.2.</span> <span class="done DONE">DONE</span> map</h5>
</div>
<div id="outline-container-org68a3591" class="outline-5">
<h5 id="org68a3591"><span class="section-number-5">1.6.38.3.</span> <span class="done DONE">DONE</span> filter</h5>
</div>
<div id="outline-container-org52b1620" class="outline-5">
<h5 id="org52b1620"><span class="section-number-5">1.6.38.4.</span> <span class="done DONE">DONE</span> take</h5>
</div>
<div id="outline-container-org168e9a5" class="outline-5">
<h5 id="org168e9a5"><span class="section-number-5">1.6.38.5.</span> <span class="done DONE">DONE</span> drop</h5>
<div class="outline-text-5" id="text-1-6-38-5">
<div class="org-src-container">
<pre class="src src-kcats">integers 15 taker 10 dropper <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> reduce
</pre>
</div>

<pre class="example">
60 [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 14
</pre>
</div>
</div>

<div id="outline-container-org65cb5fd" class="outline-5">
<h5 id="org65cb5fd"><span class="section-number-5">1.6.38.6.</span> <span class="done CANCELED">CANCELED</span> last</h5>
</div>
<div id="outline-container-orgca1b2c4" class="outline-5">
<h5 id="orgca1b2c4"><span class="section-number-5">1.6.38.7.</span> <span class="todo TODO">TODO</span> distinct</h5>
<div class="outline-text-5" id="text-1-6-38-7">
<p>
depends on sets
</p>

<p>
The difference between this and just calling <code>set</code> is that the result is
still a list, and it preserves the original order, just removes
duplicates. Should be a similar impl to <code>keep</code>.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 1 3<span class="org-kcats-brackets">]</span> liberate
<span class="org-kcats-brackets">[]</span> set <span class="org-comment-delimiter">;; </span><span class="org-comment">state</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n seen g</span>

 <span class="org-kcats-brackets">[</span>contains?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">seen g</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n seen g</span>
 <span class="org-preprocessor">while</span>
<span class="org-kcats-brackets">]</span>
collect
</pre>
</div>

<pre class="example">
[1 1 3] [[generate] dive [contains?] [put [generate] dive] while] [] [take] []
</pre>
</div>
</div>

<div id="outline-container-org60399c9" class="outline-5">
<h5 id="org60399c9"><span class="section-number-5">1.6.38.8.</span> <span class="todo TODO">TODO</span> partition</h5>
</div>
<div id="outline-container-orgf49d6d2" class="outline-5">
<h5 id="orgf49d6d2"><span class="section-number-5">1.6.38.9.</span> <span class="done DONE">DONE</span> joiner (aka catenate)</h5>
<div class="outline-text-5" id="text-1-6-38-9">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>7 8 9<span class="org-kcats-brackets">]]</span>
liberate
<span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span>
 <span class="org-kcats-brackets">[]</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> 
 <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> 
generate
</pre>
</div>

<pre class="example">
[1 2 3 4 5 6 7 8 9] [generate [] swap [] [join [generate] dip swap] while drop] [take] []
</pre>
</div>
</div>

<div id="outline-container-orga17e212" class="outline-5">
<h5 id="orga17e212"><span class="section-number-5">1.6.38.10.</span> <span class="todo TODO">TODO</span> groupby</h5>
<div class="outline-text-5" id="text-1-6-38-10">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baaz"</span> <span class="org-string">"quux"</span><span class="org-kcats-brackets">]</span>
liberate <span class="org-comment-delimiter">;; </span><span class="org-comment">(the next word foo)</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">liberate ;; (the first letter f)</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>

<span class="org-function-name">wrap</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">k v state</span>
 <span class="org-function-name">wrap</span> <span class="org-builtin">swap</span>  <span class="org-comment-delimiter">;;  </span><span class="org-comment">v k state</span>
 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[]</span> association <span class="org-comment-delimiter">;; </span><span class="org-comment">state f</span>
<span class="org-builtin">swap</span>

cram
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>\q <span class="org-kcats-brackets">[</span><span class="org-string">"quux"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>\f <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>\b <span class="org-kcats-brackets">[</span><span class="org-string">"bar"</span> <span class="org-string">"baaz"</span><span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Ok so now we just need to insert the [take] program instead of
specifying it inline.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> group
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span>1 3<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>2 4<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org91a6983" class="outline-5">
<h5 id="org91a6983"><span class="section-number-5">1.6.38.11.</span> <span class="done CANCELED">CANCELED</span> Map/filter can't access lower stack items</h5>
<div class="outline-text-5" id="text-1-6-38-11">
</div>
<ol class="org-ol">
<li><a id="org32c9046"></a>Problem<br />
<div class="outline-text-6" id="text-1-6-38-11-1">
<p>
this doesn't work:
</p>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> each
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> 10
</pre>
</div>

<p>
We should get <code>[11 12 13]</code> but it errors out.
</p>

<p>
The reason is that when + runs, the generators are still on the stack,
in between this mapping function, and the original stack arguments.
</p>

<p>
We need a way to break out of the generation part of the stack and let
the mapping function access the arguments below it.
</p>

<p>
I can't immediately think of a good way to do it.
</p>

<p>
Actually I think that instead of recursively calling generate, and
passing the values back up the stack, there might be a way to build up
the program recursively, and then execute it in one swoop? 
</p>

<p>
Perhaps we can split each stage into several parts:
</p>

<ul class="org-ul">
<li>Generate from the layer below (in which case we obviously need the
layers below to get the next value)</li>
<li>dip underneath the layers to calculate the next value using lower stack items</li>
<li>swap the new value to the top of stack</li>
<li></li>
</ul>
</div>
</li>
<li><a id="org47e1f90"></a>Debug session<br />
<div class="outline-text-6" id="text-1-6-38-11-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> each generate<span class="org-kcats-brackets">]]]</span> environment
advance advance advance advance eval-<span class="org-function-name">step</span> <span class="org-kcats-brackets">[</span>advance<span class="org-kcats-brackets">]</span> 5 <span class="org-preprocessor">times</span> eval-<span class="org-function-name">step</span>
<span class="org-kcats-brackets">[</span>advance<span class="org-kcats-brackets">]</span> 2 <span class="org-preprocessor">times</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> 99 <span class="org-preprocessor">times</span> 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> each generate
</pre>
</div>

<pre class="example">
[[asked [number]] [reason "type mismatch"] [unwound [+ [[1 [take] [2 3] 10]] unwrap evert first swap drop [[generate [[+] bail] shielddown]] unwrap swap]] [actual [take]] [type error] [handled true]] 1 [take] [2 3] 10
</pre>



<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]]</span> environment advance<span class="org-kcats-brackets">]]]</span> environment advance advance eval-<span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>&lt;=<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>stack <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]]]]]</span>
</pre>
</div>
</div>
</li>
<li><a id="orgf2cf263"></a>Resolution<br />
<div class="outline-text-6" id="text-1-6-38-11-3">
<p>
After thinking about this some more, my conclusion:
</p>

<p>
This is supporting multi-arity mapping functions, which did work in
the original map implementation but they are not supported in other
languages. The way you access multiple values there is by closing over
them. So the way you'd do it in kcats is like so:
</p>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the extra arg and the list</span>
<span class="org-kcats-brackets">[</span>-<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the multi-arity map fn</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">clone the 10</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend <span class="org-comment-delimiter">;; </span><span class="org-comment">prepend the word swap to the fn so that the 10 ends up beneath the list item</span>
<span class="org-builtin">float</span> prepend <span class="org-comment-delimiter">;; </span><span class="org-comment">prepend the 10</span>
<span class="org-function-name">map</span>
</pre>
</div>

<pre class="example">
[9 8 7] 10
</pre>


<p>
In theory we could write a helper function called <code>capture1</code> or something that does this for us, so you can write
</p>

<pre class="example">
10 [1 2 3] [-] capture1 map
</pre>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the extra arg and the list</span>
<span class="org-kcats-brackets">[</span>-<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the multi-arity map fn</span>

<span class="org-kcats-brackets">[</span><span class="org-builtin">swapdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">f i</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend
 <span class="org-builtin">swap</span> prepend<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>
<span class="org-kcats-brackets">[</span>liberate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> each collect
</pre>
</div>

<pre class="example">
[9 8 7] [generate [[10 swap -] bail] shielddown] [take] [] 10
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 <span class="org-string">"oh fudge"</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>5 +<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 5<span class="org-kcats-brackets">]</span>
 recover<span class="org-kcats-brackets">]</span>
<span class="org-function-name">map</span>
</pre>
</div>

<pre class="example">
[6 7 5]
</pre>
</div>
</li>
<li><a id="org1cc1d66"></a><span class="done DONE">DONE</span> Add functions to help capture environment for map/filter fns<br />
<div class="outline-text-6" id="text-1-6-38-11-4">
<p>
It's too difficult to do this manually.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-kcats-brackets">[</span>2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
</pre>
</div>

<p>
we want to redesign this so that we build the mapping function first:
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> capture
<span class="org-kcats-brackets">[</span>2 3 4<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">map</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>3 4 5<span class="org-kcats-brackets">]</span> 1
</pre>
</div>

<p>
and the generator equivalent
</p>
<div class="org-src-container">
<pre class="src src-kcats">5 <span class="org-kcats-brackets">[</span>* inc<span class="org-kcats-brackets">]</span> capture <span class="org-kcats-brackets">[</span>integers 100 dropper 10 taker<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> each collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>501 506 511 516 521 526 531 536 541 546<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[[</span>5<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> * inc<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 0 <span class="org-kcats-brackets">[[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>generate <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span>
                                                             <span class="org-preprocessor">dip</span> dec<span class="org-kcats-brackets">]</span>
                                                <span class="org-preprocessor">while</span> <span class="org-kcats-brackets">[</span>generate <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
                                                <span class="org-preprocessor">dip</span> <span class="org-builtin">float</span><span class="org-kcats-brackets">]</span>
                                               bail<span class="org-kcats-brackets">]</span>
0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
109 5
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org75e87a8" class="outline-5">
<h5 id="org75e87a8"><span class="section-number-5">1.6.38.12.</span> <span class="done DONE">DONE</span> Reduce</h5>
<div class="outline-text-5" id="text-1-6-38-12">
<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 30 taker <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc f</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">drop [generate] divedown [] [float execute clone] [] if</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">acc f g</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i acc f g</span>
 <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-preprocessor">execute</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc f g</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 10 taker 
generate <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc </span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">drop [generate] divedown [] [float execute clone] [] if</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">acc g</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i acc g</span>
 <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>+ <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc f g</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">55 <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 10
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 3 taker
<span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">build the 'then' branch</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; [+ clone]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">build the loop body</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[]]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">generate the first item under the loop body</span>
<span class="org-kcats-brackets">[</span>generate <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">6 <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 3
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 2 3 4 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span>
</pre>
</div>

<pre class="example">
3 4 3
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span> inc <span class="org-builtin">clone</span> 5 &lt; <span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span>
</pre>
</div>

<pre class="example">
5
</pre>


<div class="org-src-container">
<pre class="src src-kcats">integers
1 dropper <span class="org-comment-delimiter">;; </span><span class="org-comment">start with 1</span>
1000 taker <span class="org-comment-delimiter">;; </span><span class="org-comment">take items</span>
<span class="org-kcats-brackets">[</span>3 *<span class="org-kcats-brackets">]</span> each
<span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> keep
<span class="org-kcats-brackets">[</span>+ 37 mod<span class="org-kcats-brackets">]</span> reduce
</pre>
</div>

<pre class="example">
10 [clone [[generate] dip [drop generate] while] dive] [[[something?] [odd? not]] [execute] every?] [generate [[3 *] bail] shielddown] [[positive?] [dec [generate] dive] [drop []] if] [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [inc clone] 1000
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1025 8 mod
</pre>
</div>

<pre class="example">
1
</pre>


<p>
let's make an equivalent to <code>map</code> (that doesn't require a generator) for ease of use
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span>  
</pre>
</div>

<p>
&#x2026;wait a minute, isn't that just <code>step</code>?
</p>
</div>
</div>
</div>
<div id="outline-container-orgabb2341" class="outline-4">
<h4 id="orgabb2341"><span class="section-number-4">1.6.39.</span> <span class="done DONE">DONE</span> Investigate simpler map/filter impls</h4>
<div class="outline-text-4" id="text-1-6-39">
<div class="org-src-container">
<pre class="src src-kcats">7 8 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">sink</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shielddown</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> decorate <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> 8 7
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">3 <span class="org-kcats-brackets">[</span>1 2 3 4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> odd?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">sink</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> decorate <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend <span class="org-kcats-brackets">[</span><span class="org-builtin">sink</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5 6<span class="org-kcats-brackets">]</span> 3
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8c3702" class="outline-4">
<h4 id="orgd8c3702"><span class="section-number-4">1.6.40.</span> <span class="done DONE">DONE</span> Allow generator transforms to work on pipes</h4>
<div class="outline-text-4" id="text-1-6-40">
<p>
pipe + [take] = generator
</p>
</div>
</div>
<div id="outline-container-org450e2c1" class="outline-4">
<h4 id="org450e2c1"><span class="section-number-4">1.6.41.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement hashset&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-6-41">
<p>
Once we have this, we can implement stuff like the <code>distinct</code> transform
function.
</p>
</div>

<div id="outline-container-orgff68c51" class="outline-5">
<h5 id="orgff68c51"><span class="section-number-5">1.6.41.1.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement set membership check</h5>
<div class="outline-text-5" id="text-1-6-41-1">
<p>
Could possibly piggyback on <code>lookup</code> here, but the semantics are a
little different (nested sets are not allowed, return value is the
same as the key argument).
</p>

<p>
Another option is to call it <code>contains?</code> and check for membership. The
implementation could accept any Sized type, but it's not obvious how
to handle map types - are we checking just for the key, or key/val
pair? I lean slightly toward just the key, but hard to say. For list
types do we convert or promote to set, or just do a (worst case) full
pass over the elements? Vec[Deque] has a contains method so I'm
inclined to just use that.
</p>
</div>

<ol class="org-ol">
<li><a id="orgef13997"></a><span class="todo TODO">TODO</span> Substring or subcollection<br />
<div class="outline-text-6" id="text-1-6-41-1-1">
<p>
Included as part of this should be substring and subarray checking. eg
<code>"foobar" "bar" contains?</code> should return <code>true</code>. It's a different behavior
when the member and collection are the same type vs different
types. Should probably error when it's two different collection types,
eg <code>[1 2 3] [2 3] set contains?</code> should error.
</p>
</div>
</li>
</ol>
</div>
</div>


<div id="outline-container-org05895c5" class="outline-4">
<h4 id="org05895c5"><span class="section-number-4">1.6.42.</span> <span class="done DONE">DONE</span> Implement until</h4>
<div class="outline-text-4" id="text-1-6-42">
<p>
like <code>while</code> but always runs the body once.
</p>

<div class="org-src-container">
<pre class="src src-kcats">64 <span class="org-kcats-brackets">[</span>50 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">until</span>
<span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pred body</span>
<span class="org-kcats-brackets">[</span>not<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">reverse logic</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> decorate <span class="org-comment-delimiter">;; </span><span class="org-comment">add shield to the pred program -&gt; pred body</span>
<span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">[body ..  pred]</span>
<span class="org-keyword">true</span> <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">run at least once</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">4096
</pre>
</div>

<p>
use until in places I wish i'd had it:
laster:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> liberate
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[</span>empty?<span class="org-kcats-brackets">]</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">l sl</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">sl l</span>
  <span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">l</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">sl l</span>
  <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">l sl </span>
 <span class="org-preprocessor">until</span> <span class="org-builtin">swap</span>
 <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">dipdown</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">replace the empty state</span>
collect
</pre>
</div>

<p>
joiner
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>7 8 9<span class="org-kcats-brackets">]]</span> liberate
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">r</span>
 <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">r i</span>
 <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i r</span>
 <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i i r</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i r2</span>
<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">until</span>  generate
</pre>
</div>
<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5 6 7 8 9<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> liberate generate
</pre>
</div>

<pre class="example">
1 [take] [2 3 4]
</pre>
</div>
</div>

<div id="outline-container-orgdf2ac3f" class="outline-4">
<h4 id="orgdf2ac3f"><span class="section-number-4">1.6.43.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement sorting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h4>
<div class="outline-text-4" id="text-1-6-43">
</div>
<div id="outline-container-org0e25471" class="outline-5">
<h5 id="org0e25471"><span class="section-number-5">1.6.43.1.</span> <span class="todo TODO">TODO</span> Implement partialord</h5>
<div class="outline-text-5" id="text-1-6-43-1">
<p>
Each type needs to be comparable to another.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-string">"b"</span> 2<span class="org-kcats-brackets">][</span><span class="org-string">"g"</span> 5<span class="org-kcats-brackets">][</span><span class="org-string">"a"</span>, 1<span class="org-kcats-brackets">][</span><span class="org-string">"d"</span> 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"c"</span> 3<span class="org-kcats-brackets">]]</span> association sort-indexed
</pre>
</div>

<pre class="example">
[1 2 3 4 5]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>-2 10 -8 -12 8 0 1 20<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>5 - abs<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span> pair<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-function-name">map</span>  sort-indexed 
</pre>
</div>

<pre class="example">
Pair is (Int(-2), Int(7))
Pair is (Int(10), Int(5))
Pair is (Int(-8), Int(13))
Pair is (Int(-12), Int(17))
Pair is (Int(8), Int(3))
Pair is (Int(0), Int(5))
Pair is (Int(1), Int(4))
Pair is (Int(20), Int(15))
[8 1 10 0 -2 -8 20 -12]
</pre>


<p>
UHOH
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"hi"</span> <span class="org-string">"there"</span> <span class="org-string">"what"</span> <span class="org-string">"is"</span> <span class="org-string">"your"</span> <span class="org-string">"birthdate"</span> <span class="org-string">"homeboy"</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span>pair<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-function-name">map</span>  sort-indexed 
</pre>
</div>

<pre class="example">
Pair is (Iterable(Sized(String("hi"))), String("hi"))
Pair is (Iterable(Sized(String("there"))), String("there"))
Pair is (Iterable(Sized(String("what"))), String("what"))
Pair is (Iterable(Sized(String("is"))), String("is"))
Pair is (Iterable(Sized(String("your"))), String("your"))
Pair is (Iterable(Sized(String("birthdate"))), String("birthdate"))
Pair is (Iterable(Sized(String("homeboy"))), String("homeboy"))
["birthdate" "hi" "homeboy" "is" "there" "what" "your"]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">8 5 - 
</pre>
</div>

<pre class="example">
3
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 2 <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> both
</pre>
</div>

<pre class="example">
[[reason "word is not defined"] [unwound [both]] [type error] [asked [both]] [handled true]] [inc] 2 1
</pre>
</div>
</div>

<div id="outline-container-org82daec8" class="outline-5">
<h5 id="org82daec8"><span class="section-number-5">1.6.43.2.</span> <span class="todo TODO">TODO</span> Make floats hashable</h5>
<div class="outline-text-5" id="text-1-6-43-2">
<p>
This will allow floats to be added to the <code>KeyItem</code> enum. Floats are not
normally hashable, because mathematically identical numbers are not
always represented the same way in memory and wouldn't hash the
same. But for the purposes of kcats, I think this doesn't matter. We
can document that you can't expect (10.0 + 10.0) and (15.0 + 5.0) to
be the same map key.
</p>

<p>
This will then allow a list that contains floats, to be sorted, or be
able to use float values as a sort-by key.
</p>
</div>
</div>

<div id="outline-container-orge37c0cd" class="outline-5">
<h5 id="orge37c0cd"><span class="section-number-5">1.6.43.3.</span> <span class="todo TODO">TODO</span> Implement compare</h5>
<div class="outline-text-5" id="text-1-6-43-3">
<p>
Should expose Rust's comparison function. That will allow a native
sort function, for max flexibility (but not performance).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"a"</span> <span class="org-string">"b"</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"a"</span> <span class="org-string">"a"</span> compare
</pre>
</div>

<pre class="example">
equal
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"a"</span> <span class="org-string">"c"</span><span class="org-kcats-brackets">]</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<p>
This should work - the empty set and map maybe can't be compared but Nothing should be in there.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> -1000 compare
</pre>
</div>

<pre class="example">
less
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d01655" class="outline-4">
<h4 id="org8d01655"><span class="section-number-4">1.6.44.</span> <span class="done DONE">DONE</span> CI on github&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
</div>

<div id="outline-container-orgaf9acab" class="outline-4">
<h4 id="orgaf9acab"><span class="section-number-4">1.6.45.</span> <span class="done DONE">DONE</span> Add a kcats logo to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
</div>

<div id="outline-container-org6526077" class="outline-4">
<h4 id="org6526077"><span class="section-number-4">1.6.46.</span> <span class="done DONE">DONE</span> Add a video snippet of repl interaction to github project page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
</div>

<div id="outline-container-org538e908" class="outline-4">
<h4 id="org538e908"><span class="section-number-4">1.6.47.</span> <span class="todo INPROGRESS">INPROGRESS</span> Write an alpha release announcement&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
<div class="outline-text-4" id="text-1-6-47">
<p>
Show HN: Kcats: A Powerful, Beginner-Friendly, Stack-Based Programming Language
</p>
<div class="org-src-container">
<pre class="src src-fundamental">Hello everyone,

I'm excited to introduce the alpha release of kcats, a fresh take on stack-based programming languages, inspired by the language Joy, designed with simplicity, learnability, and functionality in mind.

Our aim with kcats is to make it easier for anyone to write short programs for personal automation tasks. We believe that existing languages require learning too many specialized functions and concepts. Kcats addresses these issues by offering a streamlined alternative. Originally conceived as a scripting language for a forthcoming messaging protocol, it's useful for general programming as well.

Key features of kcats:

    Simplicity: kcats emphasizes fewer, general-purpose tools instead
    of a complex array of specialized ones. Its syntax uses words and
    bracket quotation marks [ and ], and no other symbols. It uses a
    few simple programming concepts including stacks, lists,
    functions, and pipes.

    Introspective: The documentation, examples, and even the entire
    state of a running program, are data that can be queried and
    processed with the language itself. Kcats is its own debugger.

    Powerful and Versatile: Despite its simplicity, kcats is designed
    to be a powerful tool capable of handling a wide range of
    programming tasks. The tools programmers use in other languages
    are there, and built from simple primitives - closures, error
    handling, metaprogramming, multithreading, channels, generators,
    i/o, and serialization.

    A Focus on Tooling: kcats intends to make tool development,
    including IDEs and debuggers, as easy as possible.

As this is the alpha release, we eagerly welcome all feedback, contributions, and constructive criticisms from the community. We're especially interested in improving the documentation and learning experience.

Join us in exploring this new language and contribute to making programming more accessible to everyone. Your feedback is essential to making it intuitive and easy to use!

Please check out our docs and alpha release here:
https://github.com/skyrod-vactai/kcats

Happy coding!

Best, Skyrod
</pre>
</div>
<div class="org-src-container">
<pre class="src src-fundamental">Announcing the Alpha Release of kcats: A Simple, Powerful,
Beginner-Friendly, Stack-Based Programming Language

Hello everyone,

I'm excited to introduce the alpha release of kcats, a fresh take on
stack-based programming languages, inspired by the language Joy,
designed with simplicity, learnability, and functionality in mind.

Our aim with kcats is to make it easier for anyone to write short
programs for personal automation tasks. We believe that existing
languages require learning too many specialized functions and
concepts. Kcats addresses these issues by offering a streamlined
alternative. Originally conceived as a scripting language for a
forthcoming messaging protocol, it's useful for general programming as
well.

Key features of kcats:

    Simplicity: kcats emphasizes fewer, general-purpose tools instead
    of a complex array of specialized ones. Its syntax uses words and
    bracket quotation marks [ and ], and no other symbols. It uses a
    few simple programming concepts including stacks, lists,
    functions, and pipes.

    Introspective: The documentation, examples, and even the entire
    state of a running program, are data that can be queried and
    processed with the language itself. Kcats is its own debugger.

    Powerful and Versatile: Despite its simplicity, kcats is designed
    to be a powerful tool capable of handling a wide range of
    programming tasks. The tools programmers use in other languages
    are there, and built from simple primitives - closures, error
    handling, metaprogramming, multithreading, channels, generators,
    i/o, and serialization.

    A Focus on Tooling: kcats intends to make tool development,
    including IDEs and debuggers, as easy as possible.

As this is the alpha release, we eagerly welcome all feedback,
contributions, and constructive criticisms from the community. We're
especially interested in improving the documentation and learning
experience.

Join us in exploring this new language and contribute to making
programming more accessible to everyone. Your feedback is essential to
making it intuitive and easy to use!

Please check out our alpha release here:
https://github.com/skyrod-vactai/kcats

Happy coding!

Best, Skyrod

</pre>
</div>
</div>
</div>

<div id="outline-container-orge6aa5aa" class="outline-4">
<h4 id="orge6aa5aa"><span class="section-number-4">1.6.48.</span> <span class="todo INPROGRESS">INPROGRESS</span> Post announcement on various forums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="alpha">alpha</span></span></h4>
<div class="outline-text-4" id="text-1-6-48">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> Hacker news</li>
<li class="on"><code>[X]</code> Reddit r/concatenative</li>
<li class="off"><code>[&#xa0;]</code> Reddit r/programming</li>
<li class="off"><code>[&#xa0;]</code> r/learnprogramming</li>
<li class="off"><code>[&#xa0;]</code> r/coding</li>
<li class="on"><code>[X]</code> programming.dev</li>
</ul>
</div>
<div id="outline-container-orgc924f79" class="outline-5">
<h5 id="orgc924f79"><span class="section-number-5">1.6.48.1.</span> <span class="done DONE">DONE</span> Solve some programmer.dev challenges</h5>
<div class="outline-text-5" id="text-1-6-48-1">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-05 Thu 11:11]</span></span></li>
</ul>
<p>
Remove matching parens
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"[(({})({)(()}]"</span>
<span class="org-kcats-brackets">[[</span>\<span class="org-kcats-brackets">[</span> \<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>\{ \}<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>\( \)<span class="org-kcats-brackets">]]</span>
<span class="org-string">""</span> <span class="org-builtin">float</span>
<span class="org-kcats-brackets">[[[</span><span class="org-function-name">last</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> =<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-function-name">pop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
 <span class="org-builtin">dropdown</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"[(({)(}]"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgadd5b31" class="outline-4">
<h4 id="orgadd5b31"><span class="section-number-4">1.6.49.</span> <span class="todo TODO">TODO</span> Stream transformation</h4>
<div class="outline-text-4" id="text-1-6-49">
<p>
Problem: kcats doesn't speak http or https or various other protocols
and formats, but rust does. We want to be able to use the complicated
bits of rust, but let kcats decide how to combine them.
</p>

<p>
Implementation: I think we may need to create a new Rust enum Item
type, that acts as a generator. It has an input method "next<sub>input</sub>"
that takes an input chunk which is the result of the generator
beneath, then it either returns None (updated the state, but no new
item yet), or Item (got a new item), or some signal for end of stream,
or Error. So it would have some program with a while loop to
iterate. All such transforms would probably have the same program.
</p>
</div>
</div>

<div id="outline-container-orgaf0f338" class="outline-4">
<h4 id="orgaf0f338"><span class="section-number-4">1.6.50.</span> <span class="done DONE">DONE</span> Auto code formatter</h4>
<div class="outline-text-4" id="text-1-6-50">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-09-22 Fri 09:25]</span></span></li>
</ul>
<p>
This is desperately needed, as a big blob of output line-wrapped is
very hard to read.
</p>

<p>
I am not sure exactly how to determine where line breaks should occur
but literally anything is better than how it is now.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo bar<span class="org-kcats-brackets">][</span>baz <span class="org-kcats-brackets">[[</span>quux floop<span class="org-kcats-brackets">][</span>toop poop<span class="org-kcats-brackets">]]]]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo bar<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>baz <span class="org-kcats-brackets">[[</span>quux floop<span class="org-kcats-brackets">]</span>
       <span class="org-kcats-brackets">[</span>toop poop<span class="org-kcats-brackets">]]]]</span>
</pre>
</div>

<p>
now test decreasing indent
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>baz <span class="org-kcats-brackets">[[</span>quux floop<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>toop poop<span class="org-kcats-brackets">]]]</span> goop<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo bar<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>baz <span class="org-kcats-brackets">[[</span>quux floop<span class="org-kcats-brackets">]</span>
       <span class="org-kcats-brackets">[</span>toop poop<span class="org-kcats-brackets">]]]</span>
 goop<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>7 8 9<span class="org-kcats-brackets">]]</span> liberate <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">until</span>  generate<span class="org-kcats-brackets">]</span> <span class="org-function-name">reverse</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>generate <span class="org-preprocessor">until</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> liberate
 <span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>7 8 9<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>blahblah blah <span class="org-kcats-brackets">[</span>blah blah foop foop <span class="org-kcats-brackets">[</span>toopy<span class="org-kcats-brackets">]</span> foop foop<span class="org-kcats-brackets">]</span> toop <span class="org-kcats-brackets">[</span>blah foop<span class="org-kcats-brackets">]</span> toopy<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>blahblah blah <span class="org-kcats-brackets">[</span>blah blah foop foop <span class="org-kcats-brackets">[</span>toopy<span class="org-kcats-brackets">]</span> foop foop<span class="org-kcats-brackets">]</span> toop <span class="org-kcats-brackets">[</span>blah foop<span class="org-kcats-brackets">]</span>
 toopy<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>1 2 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>1 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>1 2 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">false</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>1 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[]</span> b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[]</span> b<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span> <span class="org-string">"hello"</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"hello"</span> <span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]</span>
         <span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga51837e" class="outline-4">
<h4 id="orga51837e"><span class="section-number-4">1.6.51.</span> <span class="done DONE">DONE</span> Have eval-step return nothing when program is done</h4>
<div class="outline-text-4" id="text-1-6-51">
<p>
That means eval needs to keep the input until it checks the output.
</p>

<p>
That may make normal runtime a little less efficient but it means
debuggers and step generators are easy and more efficient.
</p>

<p>
At that point <code>stepper</code> can be removed and we can use <code>eval-step</code> in its place. 
</p>

<p>
(actually stepper still has a use, it just doesn't need to check for <code>nothing</code> anymore)
</p>
</div>
</div>

<div id="outline-container-orgee586e2" class="outline-4">
<h4 id="orgee586e2"><span class="section-number-4">1.6.52.</span> <span class="todo INPROGRESS">INPROGRESS</span> Select from multiple pipes</h4>
<div class="outline-text-4" id="text-1-6-52">
<p>
A basic select (which I call <code>attend</code>) is in place. 
</p>
</div>

<div id="outline-container-org203a17b" class="outline-5">
<h5 id="org203a17b"><span class="section-number-5">1.6.52.1.</span> <span class="todo TODO">TODO</span> Attend should leave the pipe list argument</h5>
<div class="outline-text-5" id="text-1-6-52-1">
<p>
A lot of callers would want to re-use that argument so it shouldn't
need to be shielded by default.
</p>
</div>
</div>

<div id="outline-container-org2022327" class="outline-5">
<h5 id="org2022327"><span class="section-number-5">1.6.52.2.</span> <span class="todo TODO">TODO</span> Better error handling</h5>
<div class="outline-text-5" id="text-1-6-52-2">
<p>
There's lots of places where flume could throw an error and we don't
do anything about it.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc065a63" class="outline-4">
<h4 id="orgc065a63"><span class="section-number-4">1.6.53.</span> <span class="done DONE">DONE</span> print</h4>
<div class="outline-text-4" id="text-1-6-53">
<p>
It's probably just an alias for something like <code>[standard] dip bytes put
drop</code> (write to stdout and then drop the pipe).
</p>
</div>
</div>

<div id="outline-container-org41eb9f0" class="outline-4">
<h4 id="org41eb9f0"><span class="section-number-4">1.6.54.</span> <span class="done DONE">DONE</span> Remove references to "expression"</h4>
<div class="outline-text-4" id="text-1-6-54">
<p>
I think the expression is just a "program". I suppose <b>the</b> program. But
still "program". And yes, it gets shorter as it runs. Still, it's a program.
</p>
</div>
<div id="outline-container-org522b0f3" class="outline-5">
<h5 id="org522b0f3"><span class="section-number-5">1.6.54.1.</span> <span class="done DONE">DONE</span> Clear up odd language</h5>
<div class="outline-text-5" id="text-1-6-54-1">
<p>
There are places in the docs where we used "expression" and "program"
in the same phrase, where now it says program in both places, and it's
confusing.
</p>
</div>
</div>
</div>
<div id="outline-container-org56fae07" class="outline-4">
<h4 id="org56fae07"><span class="section-number-4">1.6.55.</span> <span class="done DONE">DONE</span> implement breakpoints</h4>
<div class="outline-text-4" id="text-1-6-55">
</div>
<div id="outline-container-orgdb2a035" class="outline-5">
<h5 id="orgdb2a035"><span class="section-number-5">1.6.55.1.</span> <span class="done DONE">DONE</span> Fix break arg order</h5>
<div class="outline-text-5" id="text-1-6-55-1">
<p>
I think the args are in the wrong order - env should be under the program.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span> environment
<span class="org-kcats-brackets">[[</span>program 0<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> =<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span><span class="org-builtin">swap</span> something?<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">still running</span>
  <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span> not<span class="org-kcats-brackets">]]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">check condition not true yet</span>
 <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span>
 every?<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">break?</span>
<span class="org-kcats-brackets">[[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">evaluate the environment one step</span>
<span class="org-preprocessor">while</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program 0<span class="org-kcats-brackets">]</span>
 lookup <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> =<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span>1 1<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>+ <span class="org-kcats-brackets">[</span>2 3<span class="org-kcats-brackets">]</span>
              <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd0a807a" class="outline-5">
<h5 id="orgd0a807a"><span class="section-number-5">1.6.55.2.</span> <span class="done DONE">DONE</span> Test breakpoint</h5>
<div class="outline-text-5" id="text-1-6-55-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>2 <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 *<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span><span class="org-kcats-brackets">]]]</span> environment <span class="org-kcats-brackets">[</span>sprint <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>2<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[[</span>2 *<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]]</span>
               <span class="org-function-name">unwrap</span> <span class="org-function-name">join</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>100 2<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>4<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>2 * <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>100 4<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>8<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>2 * <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>100 8<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>16<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>2 * <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>100 16<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>32<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>2 * <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>100 32<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>64<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>2 * <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>100 64<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span>100 128<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>&lt; <span class="org-kcats-brackets">[[</span>128<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>2 * <span class="org-kcats-brackets">[</span>100 breakpoint &lt;<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]]]</span>
<span class="org-kcats-brackets">[</span>sprint <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org36708a9" class="outline-4">
<h4 id="org36708a9"><span class="section-number-4">1.6.56.</span> <span class="todo TODO">TODO</span> Monitoring tools</h4>
<div class="outline-text-4" id="text-1-6-56">
</div>
<div id="outline-container-orgec931d7" class="outline-5">
<h5 id="orgec931d7"><span class="section-number-5">1.6.56.1.</span> <span class="todo TODO">TODO</span> Reporting back to the mothership</h5>
<div class="outline-text-5" id="text-1-6-56-1">
<p>
When we spawn/animate, the environment is in its own universe and the
main environment has no way to get any information about it, except by
whatever means are baked into the spawned env's program. Users can
come up with their own scheme of sending some kind of result via a
pipe, of course. But what happens if the program encounters an error?
</p>

<p>
It would be nice to wrap the program such that it reports the final
stack via a pipe, back to the main environment. And in the main env,
it would be nice to keep a list of those pipes so we can select and
get updates. Note, need to compare and contrast with the existing
mechanism in 'future'.
</p>

<p>
Another nice tool would be the ability to send the current state back
on demand (sort of like a thread dump) - in the spawned env, call
eval-step until some signal comes in on the pipe from the main env,
then send back a copy of the env. This mechanism could be used later
to implement a monitoring tool.
</p>

<p>
How to do this: I think a combination of "channel of channels", and
redefinition of <code>spawn</code> with <code>let</code> should go a long way. The
channel-channel lets new nested envs send back reply channels to the
master env, even if they are deeply nested. Redefining <code>spawn</code> lets us
insert the code to send those channels back (by passing in the channel
that leads back to the master env). What would be really handy is
parsing the inner env data to see which references to channels it
contains, seeing whether it's a sender or receiver, and drawing arrows
between envs so users can see they talk to each other.
</p>
</div>
</div>
<div id="outline-container-org5a31308" class="outline-5">
<h5 id="org5a31308"><span class="section-number-5">1.6.56.2.</span> <span class="todo TODO">TODO</span> Monitoring UI</h5>
<div class="outline-text-5" id="text-1-6-56-2">
<p>
We could show not only all the envs and ther recent state (perhaps
dumped every few seconds), we could show arrows between environments
that represent pipes (if two envs have a copy of the same pipe
anywhere in the stack or program, draw an arrow. If one env has a
sender and the other receiver, then show an arrow indicating the
direction of data flow along with the pipe id.
</p>

<p>
We could also allow views into a particular pipe where we copy the
last handful of values to pass through (this is doable for channels
but probably not file/network pipes).
</p>
</div>
</div>
</div>
<div id="outline-container-org523a8e7" class="outline-4">
<h4 id="org523a8e7"><span class="section-number-4">1.6.57.</span> <span class="done DONE">DONE</span> Rewrite future in terms of spawn</h4>
<div class="outline-text-4" id="text-1-6-57">
<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">do other stuff</span>

handoff <span class="org-builtin">swap</span> 
<span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">return the whole stack</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dive</span> <span class="org-function-name">put</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> 
spawn animate

  4 5 + <span class="org-builtin">drop</span>

<span class="org-function-name">take</span> <span class="org-builtin">dropdown</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]</span> 1
</pre>
</div>
</div>
</div>
<div id="outline-container-org3fd93e6" class="outline-4">
<h4 id="org3fd93e6"><span class="section-number-4">1.6.58.</span> <span class="done DONE">DONE</span> Re-implement let</h4>
<div class="outline-text-4" id="text-1-6-58">
<p>
I think it's pretty useless as-is. I think it should just be a quicker
version of lingo, where you don't need to specify a spec, and it
always adds items to the dictionary instead of arbitrary changes.
</p>

<div class="org-src-container">
<pre class="src src-kcats">  <span class="org-kcats-brackets">[[</span>times5 <span class="org-kcats-brackets">[</span>5 *<span class="org-kcats-brackets">]]</span>
   <span class="org-kcats-brackets">[</span>doubledec <span class="org-kcats-brackets">[</span>dec dec<span class="org-kcats-brackets">]]]</span>
  <span class="org-kcats-brackets">[</span>3 times5 doubledec<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[]]]]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">spec of self-insert</span>
          <span class="org-kcats-brackets">[</span>definition<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span>
         assign<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">build a full entry</span>
    update<span class="org-kcats-brackets">]</span>
   <span class="org-function-name">map</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
lingo
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">13
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbd99736" class="outline-4">
<h4 id="orgbd99736"><span class="section-number-4">1.6.59.</span> <span class="todo INPROGRESS">INPROGRESS</span> Native REPL</h4>
<div class="outline-text-4" id="text-1-6-59">
</div>
<div id="outline-container-orgc959d4a" class="outline-5">
<h5 id="orgc959d4a"><span class="section-number-5">1.6.59.1.</span> <span class="todo TODO">TODO</span> Main mode of reading program from cmdline or file</h5>
</div>
<div id="outline-container-org80c4b7b" class="outline-5">
<h5 id="org80c4b7b"><span class="section-number-5">1.6.59.2.</span> <span class="todo TODO">TODO</span> REPL as a kcats program</h5>
<div class="outline-text-5" id="text-1-6-59-2">
<p>
Read inputs from stdin, eval in a nested env, write to stdout.
</p>
</div>
</div>
</div>
<div id="outline-container-org096c1af" class="outline-4">
<h4 id="org096c1af"><span class="section-number-4">1.6.60.</span> <span class="todo TODO">TODO</span> Words that quote programs instead of executing them</h4>
<div class="outline-text-4" id="text-1-6-60">
<p>
eg <code>liberate</code> - it is just <code>[take]</code>, so it doesn't actually do anything by
itself. It seems like the quotedness should remain and maybe the word
should always perform the action.
</p>

<p>
In that case we would have to write <code>5 [taker]</code>. I'm not thrilled with
that either, but maybe it's just not a good name.
</p>

<p>
It does seem like there's an inconsistency having a word quote a
program instead of the caller doing it.
</p>

<p>
There are certainly words that operate on programs without executing
them (like <code>each</code>) but the word is still executing a program vs just
self-inserting one object.
</p>

<p>
So I think I do have to fix this. I'm just not sure what to do.
</p>

<p>
I think it will <b>look</b> inconsistent to write:
</p>
<div class="org-src-container">
<pre class="src src-kcats">integers
5 <span class="org-kcats-brackets">[</span>taker<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> each
</pre>
</div>
<p>
People will see that and wonder why <code>taker</code> is quoted but not <code>each</code>. It
makes sense when you dive into it (each modifies a program and taker
executes a program).
</p>
</div>
</div>
<div id="outline-container-org0fcadb6" class="outline-4">
<h4 id="org0fcadb6"><span class="section-number-4">1.6.61.</span> <span class="done DONE">DONE</span> Loop combinator that has an initialization program</h4>
<div class="outline-text-4" id="text-1-6-61">
<p>
Like <code>while</code> but calls init before starting and each time through the loop. Call it <code>prime</code>?
</p>
<div class="org-src-container">
<pre class="src src-kcats">timestamps
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dump <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-builtin">float</span>  <span class="org-function-name">join</span> <span class="org-preprocessor">while</span>  
</pre>
</div>
</div>
</div>
<div id="outline-container-org75c5d7e" class="outline-4">
<h4 id="org75c5d7e"><span class="section-number-4">1.6.62.</span> <span class="done DONE">DONE</span> startswith/endswith</h4>
<div class="outline-text-4" id="text-1-6-62">
<p>
Note this impl is not efficient because it zips the entire input
before starting comparison. An efficient one would keep an index
counter and compare via lookup.
</p>

<p>
starts
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"abcd"</span> <span class="org-string">""</span> zip <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> every? 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span>
</pre>
</div>

<p>
ends
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"abcd"</span> <span class="org-string">"abcd"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> both zip <span class="org-kcats-brackets">[[</span>=<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-kcats-brackets">[]</span> every? 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org56ca522" class="outline-4">
<h4 id="org56ca522"><span class="section-number-4">1.6.63.</span> <span class="done DONE">DONE</span> map doesn't handle nothing values</h4>
<div class="outline-text-4" id="text-1-6-63">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> <span class="org-kcats-brackets">[]</span> <span class="org-keyword">true</span> <span class="org-kcats-brackets">[]</span> <span class="org-keyword">true</span><span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
ughhh should probably revert the change that left map in terms of
generators, because map isn't indefinite and has different handling of <code>nothing</code>.
</p>
</div>
</div>
<div id="outline-container-orge13e11d" class="outline-4">
<h4 id="orge13e11d"><span class="section-number-4">1.6.64.</span> <span class="todo INPROGRESS">INPROGRESS</span> Separate formatting from emitting</h4>
<div class="outline-text-4" id="text-1-6-64">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-09-23 Sat 10:29]</span></span></li>
</ul>
</div>
</div>
<div id="outline-container-orgbc7c05c" class="outline-4">
<h4 id="orgbc7c05c"><span class="section-number-4">1.6.65.</span> <span class="todo TODO">TODO</span> Fix line breaks with byte literals</h4>
<div class="outline-text-4" id="text-1-6-65">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>public #b64 <span class="org-string">"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>secret #b64 <span class="org-string">"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type elliptic-curve-key<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
Line break doesn't get added because it thinks <code>#b64</code> is an item when
it's really a parsing hint.
</p>
</div>
</div>
<div id="outline-container-org237000b" class="outline-4">
<h4 id="org237000b"><span class="section-number-4">1.6.66.</span> <span class="todo INPROGRESS">INPROGRESS</span> slice ordered items</h4>
<div class="outline-text-4" id="text-1-6-66">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-04 Wed 19:00]</span></span></li>
</ul>
<p>
We have indexing to a single subitem but we need to be able to get
ranges too. I think all the underlying types support it so we just
need to expose it.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foobarbaz"</span> 3 60 slice
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>a b c d e f<span class="org-kcats-brackets">]</span> 2 4 slice
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>c d<span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
This works but currently panics if you go beyond the valid
indices. Should probably throw a proper error.
</p>
</div>
</div>
<div id="outline-container-orga6b674e" class="outline-4">
<h4 id="orga6b674e"><span class="section-number-4">1.6.67.</span> <span class="todo INPROGRESS">INPROGRESS</span> Templating</h4>
<div class="outline-text-4" id="text-1-6-67">
<ul class="org-ul">
<li>State "INPROGRESS" from "DONE"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-15 Sun 17:23]</span></span></li>
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-09 Mon 19:04]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-09 Mon 19:04]</span></span></li>
</ul>
<p>
It would be nice if we could build nested programs as a template
instead of assembling them from parts.
</p>

<p>
For example lets say I wanted <code>[foo [[blah] dip] shield]</code> where <code>blah</code> is
a runtime value. Currently I'd have to use <code>join</code> to put it together.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>w1 <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"baz"</span> <span class="org-string">"bar"</span> <span class="org-string">"foo"</span> <span class="org-kcats-brackets">[[</span>w1<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
let
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"foo"</span> <span class="org-string">"bazbar"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>
</pre>
</div>

<p>
This isn't quite "templating", since it requires that the <code>let</code> scope
encompasses wherever the program is <b>executed</b>, and not just where it is
built. What we want is a portable program with <code>join</code> substituted for
<code>w1</code>. I think recursive replace should be straightforward enough.
</p>

<blockquote>
<p>
function template<sub>recurse</sub>(template, mapping):
    if template is a list:
        return [template<sub>recurse</sub>(item, mapping) for item in template]
    else if template is a placeholder (string) and template in mapping:
        return mapping[template]
    else:
        return template
</p>

<p>
function template(template, mapping):
    return template<sub>recurse</sub>(template, mapping)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>*a* <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*b* bar<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>*a* <span class="org-kcats-brackets">[</span>*b*<span class="org-kcats-brackets">]</span> c d 1 2 3<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">t v</span>
<span class="org-kcats-brackets">[</span>list? not<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">recur condition</span>
<span class="org-kcats-brackets">[[</span>word?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">wrap</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span>
 when<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">rec1</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">recur</span> <span class="org-builtin">dropdown</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>bar<span class="org-kcats-brackets">]</span> c d 1 2 3<span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
Note this currently behaves oddly if you don't declare the mapping as
an association and you have integers in your template. Should probably
fix that, I don't think we intend to replace ints with other values
based on index.
</p>

<p>
Come to think of it, since the template's values will come from the
stack, I think we should let the caller construct that first and then
put the template on top.
</p>

<p>
Test this out on the current impl of <code>until</code>.
</p>
<div class="org-src-container">
<pre class="src src-kcats">2 <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span>
pair <span class="org-kcats-brackets">[</span>pred body<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> zip 
<span class="org-kcats-brackets">[[</span>splice body<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>splice pred<span class="org-kcats-brackets">]</span> not<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> template
yes <span class="org-builtin">swap</span> <span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">4
</pre>
</div>

<p>
Aha, we need <code>unquote-splicing</code> ! Well I am not sure how to implement that.
</p>

<p>
So this is implementing the different syntax for placeholders, <code>[poke
a]</code> and <code>[splice a]</code>. However splicing is still not supported, as it
requires a different <code>recur</code> structure.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>b bar<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>poke a<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>poke b<span class="org-kcats-brackets">]</span> x <span class="org-kcats-brackets">[</span>poke a<span class="org-kcats-brackets">]]</span> c d 1 2 3<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">t v</span>
<span class="org-kcats-brackets">[[</span>subs-point? <span class="org-kcats-brackets">[[[</span>list?<span class="org-kcats-brackets">]</span>
                <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 2 =<span class="org-kcats-brackets">]</span>
                <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>poke splice<span class="org-kcats-brackets">]</span> set <span class="org-builtin">swap</span> contains?<span class="org-kcats-brackets">]]</span>
               <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[[[</span>list? not<span class="org-kcats-brackets">]</span>
   <span class="org-kcats-brackets">[</span>subs-point?<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> any?<span class="org-kcats-brackets">]</span><span class="org-comment-delimiter">;; </span><span class="org-comment">recur condition</span>
 <span class="org-kcats-brackets">[[</span>subs-point?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span> <span class="org-kcats-brackets">]</span>
  when dump<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;;  </span><span class="org-comment">rec t v</span>

 <span class="org-comment-delimiter">;;</span><span class="org-comment">ok so the idea here is to just use `step` and the trick is that the</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">recur fn needs to have the accumulator out of the way, via `dip`,</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">and then the step fn (after the recur is done) should have the acc</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">on top again, with the new value beneath, which it can just `swap</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">put` or `swap join` i suppose. So we need to append that part to</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">the step program.</span>
 <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">sink</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">rec t acc v</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">now build the step fn to include the push into acc</span>
  <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> decorate <span class="org-comment-delimiter">;; </span><span class="org-comment">run the rec with dip (under the acc) </span>
  <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">prepend floating the acc to the top before the dipping</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">then after the dipping we have acc res </span>
  <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">step</span>
 <span class="org-kcats-brackets">]</span>

 <span class="org-comment-delimiter">;;</span><span class="org-comment">drop dump</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">rec2 acc t  v</span>
 <span class="org-comment-delimiter">;;  </span>
 <span class="org-preprocessor">recur</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span>
let
</pre>
</div>

<p>
Ok so maybe an easier way to think about this is using <code>let</code> and calling
the templating recursively.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a <span class="org-kcats-brackets">[</span>foo quux<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>b bar<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[[[</span>a b <span class="org-kcats-brackets">[</span>splice a<span class="org-kcats-brackets">]</span> c<span class="org-kcats-brackets">]]]</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">[[poke a] [[poke b] x [splice a]] c d 1 2 3]</span>
  <span class="org-comment-delimiter">; </span><span class="org-comment">t v</span>
  <span class="org-kcats-brackets">[[</span>subs-point? <span class="org-kcats-brackets">[[[</span>list?<span class="org-kcats-brackets">]</span>
                  <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 2 =<span class="org-kcats-brackets">]</span>
                  <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>poke splice<span class="org-kcats-brackets">]</span> set <span class="org-builtin">swap</span> contains?<span class="org-kcats-brackets">]]</span>
                 <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]]</span>
   <span class="org-kcats-brackets">[</span>subs <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">clone</span>
          <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">branch</span><span class="org-kcats-brackets">]]</span>
   <span class="org-comment-delimiter">;; </span><span class="org-comment">takes t v</span>
   <span class="org-kcats-brackets">[</span>template <span class="org-kcats-brackets">[[[[</span>subs-point?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>poke<span class="org-kcats-brackets">]</span> =<span class="org-kcats-brackets">]</span>
                               <span class="org-kcats-brackets">[</span>subs <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span>
                               <span class="org-kcats-brackets">[</span>subs<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]</span>
               <span class="org-kcats-brackets">[[</span>list?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;;  </span><span class="org-comment">t acc v</span>
                         <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>template<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]]</span>
               <span class="org-kcats-brackets">[[</span>yes<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]]]</span>
              decide<span class="org-kcats-brackets">]]]</span>
  <span class="org-kcats-brackets">[</span>template<span class="org-kcats-brackets">]</span>
  let <span class="org-function-name">unwrap</span> <span class="org-builtin">dropdown</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>a b foo quux c<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>body <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>pred <span class="org-kcats-brackets">[</span>even?<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>not <span class="org-kcats-brackets">[</span>splice pred<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> template
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>not even? <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org531f930" class="outline-4">
<h4 id="org531f930"><span class="section-number-4">1.6.68.</span> <span class="done DONE">DONE</span> Eliminate 'nothing'</h4>
<div class="outline-text-4" id="text-1-6-68">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-17 Tue 18:58]</span></span></li>
</ul>
<p>
The concept is confusing because an empty container is not <code>nothing</code>. 
</p>
</div>
<div id="outline-container-orgf372168" class="outline-5">
<h5 id="orgf372168"><span class="section-number-5">1.6.68.1.</span> <span class="done DONE">DONE</span> Rename nothing? to empty?</h5>
<div class="outline-text-5" id="text-1-6-68-1">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-17 Tue 18:51]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-17 Tue 18:33]</span></span></li>
</ul>
</div>
</div>
<div id="outline-container-orge4df895" class="outline-5">
<h5 id="orge4df895"><span class="section-number-5">1.6.68.2.</span> <span class="done DONE">DONE</span> Use yes instead of true</h5>
<div class="outline-text-5" id="text-1-6-68-2">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-17 Tue 18:33]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-17 Tue 18:06]</span></span></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Skyrod Vactai</p>
<p class="date">Created: 2023-10-18 Wed 23:04</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>