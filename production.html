<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-09 Thu 22:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The kcats Programming Language (Production Implementation)</title>
<meta name="author" content="Skyrod Vactai" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="docs-custom.css"/>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The kcats Programming Language (Production Implementation)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3a769c7">1. Production implementation</a>
<ul>
<li><a href="#org03c9110">1.1. Base Language</a></li>
<li><a href="#orgb67e03d">1.2. Status</a></li>
<li><a href="#org9c0fb69">1.3. Building</a>
<ul>
<li><a href="#org85abc74">1.3.1. Dependencies</a></li>
<li><a href="#org36dc783">1.3.2. Build</a></li>
</ul>
</li>
<li><a href="#using">1.4. Using</a>
<ul>
<li><a href="#orgfe4b893">1.4.1. Command line REPL</a></li>
<li><a href="#org2da6c01">1.4.2. Command line</a></li>
<li><a href="#orgd1ba716">1.4.3. Emacs Interactive REPL</a></li>
</ul>
</li>
<li><a href="#source">1.5. Source</a>
<ul>
<li><a href="#org8aa2ec1">1.5.1. Project File</a></li>
<li><a href="#org85c3fb6">1.5.2. Internal data types</a>
<ul>
<li><a href="#orgd952dff">1.5.2.1. Basic internal types</a></li>
<li><a href="#org0c78e29">1.5.2.2. Container types</a></li>
<li><a href="#org4c75ff1">1.5.2.3. Associative types</a></li>
<li><a href="#org13d7e61">1.5.2.4. Error types</a></li>
<li><a href="#org45bea59">1.5.2.5. Dictionary types</a></li>
<li><a href="#org0ea9ab3">1.5.2.6. Environment types</a></li>
<li><a href="#org65d79b6">1.5.2.7. Hash-based object cache</a></li>
<li><a href="#org1cefc2e">1.5.2.8. Cryptographic primitives</a></li>
</ul>
</li>
<li><a href="#org332ea1f">1.5.3. Serialization</a></li>
<li><a href="#org0f479fe">1.5.4. Builtin words</a></li>
<li><a href="#orga3280ff">1.5.5. Top level execution</a></li>
<li><a href="#orgf536a96">1.5.6. Pipes (input/output)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc5f82fd">2. Issues</a>
<ul>
<li><a href="#org02a8be5">2.1. <span class="todo INPROGRESS">INPROGRESS</span> Interactive mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></a>
<ul>
<li><a href="#org707b411">2.1.1. <span class="todo TODO">TODO</span> Only print the changed part of the stack</a></li>
<li><a href="#org56b801f">2.1.2. <span class="todo TODO">TODO</span> Emacs keybindings to send common stack ops</a></li>
</ul>
</li>
<li><a href="#org97ee71d">2.2. <span class="todo TODO">TODO</span> Source mapping&#xa0;&#xa0;&#xa0;<span class="tag"><span class="debugging">debugging</span>&#xa0;<span class="errorHandling">errorHandling</span></span></a></li>
<li><a href="#org7460ca7">2.3. <span class="todo TODO">TODO</span> Call stack in errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="debugging">debugging</span>&#xa0;<span class="errorHandling">errorHandling</span></span></a></li>
<li><a href="#orgdcd2e86">2.4. <span class="todo INPROGRESS">INPROGRESS</span> Implement pipes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org3b1d125">2.4.1. <span class="done DONE">DONE</span> Write to a file</a></li>
<li><a href="#orgd462fa5">2.4.2. <span class="done DONE">DONE</span> Read from a file</a></li>
<li><a href="#org4d0ab39">2.4.3. <span class="done DONE">DONE</span> Close a pipe</a></li>
<li><a href="#orgd208dd7">2.4.4. <span class="done DONE">DONE</span> Serialize pipes with something sane</a></li>
<li><a href="#orgcad62e5">2.4.5. <span class="done DONE">DONE</span> Sockets</a>
<ul>
<li><a href="#orgc3576de">2.4.5.1. <span class="done DONE">DONE</span> Server Sockets</a></li>
<li><a href="#org18fd142">2.4.5.2. <span class="done DONE">DONE</span> Sockets</a></li>
<li><a href="#org96d46f8">2.4.5.3. <span class="done CANCELED">CANCELED</span> Assemble is broken when reading files</a></li>
</ul>
</li>
<li><a href="#org3847a7a">2.4.6. <span class="done DONE">DONE</span> Convert In/Out traits to enums in pipes modules</a></li>
<li><a href="#orgd018a4e">2.4.7. <span class="done DONE">DONE</span> Composable transforms</a>
<ul>
<li><a href="#org3045248">2.4.7.1. <span class="done DONE">DONE</span> Siphon from one pipe to another</a></li>
</ul>
</li>
<li><a href="#orgd550a08">2.4.8. <span class="done CANCELED">CANCELED</span> Filled pipes</a></li>
<li><a href="#orgebb7b7d">2.4.9. <span class="todo INPROGRESS">INPROGRESS</span> Object pipes</a></li>
<li><a href="#orgb91313e">2.4.10. <span class="done DONE">DONE</span> Time pipe</a></li>
<li><a href="#orgbf5d9cb">2.4.11. <span class="done DONE">DONE</span> stdin/stdout pipes</a></li>
<li><a href="#org064164d">2.4.12. <span class="done CANCELED">CANCELED</span> Pipe take outcome</a></li>
</ul>
</li>
<li><a href="#orga35527c">2.5. <span class="todo INPROGRESS">INPROGRESS</span> Use a single word for all derivation/conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a></li>
<li><a href="#org16d048d">2.6. <span class="todo TODO">TODO</span> Error should have actual struct fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></a></li>
<li><a href="#org7df8595">2.7. <span class="todo INPROGRESS">INPROGRESS</span> Script</a>
<ul>
<li><a href="#org0e30691">2.7.1. <span class="done DONE">DONE</span> Cryptographic primitives</a>
<ul>
<li><a href="#orgb2a0623">2.7.1.1. <span class="done DONE">DONE</span> SHA256</a></li>
<li><a href="#org35909d3">2.7.1.2. <span class="done DONE">DONE</span> Signing</a></li>
<li><a href="#orgeab5963">2.7.1.3. <span class="done DONE">DONE</span> Make verify return the message</a></li>
<li><a href="#orgb883164">2.7.1.4. <span class="todo TODO">TODO</span> AES Encryption</a></li>
<li><a href="#orgc1d2c66">2.7.1.5. <span class="todo TODO">TODO</span> Random</a></li>
</ul>
</li>
<li><a href="#orgcd3bb03">2.7.2. <span class="done DONE">DONE</span> Pure functional env</a></li>
<li><a href="#orgd19224e">2.7.3. <span class="todo TODO">TODO</span> Infinite loop protection</a></li>
</ul>
</li>
<li><a href="#orgccb6bbb">2.8. <span class="todo TODO">TODO</span> retry should have opposite argument order&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span>&#xa0;<span class="consistency">consistency</span></span></a></li>
<li><a href="#orgc1af7ca">2.9. <span class="todo INPROGRESS">INPROGRESS</span> Support Kademlia DHT</a>
<ul>
<li><a href="#org19e8b28">2.9.1. <span class="done DONE">DONE</span> XOR</a></li>
<li><a href="#orga9a7175">2.9.2. <span class="todo INPROGRESS">INPROGRESS</span> Simple API server</a></li>
<li><a href="#orgad5790c">2.9.3. <span class="todo INPROGRESS">INPROGRESS</span> Simple API client</a></li>
<li><a href="#org869f6ea">2.9.4. <span class="todo TODO">TODO</span> Kademlia functions</a></li>
</ul>
</li>
<li><a href="#org560ba4b">2.10. <span class="todo TODO">TODO</span> read and emit don't have quite the same semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></a></li>
<li><a href="#orgc93ff7d">2.11. <span class="todo INPROGRESS">INPROGRESS</span> Inconsistent stack handling when encountering error&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></a>
<ul>
<li><a href="#orge63546c">2.11.1. <span class="todo TODO">TODO</span> 'read' on invalid edn consumes the string argument</a></li>
<li><a href="#orga24d480">2.11.2. <span class="todo TODO">TODO</span> Division by zero consumes stack items</a></li>
</ul>
</li>
<li><a href="#org755be89">2.12. <span class="done DONE">DONE</span> Inconsistent expression handling when encountering error</a></li>
<li><a href="#org6e20a6d">2.13. <span class="todo TODO">TODO</span> Performance optimizations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></a>
<ul>
<li><a href="#orgaf63b8d">2.13.1. <span class="todo TODO">TODO</span> Compile programs</a></li>
<li><a href="#org7159cb6">2.13.2. <span class="todo TODO">TODO</span> Programs as their own immutable type</a></li>
</ul>
</li>
<li><a href="#orga963f71">2.14. <span class="todo INPROGRESS">INPROGRESS</span> Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org66e743a">2.14.1. <span class="done DONE">DONE</span> Basic functionality and generators</a></li>
<li><a href="#org325021b">2.14.2. <span class="done DONE">DONE</span> map</a></li>
<li><a href="#org8ca0a37">2.14.3. <span class="done DONE">DONE</span> filter</a></li>
<li><a href="#org71d95a8">2.14.4. <span class="done DONE">DONE</span> take</a></li>
<li><a href="#org4058f9d">2.14.5. <span class="done DONE">DONE</span> drop</a></li>
<li><a href="#orga45a68e">2.14.6. <span class="done DONE">DONE</span> drop-while (skipper)</a></li>
<li><a href="#orge38153e">2.14.7. <span class="done DONE">DONE</span> take-while (catcher)</a></li>
<li><a href="#org44c89f3">2.14.8. <span class="done CANCELED">CANCELED</span> last</a></li>
<li><a href="#org9c61d2c">2.14.9. <span class="todo TODO">TODO</span> distinct</a></li>
<li><a href="#orgab70474">2.14.10. <span class="done DONE">DONE</span> partition</a></li>
<li><a href="#org787e822">2.14.11. <span class="done DONE">DONE</span> joiner (aka catenate)</a></li>
<li><a href="#org01a6321">2.14.12. <span class="todo TODO">TODO</span> groupby</a></li>
<li><a href="#orgd29357d">2.14.13. <span class="done CANCELED">CANCELED</span> Map/filter can't access lower stack items</a>
<ul>
<li><a href="#orgac75d43">2.14.13.1. Problem</a></li>
<li><a href="#org1f40179">2.14.13.2. Debug session</a></li>
<li><a href="#org751b1fb">2.14.13.3. Resolution</a></li>
<li><a href="#org9cde317">2.14.13.4. <span class="done DONE">DONE</span> Add functions to help capture environment for map/filter fns</a></li>
</ul>
</li>
<li><a href="#org5c301b5">2.14.14. <span class="done DONE">DONE</span> Reduce</a></li>
<li><a href="#org718cf19">2.14.15. <span class="done CANCELED">CANCELED</span> Generator combinators?</a></li>
<li><a href="#org9d301cc">2.14.16. <span class="done DONE">DONE</span> Applying generator to an existing container</a></li>
<li><a href="#org5b3d95e">2.14.17. <span class="todo INPROGRESS">INPROGRESS</span> Combinations</a></li>
</ul>
</li>
<li><a href="#org86d3cff">2.15. <span class="todo INPROGRESS">INPROGRESS</span> Implement sorting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></a>
<ul>
<li><a href="#org8447034">2.15.1. <span class="todo TODO">TODO</span> Implement partialord</a></li>
<li><a href="#org965dcdc">2.15.2. <span class="todo TODO">TODO</span> Make floats hashable</a></li>
<li><a href="#org2382388">2.15.3. <span class="todo TODO">TODO</span> Implement compare</a></li>
</ul>
</li>
<li><a href="#orgb80af6e">2.16. <span class="todo TODO">TODO</span> Stream transformation</a></li>
<li><a href="#orgbe7eec1">2.17. <span class="todo INPROGRESS">INPROGRESS</span> Select from multiple pipes</a>
<ul>
<li><a href="#org3f96bd0">2.17.1. <span class="todo TODO">TODO</span> Attend should leave the pipe list argument</a></li>
<li><a href="#org9d52c06">2.17.2. <span class="todo TODO">TODO</span> Better error handling</a></li>
</ul>
</li>
<li><a href="#org1dbc0d5">2.18. <span class="todo TODO">TODO</span> Monitoring tools</a>
<ul>
<li><a href="#org12e3b17">2.18.1. <span class="todo TODO">TODO</span> Reporting back to the mothership</a></li>
<li><a href="#orge2c47b3">2.18.2. <span class="todo TODO">TODO</span> Monitoring UI</a></li>
</ul>
</li>
<li><a href="#orgbf14566">2.19. <span class="todo INPROGRESS">INPROGRESS</span> Native REPL</a>
<ul>
<li><a href="#org6171dce">2.19.1. <span class="done DONE">DONE</span> Main mode of reading program from cmdline or file</a></li>
<li><a href="#org4294cb0">2.19.2. <span class="todo INPROGRESS">INPROGRESS</span> REPL as a kcats program</a></li>
</ul>
</li>
<li><a href="#orgabe5954">2.20. <span class="todo TODO">TODO</span> Words that quote programs instead of executing them</a>
<ul>
<li><a href="#orgdce0c1e">2.20.1. <span class="todo TODO">TODO</span> Get rid of self-inserting programs (esp with generators)</a></li>
</ul>
</li>
<li><a href="#org4198c28">2.21. <span class="todo TODO">TODO</span> Data compression</a></li>
<li><a href="#org6127a6a">2.22. <span class="todo TODO">TODO</span> Multimethod improvements</a>
<ul>
<li><a href="#org0b54b82">2.22.1. <span class="todo TODO">TODO</span> Convert to multi</a></li>
<li><a href="#org7bcc874">2.22.2. <span class="done DONE">DONE</span> Refactor addmethod</a></li>
<li><a href="#orga3216b6">2.22.3. <span class="done DONE">DONE</span> ismulti?</a></li>
</ul>
</li>
<li><a href="#org42618ad">2.23. <span class="todo TODO">TODO</span> run multiple programs on same argument to get list</a></li>
<li><a href="#org1ac10fc">2.24. <span class="todo INPROGRESS">INPROGRESS</span> pairwise operations</a></li>
<li><a href="#orgb91b4df">2.25. <span class="todo INPROGRESS">INPROGRESS</span> Non-generator filter</a></li>
<li><a href="#orgac0e0ab">2.26. <span class="todo TODO">TODO</span> Modules</a>
<ul>
<li><a href="#orgc01834e">2.26.1. Problem statement</a>
<ul>
<li><a href="#org57312aa">2.26.1.1. <span class="todo TODO">TODO</span> Efficient use</a></li>
<li><a href="#orgcfff508">2.26.1.2. <span class="todo TODO">TODO</span> Modification happens once per program</a></li>
<li><a href="#org86b2849">2.26.1.3. <span class="todo TODO">TODO</span> Nested library calls need to work</a></li>
<li><a href="#orgcc8990c">2.26.1.4. <span class="todo TODO">TODO</span> Code should be shareable</a></li>
<li><a href="#orga2374e5">2.26.1.5. <span class="todo TODO">TODO</span> Building vocabulary and the programs that use that vocabulary need to be separable</a></li>
<li><a href="#orgac09dae">2.26.1.6. <span class="todo TODO">TODO</span> Sandboxing</a></li>
</ul>
</li>
<li><a href="#orga6fe108">2.26.2. Discussion</a>
<ul>
<li><a href="#orga70a1f2">2.26.2.1. pairs of program/dictionary.</a></li>
<li><a href="#org3adc66b">2.26.2.2. not having to recalculate the whole dictionary each time we want to use a module.</a></li>
<li><a href="#orgbe5dccf">2.26.2.3. Use of names</a></li>
</ul>
</li>
<li><a href="#org9589bbe">2.26.3. <span class="todo INPROGRESS">INPROGRESS</span> inscribe currently re-defines words repeatedly at runtime</a>
<ul>
<li><a href="#orgc381fb2">2.26.3.1. <span class="todo INPROGRESS">INPROGRESS</span> Current design</a></li>
<li><a href="#org3be0d14">2.26.3.2. <span class="todo INPROGRESS">INPROGRESS</span> Library loading</a></li>
<li><a href="#org894ed2e">2.26.3.3. <span class="todo INPROGRESS">INPROGRESS</span> Nesting scopes</a></li>
<li><a href="#org7ba3199">2.26.3.4. <span class="todo TODO">TODO</span> Stack escape protection</a></li>
<li><a href="#org2a570be">2.26.3.5. <span class="todo INPROGRESS">INPROGRESS</span> Sandboxing support</a></li>
<li><a href="#org9a10034">2.26.3.6. <span class="todo INPROGRESS">INPROGRESS</span> Access control</a></li>
<li><a href="#org7da2d7e">2.26.3.7. <span class="todo INPROGRESS">INPROGRESS</span> Words can refer to other words in the same library</a></li>
<li><a href="#orgee92271">2.26.3.8. <span class="todo TODO">TODO</span> Convenient module definition</a></li>
<li><a href="#orgb9a0724">2.26.3.9. <span class="todo TODO">TODO</span> convenient 'let'</a></li>
<li><a href="#org4b781ac">2.26.3.10. <span class="todo INPROGRESS">INPROGRESS</span> Break up the standard library</a></li>
<li><a href="#orgd8c1295">2.26.3.11. <span class="done CANCELED">CANCELED</span> Disallow module alias overwriting</a></li>
<li><a href="#org9be3a33">2.26.3.12. <span class="todo TODO">TODO</span> Store data sources</a></li>
<li><a href="#org00bde3a">2.26.3.13. <span class="todo TODO">TODO</span> Find stdlib by alias</a></li>
<li><a href="#org6820103">2.26.3.14. <span class="todo TODO">TODO</span> LIbrary loading should be in order of decreasing trust</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org903930d">2.27. <span class="todo INPROGRESS">INPROGRESS</span> Database</a>
<ul>
<li><a href="#org8799ee6">2.27.1. Books db</a></li>
<li><a href="#org0442e28">2.27.2. EAVTO (entity, attribute, value, time, observer)</a></li>
</ul>
</li>
<li><a href="#orged56b89">2.28. <span class="todo TODO">TODO</span> Reduce CPU cost of `shield`</a></li>
<li><a href="#org73625fd">2.29. <span class="todo TODO">TODO</span> Sort out feature dependencies</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org3a769c7" class="outline-2">
<h2 id="org3a769c7"><span class="section-number-2">1.</span> Production implementation</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org03c9110" class="outline-3">
<h3 id="org03c9110"><span class="section-number-3">1.1.</span> Base Language</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Built in Rust - it's fast and modern, its memory allocation model
seems well suited to kcats.
</p>
</div>
</div>
<div id="outline-container-orgb67e03d" class="outline-3">
<h3 id="orgb67e03d"><span class="section-number-3">1.2.</span> Status</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Unstable
</p>
</div>
</div>
<div id="outline-container-org9c0fb69" class="outline-3">
<h3 id="org9c0fb69"><span class="section-number-3">1.3.</span> Building</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org85abc74" class="outline-4">
<h4 id="org85abc74"><span class="section-number-4">1.3.1.</span> Dependencies</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>rustc</li>
<li>cargo</li>
</ul>
</div>
</div>
<div id="outline-container-org36dc783" class="outline-4">
<h4 id="org36dc783"><span class="section-number-4">1.3.2.</span> Build</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Run <code>cargo build --release</code>, the binary will be placed in <code>./target/release</code> by
default.
</p>
</div>
</div>
</div>
<div id="outline-container-using" class="outline-3">
<h3 id="using"><span class="section-number-3">1.4.</span> Using</h3>
<div class="outline-text-3" id="text-using">
</div>

<div id="outline-container-orgfe4b893" class="outline-4">
<h4 id="orgfe4b893"><span class="section-number-4">1.4.1.</span> Command line REPL</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
This is the easiest way to get started. Run <code>kcats -r</code> and it will print
a prompt and wait for you to input items (as many as you like, on a
single line). It will then evaluate all the items and print the
resulting stack. You can then enter more items. It keeps the stack
intact so you're not starting fresh with each input. If you want to
clear the stack, you can use <code>[] restore</code>.
</p>

<p>
Use Ctrl-C to quit.
</p>

<p>
Example session:
</p>
<div class="org-src-container">
<pre class="src src-fundamental">~/workspace/kcats $ kcats -r
kcats&gt; 1
1
kcats&gt; 2
2 1
kcats&gt; +
3
kcats&gt; [7 8 9] [*] step
1512
kcats&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org2da6c01" class="outline-4">
<h4 id="org2da6c01"><span class="section-number-4">1.4.2.</span> Command line</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Execute <code>kcats</code>. It will read a program from stdin and execute it,
then print the resulting stack to stdout. You can pass input to it via stdin via
</p>
<ul class="org-ul">
<li>interactive typing (end input with CTRL-D on most platforms): <code>kcats</code></li>
<li>Piping from a file eg: <code>kcats &lt; myprog.kcats</code></li>
<li>Using echo: <code>echo "[1 2 3] [inc] map" | kcats</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgd1ba716" class="outline-4">
<h4 id="orgd1ba716"><span class="section-number-4">1.4.3.</span> Emacs Interactive REPL</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
See <code>emacs-ide.org</code> in the source tree. The elisp files you need to
evaluate are there. Evaluate them, then run <code>M-x kcats-repl</code>. You may
need to run <code>M-x customize-variable</code>, <code>kcats-babel-executable</code>, and enter
the location where you installed the kcats binary.
</p>
</div>
</div>
</div>
<div id="outline-container-source" class="outline-3">
<h3 id="source"><span class="section-number-3">1.5.</span> Source</h3>
<div class="outline-text-3" id="text-source">
</div>

<div id="outline-container-org8aa2ec1" class="outline-4">
<h4 id="org8aa2ec1"><span class="section-number-4">1.5.1.</span> Project File</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class='tangle-wrapper' data-tangle='Cargo.toml'><div class="org-src-container">
<pre class="src src-toml">[<span class="org-type">package</span>]
<span class="org-variable-name">name</span> = <span class="org-string">"kcats"</span>
<span class="org-variable-name">version</span> = <span class="org-string">"0.8.0"</span>
<span class="org-variable-name">edition</span> = <span class="org-string">"2021"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

[<span class="org-type">dependencies</span>]
<span class="org-comment-delimiter"># </span><span class="org-comment">serialization</span>
<span class="org-variable-name">edn-format</span> = <span class="org-string">"3.3.0"</span>
<span class="org-variable-name">serde</span> = <span class="org-string">"1"</span>
<span class="org-variable-name">serde_json</span> = <span class="org-string">"1"</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">edn-format = { path = "../edn-format" }</span>
<span class="org-variable-name">base64</span> = <span class="org-string">"0.13.0"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">String literals</span>
<span class="org-variable-name">internment</span> = {version = <span class="org-string">"0.6.0"</span>, features = [<span class="org-string">"serde"</span>]}
<span class="org-variable-name">lazy_static</span> = <span class="org-string">"1.4.0"</span>

<span class="org-variable-name">num-integer</span> = <span class="org-string">"0.1.44"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">String format</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">dyn-fmt = "0.4.0" </span>
<span class="org-variable-name">dynfmt</span> = { version = <span class="org-string">"0.1.5"</span>, features = [<span class="org-string">"curly"</span>] }

<span class="org-comment-delimiter"># </span><span class="org-comment">crypto stuff</span>
<span class="org-variable-name">ed25519-dalek</span> = {version=<span class="org-string">"1"</span>, features=[<span class="org-string">"batch_deterministic"</span>, <span class="org-string">"std"</span>, <span class="org-string">"rand"</span>]}
<span class="org-variable-name">sha2</span> = {version=<span class="org-string">"0.10.6"</span>, features=[<span class="org-string">"std"</span>]}
<span class="org-variable-name">rand_core</span> = <span class="org-string">"0.5.1"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">careful here, having 2 versions present will make weird compile errors</span>
<span class="org-variable-name">rand</span> = <span class="org-string">"0.8"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">multithreading</span>
<span class="org-variable-name">futures</span> = <span class="org-string">"0.3"</span>
<span class="org-variable-name">tokio</span> = { version = <span class="org-string">"1"</span>, features = [<span class="org-string">"full"</span>] }
<span class="org-comment-delimiter"># </span><span class="org-comment">multiple-consumer channels</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">crossbeam-channel = "0.5" # doesn't support async send/recv</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">async-channel = "1.8.0"</span>
<span class="org-variable-name">flume</span> = <span class="org-string">"0.11.0"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">debugging</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">backtrace = "0.3.61"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">database</span>
<span class="org-comment-delimiter">## </span><span class="org-comment">Figure out best place to store the db and stdlib files</span>
<span class="org-variable-name">directories</span> = <span class="org-string">"5.0"</span>

<span class="org-variable-name">rusqlite</span> = { version = <span class="org-string">"0.30"</span>, optional = <span class="org-keyword">true</span>, features = [<span class="org-string">"uuid"</span>] }

<span class="org-comment-delimiter"># </span><span class="org-comment">memoized functions</span>
<span class="org-variable-name">once_cell</span> = <span class="org-string">"1"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">The blob cache</span>
<span class="org-variable-name">cache</span> = {path = <span class="org-string">"./cache"</span>}

[<span class="org-type">dependencies.uuid</span>]
<span class="org-variable-name">version</span> = <span class="org-string">"1.6.1"</span>
<span class="org-variable-name">features</span> = [
    <span class="org-string">"v4"</span>,                <span class="org-comment-delimiter"># </span><span class="org-comment">Lets you generate random UUIDs</span>
    <span class="org-string">"v7"</span>,
    <span class="org-string">"fast-rng"</span>,          <span class="org-comment-delimiter"># </span><span class="org-comment">Use a faster (but still sufficiently random) RNG</span>
]
<span class="org-comment-delimiter">#</span><span class="org-comment">chrono = "0.4.31"</span>

[<span class="org-type">dev-dependencies</span>]
<span class="org-variable-name">test-case</span> = <span class="org-string">"2.0.0"</span>

[<span class="org-type">build-dependencies</span>]
<span class="org-variable-name">directories</span> = <span class="org-string">"5.0"</span>
<span class="org-variable-name">sha2</span> = <span class="org-string">"0.10.6"</span>
<span class="org-variable-name">base64</span> = <span class="org-string">"0.13.0"</span>
<span class="org-variable-name">cache</span> = {path = <span class="org-string">"./cache"</span>}

[<span class="org-type">features</span>]
<span class="org-variable-name">database</span> = [<span class="org-string">"rusqlite"</span>]
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org85c3fb6" class="outline-4">
<h4 id="org85c3fb6"><span class="section-number-4">1.5.2.</span> Internal data types</h4>
<div class="outline-text-4" id="text-1-5-2">
</div>
<div id="outline-container-orgd952dff" class="outline-5">
<h5 id="orgd952dff"><span class="section-number-5">1.5.2.1.</span> Basic internal types</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<p>
We'll start by defining the basic data structures that kcats will use
internally, to keep track of things like the stack, program, lists etc.
</p>
<div class='tangle-wrapper' data-tangle='src/types.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! Defines kcats internal data types.</span>

<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::dictionary <span class="org-keyword">as</span> dict;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::environment <span class="org-keyword">as</span> env;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;

<span class="org-keyword">use</span> <span class="org-constant">core</span>::<span class="org-constant">default</span>::<span class="org-type">Default</span>;
<span class="org-keyword">use</span> <span class="org-constant">internment</span>::<span class="org-type">Intern</span>;
<span class="org-keyword">use</span> <span class="org-constant">lazy_static</span>::lazy_static;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::{<span class="org-type">HashMap</span>, <span class="org-type">VecDeque</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::fmt;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">fmt</span>::<span class="org-type">Display</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">hash</span>::<span class="org-type">Hash</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">marker</span>::<span class="org-type">Sync</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">ops</span>::{<span class="org-type">Deref</span>, <span class="org-type">DerefMut</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">pin</span>::<span class="org-type">Pin</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">container</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">number</span>;

<span class="org-doc">/// A generic newtype to contain various types, so that we can</span>
<span class="org-doc">/// implement traits on them.</span>
<span class="org-preprocessor">#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt;(<span class="org-keyword">pub</span> <span class="org-type">T</span>);

<span class="org-doc">/// Access the inner value easily</span>
<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">Deref</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Target</span> = <span class="org-type">T</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">deref</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>::<span class="org-type">Target</span> {
        <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.0
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">DerefMut</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">deref_mut</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Self</span>::<span class="org-type">Target</span> {
        <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.0
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt;
<span class="org-keyword">where</span>
    <span class="org-variable-name">T</span>: <span class="org-type">Default</span>,
{
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
        <span class="org-type">Newtype</span>(<span class="org-type">T</span>::default())
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">IntoIterator</span>&gt; <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-type">T</span>::<span class="org-type">Item</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">T</span>::<span class="org-type">IntoIter</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">self</span>.0.into_iter()
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">but still clone the whole thing, not the inner part</span>
<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Clone</span>&gt; <span class="org-type">Clone</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">clone</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Newtype</span>(<span class="org-keyword">self</span>.0.clone())
    }
}

<span class="org-doc">/// Implement Debug trait for Newtype, so it hides</span>
<span class="org-doc">/// itself and only prints the inner type.</span>
<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-constant">fmt</span>::<span class="org-type">Debug</span>&gt; <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Newtype</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>&lt;'<span class="org-variable-name">_</span>&gt;) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Directly print the wrapped value</span>
        <span class="org-rust-builtin-formatting-macro">write!</span>(f, <span class="org-string">"</span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, <span class="org-keyword">self</span>.0)
    }
}

<span class="org-doc">/// A Word causes a kcats program to do something, usually taking some</span>
<span class="org-doc">/// items from the top of the stack, and using them to create new</span>
<span class="org-doc">/// stack items. (examples: `swap`, `+`, `dip`).</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Word</span> = <span class="org-type">Newtype</span>&lt;<span class="org-type">Intern</span>&lt;<span class="org-type">String</span>&gt;&gt;;

<span class="org-keyword">impl</span> <span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>&lt;'<span class="org-variable-name">_</span>&gt;) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-rust-builtin-formatting-macro">write!</span>(f, <span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, <span class="org-keyword">self</span>.0.as_str())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Newtype</span>(<span class="org-type">Intern</span>::&lt;<span class="org-type">String</span>&gt;::from(s))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">String</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Word</span>::from(s.as_str())
    }
}

<span class="org-keyword">impl</span>&lt;'<span class="org-variable-name">a</span>&gt; <span class="org-type">From</span>&lt;<span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-type">Word</span>&gt; <span class="org-keyword">for</span> <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-type">str</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-type">Word</span>) -&gt; <span class="org-type">Self</span> {
        s.0.as_str()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Word</span>&gt; <span class="org-keyword">for</span> <span class="org-type">String</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Self</span> {
        s.0.to_string()
    }
}

<span class="org-doc">/// Represents a stack (the part of an</span>
<span class="org-doc">/// [crate::types::container::environment::Environment] that holds the data</span>
<span class="org-doc">/// values being manipulated by the program).</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Stack</span> = <span class="org-constant">container</span>::<span class="org-type">List</span>;

<span class="org-doc">/// A byte array type</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Bytes</span> = <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;;

<span class="org-doc">/// A character type</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Char</span> = <span class="org-type">char</span>;

<span class="org-preprocessor">lazy_static!</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ASSOC</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"association"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_BOOLEAN</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"boolean"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_BYTES</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"bytes"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_CHAR</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"character"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_DICTIONARY</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"dictionary"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_DISPENSER</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"dispenser"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ENVIRONMENT</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"environment"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ERROR</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"error"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_FLOAT</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"float"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_INTEGER</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"integer"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ITEM</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"item"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_LIST</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"list"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_NUMBER</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"number"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_ORDERED</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"ordered"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_PIPE</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"pipe"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_PROGRAM</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"program"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_RECEPTACLE</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"receptacle"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_SIZED</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"sized"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_STRING</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"string"</span>);
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">S_WORD</span>: <span class="org-type">Word</span> = <span class="org-type">Word</span>::from(<span class="org-string">"word"</span>);
}

<span class="org-doc">/// A kcats data value.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Item</span> {
    <span class="org-doc">/// A number value</span>
    <span class="org-type">Number</span>(<span class="org-constant">number</span>::<span class="org-type">Number</span>),
    <span class="org-doc">/// A word value. Words are atomic, they can't be broken down into</span>
    <span class="org-doc">/// characters like Strings.</span>
    <span class="org-type">Word</span>(<span class="org-type">Word</span>),
    <span class="org-doc">/// A character value, like 'a', or '\n'.</span>
    <span class="org-type">Char</span>(<span class="org-type">Char</span>),
    <span class="org-doc">/// A container value (that [Item]s can be taken from)</span>
    <span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>),
    <span class="org-doc">/// A container value (that [Item]s can be put into)</span>
    <span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">Item</span> {
    <span class="org-doc">/// Returns whether the item is empty - only containers can be empty.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)) =&gt; s.is_empty(),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s)) =&gt; s.is_empty(),
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-doc">/// A Future value, used for async execution, which is how</span>
<span class="org-doc">/// multithreading is implemented in kcats.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Future</span>&lt;<span class="org-type">T</span>&gt; = <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">T</span>&gt; + <span class="org-type">Send</span>&gt;&gt;;

<span class="org-doc">/// A type for a function that advances the execution of a kcats</span>
<span class="org-doc">/// program by one step.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">StepFn</span> = <span class="org-keyword">dyn</span> <span class="org-type">Fn</span>(<span class="org-constant">env</span>::<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-constant">env</span>::<span class="org-type">Environment</span>&gt; + <span class="org-type">Sync</span> + <span class="org-type">Send</span>;

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">same types, just use their own eq</span>
            (<span class="org-type">Item</span>::<span class="org-type">Number</span>(a), <span class="org-type">Item</span>::<span class="org-type">Number</span>(b)) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Word</span>(a), <span class="org-type">Item</span>::<span class="org-type">Word</span>(b)) =&gt; a == b,
            (
                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(a)),
                <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(b)),
            ) =&gt; a == b,
            (
                <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(a)),
                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(b)),
            ) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(a), <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(b)) =&gt; a == b,
            (<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(a), <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(b)) =&gt; a == b,

            (<span class="org-type">Item</span>::<span class="org-type">Char</span>(a), <span class="org-type">Item</span>::<span class="org-type">Char</span>(b)) =&gt; a == b,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-doc">/// The default Item is empty list.</span>
<span class="org-keyword">impl</span> <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::default().into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">String</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i) =&gt; <span class="org-type">Ok</span>(i),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"string"</span>, i)),
        }
    }
}

<span class="org-doc">/// Converts Item to Word but also considers a quoted word as a word,</span>
<span class="org-doc">/// eg \[foo\] -&gt; foo.</span>
<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(i) =&gt; <span class="org-type">Ok</span>(i),
            i =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
                <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i);
                <span class="org-keyword">match</span> l {
                    <span class="org-type">Ok</span>(l) =&gt; {
                        <span class="org-keyword">if</span> l.len() == 1 {
                            <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = l.inner().pop_front().unwrap();
                            i.try_into()
                        } <span class="org-keyword">else</span> {
                            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"word"</span>, l))
                        }
                    }
                    <span class="org-type">Err</span>(_) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"word"</span>, i2)),
                }
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Bytes</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; <span class="org-type">Ok</span>(b),
            b =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"bytes"</span>, b)),
        }
    }
}

<span class="org-doc">/// As there are no real booleans, we use the word 'yes' but literally</span>
<span class="org-doc">/// any value except empty containers is truthy. If we read a value</span>
<span class="org-doc">/// 'false', that's not actually a boolean, it's just the [Word]</span>
<span class="org-doc">/// false. The fact that the word 'yes' is used in the language but</span>
<span class="org-doc">/// 'no' is not, is a known tradeoff.</span>
<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">b</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">if</span> b {
            <span class="org-string">"yes"</span>.into()
        } <span class="org-keyword">else</span> {
            <span class="org-type">Item</span>::default()
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">std</span>::<span class="org-constant">io</span>::<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">err</span>: <span class="org-constant">std</span>::<span class="org-constant">io</span>::<span class="org-type">Error</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"io"</span>), <span class="org-rust-ampersand">&amp;</span>err.to_string(), <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(<span class="org-type">Word</span>::from(i))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">String</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Bytes</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">b</span>: <span class="org-type">Bytes</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Word</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">w</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(w)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Char</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Char</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Char</span>(c)
    }
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">From</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">T</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span>
<span class="org-keyword">where</span>
    <span class="org-variable-name">Item</span>: <span class="org-type">From</span>&lt;<span class="org-type">T</span>&gt;,
{
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">opt</span>: <span class="org-type">Option</span>&lt;<span class="org-type">T</span>&gt;) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> opt {
            <span class="org-type">Some</span>(t) =&gt; <span class="org-type">Item</span>::from(t),
            <span class="org-type">None</span> =&gt; <span class="org-type">Item</span>::default(),
        }
    }
}

<span class="org-doc">/// A macro to build a kcats List, accepts any values that are</span>
<span class="org-doc">/// convertible to [Item].</span>
<span class="org-preprocessor">#[macro_export]</span>
<span class="org-preprocessor">macro_rules!</span> list {
    ( $( <span class="org-variable-name">$x</span>:expr ),* $(,)<span class="org-rust-question-mark">?</span> ) =&gt; {
        {
            <span class="org-keyword">let</span> <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt; = <span class="org-preprocessor">vec!</span>[
                $( $x.into(), )*
            ];
            $<span class="org-constant">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-type">List</span>::from_iter(v.into_iter())
        }
    };
}

<span class="org-keyword">mod</span> <span class="org-constant">serde</span> {
    <span class="org-doc">//! Support for json serialization of kcats objects</span>
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::<span class="org-type">Item</span>;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::associative <span class="org-keyword">as</span> assoc;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::number;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-type">Error</span>;
    <span class="org-keyword">use</span> <span class="org-constant">serde</span>::<span class="org-constant">de</span>::{<span class="org-keyword">self</span>, <span class="org-type">Deserialize</span>, <span class="org-type">Deserializer</span>, <span class="org-type">Visitor</span>};
    <span class="org-keyword">use</span> <span class="org-constant">serde</span>::<span class="org-constant">ser</span>::{<span class="org-type">Serialize</span>, <span class="org-type">Serializer</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashMap</span>;
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::fmt;

    <span class="org-keyword">struct</span> <span class="org-type">ItemVisitor</span>;

    <span class="org-keyword">impl</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-type">Visitor</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-keyword">for</span> <span class="org-type">ItemVisitor</span> {
        <span class="org-keyword">type</span> <span class="org-type">Value</span> = <span class="org-type">Item</span>;

        <span class="org-keyword">fn</span> <span class="org-function-name">expecting</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">formatter</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
            formatter.write_str(<span class="org-string">"expected a specific representation for Item"</span>)
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_i64</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">value</span>: <span class="org-type">i64</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-constant">number</span>::<span class="org-type">Number</span>::<span class="org-type">Int</span>(value)))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_u64</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">value</span>: <span class="org-type">u64</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-constant">number</span>::<span class="org-type">Number</span>::<span class="org-type">Int</span>(value <span class="org-keyword">as</span> <span class="org-type">i64</span>)))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_f64</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">value</span>: <span class="org-type">f64</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-constant">number</span>::<span class="org-type">Number</span>::<span class="org-type">Float</span>(value)))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_none</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::default())
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_bool</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">v</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(v))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_str</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">v</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
                <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(v.to_string()),
            )))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_byte_buf</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(
                v,
            ))))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_map</span>&lt;<span class="org-type">A</span>&gt;(<span class="org-keyword">self</span>, <span class="org-keyword">mut</span> <span class="org-variable-name">ma</span>: <span class="org-type">A</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">A</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">A</span>: <span class="org-constant">de</span>::<span class="org-type">MapAccess</span>&lt;'<span class="org-variable-name">de</span>&gt;,
        {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">map</span> = <span class="org-type">HashMap</span>::new();
            <span class="org-keyword">while</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>((key, value)) = ma.next_entry::&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;()<span class="org-rust-question-mark">?</span> {
                map.insert(key, value);
            }
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
                <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(map.into())),
            )))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_seq</span>&lt;<span class="org-type">A</span>&gt;(<span class="org-keyword">self</span>, <span class="org-keyword">mut</span> <span class="org-variable-name">seq</span>: <span class="org-type">A</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">A</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">A</span>: <span class="org-constant">de</span>::<span class="org-type">SeqAccess</span>&lt;'<span class="org-variable-name">de</span>&gt;,
        {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">items</span> = <span class="org-type">Vec</span>::new();
            <span class="org-keyword">while</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(item) = seq.next_element::&lt;<span class="org-type">Item</span>&gt;()<span class="org-rust-question-mark">?</span> {
                items.push(item);
            }
            <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from(items).into())
        }
    }

    <span class="org-keyword">impl</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-type">Deserialize</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">deserialize</span>&lt;<span class="org-type">D</span>&gt;(<span class="org-variable-name">deserializer</span>: <span class="org-type">D</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">D</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">D</span>: <span class="org-type">Deserializer</span>&lt;'<span class="org-variable-name">de</span>&gt;,
        {
            deserializer.deserialize_any(<span class="org-type">ItemVisitor</span>)
        }
    }

    <span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">serde_json</span>::<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">err</span>: <span class="org-constant">serde_json</span>::<span class="org-type">Error</span>) -&gt; <span class="org-type">Error</span> {
            <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"serialize"</span>), <span class="org-rust-ampersand">&amp;</span>err.to_string(), <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
        }
    }

    <span class="org-keyword">impl</span> <span class="org-type">Serialize</span> <span class="org-keyword">for</span> <span class="org-type">Item</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">serialize</span>&lt;<span class="org-type">S</span>&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">serializer</span>: <span class="org-type">S</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">S</span>::<span class="org-type">Ok</span>, <span class="org-type">S</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">S</span>: <span class="org-type">Serializer</span>,
        {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
                <span class="org-type">Item</span>::<span class="org-type">Number</span>(num) =&gt; num.serialize(serializer),
                <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; serializer.serialize_char(*c),
                <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; serializer.serialize_str(w.into()),

                <span class="org-comment-delimiter">// </span><span class="org-comment">Handle other variants</span>
                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-keyword">ref</span> <span class="org-variable-name">dispenser</span>) =&gt; dispenser.serialize(serializer),
                <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-keyword">ref</span> <span class="org-variable-name">receptacle</span>) =&gt; receptacle.serialize(serializer),
            }
        }
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org0c78e29" class="outline-5">
<h5 id="org0c78e29"><span class="section-number-5">1.5.2.2.</span> Container types</h5>
<div class="outline-text-5" id="text-1-5-2-2">
<div class='tangle-wrapper' data-tangle='src/types/container.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! Support for containers in kcats. Includes types like</span>
<span class="org-doc">//! [List], [Set],</span>
<span class="org-doc">//! [associative::Association], String,</span>
<span class="org-doc">//! [pipe::In],</span>
<span class="org-doc">//! [pipe::Out], and Byte arrays. The</span>
<span class="org-doc">//! container contract is you can put things into, or take things out</span>
<span class="org-doc">//! of them. [Receptacle]s are for putting into, and [Dispenser]s are</span>
<span class="org-doc">//! for taking out of. For underlying types that support both</span>
<span class="org-doc">//! operations (like [List]), we can easily convert between</span>
<span class="org-doc">//! [Receptacle] and [Dispenser] as needed.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">associative</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">dictionary</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">environment</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">error</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">pipe</span>;

<span class="org-keyword">use</span> <span class="org-constant">futures</span>::<span class="org-type">FutureExt</span>;

<span class="org-keyword">use</span> <span class="org-keyword">self</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::{<span class="org-type">Int</span>, <span class="org-type">Number</span>};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::{<span class="org-constant">collections</span>::<span class="org-type">HashSet</span>, future, sync};

<span class="org-doc">/// A generic Arc type that we control</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Arc</span>&lt;<span class="org-type">T</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-constant">sync</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">T</span>&gt;&gt;;

<span class="org-doc">/// A generic List type</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Listy</span>&lt;<span class="org-type">I</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">I</span>&gt;&gt;;

<span class="org-doc">/// A generic Set type</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Setty</span>&lt;<span class="org-type">I</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-type">HashSet</span>&lt;<span class="org-type">I</span>&gt;&gt;;

<span class="org-doc">/// A specific List type</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">ListContent</span> = <span class="org-type">Listy</span>&lt;<span class="org-type">Item</span>&gt;;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">List</span> = <span class="org-type">Arc</span>&lt;<span class="org-type">ListContent</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Set</span> = <span class="org-type">Arc</span>&lt;<span class="org-type">Setty</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;&gt;;

<span class="org-keyword">impl</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Clone</span>&gt; <span class="org-type">Arc</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-doc">/// Returns a mutable reference to the value inside this Arc, just</span>
    <span class="org-doc">/// passes through to [sync::Arc].</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">make_mut</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">T</span> {
        <span class="org-constant">sync</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.0)
    }

    <span class="org-doc">/// Returns the inner value - cloning if this Arc is not the only</span>
    <span class="org-doc">/// pointer to the inner value.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">inner</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">T</span> {
        <span class="org-constant">sync</span>::<span class="org-type">Arc</span>::try_unwrap(<span class="org-keyword">self</span>.0.clone()).unwrap_or_else(|rc| (*rc).clone())
    }

    <span class="org-doc">/// Wraps the given value in an Arc.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">wrap</span>(<span class="org-variable-name">inner</span>: <span class="org-type">T</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Self</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(inner))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Set</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">h</span>: <span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;) -&gt; <span class="org-type">Set</span> {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(h)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">List</span> {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(l)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">ListContent</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">ListContent</span>) -&gt; <span class="org-type">List</span> {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(l))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;,
    {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;&gt;(),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Set</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;,
    {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;&gt;(),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">List</span> {
    <span class="org-doc">/// Appends the items to the beginning of this list, preserving</span>
    <span class="org-doc">/// their order. eg `[1, 2, 3].append([4, 5, 6])` -&gt; `[4, 5, 6, 1,</span>
    <span class="org-doc">/// 2, 3]`.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">append</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-keyword">mut</span> <span class="org-variable-name">items</span>: <span class="org-type">List</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Ensure both VecDeques are uniquely owned to avoid cloning during modifications</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">self_mut</span> = <span class="org-keyword">self</span>.make_mut();
        <span class="org-keyword">let</span> <span class="org-variable-name">items_mut</span> = items.make_mut();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Prepend the elements of `items` to `self`</span>
        <span class="org-keyword">while</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(item) = items_mut.pop_back() {
            self_mut.push_front(item);
        }
    }

    <span class="org-doc">/// Appends the items in the iterator to the beginning of this</span>
    <span class="org-doc">/// list, preserving order.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">extend</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">items</span>: <span class="org-type">T</span>) {
        <span class="org-keyword">let</span> <span class="org-variable-name">m</span> = <span class="org-keyword">self</span>.make_mut();
        <span class="org-keyword">let</span> <span class="org-variable-name">ct</span> = m.len();
        m.extend(items);
        m.rotate_left(ct);
    }

    <span class="org-doc">/// Reverses the order of the list.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">reverse</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">let</span> <span class="org-variable-name">m</span> = <span class="org-keyword">self</span>.make_mut();
        m.make_contiguous().reverse();
    }
}

<span class="org-doc">/// A generic container type, all we know is it can contain multiple</span>
<span class="org-doc">/// items. Includes things like lists, sets, and IO channels. Items</span>
<span class="org-doc">/// can be taken out.</span>
<span class="org-preprocessor">#[derive(Debug, Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Dispenser</span> {
    <span class="org-doc">/// A container with a known number of items inside</span>
    <span class="org-type">Sized</span>(<span class="org-type">Sized</span>),
    <span class="org-doc">/// A pipe that dispenses an unknown number of items</span>
    <span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>),
    <span class="org-doc">/// Similar to Out but also convertible to [Receptacle]</span>
    <span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>),
}

<span class="org-doc">/// A generic container type, all we know is it can contain multiple</span>
<span class="org-doc">/// items. Includes things like lists, sets, and IO channels. Items</span>
<span class="org-doc">/// can be put in.</span>
<span class="org-preprocessor">#[derive(Debug, Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Receptacle</span> {
    <span class="org-doc">/// A container with a known number of items inside</span>
    <span class="org-type">Sized</span>(<span class="org-type">Sized</span>),
    <span class="org-doc">/// A pipe that can receive an arbitrary number of items</span>
    <span class="org-type">In</span>(<span class="org-constant">pipe</span>::<span class="org-type">In</span>),
    <span class="org-doc">/// Similar to In but also convertible to [Dispenser]</span>
    <span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>),
}

<span class="org-doc">/// Collections that have a definite size that we can access. Implies</span>
<span class="org-doc">/// that it can also be appended to.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Sized</span> {
    <span class="org-doc">/// Associative containers associate Items in pairs, like Map or</span>
    <span class="org-doc">/// Dict in other languages.</span>
    <span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>),
    <span class="org-doc">/// List containers have multiple Items in a specific order.</span>
    <span class="org-type">List</span>(<span class="org-type">List</span>),
    <span class="org-doc">/// Set containers have multiple Items in no particular order, and</span>
    <span class="org-doc">/// each Item can only appear once.</span>
    <span class="org-type">Set</span>(<span class="org-type">Set</span>),
    <span class="org-doc">/// A String is a chunk of text, like a list of individual</span>
    <span class="org-doc">/// characters.</span>
    <span class="org-type">String</span>(<span class="org-type">String</span>),
    <span class="org-doc">/// Bytes is the lowest common denominator form of data, useful</span>
    <span class="org-doc">/// for when no other type applies.</span>
    <span class="org-type">Bytes</span>(<span class="org-type">Bytes</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.is_empty() &amp;&amp; other.is_empty() {
            <span class="org-keyword">return</span> <span class="org-keyword">true</span>;
        }
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(a), <span class="org-type">Sized</span>::<span class="org-type">String</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)) =&gt; a == b,
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Set</span>(b)) =&gt; a == b,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Dispenser</span> {
    <span class="org-doc">/// Takes an item out of the [Dispenser], and returns a future</span>
    <span class="org-doc">/// that gives a new [Dispenser], and the [Item] that was removed</span>
    <span class="org-doc">/// (if there was one).</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Future</span>&lt;(<span class="org-type">Dispenser</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;)&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; {
                <span class="org-keyword">let</span> (s, item) = s.take();

                <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready((<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s), item)))
            }
            <span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-keyword">mut</span> o) =&gt; <span class="org-type">Box</span>::pin({
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = o.take();
                i.map(|r| {
                    (
                        <span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o),
                        <span class="org-keyword">match</span> r {
                            <span class="org-type">Ok</span>(<span class="org-type">Some</span>(i)) =&gt; <span class="org-type">Some</span>(i),
                            <span class="org-type">Ok</span>(<span class="org-type">None</span>) =&gt; <span class="org-type">None</span>,
                            <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Some</span>(<span class="org-type">Item</span>::from(e)),
                        },
                    )
                })
            }),
            <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(<span class="org-keyword">mut</span> t) =&gt; <span class="org-type">Box</span>::pin({
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = t.take();
                i.map(|r| {
                    (
                        <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t),
                        <span class="org-keyword">match</span> r {
                            <span class="org-type">Ok</span>(<span class="org-type">Some</span>(i)) =&gt; <span class="org-type">Some</span>(i),
                            <span class="org-type">Ok</span>(<span class="org-type">None</span>) =&gt; <span class="org-type">None</span>,
                            <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Some</span>(<span class="org-type">Item</span>::from(e)),
                        },
                    )
                })
            }),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Sized</span> {
    <span class="org-doc">/// Returns whether the collection is empty</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">self</span>.len() == 0
    }

    <span class="org-doc">/// Returns the number of items in the collection.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; a.len(),
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(l) =&gt; l.len(),
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; s.len(),
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; b.len(),
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(s) =&gt; s.len(),
        }
    }

    <span class="org-doc">/// Takes an item out of the collection, returning the item and</span>
    <span class="org-doc">/// the rest of the collection separately. Items are taken from</span>
    <span class="org-doc">/// the front (beginning) of the collection.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">self</span>) -&gt; (<span class="org-type">Self</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; {
                <span class="org-keyword">let</span> (a, i) = a.take();
                (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = l.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = lm.pop_front();
                (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> s) =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: this may perform badly</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">first_char</span> = s.chars().next();
                s.drain(..first_char.map(|s| s.len_utf8()).unwrap_or(0));
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = first_char.map(<span class="org-type">Item</span>::<span class="org-type">Char</span>);
                (<span class="org-type">Sized</span>::<span class="org-type">String</span>(s), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> b) =&gt; {
                <span class="org-keyword">if</span> b.is_empty() {
                    (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), <span class="org-type">None</span>)
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-type">Some</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(b[0] <span class="org-keyword">as</span> <span class="org-type">Int</span>)));
                    b.drain(..1);
                    (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), i)
                }
            }
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = s.iter().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">sm</span> = s.make_mut();
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(i) = i.clone() {
                    sm.take(<span class="org-rust-ampersand">&amp;</span>i);
                }
                (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), i.map(<span class="org-type">Item</span>::from))
            }
        }
    }

    <span class="org-doc">/// Takes an item from the back (end) of the collection.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop</span>(<span class="org-keyword">self</span>) -&gt; (<span class="org-type">Self</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; {
                <span class="org-keyword">let</span> (a, i) = a.take();
                (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = l.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = lm.pop_back();
                (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), i)
            }
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> s) =&gt; s
                .pop()
                .map(|c| (<span class="org-type">Sized</span>::<span class="org-type">String</span>(s), <span class="org-type">Some</span>(c.into())))
                .unwrap_or((<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-type">String</span>::new()), <span class="org-type">None</span>)),
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> b) =&gt; b
                .pop()
                .map(|c| (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), <span class="org-type">Some</span>((c <span class="org-keyword">as</span> <span class="org-type">Int</span>).into())))
                .unwrap_or((<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-preprocessor">vec!</span>[]), <span class="org-type">None</span>)),
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = s.iter().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">sm</span> = s.make_mut();
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(i) = i.clone() {
                    sm.take(<span class="org-rust-ampersand">&amp;</span>i);
                }
                (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), i.map(<span class="org-type">Item</span>::from))
            }
        }
    }

    <span class="org-doc">/// Puts an item into the collection, at the end.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Sized</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> c), i) =&gt; {
                c.make_mut().push_back(i);
                <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(c))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), l) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a.put(l)<span class="org-rust-question-mark">?</span>)),
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> s), i) =&gt; {
                s.make_mut().insert(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(i)<span class="org-rust-question-mark">?</span>);
                <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> b), <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i))) =&gt; {
                b.push(i <span class="org-keyword">as</span> <span class="org-type">u8</span>);
                <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_), i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"integer"</span>, i)),
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> s), <span class="org-type">Item</span>::<span class="org-type">Char</span>(c)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::<span class="org-type">String</span>({
                s.push(c);
                s
            })),
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(_), i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"char"</span>, i)),
        }
    }

    <span class="org-doc">/// Joins two collections into one. If the collections are</span>
    <span class="org-doc">/// different types, generally the result is the type of the first</span>
    <span class="org-doc">/// argument.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">join</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Sized</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-type">Ok</span>(<span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(l)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">la</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-constant">assoc</span>::<span class="org-type">Association</span>::try_from_iter(
                    l.clone().inner().into_iter(),
                )<span class="org-rust-question-mark">?</span>);
                <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a.join(la))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">la</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-constant">assoc</span>::<span class="org-type">Association</span>::try_from_iter(
                    l.clone().inner().into_iter(),
                )<span class="org-rust-question-mark">?</span>);
                <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(la.join(a))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(b)) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a.join(b)),
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                am.extend(b.inner());
                <span class="org-type">Sized</span>::<span class="org-type">List</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">Set</span>(b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                am.extend(b.inner());
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(a), <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">bm</span> = b.make_mut();

                bm.extend(
                    a.inner()
                        .into_iter()
                        .map(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from)
                        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
                );
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(b)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">List</span>(b)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();

                am.extend(
                    b.inner()
                        .into_iter()
                        .map(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from)
                        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
                );
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">String</span>(b)) =&gt; {
                a.push_str(<span class="org-rust-ampersand">&amp;</span>b);
                <span class="org-type">Sized</span>::<span class="org-type">String</span>(a)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-keyword">mut</span> a), <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)) =&gt; {
                a.extend(b);
                <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(a)
            }
            (s, other) =&gt; {
                <span class="org-keyword">if</span> s.is_empty() {
                    other
                } <span class="org-keyword">else</span> <span class="org-keyword">if</span> other.is_empty() {
                    s
                } <span class="org-keyword">else</span> {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"joinable"</span>, <span class="org-preprocessor">list!</span>(s, other)))<span class="org-rust-question-mark">?</span>
                }
            }
        })
    }

    <span class="org-doc">/// Returns whether this collection contains the given [Item].</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a), other) =&gt; {
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(other.clone()).map_or(<span class="org-keyword">false</span>, |k| a.contains_key(<span class="org-rust-ampersand">&amp;</span>k))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), other) =&gt; l.contains(other),
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">Set</span>(other)))) =&gt; {
                other.is_subset(s)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">Set</span>(other)))) =&gt; {
                other.is_subset(s)
            }
            (<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s), other) =&gt; {
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(other.clone()).map_or(<span class="org-keyword">false</span>, |k| s.contains(<span class="org-rust-ampersand">&amp;</span>k))
            }
            (<span class="org-type">Sized</span>::<span class="org-type">String</span>(container), other) =&gt; <span class="org-keyword">match</span> other {
                <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; container.contains(*c),
                i =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">String</span>::try_from(i.clone());
                    <span class="org-keyword">match</span> s {
                        <span class="org-type">Ok</span>(s) =&gt; container.contains(<span class="org-rust-ampersand">&amp;</span>s),
                        <span class="org-type">Err</span>(_) =&gt; <span class="org-keyword">false</span>,
                    }
                }
            },
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }

    <span class="org-doc">/// Returns a new empty version of this collection. Does not</span>
    <span class="org-doc">/// modify this collection. The new collection will be the same</span>
    <span class="org-doc">/// type as this one (if this is a [Sized::String], you'll get an empty</span>
    <span class="org-doc">/// [Sized::String], etc)</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Sized</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_) =&gt; {
                <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new()))
            }
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-type">List</span>::default()),
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Set</span>(<span class="org-type">Set</span>::default()),
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-type">String</span>::new()),
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_) =&gt; <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(<span class="org-preprocessor">vec!</span>[]),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Receptacle</span> {
    <span class="org-doc">/// Puts the given [Item] into this collection, items are added at</span>
    <span class="org-doc">/// the end.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Receptacle</span>, <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(s.put(i).map(<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>))),
            <span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-keyword">mut</span> p) =&gt; <span class="org-type">Box</span>::pin(p.put(i).map(|r| r.map(|_| <span class="org-type">Receptacle</span>::<span class="org-type">In</span>(p)))),
            <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(<span class="org-keyword">mut</span> t) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = t.put(i);
                <span class="org-type">Box</span>::pin(p.map(|r| r.map(|_| <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t))))
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-type">Item</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(map) =&gt; <span class="org-type">Box</span>::new(map.into_iter().map(|kv| kv.into())),
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(list) =&gt; <span class="org-type">Box</span>::new(list.inner().into_iter()),
            <span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">chars</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">char</span>&gt; = s.chars().collect();
                <span class="org-type">Box</span>::new(chars.into_iter().map(|c| c.into()))
            }
            <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">vec</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt; = b.into_iter().map(|byte| <span class="org-type">Item</span>::from(byte <span class="org-keyword">as</span> <span class="org-type">Int</span>)).collect();
                <span class="org-type">Box</span>::new(vec.into_iter())
            }
            <span class="org-type">Sized</span>::<span class="org-type">Set</span>(s) =&gt; <span class="org-type">Box</span>::new(s.inner().into_iter().map(|i| i.into())),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Dispenser</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Dispenser</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("from iterable {:?}", c);</span>
        <span class="org-keyword">match</span> c {
            <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(s),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Receptacle</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Receptacle</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> c {
            <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(s),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(i))),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> s {
            <span class="org-type">Sized</span>::<span class="org-type">List</span>(l) =&gt; <span class="org-type">Ok</span>(l),
            <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; <span class="org-type">Ok</span>(<span class="org-type">List</span>::from_iter(a.into_iter().map(<span class="org-type">Item</span>::from))),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"list"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">List</span>::from_iter(v)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">List</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(l) =&gt; <span class="org-type">Sized</span>::try_from(l).and_then(<span class="org-type">List</span>::try_from),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(l) =&gt; <span class="org-type">Sized</span>::try_from(l).and_then(<span class="org-type">List</span>::try_from),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"list"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> item {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c) =&gt; c.try_into(),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p) =&gt; <span class="org-type">Dispenser</span>::try_from(p)<span class="org-rust-question-mark">?</span>.try_into(),
            i =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">let bt = backtrace::Backtrace::new();</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">println!("try from item {:?},\n {:?}", i, bt);</span>
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"sized"</span>, i))
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Receptacle</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> item {
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c) =&gt; c.try_into(),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"packable"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Dispenser</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Receptacle</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Dispenser</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> c {
            <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s)),
            <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"packable"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Receptacle</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Receptacle</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> c {
            <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)),
            <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"iterable"</span>, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(i))),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-type">Ok</span>(<span class="org-type">Sized</span>::try_from(item)<span class="org-rust-question-mark">?</span>.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">sized</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Box</span>::new(sized.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">List</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">List</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Sized</span>::<span class="org-type">List</span>(l)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">String</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Sized</span>::<span class="org-type">String</span>(s)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Bytes</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">b</span>: <span class="org-type">Bytes</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">List</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">List</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">List</span>(l)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Set</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">l</span>: <span class="org-type">Set</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::<span class="org-type">Set</span>(l)))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Dispenser</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">c</span>: <span class="org-type">Dispenser</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Sized</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> item {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(c) =&gt; <span class="org-type">Ok</span>(c),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Dispenser</span>::try_from(p)<span class="org-rust-question-mark">?</span>),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"iterable"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Set</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">item</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">Sized</span>::try_from(item)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">hs</span>: <span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt; = s
            .into_iter()
            .map(|i| i.try_into())
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">HashSet</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(<span class="org-type">Set</span>::from(hs))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-type">List</span>::default())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::default())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Receptacle</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-type">Sized</span>::default())
    }
}

<span class="org-keyword">mod</span> <span class="org-constant">serde</span> {
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::{<span class="org-type">Dispenser</span>, <span class="org-type">Receptacle</span>, <span class="org-type">Sized</span>};
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span>;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::associative <span class="org-keyword">as</span> assoc;
    <span class="org-keyword">use</span> <span class="org-constant">serde</span>::<span class="org-constant">ser</span>::{<span class="org-type">Serialize</span>, <span class="org-type">SerializeMap</span>, <span class="org-type">SerializeSeq</span>};

    <span class="org-keyword">impl</span> <span class="org-type">Serialize</span> <span class="org-keyword">for</span> <span class="org-type">Dispenser</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">serialize</span>&lt;<span class="org-type">S</span>&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">serializer</span>: <span class="org-type">S</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">S</span>::<span class="org-type">Ok</span>, <span class="org-type">S</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">S</span>: <span class="org-constant">serde</span>::<span class="org-type">Serializer</span>,
        {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
                <span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o) =&gt; o.representation().serialize(serializer),
                <span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t) =&gt; t.representation().serialize(serializer),
                <span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s) =&gt; s.serialize(serializer),
            }
        }
    }

    <span class="org-keyword">impl</span> <span class="org-type">Serialize</span> <span class="org-keyword">for</span> <span class="org-type">Receptacle</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">serialize</span>&lt;<span class="org-type">S</span>&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">serializer</span>: <span class="org-type">S</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">S</span>::<span class="org-type">Ok</span>, <span class="org-type">S</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">S</span>: <span class="org-constant">serde</span>::<span class="org-type">Serializer</span>,
        {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
                <span class="org-type">Receptacle</span>::<span class="org-type">In</span>(i) =&gt; i.representation().serialize(serializer),
                <span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t) =&gt; t.representation().serialize(serializer),
                <span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s) =&gt; s.serialize(serializer),
            }
        }
    }

    <span class="org-keyword">impl</span> <span class="org-type">Serialize</span> <span class="org-keyword">for</span> <span class="org-type">Sized</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">serialize</span>&lt;<span class="org-type">S</span>&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">serializer</span>: <span class="org-type">S</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">S</span>::<span class="org-type">Ok</span>, <span class="org-type">S</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">S</span>: <span class="org-constant">serde</span>::<span class="org-type">Serializer</span>,
        {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
                <span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">Start serializing a map</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">assoc</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from(a.clone());
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">map</span> = serializer.serialize_map(<span class="org-type">Some</span>(assoc.len()))<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">for</span> (key, value) <span class="org-keyword">in</span> assoc.inner() {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">Serialize each entry in the map</span>
                        map.serialize_entry(<span class="org-rust-ampersand">&amp;</span>key, <span class="org-rust-ampersand">&amp;</span>value)<span class="org-rust-question-mark">?</span>;
                    }
                    <span class="org-comment-delimiter">// </span><span class="org-comment">Finish serializing the map</span>
                    map.end()
                }

                <span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">ref</span> <span class="org-variable-name">l</span>) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">Serialize a list (sequence)</span>
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">seq</span> = serializer.serialize_seq(<span class="org-type">Some</span>(l.len()))<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">for</span> <span class="org-variable-name">element</span> <span class="org-keyword">in</span> l.inner() {
                        seq.serialize_element(<span class="org-rust-ampersand">&amp;</span>element)<span class="org-rust-question-mark">?</span>;
                    }
                    seq.end()
                }
                <span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; serializer.serialize_bytes(b.as_slice()),
                <span class="org-type">Sized</span>::<span class="org-type">Set</span>(s) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">Serialize a list (sequence)</span>
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">seq</span> = serializer.serialize_seq(<span class="org-type">Some</span>(s.len()))<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">for</span> <span class="org-variable-name">element</span> <span class="org-keyword">in</span> s.inner() {
                        seq.serialize_element(<span class="org-rust-ampersand">&amp;</span>element)<span class="org-rust-question-mark">?</span>;
                    }
                    seq.end()
                }
                <span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; serializer.serialize_str(s.as_str()),
            }
        }
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org4c75ff1" class="outline-5">
<h5 id="org4c75ff1"><span class="section-number-5">1.5.2.3.</span> Associative types</h5>
<div class="outline-text-5" id="text-1-5-2-3">
<div class='tangle-wrapper' data-tangle='src/types/container/associative.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! Support for Associative data types (similar contract to Rust's</span>
<span class="org-doc">//! HashMap). Includes specific runtime data types like Errors,</span>
<span class="org-doc">//! Dictionaries, Environments, as well as generic maps (which are</span>
<span class="org-doc">//! called "associations" in kcats)</span>
<span class="org-keyword">use</span> <span class="org-keyword">super</span>::{dictionary <span class="org-keyword">as</span> dict, environment <span class="org-keyword">as</span> env};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::{<span class="org-type">Int</span>, <span class="org-type">Number</span>};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">iter</span>::<span class="org-type">FromIterator</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::sync;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Associationy</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt; = <span class="org-type">Newtype</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt;&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">AssociationContent</span> = <span class="org-type">Associationy</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Association</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">AssociationContent</span>&gt;;

<span class="org-doc">/// A KeyItem is all the Item types that can be used as a key in an</span>
<span class="org-doc">/// Associative structure. In order to be a key, the type has to be</span>
<span class="org-doc">/// hashable and have an ordering, so types like floating point</span>
<span class="org-doc">/// numbers or sets can't be used.</span>
<span class="org-preprocessor">#[derive(Debug, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">KeyItem</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Order matters here, for comparison purposes - changing the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">order will change the result of how eg int compares to word.</span>
    <span class="org-type">Int</span>(<span class="org-type">Int</span>),
    <span class="org-type">Char</span>(<span class="org-type">Char</span>),
    <span class="org-type">Word</span>(<span class="org-type">Word</span>),
    <span class="org-type">Bytes</span>(<span class="org-type">Bytes</span>),
    <span class="org-type">String</span>(<span class="org-type">String</span>),
    <span class="org-type">List</span>(<span class="org-type">KeyList</span>),
}

<span class="org-doc">/// An Entry is a single pairing in an Associative type</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Entry</span> = (<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>);

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">KeyListContent</span> = <span class="org-constant">coll</span>::<span class="org-type">Listy</span>&lt;<span class="org-type">KeyItem</span>&gt;;
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">KeyList</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">KeyListContent</span>&gt;;

<span class="org-keyword">impl</span> <span class="org-type">KeyList</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">try_from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">l</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt;
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;,
    {
        <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            l.into_iter()
                .map(<span class="org-type">KeyItem</span>::try_from)
                .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">KeyItem</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
        )))
    }
}

<span class="org-doc">/// An Associative is a container type that associates one Item (the</span>
<span class="org-doc">/// key) with another (the value). It has the property where you can</span>
<span class="org-doc">/// look up a value using the key, and you can update the value that a</span>
<span class="org-doc">/// key points to. Some Item types cannot be used as keys, only</span>
<span class="org-doc">/// [KeyItem] is accepted as an Associative key.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Associative</span> {
    <span class="org-doc">/// A generic associative structure where you can associate any</span>
    <span class="org-doc">/// [KeyItem] with any [Item].</span>
    <span class="org-type">Assoc</span>(<span class="org-type">Association</span>),
    <span class="org-doc">/// Represents an [dict::Dictionary] entry structure with</span>
    <span class="org-doc">/// specific keys.</span>
    <span class="org-type">DictEntry</span>(<span class="org-constant">dict</span>::<span class="org-type">Entry</span>),
    <span class="org-doc">/// Represents an execution environment, with specific keys</span>
    <span class="org-type">Env</span>(<span class="org-constant">env</span>::<span class="org-type">Environment</span>),
    <span class="org-doc">/// Represents a runtime Error value, with specific keys</span>
    <span class="org-type">Error</span>(<span class="org-type">Error</span>),
    <span class="org-doc">/// Represents a dictionary for an execution environment, with</span>
    <span class="org-doc">/// more specific key and value types.</span>
    <span class="org-type">Dictionary</span>(<span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>),
    <span class="org-type">Nothing</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">KeyItem</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> i {
            <span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i)),
            <span class="org-type">KeyItem</span>::<span class="org-type">String</span>(i) =&gt; i.into(),
            <span class="org-type">KeyItem</span>::<span class="org-type">List</span>(l) =&gt; <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(l.inner().into_iter().map(<span class="org-type">Item</span>::from)).into(),
            <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Item</span>::<span class="org-type">Word</span>(w),
            <span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(bs) =&gt; bs.into(),
            <span class="org-type">KeyItem</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-type">Item</span>::<span class="org-type">Char</span>(c),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(<span class="org-type">Word</span>::from(i))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Word</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(i)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i)) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(i)),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">String</span>(i))
            }
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">String</span>(i))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(i)),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(i))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">List</span>(
                <span class="org-type">KeyList</span>::try_from_iter(l.inner().into_iter())<span class="org-rust-question-mark">?</span>,
            )),
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w)),
            <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Char</span>(c)),

            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"KeyItem"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Word</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">k</span>: <span class="org-type">KeyItem</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> k {
            <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Ok</span>(w),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"word"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(a), <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Env</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Env</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Error</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Error</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(a), <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(b)) =&gt; a == b,
            (<span class="org-type">Associative</span>::<span class="org-type">Nothing</span>, <span class="org-type">Associative</span>::<span class="org-type">Nothing</span>) =&gt; <span class="org-keyword">true</span>,
            <span class="org-comment-delimiter">//</span><span class="org-comment">(Associative::Assoc(a), b) =&gt; Association::from(a) == Association::from(b),</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">(a, Associative::Assoc(b)) =&gt; Association::from(a) == Association::from(b),</span>
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Associative</span> {
    <span class="org-doc">/// Retuns the number of associations in the container</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a.len(),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(a) =&gt; a.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; d.len(),
            <span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; 0,
        }
    }

    <span class="org-doc">/// Returns true if the container is empty</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">self</span>.len() == 0
    }

    <span class="org-doc">/// Inserts a new association of a [KeyItem] to [Item]. If the key</span>
    <span class="org-doc">/// already exists, the value is replaced and the old value is</span>
    <span class="org-doc">/// returned. If the key doesn't exist, a new one is created with</span>
    <span class="org-doc">/// the new value and no old value is returned. The overall return</span>
    <span class="org-doc">/// value is tuple of an updated Associative, and an optional old</span>
    <span class="org-doc">/// value.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// The Associative returned is not necessarily the same type as</span>
    <span class="org-doc">/// self, as sometimes there is auto-demotion, eg from Error to</span>
    <span class="org-doc">/// Association. Demotion typically happens when you insert a key</span>
    <span class="org-doc">/// into a type that doesn't support that key, you'll get a more</span>
    <span class="org-doc">/// generic type back instead.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-type">KeyItem</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; (<span class="org-type">Associative</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> a);
                <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = am.insert(k, v);
                (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), e)
            }
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; <span class="org-keyword">match</span> (k, v) {
                (<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w), e) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">e2</span> = e.clone();
                    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Ok</span>(e) = <span class="org-constant">dict</span>::<span class="org-type">Entry</span>::try_from(e) {
                        <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> d);
                        <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = dm.insert(w, e).map(<span class="org-type">Item</span>::from);
                        (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), e)
                    } <span class="org-keyword">else</span> {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO silently failing to insert here is bad</span>
                        <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Warning, failed to insert into dictionary: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e2);
                        (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), <span class="org-type">None</span>)
                    }
                }
                _ =&gt; (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), <span class="org-type">None</span>),
            },
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.insert(k, v),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(<span class="org-keyword">mut</span> de) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(<span class="org-keyword">ref</span> <span class="org-variable-name">w</span>) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">w</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span> = w.into();
                    <span class="org-keyword">if</span> w == <span class="org-string">"definition"</span> {
                        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v);
                        <span class="org-keyword">match</span> l {
                            <span class="org-type">Ok</span>(l) =&gt; {
                                de.definition = <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(l);
                                (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: return the old def</span>
                            }
                            <span class="org-type">Err</span>(_) =&gt; (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>),
                        }
                    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> w == <span class="org-string">"examples"</span> {
                        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v);
                        <span class="org-keyword">match</span> l {
                            <span class="org-type">Ok</span>(l) =&gt; {
                                de.examples = <span class="org-type">Some</span>(l);
                                (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: return the old examples</span>
                            }
                            <span class="org-type">Err</span>(_) =&gt; (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>),
                        }
                    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> w == <span class="org-string">"spec"</span> {
                        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v);
                        <span class="org-keyword">match</span> l {
                            <span class="org-type">Ok</span>(l) =&gt; {
                                de.spec = l.try_into().ok();
                                (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: return the old spec</span>
                            }
                            <span class="org-type">Err</span>(_) =&gt; (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>),
                        }
                    } <span class="org-keyword">else</span> {
                        (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>)
                    }
                }
                _ =&gt; (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(de), <span class="org-type">None</span>),
            },
            _ =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"insert Implementations for error, env etc"</span>),
        }
    }

    <span class="org-doc">/// The put operation is for generic containers, adding a new Item</span>
    <span class="org-doc">/// to the container. In the case of Associative, we can still do</span>
    <span class="org-doc">/// this if the Item is the right type: a key/value pair. If it's</span>
    <span class="org-doc">/// the right type, we [Self::insert] the value using the key,</span>
    <span class="org-doc">/// otherwise return an error.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Associative</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> this), other) =&gt; {
                <span class="org-keyword">let</span> (word, entry) = &lt;(<span class="org-type">Word</span>, <span class="org-constant">dict</span>::<span class="org-type">Entry</span>)&gt;::try_from(other)<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">thismut</span> = this.make_mut();
                thismut.insert(word.into(), entry.into());
                <span class="org-type">Ok</span>(<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(this))
            }
            (this, other) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">entry</span>: (<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = other.try_into()<span class="org-rust-question-mark">?</span>;
                <span class="org-type">Ok</span>(this.insert(entry.0, entry.1).0)
            }
        }
    }

    <span class="org-doc">/// The join operation is for generic containers, but we can join</span>
    <span class="org-doc">/// two Associatives by merging them together. If both</span>
    <span class="org-doc">/// Associatives are the same specific type, the type is</span>
    <span class="org-doc">/// preserved. If `other` can be converted to the same specific</span>
    <span class="org-doc">/// type as `self`, that conversion will be done and the specific</span>
    <span class="org-doc">/// type of `self` is preserved. If they are different types and we</span>
    <span class="org-doc">/// can't convert `other` to `self`s type, the result will be</span>
    <span class="org-doc">/// demoted to a more generic form.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// Keys in `other` have priority over those in `self` - if a key</span>
    <span class="org-doc">/// is in both containers, the result will have only the value</span>
    <span class="org-doc">/// from `other`.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">join</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Associative</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">same type means 2nd one wins.</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: a little more complex for types that can be extended</span>
            (<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(_), <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(other)) =&gt; {
                <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(other)
            }
            (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> this), <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(other)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">thism</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> this);
                thism.extend(other.inner());
                <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(this)
            }
            (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> this), <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(other)) =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">Try to convert to dictionary type</span>
                <span class="org-keyword">match</span> other.inner().convert::&lt;<span class="org-type">Word</span>, <span class="org-constant">dict</span>::<span class="org-type">Entry</span>&gt;() {
                    <span class="org-type">Ok</span>(d) =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">tm</span> = this.make_mut();
                        tm.extend(d);
                        <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(this)
                    }
                    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: convert the other way (to assoc) instead</span>
                    <span class="org-type">Err</span>(_) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(this),
                }
            }
            (<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_), <span class="org-type">Associative</span>::<span class="org-type">Error</span>(other)) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Error</span>(other),
            (<span class="org-type">Associative</span>::<span class="org-type">Env</span>(_), <span class="org-type">Associative</span>::<span class="org-type">Env</span>(other)) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Env</span>(other),
            (<span class="org-type">Associative</span>::<span class="org-type">Nothing</span>, <span class="org-type">Associative</span>::<span class="org-type">Nothing</span>) =&gt; <span class="org-type">Associative</span>::<span class="org-type">Nothing</span>,
            (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> this), other) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">thism</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> this);
                thism.extend(other);
                <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(this)
            }
            (this, other) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">thisa</span>: <span class="org-type">Association</span> = this.into();
                (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(thisa)).join(other)
            }
        }
    }

    <span class="org-doc">/// Retrieves a value from the container using the key</span>
    <span class="org-doc">/// `k`. Returns [None] if the key is not present.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">KeyItem</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a.get(k).cloned(),
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.data.get(k).cloned(),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(s) =&gt; e.get(s.into()),
                _ =&gt; <span class="org-type">None</span>,
            },
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(d) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(s) =&gt; d.get(s.into()),
                _ =&gt; <span class="org-type">None</span>,
            },
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; d.get(w).map(|x| x.clone().into()),
                _ =&gt; <span class="org-type">None</span>,
            },
            <span class="org-rust-ampersand">&amp;</span><span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">None</span>,
        }
    }

    <span class="org-doc">/// Returns true if the key `k` is present in the container.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains_key</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">KeyItem</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.data.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(d) =&gt; d.contains_key(k),
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; <span class="org-keyword">match</span> k {
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; d.contains_key(w),
                _ =&gt; <span class="org-keyword">false</span>,
            },
            <span class="org-rust-ampersand">&amp;</span><span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-keyword">false</span>,
        }
    }

    <span class="org-doc">/// Removes the key `k` from the container, returning a tuple of a</span>
    <span class="org-doc">/// new [Associative] and an optional value if the key was</span>
    <span class="org-doc">/// present.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">remove</span>(<span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">KeyItem</span>) -&gt; (<span class="org-type">Associative</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> a);
                <span class="org-keyword">let</span> <span class="org-variable-name">v</span> = am.remove(k);
                (<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), v)
            }
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> d);
                <span class="org-keyword">let</span> <span class="org-variable-name">v</span> = dm.remove(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Word</span>::try_from(k.clone()).unwrap_or_default());
                (<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d), v.map(|v| v.into()))
            }
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(<span class="org-keyword">mut</span> e) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = e.data.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">v</span> = a.remove(k);
                (<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e), v)
            }
            _ =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"Removing from other associative types"</span>),
        }
    }

    <span class="org-doc">/// The take operation is for generic containers but we can</span>
    <span class="org-doc">/// perform it on an Associative by removing an arbitrary pair and</span>
    <span class="org-doc">/// returning it.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">self</span>) -&gt; (<span class="org-type">Self</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-keyword">mut</span> a) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_key</span> = a.inner().keys().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_value</span> = maybe_key.as_ref().and_then(|key| am.remove(key));
                (
                    <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a),
                    maybe_key.map(|key| {
                        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(<span class="org-preprocessor">vec!</span>[
                            <span class="org-type">Item</span>::from(key),
                            maybe_value.unwrap_or_default(),
                        ])
                        .into()
                    }),
                )
            }
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(<span class="org-keyword">mut</span> d) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_key</span> = d.inner().keys().next().cloned();
                <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = d.make_mut();
                <span class="org-keyword">let</span> <span class="org-variable-name">maybe_value</span> = maybe_key.clone().and_then(|key| dm.remove(<span class="org-rust-ampersand">&amp;</span>key));
                (
                    <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d),
                    maybe_key.map(|key| {
                        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(<span class="org-preprocessor">vec!</span>[
                            <span class="org-type">Item</span>::<span class="org-type">Word</span>(key),
                            maybe_value.map(<span class="org-type">Item</span>::from).unwrap_or(<span class="org-type">Item</span>::default()),
                        ])
                        .into()
                    }),
                )
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">The remaining impls may require auto-demotion (eg,</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">removing a required field from say, Error)</span>
            _ =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"taking from assoc Requires insert/remove impl"</span>),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>&lt;'<span class="org-variable-name">a</span>&gt;(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; <span class="org-type">Box</span>::new(a.inner().into_iter()),
            <span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(e) =&gt; <span class="org-type">Box</span>::new(e.into_iter()),
            <span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d) =&gt; {
                <span class="org-type">Box</span>::new(d.inner().into_iter().map(|(k, v)| (k.into(), v.into())))
            }
            <span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; e.into_iter(),
            <span class="org-type">Associative</span>::<span class="org-type">Env</span>(e) =&gt; e.into_iter(),
            <span class="org-type">Associative</span>::<span class="org-type">Nothing</span> =&gt; <span class="org-type">Box</span>::new(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::empty()),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">coll</span>::<span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(a)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">Sized</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">s</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; <span class="org-type">Ok</span>(a),
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"associative"</span>, i)),
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"associative"</span>, i)),
            s =&gt; <span class="org-type">Ok</span>(<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(<span class="org-type">Association</span>::try_from_iter(s)<span class="org-rust-question-mark">?</span>)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Associative</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Associative</span>::try_from(s)
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Convert anything that can be iterated over as Items, to an</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Association. The items must be pairs that are</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">convertable to Entry, otherwise it will return an error.</span>
<span class="org-keyword">impl</span> <span class="org-type">Association</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>() -&gt; <span class="org-type">Association</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(<span class="org-type">HashMap</span>::new()))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">try_from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">l</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt;
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;,
    {
        <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            l.into_iter()
                .map(|i| <span class="org-type">Entry</span>::try_from(i.clone()))
                .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">h</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(h))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Entry</span>&gt;,
    {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>&gt;&gt;(),
        ))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">coll</span>::<span class="org-type">List</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Entry</span>&gt;,
    {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">Newtype</span>(
            iter.into_iter()
                .map(|e| e.into())
                .collect::&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;&gt;(),
        ))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">FromIterator</span>&lt;<span class="org-type">KeyItem</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyList</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from_iter</span>&lt;<span class="org-type">I</span>&gt;(<span class="org-variable-name">iter</span>: <span class="org-type">I</span>) -&gt; <span class="org-type">Self</span>
    <span class="org-keyword">where</span>
        <span class="org-variable-name">I</span>: <span class="org-type">IntoIterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">KeyItem</span>&gt;,
    {
        <span class="org-type">Newtype</span>(<span class="org-constant">sync</span>::<span class="org-type">Arc</span>::new(<span class="org-type">Newtype</span>(
            iter.into_iter().collect::&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">KeyItem</span>&gt;&gt;(),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Entry</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-type">Item</span>::from(e.0), e.1]).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> s.len() != 2 {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pair"</span>, s))
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">iter</span> = s.into_iter();
            <span class="org-keyword">let</span> <span class="org-variable-name">key</span>: <span class="org-type">KeyItem</span> = iter.next().unwrap().try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">value</span> = iter.next().unwrap();
            <span class="org-type">Ok</span>((key, value))
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Association</span> {
        <span class="org-keyword">match</span> a {
            <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; a,
            a =&gt; a.into_iter().collect::&lt;<span class="org-type">Association</span>&gt;(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">AssociationContent</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">AssociationContent</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(a).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Association</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Association</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">a</span>: <span class="org-type">Associative</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a).into()
    }
}

<span class="org-doc">/// Convert from any type of hashmap to any other, assuming the keys</span>
<span class="org-doc">/// and values convert</span>
<span class="org-keyword">impl</span>&lt;<span class="org-type">KA</span>, <span class="org-type">VA</span>&gt; <span class="org-type">Newtype</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KA</span>, <span class="org-type">VA</span>&gt;&gt; {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">convert</span>&lt;<span class="org-type">KB</span>, <span class="org-type">VB</span>&gt;(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Newtype</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">KB</span>, <span class="org-type">VB</span>&gt;&gt;, <span class="org-type">Error</span>&gt;
    <span class="org-keyword">where</span>
        <span class="org-variable-name">KB</span>: <span class="org-type">Clone</span> + <span class="org-type">Eq</span> + <span class="org-type">Hash</span> + <span class="org-type">TryFrom</span>&lt;<span class="org-type">KA</span>, <span class="org-type">Error</span> = <span class="org-type">Error</span>&gt;,
        <span class="org-variable-name">VB</span>: <span class="org-type">Clone</span> + <span class="org-type">TryFrom</span>&lt;<span class="org-type">VA</span>, <span class="org-type">Error</span> = <span class="org-type">Error</span>&gt;,
        <span class="org-variable-name">KA</span>: <span class="org-type">Clone</span> + <span class="org-type">Eq</span> + <span class="org-type">Hash</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">Assuming Clone is needed for TryFrom</span>
        <span class="org-variable-name">VA</span>: <span class="org-type">Clone</span>,
    {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">new_hashmap</span> = <span class="org-type">HashMap</span>::new();

        <span class="org-keyword">for</span> (key, value) <span class="org-keyword">in</span> <span class="org-keyword">self</span>.into_iter() {
            <span class="org-keyword">let</span> <span class="org-variable-name">new_key</span>: <span class="org-type">KB</span> = key.try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">new_value</span>: <span class="org-type">VB</span> = value.try_into()<span class="org-rust-question-mark">?</span>;
            new_hashmap.insert(new_key, new_value);
        }

        <span class="org-type">Ok</span>(<span class="org-type">Newtype</span>(new_hashmap))
    }
}

<span class="org-keyword">mod</span> <span class="org-constant">serde</span> {
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::{<span class="org-type">KeyItem</span>, <span class="org-type">KeyList</span>};
    <span class="org-keyword">use</span> <span class="org-constant">serde</span>::<span class="org-constant">de</span>::{<span class="org-keyword">self</span>, <span class="org-type">Deserialize</span>, <span class="org-type">Deserializer</span>, <span class="org-type">Visitor</span>};
    <span class="org-keyword">use</span> <span class="org-constant">serde</span>::<span class="org-constant">ser</span>::{<span class="org-type">Serialize</span>, <span class="org-type">SerializeSeq</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::fmt;

    <span class="org-keyword">struct</span> <span class="org-type">KeyItemVisitor</span>;

    <span class="org-keyword">impl</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-type">Visitor</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItemVisitor</span> {
        <span class="org-keyword">type</span> <span class="org-type">Value</span> = <span class="org-type">KeyItem</span>;

        <span class="org-keyword">fn</span> <span class="org-function-name">expecting</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">formatter</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
            formatter.write_str(<span class="org-string">"expected a specific representation for Item"</span>)
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_i64</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">value</span>: <span class="org-type">i64</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(value))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_u64</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">value</span>: <span class="org-type">u64</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(value <span class="org-keyword">as</span> <span class="org-type">i64</span>))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_str</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">v</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">String</span>(v.to_string()))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_byte_buf</span>&lt;<span class="org-type">E</span>&gt;(<span class="org-keyword">self</span>, <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">E</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">E</span>: <span class="org-constant">de</span>::<span class="org-type">Error</span>,
        {
            <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(v))
        }

        <span class="org-keyword">fn</span> <span class="org-function-name">visit_seq</span>&lt;<span class="org-type">A</span>&gt;(<span class="org-keyword">self</span>, <span class="org-keyword">mut</span> <span class="org-variable-name">seq</span>: <span class="org-type">A</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>::<span class="org-type">Value</span>, <span class="org-type">A</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">A</span>: <span class="org-constant">de</span>::<span class="org-type">SeqAccess</span>&lt;'<span class="org-variable-name">de</span>&gt;,
        {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">items</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">KeyItem</span>&gt; = <span class="org-type">Vec</span>::new();
            <span class="org-keyword">while</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(item) = seq.next_element::&lt;<span class="org-type">KeyItem</span>&gt;()<span class="org-rust-question-mark">?</span> {
                items.push(item);
            }
            <span class="org-type">Ok</span>(<span class="org-type">KeyItem</span>::<span class="org-type">List</span>(<span class="org-type">KeyList</span>::from_iter(items)))
        }
    }

    <span class="org-keyword">impl</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-type">Deserialize</span>&lt;'<span class="org-variable-name">de</span>&gt; <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">deserialize</span>&lt;<span class="org-type">D</span>&gt;(<span class="org-variable-name">deserializer</span>: <span class="org-type">D</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">D</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">D</span>: <span class="org-type">Deserializer</span>&lt;'<span class="org-variable-name">de</span>&gt;,
        {
            deserializer.deserialize_any(<span class="org-type">KeyItemVisitor</span>)
        }
    }

    <span class="org-keyword">impl</span> <span class="org-type">Serialize</span> <span class="org-keyword">for</span> <span class="org-type">KeyItem</span> {
        <span class="org-keyword">fn</span> <span class="org-function-name">serialize</span>&lt;<span class="org-type">S</span>&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">serializer</span>: <span class="org-type">S</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">S</span>::<span class="org-type">Ok</span>, <span class="org-type">S</span>::<span class="org-type">Error</span>&gt;
        <span class="org-keyword">where</span>
            <span class="org-variable-name">S</span>: <span class="org-constant">serde</span>::<span class="org-type">Serializer</span>,
        {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
                <span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(i) =&gt; serializer.serialize_i64(*i),
                <span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; serializer.serialize_str(w.into()),
                <span class="org-type">KeyItem</span>::<span class="org-type">Char</span>(c) =&gt; serializer.serialize_char(*c),
                <span class="org-type">KeyItem</span>::<span class="org-type">Bytes</span>(b) =&gt; serializer.serialize_bytes(b.as_slice()),
                <span class="org-type">KeyItem</span>::<span class="org-type">List</span>(<span class="org-keyword">ref</span> <span class="org-variable-name">l</span>) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">Serialize a list (sequence)</span>
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">seq</span> = serializer.serialize_seq(<span class="org-type">Some</span>(l.len()))<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">for</span> <span class="org-variable-name">element</span> <span class="org-keyword">in</span> l.inner() {
                        seq.serialize_element(<span class="org-rust-ampersand">&amp;</span>element)<span class="org-rust-question-mark">?</span>;
                    }
                    seq.end()
                }
                <span class="org-type">KeyItem</span>::<span class="org-type">String</span>(s) =&gt; serializer.serialize_str(s.as_str()),
            }
        }
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org13d7e61" class="outline-5">
<h5 id="org13d7e61"><span class="section-number-5">1.5.2.4.</span> Error types</h5>
<div class="outline-text-5" id="text-1-5-2-4">
<div class='tangle-wrapper' data-tangle='src/types/container/error.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">super</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Int</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-type">Item</span>, <span class="org-type">Word</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">convert</span>::<span class="org-type">Infallible</span>;

<span class="org-doc">/// Represents a runtime error type. Contains generic fields to hold</span>
<span class="org-doc">/// things like what type of error, the actual vs expected conditions,</span>
<span class="org-doc">/// etc. Also holds whether the error has been handled or not, which</span>
<span class="org-doc">/// the runtime uses to decide whether to keep unwinding the program</span>
<span class="org-doc">/// looking for something to handle the error. An error that has been</span>
<span class="org-doc">/// handled is inert, it is just another data value.</span>
<span class="org-preprocessor">#[derive(Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Error</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">data</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">is_handled</span>: <span class="org-type">bool</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">Error</span> {
    <span class="org-doc">/// Creates a new error.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">create</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;&gt;(<span class="org-variable-name">asked</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">reason</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">actual</span>: <span class="org-type">Option</span>&lt;<span class="org-type">T</span>&gt;) -&gt; <span class="org-type">Error</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">let bt = backtrace::Backtrace::new();</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">data</span>: <span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt; = <span class="org-preprocessor">vec!</span>[
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"error"</span>.into()),
            (<span class="org-string">"asked"</span>.into(), asked.into()),
            (<span class="org-string">"reason"</span>.into(), reason.to_string().into()),
            <span class="org-comment-delimiter">//</span><span class="org-comment">("backtrace".into(), Item::String(format!("{:?}", bt))),</span>
        ];
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(actual) = actual {
            data.push((<span class="org-string">"actual"</span>.into(), actual.into()));
        }
        <span class="org-type">Error</span> {
            <span class="org-variable-name">is_handled</span>: <span class="org-keyword">false</span>,

            <span class="org-variable-name">data</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(data),
        }
    }

    <span class="org-doc">/// Creates a stack underflow error for when the current word</span>
    <span class="org-doc">/// needs more items than there are on the stack.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">stack_underflow</span>() -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-preprocessor">list!</span>(<span class="org-string">"consume"</span>),
            <span class="org-string">"not enough items on stack"</span>,
            <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>,
        )
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">overflow</span>() -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"arithmetic"</span>), <span class="org-string">"number overflow"</span>, <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">undefined</span>(<span class="org-variable-name">w</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(w), <span class="org-string">"word is not defined"</span>, <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">type_mismatch</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;&gt;(<span class="org-variable-name">asked</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">actual</span>: <span class="org-type">Option</span>&lt;<span class="org-type">T</span>&gt;) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(asked, <span class="org-string">"type mismatch"</span>, actual)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">division_by_zero</span>() -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"/"</span>), <span class="org-string">"division by zero"</span>, <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">expected</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;&gt;(<span class="org-variable-name">typestr</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">actual</span>: <span class="org-type">T</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::type_mismatch(<span class="org-preprocessor">list!</span>(typestr), <span class="org-type">Some</span>(actual))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">short_list</span>(<span class="org-variable-name">expected</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-preprocessor">list!</span>(<span class="org-string">"count"</span>, expected, <span class="org-string">"&gt;="</span>),
            <span class="org-string">"list had too few items"</span>,
            <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>,
        )
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">list_count</span>(<span class="org-variable-name">expected</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-preprocessor">list!</span>(<span class="org-string">"count"</span>, expected, <span class="org-string">"="</span>),
            <span class="org-string">"list had wrong number of items"</span>,
            <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>,
        )
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">negative</span>(<span class="org-variable-name">actual</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::too_small(actual, 0)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">too_small</span>(<span class="org-variable-name">actual</span>: <span class="org-type">Int</span>, <span class="org-variable-name">expected</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(expected, <span class="org-string">"&gt;="</span>), <span class="org-string">"number too small"</span>, <span class="org-type">Some</span>(actual))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">too_large</span>(<span class="org-variable-name">actual</span>: <span class="org-type">Int</span>, <span class="org-variable-name">expected</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(expected, <span class="org-string">"&lt;="</span>), <span class="org-string">"number too large"</span>, <span class="org-type">Some</span>(actual))
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">parse</span>(<span class="org-variable-name">reason</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"read"</span>), reason, <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">test_assertion</span>(<span class="org-variable-name">program</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">expected</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">actual</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">e</span> = <span class="org-type">Error</span>::create(program, <span class="org-string">"assertion failed"</span>, <span class="org-type">Some</span>(actual));
        <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = e.data.make_mut();
        d.insert(<span class="org-string">"expected-program"</span>.into(), expected.into());
        e
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        <span class="org-keyword">self</span>.data.len()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Infallible</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">_x</span>: <span class="org-type">Infallible</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> _x {} <span class="org-comment-delimiter">// </span><span class="org-comment">Since Infallible can never be instantiated, this will never run</span>
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Infallible</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">_x</span>: <span class="org-type">Infallible</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> _x {} <span class="org-comment-delimiter">// </span><span class="org-comment">Since Infallible can never be instantiated, this will never run</span>
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">assoc</span>::<span class="org-type">Association</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Error</span>) -&gt; <span class="org-constant">assoc</span>::<span class="org-type">Association</span> {
        e.data
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e),
            ))) =&gt; <span class="org-type">Ok</span>(e),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_))) =&gt; {
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, <span class="org-type">Item</span>::default()))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(c)) =&gt; c.into_iter().try_into(),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: this can't fail, can just be a From.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Really though, Error should have predefined fields like Environment.</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">data</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::try_from_iter(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(<span class="org-type">Error</span> {
            data,
            <span class="org-variable-name">is_handled</span>: <span class="org-keyword">false</span>,
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> a {
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e) =&gt; <span class="org-type">Ok</span>(e),
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a) =&gt; {
                <span class="org-keyword">if</span> a.get(<span class="org-rust-ampersand">&amp;</span><span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::from(<span class="org-string">"type"</span>)) != <span class="org-type">Some</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-string">"error"</span>)) {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, a))
                } <span class="org-keyword">else</span> {
                    <span class="org-type">Ok</span>(<span class="org-type">Error</span> {
                        <span class="org-variable-name">data</span>: a.clone(),
                        <span class="org-variable-name">is_handled</span>: <span class="org-keyword">true</span>,
                    })
                }
            }
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"error"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Error</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-type">Box</span>::new(
            <span class="org-keyword">self</span>.data
                .inner()
                .into_iter()
                .chain(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::once((<span class="org-string">"handled"</span>.into(), <span class="org-keyword">self</span>.is_handled.into()))),
        )
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org45bea59" class="outline-5">
<h5 id="org45bea59"><span class="section-number-5">1.5.2.5.</span> Dictionary types</h5>
<div class="outline-text-5" id="text-1-5-2-5">
<div class='tangle-wrapper' data-tangle='src/types/container/dictionary.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">super</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">BUILTIN_FUNCTIONS</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::serialize;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashSet</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;

<span class="org-doc">/// The definition of a [Word], contains its actual code (the</span>
<span class="org-doc">/// definition), and also documentation like specs and examples.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">examples</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">spec</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Spec</span>&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">definition</span>: <span class="org-type">Definition</span>,
}

<span class="org-comment-delimiter">// </span><span class="org-comment">TODO: move specs to their own module</span>
<span class="org-doc">/// An element of a [Spec], either an input or an output. Holds the</span>
<span class="org-doc">/// type and optional name of the input/output.</span>
<span class="org-preprocessor">#[derive(Debug, Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">SpecElement</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">elemtype</span>: <span class="org-type">Word</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">name</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Word</span>&gt;,
}

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">StackSpec</span> = <span class="org-type">Vec</span>&lt;<span class="org-type">SpecElement</span>&gt;;

<span class="org-doc">/// The spec of a [Word] consists of the input spec and the output</span>
<span class="org-doc">/// spec, that shows what the stack should look like before and after</span>
<span class="org-doc">/// the [Word] is invoked.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Spec</span> = (<span class="org-type">StackSpec</span>, <span class="org-type">StackSpec</span>);

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">SpecElement</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">SpecElement</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Ok</span>(<span class="org-type">SpecElement</span> {
                <span class="org-variable-name">elemtype</span>: w,
                <span class="org-variable-name">name</span>: <span class="org-type">None</span>,
            }),
            i =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">if</span> s.len() != 2 {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::list_count(2))
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = <span class="org-type">Word</span>::try_from(s.get(0).unwrap().clone())<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">let</span> <span class="org-variable-name">n</span> = <span class="org-type">Word</span>::try_from(s.get(1).unwrap().clone())<span class="org-rust-question-mark">?</span>;
                    <span class="org-type">Ok</span>(<span class="org-type">SpecElement</span> {
                        <span class="org-variable-name">elemtype</span>: t,
                        <span class="org-variable-name">name</span>: <span class="org-type">Some</span>(n),
                    })
                }
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; <span class="org-keyword">for</span> <span class="org-type">StackSpec</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">s</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">StackSpec</span>, <span class="org-type">Error</span>&gt; {
        s.inner()
            .into_iter()
            .map(<span class="org-type">SpecElement</span>::try_from)
            <span class="org-comment-delimiter">//</span><span class="org-comment">.map(|r| r.and_then(SpecElement::try_from))</span>
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">StackSpec</span>, <span class="org-type">Error</span>&gt;&gt;()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Spec</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">s</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Spec</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">if</span> s.len() != 2 {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::list_count(2))
        } <span class="org-keyword">else</span> {
            <span class="org-type">Ok</span>((
                <span class="org-type">StackSpec</span>::try_from(<span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(s.get(0).unwrap().clone())<span class="org-rust-question-mark">?</span>)<span class="org-rust-question-mark">?</span>,
                <span class="org-type">StackSpec</span>::try_from(<span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(s.get(1).unwrap().clone())<span class="org-rust-question-mark">?</span>)<span class="org-rust-question-mark">?</span>,
            ))
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Spec</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Spec</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-type">Spec</span>::try_from(<span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">StackSpec</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">ss</span>: <span class="org-type">StackSpec</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(ss.into_iter().map(<span class="org-type">Item</span>::from)).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">SpecElement</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">se</span>: <span class="org-type">SpecElement</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">if</span> se.name.is_some() {
            <span class="org-preprocessor">list!</span>(se.elemtype, se.name).into()
        } <span class="org-keyword">else</span> {
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(se.elemtype)
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Spec</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">s</span>: <span class="org-type">Spec</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-type">Item</span>::from(<span class="org-preprocessor">list!</span>(s.0, s.1))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        3 <span class="org-comment-delimiter">// </span><span class="org-comment">3 fields</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">match</span> key {
            <span class="org-string">"spec"</span> =&gt; <span class="org-keyword">self</span>.spec.clone().map(|x| x.into()),
            <span class="org-string">"examples"</span> =&gt; <span class="org-keyword">self</span>.examples.clone().map(|x| x.into()),
            <span class="org-string">"definition"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">match</span> <span class="org-keyword">self</span>.definition.clone() {
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(_) =&gt; <span class="org-string">"builtin"</span>.into(),
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; d.into(),
            }),
            _ =&gt; <span class="org-type">None</span>,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains_key</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-type">Word</span>::try_from(key.clone()).map_or(<span class="org-keyword">false</span>, |<span class="org-keyword">ref</span> <span class="org-variable-name">w</span>| {
            <span class="org-preprocessor">matches!</span>(w.into(), <span class="org-string">"examples"</span> | <span class="org-string">"spec"</span> | <span class="org-string">"definition"</span>)
        })
    }
}

<span class="org-doc">/// One of the main components of an</span>
<span class="org-doc">/// [crate::types::container::environment::Environment], holds [Word]s and their</span>
<span class="org-doc">/// definitions.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">Dictionary</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">Word</span>, <span class="org-type">Entry</span>&gt;&gt;;

<span class="org-keyword">impl</span> <span class="org-type">Dictionary</span> {
    <span class="org-doc">/// Returns the difference between this dictionary and a "newer"</span>
    <span class="org-doc">/// one: The additions/updates, and the deletions.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">diff</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">newer</span>: <span class="org-type">Dictionary</span>) -&gt; (<span class="org-type">Vec</span>&lt;(<span class="org-type">Word</span>, <span class="org-type">Entry</span>)&gt;, <span class="org-type">Vec</span>&lt;<span class="org-type">Word</span>&gt;) {
        diff_hashmaps(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.inner(), <span class="org-rust-ampersand">&amp;</span>newer.inner())
    }

    <span class="org-doc">/// Takes a core module (in string form - should contain a series</span>
    <span class="org-doc">/// of word definitions, not wrapped in a single list), and</span>
    <span class="org-doc">/// inserts all the definitions into the dictionary, with an</span>
    <span class="org-doc">/// optional namespace.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert_core_module</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">lexicon</span>: <span class="org-type">String</span>) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Parsing: {}", lexicon);</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">items</span> = <span class="org-constant">serialize</span>::parse(lexicon).unwrap();
        <span class="org-keyword">for</span> <span class="org-variable-name">r</span> <span class="org-keyword">in</span> <span class="org-type">Box</span>::new(items.inner().into_iter()) {
            <span class="org-keyword">let</span> (k, def): (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = r.try_into().unwrap();
            <span class="org-keyword">let</span> <span class="org-variable-name">word</span>: <span class="org-type">Word</span> = k.try_into().unwrap();

            <span class="org-keyword">let</span> <span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt; = def.try_into().unwrap();
            <span class="org-keyword">let</span> <span class="org-variable-name">new_entry</span>: <span class="org-constant">dict</span>::<span class="org-type">Entry</span> = iter.try_into().unwrap();
            <span class="org-keyword">let</span> <span class="org-variable-name">new_entry2</span> = new_entry.clone();
            <span class="org-keyword">let</span> <span class="org-variable-name">dict</span> = <span class="org-keyword">self</span>.make_mut();
            dict.entry(word)
                .and_modify(|e| {
                    e.examples = new_entry.examples;
                    e.spec = new_entry.spec;
                    e.definition = new_entry.definition;
                })
                .or_insert(new_entry2);
        }
    }

    <span class="org-doc">/// Takes a mapping of word to definition, and updates all the</span>
    <span class="org-doc">/// dictionary entries so that the word will call that definition</span>
    <span class="org-doc">/// when the word is executed. The definitions should be Axiom</span>
    <span class="org-doc">/// variants, since those are the ones we have to define in rust.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// This method is used during bootstrap of the default environment.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert_axiom_fns</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">updates</span>: <span class="org-type">Vec</span>&lt;(<span class="org-type">Word</span>, <span class="org-type">Definition</span>)&gt;) {
        <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-keyword">self</span>.make_mut();
        <span class="org-keyword">for</span> (w, f) <span class="org-keyword">in</span> updates {
            dm.entry(w).and_modify(|e| e.definition = f);
        }
    }

    <span class="org-doc">/// For stdlib words that are both built-in and part of a module</span>
    <span class="org-doc">/// that isn't necessarily loaded as part of the standard</span>
    <span class="org-doc">/// environment, we need to be able to link the word to its rust</span>
    <span class="org-doc">/// definition. Calling this function on a dictionary (whether</span>
    <span class="org-doc">/// full or just the partial dictionary created from a module),</span>
    <span class="org-doc">/// will create those links. In order for the links to be created,</span>
    <span class="org-doc">/// the current word currently has to have no definition field</span>
    <span class="org-doc">/// (set to None). Otherwise changes will not be applied.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">add_builtins</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">let</span> <span class="org-variable-name">dm</span> = <span class="org-keyword">self</span>.make_mut();
        <span class="org-keyword">for</span> (bw, bd) <span class="org-keyword">in</span> <span class="org-type">BUILTIN_FUNCTIONS</span>.iter() {
            dm.entry(bw.clone()).and_modify(|d| <span class="org-keyword">match</span> <span class="org-rust-ampersand">&amp;</span>d.definition {
                <span class="org-type">Definition</span>::<span class="org-type">Derived</span>(dd) =&gt; {
                    <span class="org-keyword">if</span> dd.is_empty() {
                        d.definition = bd.clone();
                    }
                }
                _ =&gt; {}
            });
        }
    }
}

<span class="org-doc">/// Returns the differences between two hashmaps, including the keys</span>
<span class="org-doc">/// that have been added or changed (including the new values), and</span>
<span class="org-doc">/// the keys that were deleted.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">diff_hashmaps</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt;(<span class="org-variable-name">a</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">HashMap</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt;, <span class="org-variable-name">b</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">HashMap</span>&lt;<span class="org-type">K</span>, <span class="org-type">V</span>&gt;) -&gt; (<span class="org-type">Vec</span>&lt;(<span class="org-type">K</span>, <span class="org-type">V</span>)&gt;, <span class="org-type">Vec</span>&lt;<span class="org-type">K</span>&gt;)
<span class="org-keyword">where</span>
    <span class="org-variable-name">K</span>: <span class="org-type">Eq</span> + <span class="org-type">Hash</span> + <span class="org-type">Clone</span>,
    <span class="org-variable-name">V</span>: <span class="org-type">PartialEq</span> + <span class="org-type">Clone</span>,
{
    <span class="org-keyword">let</span> <span class="org-variable-name">a_keys</span>: <span class="org-type">HashSet</span>&lt;<span class="org-type">K</span>&gt; = a.keys().cloned().collect();
    <span class="org-keyword">let</span> <span class="org-variable-name">b_keys</span>: <span class="org-type">HashSet</span>&lt;<span class="org-type">K</span>&gt; = b.keys().cloned().collect();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Keys that are in `b` but not in `a` or have updated values in `b`</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">added_or_updated</span>: <span class="org-type">Vec</span>&lt;(<span class="org-type">K</span>, <span class="org-type">V</span>)&gt; = b
        .iter()
        .filter(|(k, v)| !a_keys.contains(k) || a.get(k) != <span class="org-type">Some</span>(v))
        .map(|(k, v)| (k.clone(), v.clone()))
        .collect();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Keys that are in `a` but not in `b`</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">deleted</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">K</span>&gt; = a_keys.difference(<span class="org-rust-ampersand">&amp;</span>b_keys).cloned().collect();

    (added_or_updated, deleted)
}

<span class="org-doc">/// The actual code for what a [Word] should do.</span>
<span class="org-preprocessor">#[derive(Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Definition</span> {
    <span class="org-doc">/// A definition in the base language - a rust function that</span>
    <span class="org-doc">/// modifies the environment.</span>
    <span class="org-type">Axiom</span>(<span class="org-rust-ampersand">&amp;</span>'<span class="org-keyword">static</span> <span class="org-type">StepFn</span>),
    <span class="org-doc">/// A definition in terms of other [Word]s - a kcats program</span>
    <span class="org-type">Derived</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>),
}

<span class="org-comment-delimiter">// </span><span class="org-comment">dictionary entries are equal if they have the same function reference,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">no need to compare the function values</span>
<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Definition</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(s), <span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(o)) =&gt; <span class="org-constant">ptr</span>::eq(*s, *o),
            (<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(s), <span class="org-type">Definition</span>::<span class="org-type">Derived</span>(o)) =&gt; s == o,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">self</span>.definition == other.definition
            &amp;&amp; <span class="org-keyword">self</span>.examples == other.examples
            &amp;&amp; <span class="org-keyword">self</span>.spec == other.spec
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Definition</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(_) =&gt; f.write_str(<span class="org-string">"Builtin"</span>),
            <span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ds</span> = f.debug_list();
                ds.entries(d.iter());
                ds.finish()
            }
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt; = <span class="org-preprocessor">vec!</span>[(<span class="org-string">"definition"</span>.into(), {
            <span class="org-keyword">match</span> <span class="org-keyword">self</span>.definition {
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(l) =&gt; l.into(),
                <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(_) =&gt; <span class="org-string">"builtin-function"</span>.into(),
            }
        })];
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(e) = <span class="org-keyword">self</span>.examples {
            v.push((<span class="org-string">"examples"</span>.into(), e.into()));
        }
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(s) = <span class="org-keyword">self</span>.spec {
            v.push((<span class="org-string">"spec"</span>.into(), s.into()))
        }
        <span class="org-type">Box</span>::new(v.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">examples</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">definition</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Definition</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">spec</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Spec</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> iter {
            <span class="org-keyword">let</span> (k, v): (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = i.try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("k: {:?}, v: {:?}", k, v);</span>
            <span class="org-keyword">if</span> k == <span class="org-string">"examples"</span>.into() {
                examples = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>);
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"definition"</span>.into() {
                definition = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>);
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"spec"</span>.into() {
                spec = v.try_into().ok();
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">continue</span>;
            }
        }
        <span class="org-type">Ok</span>(<span class="org-type">Entry</span> {
            examples,
            <span class="org-variable-name">definition</span>: definition.unwrap_or(<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::default())),
            spec,
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Dictionary</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        iter.map(&lt;(<span class="org-type">Word</span>, <span class="org-type">Entry</span>)&gt;::try_from)
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">Word</span>, <span class="org-type">Entry</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()
            .map(<span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Definition</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i).map(<span class="org-type">Definition</span>::<span class="org-type">Derived</span>)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Entry</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(d)) =&gt; <span class="org-type">Ok</span>(d),
            c =&gt; c.into_iter().try_into(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">assoc</span>::<span class="org-type">Associative</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">d</span>: <span class="org-type">Entry</span>) -&gt; <span class="org-constant">assoc</span>::<span class="org-type">Associative</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">assoc</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new();
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = assoc.make_mut();
        d.examples
            .and_then(|l| a.insert(<span class="org-string">"examples"</span>.into(), l.into()));
        d.spec.and_then(|l| a.insert(<span class="org-string">"spec"</span>.into(), l.into()));

        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) = d.definition {
            a.insert(<span class="org-string">"definition"</span>.into(), d.into());
        }

        <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(assoc)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Dictionary</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d)) =&gt; <span class="org-type">Ok</span>(d),
            c =&gt; c.into_iter().try_into(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Entry</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-type">Entry</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">DictEntry</span>(e),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Dictionary</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">d</span>: <span class="org-type">Dictionary</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(d),
        )))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;(<span class="org-type">Word</span>, <span class="org-type">Entry</span>)&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>((k, v): (<span class="org-type">Word</span>, <span class="org-type">Entry</span>)) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([<span class="org-type">Item</span>::<span class="org-type">Word</span>(k), <span class="org-type">Item</span>::from(v.clone())]).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> (<span class="org-type">Word</span>, <span class="org-type">Entry</span>) {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> s.len() != 2 {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pair"</span>, s))
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">iter</span> = s.into_iter();
            <span class="org-keyword">let</span> <span class="org-variable-name">key</span>: <span class="org-type">Word</span> = iter.next().unwrap().try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">value</span>: <span class="org-type">Entry</span> = iter.next().unwrap().try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>((key, value))
        }
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org0ea9ab3" class="outline-5">
<h5 id="org0ea9ab3"><span class="section-number-5">1.5.2.6.</span> Environment types</h5>
<div class="outline-text-5" id="text-1-5-2-6">
<div class='tangle-wrapper' data-tangle='src/types/container/environment.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! Functionality of a kcats execution environment.</span>
<span class="org-keyword">use</span> <span class="org-keyword">super</span>::{associative <span class="org-keyword">as</span> assoc, dictionary <span class="org-keyword">as</span> dict};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::axiom;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::serialize;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Number</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">once_cell</span>::<span class="org-constant">sync</span>::<span class="org-type">Lazy</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">ops</span>::<span class="org-type">Range</span>;

<span class="org-doc">/// A struct to hold the state of an executing kcats program. The</span>
<span class="org-doc">/// `stack` is the data being manipulated, the `program` is program</span>
<span class="org-doc">/// remaining to be executed, and the `dictionary` is the set of</span>
<span class="org-doc">/// functions available to the program.</span>
<span class="org-preprocessor">#[derive(Clone, PartialEq)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">stack</span>: <span class="org-type">Stack</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">program</span>: <span class="org-type">Stack</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">dictionary</span>: <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">Environment</span> {
    <span class="org-doc">/// Push the [Item] onto the top of the stack.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">push</span>&lt;<span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;&gt;(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">T</span>) {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.stack).push_front(i.into());
    }

    <span class="org-doc">/// Pop the top [Item] from the stack, panicking if the stack is</span>
    <span class="org-doc">/// empty.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.stack).pop_front().unwrap()
    }

    <span class="org-doc">/// Pushes one item onto the front of the program (so that it</span>
    <span class="org-doc">/// executes first).</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">push_prog</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.program).push_front(i);
    }

    <span class="org-doc">/// Pops an [Item] from the front of the program.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop_prog</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>.program).pop_front().unwrap()
    }

    <span class="org-doc">/// Returns a reference to the top stack [Item], or [None] if it's</span>
    <span class="org-doc">/// empty.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">tos</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>&gt; {
        <span class="org-keyword">self</span>.stack.front()
    }

    <span class="org-doc">/// Returns the length of this struct (as an associative</span>
    <span class="org-doc">/// structure), which is constant.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">len</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">usize</span> {
        3 <span class="org-comment-delimiter">// </span><span class="org-comment">3 fields</span>
    }

    <span class="org-doc">/// Treats the [Environment] as an associative structure,</span>
    <span class="org-doc">/// returning one of its fields, or [None].</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">match</span> key {
            <span class="org-string">"stack"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">self</span>.stack.clone().into()),
            <span class="org-string">"program"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">self</span>.program.clone().into()),
            <span class="org-string">"dictionary"</span> =&gt; <span class="org-type">Some</span>(<span class="org-keyword">self</span>.dictionary.clone().into()),
            _ =&gt; <span class="org-type">None</span>,
        }
    }

    <span class="org-doc">/// Returns true if the [Environment] contains the given key,</span>
    <span class="org-doc">/// which is only true for its fixed fields.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains_key</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">key</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-type">Word</span>::try_from(key.clone()).map_or(<span class="org-keyword">false</span>, |<span class="org-keyword">ref</span> <span class="org-variable-name">w</span>| {
            <span class="org-preprocessor">matches!</span>(w.into(), <span class="org-string">"stack"</span> | <span class="org-string">"program"</span> | <span class="org-string">"dictionary"</span>)
        })
    }

    <span class="org-doc">/// Inserts the key/value into the [Environment]. If the key is</span>
    <span class="org-doc">/// not one of its fixed fields, return a demoted</span>
    <span class="org-doc">/// [assoc::Associative] value that's more generic and supports</span>
    <span class="org-doc">/// any key. Also optionally return any old value that might get</span>
    <span class="org-doc">/// overwritten.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert</span>(<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">k</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>, <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;) {
        <span class="org-keyword">match</span> k {
            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(<span class="org-keyword">ref</span> <span class="org-variable-name">w</span>) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">w</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span> = w.into();
                <span class="org-keyword">match</span> w {
                    <span class="org-string">"stack"</span> =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v.clone());
                        <span class="org-keyword">match</span> l {
                            <span class="org-type">Ok</span>(l) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = <span class="org-keyword">self</span>.stack.clone();
                                <span class="org-keyword">self</span>.stack = l;
                                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(<span class="org-keyword">self</span>), <span class="org-type">Some</span>(old.into()))
                            }
                            <span class="org-type">Err</span>(_) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                            }
                        }
                    }
                    <span class="org-string">"program"</span> =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(v.clone());
                        <span class="org-keyword">match</span> l {
                            <span class="org-type">Ok</span>(l) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = <span class="org-keyword">self</span>.program.clone();
                                <span class="org-keyword">self</span>.program = l;
                                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(<span class="org-keyword">self</span>), <span class="org-type">Some</span>(old.into()))
                            }
                            <span class="org-type">Err</span>(_) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                            }
                        }
                    }
                    <span class="org-string">"dictionary"</span> =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>::try_from(v.clone());
                        <span class="org-keyword">match</span> d {
                            <span class="org-type">Ok</span>(d) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = <span class="org-keyword">self</span>.dictionary.clone();
                                <span class="org-keyword">self</span>.dictionary = d;
                                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(<span class="org-keyword">self</span>), <span class="org-type">Some</span>(old.into()))
                            }
                            <span class="org-type">Err</span>(_) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                            }
                        }
                    }
                    k =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                        <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k.into(), v);
                        (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
                    }
                }
            }
            _ =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>);
                <span class="org-keyword">let</span> <span class="org-variable-name">old</span> = a.inner().insert(k, v);
                (<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Assoc</span>(a), old)
            }
        }
    }

    <span class="org-doc">/// Reads a stdlib module and updates the dictionary.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">load_builtin_module</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">module_alias</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">self</span>.push(module_alias);
        <span class="org-constant">axiom</span>::read_blob(<span class="org-keyword">self</span>)
    }

    <span class="org-doc">/// Loads the core modules as part of preparing a standard</span>
    <span class="org-doc">/// environment.</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">load_core_modules</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Assuming /project/core/ is in your project's root directory and part of the source</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">files</span>: <span class="org-type">Vec</span>&lt;<span class="org-rust-ampersand">&amp;</span>[<span class="org-type">u8</span>]&gt; = <span class="org-preprocessor">vec!</span>[
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/stack-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/motion-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/compare-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/math-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/boolean-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/serialize-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/encode-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/strings-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/errors-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/pipes-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/stack.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/motion.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/collections-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/execute-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/execute.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/dictionary-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/math.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/compare.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/collections.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/associations-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/associations.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/dictionary.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/environment-builtins.kcats"</span>),
            <span class="org-preprocessor">include_bytes!</span>(<span class="org-string">"../../kcats/core/environment.kcats"</span>),
        ];

        <span class="org-keyword">for</span> <span class="org-rust-ampersand">&amp;</span>file_contents <span class="org-keyword">in</span> <span class="org-rust-ampersand">&amp;</span>files {
            <span class="org-keyword">let</span> <span class="org-variable-name">lexicon</span> = <span class="org-type">String</span>::from_utf8_lossy(file_contents).into_owned();
            <span class="org-keyword">self</span>.dictionary.insert_core_module(lexicon);
        }
        <span class="org-type">Ok</span>(())
    }

    <span class="org-doc">/// Returns an error if the stack isn't at least `min_depth` deep.</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">check_stack_depth</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">min_depth</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Checking stack has at least {} items", min_depth);</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.stack.len() &lt; min_depth {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::stack_underflow())
        } <span class="org-keyword">else</span> {
            <span class="org-type">Ok</span>(())
        }
    }

    <span class="org-doc">/// Returns an error if the stack doesn't match the given input spec.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">check_input_spec</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">specs</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">dict</span>::<span class="org-type">StackSpec</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">self</span>.check_stack_depth(specs.len())<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">indexes</span> = <span class="org-type">Range</span> {
            <span class="org-variable-name">start</span>: 0,
            <span class="org-variable-name">end</span>: specs.len(),
        };

        indexes.into_iter().try_for_each(|i| {
            <span class="org-keyword">let</span> <span class="org-variable-name">item</span> = <span class="org-keyword">self</span>.stack.get(i).unwrap();
            <span class="org-keyword">let</span> <span class="org-variable-name">spec</span> = specs.get(i).unwrap();
            check_type(item, <span class="org-rust-ampersand">&amp;</span>spec.elemtype)
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Default</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-doc">/// Returns the default environment, which is the "standard"</span>
    <span class="org-doc">/// environment. It loads some standard libraries and core</span>
    <span class="org-doc">/// functions. The environment is only built once and memoized.</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">default</span>() -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">static</span> <span class="org-variable-name">INST</span>: <span class="org-type">Lazy</span>&lt;<span class="org-type">Environment</span>&gt; = <span class="org-type">Lazy</span>::new(|| {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-type">Environment</span> {
                <span class="org-variable-name">dictionary</span>: <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::wrap(<span class="org-type">HashMap</span>::new()),
                <span class="org-variable-name">stack</span>: <span class="org-type">Default</span>::default(),
                <span class="org-variable-name">program</span>: <span class="org-type">Default</span>::default(),
            };
            env.load_core_modules()
                .expect(<span class="org-string">"failed to load core modules"</span>);
            env.push(<span class="org-preprocessor">list!</span>(
                <span class="org-string">"errors"</span>,
                <span class="org-string">"environment-builtins"</span>,
                <span class="org-string">"encode"</span>,
                <span class="org-string">"sets-builtins"</span>,
                <span class="org-string">"time"</span>,
                <span class="org-string">"pipes"</span>,
                <span class="org-string">"methods"</span>,
                <span class="org-string">"generators"</span>,
                <span class="org-string">"template"</span>,
                <span class="org-string">"debug"</span> <span class="org-comment-delimiter">// </span><span class="org-comment">END default namespace</span>
            ));

            <span class="org-comment-delimiter">// </span><span class="org-comment">Here we can no longer modify our own dictionary, so</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">here's what we do instead, we build a new dictionary</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">and leave it on the stack. Then when finished we grab</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">it at the end of this function.</span>
            env.program.append(<span class="org-preprocessor">list!</span>(
                <span class="org-string">"dictionary"</span>,
                <span class="org-string">"swap"</span>,
                <span class="org-preprocessor">list!</span>(<span class="org-string">"decache"</span>, <span class="org-string">"string"</span>, <span class="org-string">"read"</span>, <span class="org-string">"shielddown"</span>),
                <span class="org-string">"step"</span>
            ));

            <span class="org-comment-delimiter">// </span><span class="org-comment">There's a problem here: the builtins need to be added in a</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">way that they don't get overwritten. They may need to get</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">added piece by piece, somehow. Perhaps a hashmap that we</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">can lookup values in as words get loaded, and specify</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">they're builtin somehow (maybe [builtin yes], but just not</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">having definition would also do it)</span>
            env.dictionary.add_builtins();
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-constant">futures</span>::<span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-constant">axiom</span>::eval(env).<span class="org-keyword">await</span> });
            <span class="org-comment-delimiter">//</span><span class="org-comment">print!("Env: {:?}", env);</span>
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">dict</span>: <span class="org-constant">dict</span>::<span class="org-type">Dictionary</span> = env.pop().try_into().unwrap();
            dict.add_builtins();
            env.dictionary = dict;
            env
        });
        <span class="org-type">INST</span>.clone()
    }
}

<span class="org-doc">/// Returns an error if the [Item] is not of the type specified by</span>
<span class="org-doc">/// [Word] `w`. This allows specs to have their own little type</span>
<span class="org-doc">/// hierarchy, eg, `integer` is a `number`, `list` is a `sized` etc.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">check_type</span>(<span class="org-variable-name">i</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>, <span class="org-variable-name">w</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Word</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Check {:?} is {:?}", w, i);</span>
    <span class="org-keyword">match</span> (w, i) {
        (w, _) <span class="org-keyword">if</span> *w == *<span class="org-type">S_ITEM</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(_) | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(_)) <span class="org-keyword">if</span> *w == *<span class="org-type">S_DISPENSER</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(_) | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(_)) <span class="org-keyword">if</span> *w == *<span class="org-type">S_RECEPTACLE</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(_))) <span class="org-keyword">if</span> *w == *<span class="org-type">S_INTEGER</span> || *w == *<span class="org-type">S_NUMBER</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Float</span>(_))) <span class="org-keyword">if</span> *w == *<span class="org-type">S_FLOAT</span> || *w == *<span class="org-type">S_NUMBER</span> =&gt; <span class="org-type">Ok</span>(()),
        <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: also handle cases where bytes/string is a list</span>
        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_BYTES</span> || *w == *<span class="org-type">S_ORDERED</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_STRING</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, <span class="org-type">Item</span>::<span class="org-type">Word</span>(_)) <span class="org-keyword">if</span> *w == *<span class="org-type">S_WORD</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(_)),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_PIPE</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(_))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_LIST</span> || *w == *<span class="org-type">S_PROGRAM</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_ASSOC</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_),
            )))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_),
            ))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_ERROR</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(_),
            )))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(_),
            ))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_DICTIONARY</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(_)),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_SIZED</span> || *w == *<span class="org-type">S_ORDERED</span> =&gt; <span class="org-type">Ok</span>(()),

        (
            w,
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(_),
            )))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(_),
            ))),
        ) <span class="org-keyword">if</span> *w == *<span class="org-type">S_ENVIRONMENT</span> =&gt; <span class="org-type">Ok</span>(()),
        (w, i) =&gt; {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Type check failed! wanted {} got {:?}", w, i);</span>
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(w.into(), i.clone()))
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">iter</span>: <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-type">Item</span>&gt;&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">stack</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">program</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">dictionary</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">dict</span>::<span class="org-type">Dictionary</span>&gt; = <span class="org-type">None</span>;
        <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> iter {
            <span class="org-keyword">let</span> (k, v): (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>) = i.try_into()<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">if</span> k == <span class="org-string">"stack"</span>.into() {
                stack = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>)
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"program"</span>.into() {
                program = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>)
            } <span class="org-keyword">else</span> <span class="org-keyword">if</span> k == <span class="org-string">"dictionary"</span>.into() {
                dictionary = <span class="org-type">Some</span>(v.try_into()<span class="org-rust-question-mark">?</span>)
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">continue</span>;
            }
        }
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-type">Environment</span>::default();
        env.stack = stack.unwrap_or_default();
        env.program = program.unwrap_or_default();
        env.dictionary = dictionary.unwrap_or_else(|| <span class="org-type">Environment</span>::default().dictionary);
        <span class="org-type">Ok</span>(env)
    }
}
<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)<span class="org-rust-question-mark">?</span>;

        <span class="org-keyword">match</span> s {
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(e)) =&gt; <span class="org-type">Ok</span>(e),
            l =&gt; l.into_iter().try_into(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Environment</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(env).into()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Environment</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
        <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(env))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">IntoIterator</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">type</span> <span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>;
    <span class="org-keyword">type</span> <span class="org-type">IntoIter</span> = <span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-type">Iterator</span>&lt;<span class="org-type">Item</span> = <span class="org-constant">assoc</span>::<span class="org-type">Entry</span>&gt;&gt;;

    <span class="org-keyword">fn</span> <span class="org-function-name">into_iter</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span>::<span class="org-type">IntoIter</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">v</span>: <span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt; = <span class="org-preprocessor">vec!</span>[
            (<span class="org-string">"stack"</span>.into(), <span class="org-keyword">self</span>.stack.into()),
            (<span class="org-string">"program"</span>.into(), <span class="org-keyword">self</span>.program.into()),
            (<span class="org-string">"dictionary"</span>.into(), <span class="org-keyword">self</span>.dictionary.into()),
        ];
        <span class="org-type">Box</span>::new(v.into_iter())
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">assoc</span> = <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter(<span class="org-keyword">self</span>.clone());
        <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = assoc.make_mut();
        am.remove(<span class="org-rust-ampersand">&amp;</span>(<span class="org-string">"dictionary"</span>.into()));
        assoc.into()
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org65d79b6" class="outline-5">
<h5 id="org65d79b6"><span class="section-number-5">1.5.2.7.</span> Hash-based object cache</h5>
<div class="outline-text-5" id="text-1-5-2-7">
<p>
We will need to be able to fetch binary data via its hash, or a local
name. This will supplement the database, by storing larger objects
directly in the filesystem, which is more efficient. But it can also
be used by the kcats module system even if the optional database
feature is disabled. When the database is enabled, hashes or local
aliases can be stored in the db as values and then once those are
retrieved, the actual contents can be retrieved via the
cache. Currently there is no disk space management, so the cache grows
unbounded. 
</p>

<p>
We also want to pre-populate some cache items at build time
(some of the standard libraries), so we make the cache a separate
crate so we can use it at both build time and runtime.
</p>

<div class='tangle-wrapper' data-tangle='cache/Cargo.toml'><div class="org-src-container">
<pre class="src src-toml">[<span class="org-type">package</span>]
<span class="org-variable-name">name</span> = <span class="org-string">"cache"</span>
<span class="org-variable-name">version</span> = <span class="org-string">"0.1.0"</span>
<span class="org-variable-name">edition</span> = <span class="org-string">"2021"</span>

[<span class="org-type">dependencies</span>]
<span class="org-variable-name">base64</span> = <span class="org-string">"0.13.0"</span>
<span class="org-variable-name">sha2</span> = {version=<span class="org-string">"0.10.6"</span>, features=[<span class="org-string">"std"</span>]}
<span class="org-variable-name">directories</span> = <span class="org-string">"5.0"</span>

[<span class="org-type">dependencies.uuid</span>]
<span class="org-variable-name">version</span> = <span class="org-string">"1.6.1"</span>
<span class="org-variable-name">features</span> = [
    <span class="org-string">"v4"</span>,                <span class="org-comment-delimiter"># </span><span class="org-comment">Lets you generate random UUIDs</span>
    <span class="org-string">"v7"</span>,
    <span class="org-string">"fast-rng"</span>,          <span class="org-comment-delimiter"># </span><span class="org-comment">Use a faster (but still sufficiently random) RNG</span>
]
</pre>
</div></div>

<div class='tangle-wrapper' data-tangle='cache/src/lib.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">cache</span> {
    <span class="org-keyword">use</span> <span class="org-constant">base64</span>::<span class="org-type">URL_SAFE_NO_PAD</span>;
    <span class="org-keyword">use</span> <span class="org-constant">directories</span>::<span class="org-type">ProjectDirs</span>;
    <span class="org-keyword">use</span> <span class="org-constant">io</span>::<span class="org-type">Error</span>;
    <span class="org-keyword">use</span> <span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>;
    <span class="org-keyword">use</span> <span class="org-constant">sha2</span>::{<span class="org-keyword">self</span>, <span class="org-type">Digest</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">fs</span>::{<span class="org-keyword">self</span>, <span class="org-type">File</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">io</span>::{<span class="org-keyword">self</span>, <span class="org-type">Read</span>, <span class="org-type">Write</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">io</span>::{<span class="org-type">BufReader</span>, <span class="org-type">BufWriter</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">path</span>::{<span class="org-type">Path</span>, <span class="org-type">PathBuf</span>};
    <span class="org-keyword">use</span> <span class="org-constant">uuid</span>::<span class="org-type">Uuid</span>;

    <span class="org-keyword">type</span> <span class="org-type">Bytes</span> = <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;;

    <span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Key</span> {
        <span class="org-type">Hash</span>(<span class="org-type">Bytes</span>),
        <span class="org-type">Alias</span>(<span class="org-type">String</span>),
    }

    <span class="org-keyword">impl</span> <span class="org-type">Key</span> {
        <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Bytes</span>, <span class="org-type">Error</span>&gt; {
            <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(proj_dirs) = <span class="org-type">ProjectDirs</span>::from(<span class="org-string">"org"</span>, <span class="org-string">"skyrod"</span>, <span class="org-string">"kcats"</span>) {
                <span class="org-keyword">let</span> <span class="org-variable-name">data_dir</span> = proj_dirs.data_dir();

                <span class="org-keyword">let</span> <span class="org-variable-name">cache_path</span> = data_dir.join(<span class="org-string">"cache"</span>);

                <span class="org-comment-delimiter">// </span><span class="org-comment">Look up the file</span>
                <span class="org-keyword">if</span> cache_path.exists() &amp;&amp; cache_path.is_dir() {
                    <span class="org-keyword">let</span> <span class="org-variable-name">filename</span> = <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
                        <span class="org-type">Key</span>::<span class="org-type">Hash</span>(hash) =&gt; <span class="org-constant">base64</span>::encode_config(hash, <span class="org-constant">base64</span>::<span class="org-type">URL_SAFE_NO_PAD</span>),
                        <span class="org-type">Key</span>::<span class="org-type">Alias</span>(word) =&gt; word.to_string(),
                    };

                    <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = cache_path.join(filename);
                    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Reading cache file {:?}", file);</span>
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">content</span> = <span class="org-type">Bytes</span>::new();
                    fetch_link(file.as_path())<span class="org-rust-question-mark">?</span>.read_to_end(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> content)<span class="org-rust-question-mark">?</span>;
                    <span class="org-type">Ok</span>(content)
                } <span class="org-keyword">else</span> {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::new(<span class="org-constant">io</span>::<span class="org-type">ErrorKind</span>::<span class="org-type">Other</span>, <span class="org-string">"Cache dir not found"</span>))
                }
            } <span class="org-keyword">else</span> {
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::new(<span class="org-constant">io</span>::<span class="org-type">ErrorKind</span>::<span class="org-type">Other</span>, <span class="org-string">"Cache data dir not found"</span>))
            }
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-variable-name">content</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Bytes</span>, <span class="org-variable-name">alias</span>: <span class="org-type">Option</span>&lt;<span class="org-type">String</span>&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Bytes</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(proj_dirs) = <span class="org-type">ProjectDirs</span>::from(<span class="org-string">"org"</span>, <span class="org-string">"skyrod"</span>, <span class="org-string">"kcats"</span>) {
            <span class="org-keyword">let</span> <span class="org-variable-name">data_dir</span> = proj_dirs.data_dir();

            <span class="org-keyword">let</span> <span class="org-variable-name">cache_path</span> = data_dir.join(<span class="org-string">"cache"</span>);

            <span class="org-comment-delimiter">// </span><span class="org-comment">Look up the file</span>
            <span class="org-keyword">if</span> cache_path.exists() &amp;&amp; cache_path.is_dir() {
                <span class="org-keyword">let</span> <span class="org-variable-name">hash</span> = <span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>::digest(<span class="org-rust-ampersand">&amp;</span>content);
                <span class="org-keyword">let</span> <span class="org-variable-name">hashfilename</span> = <span class="org-constant">base64</span>::encode_config(hash, <span class="org-constant">base64</span>::<span class="org-type">URL_SAFE_NO_PAD</span>);
                <span class="org-keyword">let</span> <span class="org-variable-name">target</span> = cache_path.join(hashfilename.clone());
                <span class="org-comment-delimiter">// </span><span class="org-comment">only write the file if it doesn't exist</span>
                <span class="org-keyword">if</span> !target.exists() {
                    <span class="org-constant">std</span>::<span class="org-constant">fs</span>::write(target.clone(), content)<span class="org-rust-question-mark">?</span>;
                }

                <span class="org-comment-delimiter">// </span><span class="org-comment">Create the alias if necessary</span>
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(alias) = alias {
                    <span class="org-keyword">let</span> <span class="org-variable-name">alias_path</span> = cache_path.join(<span class="org-type">PathBuf</span>::from(alias.to_string()));
                    create_link(<span class="org-type">Path</span>::new(<span class="org-rust-ampersand">&amp;</span>hashfilename), alias_path.as_path())<span class="org-rust-question-mark">?</span>;
                }
                <span class="org-type">Ok</span>(hash.to_vec())
            } <span class="org-keyword">else</span> {
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::new(<span class="org-constant">io</span>::<span class="org-type">ErrorKind</span>::<span class="org-type">Other</span>, <span class="org-string">"Cache dir not found"</span>))
            }
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::new(<span class="org-constant">io</span>::<span class="org-type">ErrorKind</span>::<span class="org-type">Other</span>, <span class="org-string">"Cache data dir not found"</span>))
        }
    }

    <span class="org-keyword">enum</span> <span class="org-type">Link</span> {
        <span class="org-type">Manual</span>,
        <span class="org-type">Symlink</span>,
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put_from_path</span>(<span class="org-variable-name">path</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Path</span>, <span class="org-variable-name">alias</span>: <span class="org-type">Option</span>&lt;<span class="org-type">String</span>&gt;) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Bytes</span>, <span class="org-type">Error</span>&gt; {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(proj_dirs) = <span class="org-type">ProjectDirs</span>::from(<span class="org-string">"org"</span>, <span class="org-string">"skyrod"</span>, <span class="org-string">"kcats"</span>) {
            <span class="org-keyword">let</span> <span class="org-variable-name">data_dir</span> = proj_dirs.data_dir();
            <span class="org-keyword">let</span> <span class="org-variable-name">cache_path</span> = data_dir.join(<span class="org-string">"cache"</span>);

            <span class="org-comment-delimiter">// </span><span class="org-comment">Ensure the cache directory exists</span>
            <span class="org-keyword">if</span> !cache_path.exists() {
                <span class="org-constant">fs</span>::create_dir_all(<span class="org-rust-ampersand">&amp;</span>cache_path)<span class="org-rust-question-mark">?</span>;
            }

            <span class="org-keyword">let</span> <span class="org-variable-name">unique_temp_file</span> = <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"temp_</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, <span class="org-type">Uuid</span>::new_v4()); <span class="org-comment-delimiter">// </span><span class="org-comment">Generate a unique temporary filename</span>
            <span class="org-keyword">let</span> <span class="org-variable-name">temp_file_path</span> = cache_path.join(unique_temp_file);
            <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = <span class="org-type">File</span>::open(path)<span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">reader</span> = <span class="org-type">BufReader</span>::new(file);
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">hasher</span> = <span class="org-type">Sha256</span>::new();
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buffer</span> = [0<span class="org-type">u8</span>; 4096]; <span class="org-comment-delimiter">// </span><span class="org-comment">4 KiB buffer</span>
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">writer</span> = <span class="org-type">BufWriter</span>::new(<span class="org-type">File</span>::create(<span class="org-rust-ampersand">&amp;</span>temp_file_path)<span class="org-rust-question-mark">?</span>);

            <span class="org-comment-delimiter">// </span><span class="org-comment">Read, hash, and write in chunks</span>
            <span class="org-keyword">loop</span> {
                <span class="org-keyword">let</span> <span class="org-variable-name">count</span> = reader.read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buffer)<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">if</span> count == 0 {
                    <span class="org-keyword">break</span>;
                }
                hasher.update(<span class="org-rust-ampersand">&amp;</span>buffer[..count]);
                writer.write_all(<span class="org-rust-ampersand">&amp;</span>buffer[..count])<span class="org-rust-question-mark">?</span>;
            }
            writer.flush()<span class="org-rust-question-mark">?</span>;

            <span class="org-comment-delimiter">// </span><span class="org-comment">Compute the final hash and rename the file according to the hash</span>
            <span class="org-keyword">let</span> <span class="org-variable-name">hash</span> = hasher.finalize();
            <span class="org-keyword">let</span> <span class="org-variable-name">file_name</span> = <span class="org-constant">base64</span>::encode_config(<span class="org-rust-ampersand">&amp;</span>hash, <span class="org-type">URL_SAFE_NO_PAD</span>);
            <span class="org-keyword">let</span> <span class="org-variable-name">final_path</span> = cache_path.join(file_name.clone());

            <span class="org-comment-delimiter">// </span><span class="org-comment">Move to final destination, overwriting anything there</span>
            <span class="org-constant">fs</span>::rename(temp_file_path.clone(), final_path.clone())<span class="org-rust-question-mark">?</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Create the alias if necessary</span>

            <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(alias) = alias {
                <span class="org-keyword">let</span> <span class="org-variable-name">alias_path</span> = cache_path.join(alias);
                <span class="org-keyword">let</span> <span class="org-variable-name">target_path</span> = <span class="org-type">Path</span>::new(<span class="org-string">"."</span>).join(file_name);
                create_link(<span class="org-rust-ampersand">&amp;</span>target_path, <span class="org-rust-ampersand">&amp;</span>alias_path)<span class="org-rust-question-mark">?</span>;
            }
            <span class="org-type">Ok</span>(hash.to_vec())
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-constant">io</span>::<span class="org-type">Error</span>::new(
                <span class="org-constant">io</span>::<span class="org-type">ErrorKind</span>::<span class="org-type">NotFound</span>,
                <span class="org-string">"Failed to locate project directory."</span>,
            ))
        }
    }

    <span class="org-doc">/// Determines the appropriate link type based on the operating system.</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">get_link_type</span>() -&gt; <span class="org-type">Link</span> {
        <span class="org-keyword">if</span> <span class="org-preprocessor">cfg!</span>(target_os = <span class="org-string">"linux"</span>) || <span class="org-preprocessor">cfg!</span>(target_os = <span class="org-string">"macos"</span>) || <span class="org-preprocessor">cfg!</span>(target_os = <span class="org-string">"windows"</span>) {
            <span class="org-type">Link</span>::<span class="org-type">Symlink</span>
        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-preprocessor">cfg!</span>(target_os = <span class="org-string">"android"</span>) || <span class="org-preprocessor">cfg!</span>(target_os = <span class="org-string">"ios"</span>) {
            <span class="org-type">Link</span>::<span class="org-type">Manual</span>
        } <span class="org-keyword">else</span> {
            <span class="org-preprocessor">panic!</span>(<span class="org-string">"Unsupported operating system for linking"</span>);
        }
    }

    <span class="org-doc">/// Creates a link based on the specified link type.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// # Arguments</span>
    <span class="org-doc">/// * `target` - The target file or directory to link to.</span>
    <span class="org-doc">/// * `link_name` - The name of the symlink or link file to create.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// # Returns</span>
    <span class="org-doc">/// A `Result` indicating success or failure.</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">create_link</span>(<span class="org-variable-name">target</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Path</span>, <span class="org-variable-name">link_name</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Path</span>) -&gt; <span class="org-constant">io</span>::<span class="org-type">Result</span>&lt;()&gt; {
        <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Creating link from </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string"> to </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, link_name, target);

        <span class="org-keyword">if</span> link_name.exists() {
            <span class="org-constant">fs</span>::remove_file(link_name)<span class="org-rust-question-mark">?</span>;
        }

        <span class="org-keyword">match</span> get_link_type() {
            <span class="org-type">Link</span>::<span class="org-type">Symlink</span> =&gt; {
                <span class="org-preprocessor">#[cfg(unix)]</span>
                <span class="org-constant">std</span>::<span class="org-constant">os</span>::<span class="org-constant">unix</span>::<span class="org-constant">fs</span>::symlink(target, link_name)<span class="org-rust-question-mark">?</span>;

                <span class="org-preprocessor">#[cfg(windows)]</span>
                {
                    <span class="org-keyword">if</span> target.is_dir() {
                        <span class="org-constant">fs</span>::<span class="org-constant">os</span>::<span class="org-constant">windows</span>::<span class="org-constant">fs</span>::symlink_dir(target, link_name)<span class="org-rust-question-mark">?</span>
                    } <span class="org-keyword">else</span> {
                        <span class="org-constant">fs</span>::<span class="org-constant">os</span>::<span class="org-constant">windows</span>::<span class="org-constant">fs</span>::symlink_file(target, link_name)<span class="org-rust-question-mark">?</span>
                    }
                }
            }

            <span class="org-type">Link</span>::<span class="org-type">Manual</span> =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">link_file</span> = <span class="org-type">File</span>::create(link_name)<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">path</span> = target.canonicalize()<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">target_path</span> = path.to_str().ok_or(<span class="org-type">Error</span>::new(
                    <span class="org-constant">io</span>::<span class="org-type">ErrorKind</span>::<span class="org-type">Other</span>,
                    <span class="org-string">"Failed to convert path to string"</span>,
                ))<span class="org-rust-question-mark">?</span>;
                <span class="org-rust-builtin-formatting-macro">writeln!</span>(link_file, <span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, target_path)<span class="org-rust-question-mark">?</span>;
            }
        }
        <span class="org-type">Ok</span>(())
    }

    <span class="org-doc">/// Fetches the target of a link.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// # Arguments</span>
    <span class="org-doc">/// * `link_name` - The link file or symlink to fetch.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// # Returns</span>
    <span class="org-doc">/// A `Result` containing the target `File`.</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">fetch_link</span>(<span class="org-variable-name">link_name</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Path</span>) -&gt; <span class="org-constant">io</span>::<span class="org-type">Result</span>&lt;<span class="org-type">File</span>&gt; {
        <span class="org-keyword">match</span> get_link_type() {
            <span class="org-type">Link</span>::<span class="org-type">Symlink</span> =&gt; <span class="org-type">File</span>::open(link_name),
            <span class="org-type">Link</span>::<span class="org-type">Manual</span> =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">link_file</span> = <span class="org-type">File</span>::open(link_name)<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">target_path</span> = <span class="org-type">String</span>::new();
                link_file.read_to_string(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> target_path)<span class="org-rust-question-mark">?</span>;
                <span class="org-type">File</span>::open(target_path)
            }
        }
    }

    <span class="org-doc">/// Deletes a link.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// # Arguments</span>
    <span class="org-doc">/// * `link_name` - The link file or symlink to delete.</span>
    <span class="org-doc">///</span>
    <span class="org-doc">/// # Returns</span>
    <span class="org-doc">/// A `Result` indicating success or failure.</span>
    <span class="org-preprocessor">#[allow(dead_code)]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">delete_link</span>(<span class="org-variable-name">link_name</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Path</span>) -&gt; <span class="org-constant">io</span>::<span class="org-type">Result</span>&lt;()&gt; {
        <span class="org-constant">fs</span>::remove_file(link_name)
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org1cefc2e" class="outline-5">
<h5 id="org1cefc2e"><span class="section-number-5">1.5.2.8.</span> Cryptographic primitives</h5>
<div class="outline-text-5" id="text-1-5-2-8">
<p>
We'll implement certain cryptography functions in rust and make kcats
words for them (hashing, encryption, signing)
</p>
<div class='tangle-wrapper' data-tangle='src/crypto.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::{associative <span class="org-keyword">as</span> assoc, <span class="org-constant">error</span>::<span class="org-type">Error</span>};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Int</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-type">Bytes</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">core</span>::<span class="org-constant">ops</span>::<span class="org-type">Deref</span>;
<span class="org-keyword">use</span> <span class="org-constant">ed25519_dalek</span> <span class="org-keyword">as</span> signing;
<span class="org-keyword">use</span> <span class="org-constant">ed25519_dalek</span>::{<span class="org-type">Signer</span>, <span class="org-type">Verifier</span>};
<span class="org-keyword">use</span> <span class="org-constant">rand</span>::<span class="org-constant">rngs</span>::<span class="org-type">OsRng</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Import OsRng</span>
<span class="org-keyword">use</span> <span class="org-constant">rand</span>::<span class="org-type">RngCore</span> <span class="org-keyword">as</span> <span class="org-type">RandRngCore</span>;
<span class="org-keyword">use</span> <span class="org-constant">rand_core</span>::{<span class="org-type">CryptoRng</span>, <span class="org-type">RngCore</span>};
<span class="org-keyword">use</span> <span class="org-constant">sha2</span>::{<span class="org-keyword">self</span>, <span class="org-type">Digest</span>}; <span class="org-comment-delimiter">// </span><span class="org-comment">Import RngCore for the fill_bytes method</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">hash</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = <span class="org-type">Bytes</span>::try_from(i).unwrap();
    <span class="org-type">Ok</span>(<span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>::digest(b).deref().to_vec().into())
}

<span class="org-keyword">type</span> <span class="org-type">Value</span> = <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;;

<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">SeededRNG</span> {
    <span class="org-variable-name">seed</span>: <span class="org-type">Value</span>,
    <span class="org-variable-name">salt</span>: <span class="org-type">Value</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">SeededRNG</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Hash of seed|value</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">hash</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">v</span> = <span class="org-keyword">self</span>.seed.clone();
        v.extend(<span class="org-keyword">self</span>.salt.clone());
        <span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>::digest(v.as_slice()).deref().to_vec()
    }
}

<span class="org-keyword">impl</span> <span class="org-type">RngCore</span> <span class="org-keyword">for</span> <span class="org-type">SeededRNG</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">next_u32</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">u32</span> {
        <span class="org-constant">rand_core</span>::<span class="org-constant">impls</span>::next_u32_via_fill(<span class="org-keyword">self</span>)
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">next_u64</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-type">u64</span> {
        <span class="org-constant">rand_core</span>::<span class="org-constant">impls</span>::next_u64_via_fill(<span class="org-keyword">self</span>)
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">fill_bytes</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">dest</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> [<span class="org-type">u8</span>]) {
        <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = dest.len();
        dest.copy_from_slice(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.hash()[..l]);
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">try_fill_bytes</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">dest</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> [<span class="org-type">u8</span>]) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-constant">rand_core</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">self</span>.fill_bytes(dest);
        <span class="org-type">Ok</span>(())
    }
}

<span class="org-preprocessor">#[allow(dead_code)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">hash_bytes</span>(<span class="org-variable-name">contents</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;) -&gt; <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">hasher</span> = <span class="org-constant">sha2</span>::<span class="org-type">Sha256</span>::new();
    <span class="org-comment-delimiter">//</span><span class="org-comment">let mut buffer = [0; 1024]; // Read in chunks of 1024 bytes</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">count</span> = contents.len();
    hasher.update(<span class="org-rust-ampersand">&amp;</span>contents[..count]);

    hasher.finalize().to_vec()
}

<span class="org-keyword">impl</span> <span class="org-type">CryptoRng</span> <span class="org-keyword">for</span> <span class="org-type">SeededRNG</span> {}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">key</span>(<span class="org-variable-name">seed</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">sbs</span>: <span class="org-type">Bytes</span> = seed.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">kp</span> = <span class="org-constant">signing</span>::<span class="org-type">Keypair</span>::generate(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">SeededRNG</span> {
        <span class="org-variable-name">seed</span>: <span class="org-preprocessor">vec!</span>[],
        <span class="org-variable-name">salt</span>: sbs,
    });
    <span class="org-type">Ok</span>(<span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
        (<span class="org-string">"type"</span>.into(), <span class="org-string">"elliptic-curve-key"</span>.into()),
        (<span class="org-string">"secret"</span>.into(), kp.secret.as_ref().to_vec().into()),
        (<span class="org-string">"public"</span>.into(), kp.public.as_ref().to_vec().into()),
    ])
    .into())
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">signing</span>::<span class="org-type">Keypair</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">sk</span>: <span class="org-constant">signing</span>::<span class="org-type">SecretKey</span> = i.try_into()<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">pk</span>: <span class="org-constant">signing</span>::<span class="org-type">PublicKey</span> = (<span class="org-rust-ampersand">&amp;</span>sk).into();
        <span class="org-type">Ok</span>(<span class="org-constant">signing</span>::<span class="org-type">Keypair</span> {
            <span class="org-variable-name">secret</span>: sk,
            <span class="org-variable-name">public</span>: pk,
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">signing</span>::<span class="org-type">SecretKey</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> a.get(&amp;<span class="org-string">"type"</span>.into()) == <span class="org-type">Some</span>(<span class="org-string">"elliptic-curve-key"</span>.into()) {
            <span class="org-keyword">let</span> <span class="org-variable-name">sk</span> = <span class="org-constant">signing</span>::<span class="org-type">SecretKey</span>::from_bytes(
                <span class="org-rust-ampersand">&amp;</span><span class="org-type">Bytes</span>::try_from(
                    a.get(&amp;<span class="org-string">"secret"</span>.into())
                        .ok_or_else(|| <span class="org-type">Error</span>::expected(<span class="org-string">"secret"</span>, <span class="org-type">None</span>::&lt;<span class="org-type">Item</span>&gt;))<span class="org-rust-question-mark">?</span>,
                )<span class="org-rust-question-mark">?</span>[..],
            )
            .map_err(|_e| <span class="org-type">Error</span>::expected(<span class="org-string">"valid-secret-key"</span>, <span class="org-type">None</span>::&lt;<span class="org-type">Item</span>&gt;))<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(sk)
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"keypair"</span>, a))
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">signing</span>::<span class="org-type">PublicKey</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
        <span class="org-keyword">if</span> a.get(&amp;<span class="org-string">"type"</span>.into()) == <span class="org-type">Some</span>(<span class="org-string">"elliptic-curve-key"</span>.into()) {
            <span class="org-keyword">let</span> <span class="org-variable-name">pk</span> = <span class="org-constant">signing</span>::<span class="org-type">PublicKey</span>::from_bytes(
                <span class="org-rust-ampersand">&amp;</span><span class="org-type">Bytes</span>::try_from(
                    a.get(&amp;<span class="org-string">"public"</span>.into())
                        .ok_or_else(|| <span class="org-type">Error</span>::expected(<span class="org-string">"public"</span>, <span class="org-type">None</span>::&lt;<span class="org-type">Item</span>&gt;))<span class="org-rust-question-mark">?</span>,
                )<span class="org-rust-question-mark">?</span>[..],
            )
            .map_err(|_e| <span class="org-type">Error</span>::expected(<span class="org-string">"valid-public-key"</span>, <span class="org-type">None</span>::&lt;<span class="org-type">Item</span>&gt;))<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(pk)
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"public-key"</span>, a))
        }
    }
}
<span class="org-comment-delimiter">//</span><span class="org-comment">TODO: we can only call sign from a keypair, so we may want to assume</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">that we have either the kp, or just the secret key.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sign</span>(<span class="org-variable-name">k</span>: <span class="org-type">Item</span>, <span class="org-variable-name">m</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">kp</span>: <span class="org-constant">signing</span>::<span class="org-type">Keypair</span> = k.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">message</span>: <span class="org-type">Bytes</span> = m.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">signature</span>: <span class="org-constant">signing</span>::<span class="org-type">Signature</span> = kp.sign(<span class="org-rust-ampersand">&amp;</span>message);
    <span class="org-type">Ok</span>(signature.as_ref().to_vec().into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">verify</span>(<span class="org-variable-name">k</span>: <span class="org-type">Item</span>, <span class="org-variable-name">m</span>: <span class="org-type">Item</span>, <span class="org-variable-name">s</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">mret</span> = m.clone();
    <span class="org-keyword">let</span> <span class="org-variable-name">pk</span>: <span class="org-constant">signing</span>::<span class="org-type">PublicKey</span> = k.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">mbs</span>: <span class="org-type">Bytes</span> = m.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">sbs</span>: <span class="org-type">Bytes</span> = s.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">sig</span> = <span class="org-constant">signing</span>::<span class="org-type">Signature</span>::from_bytes(<span class="org-rust-ampersand">&amp;</span>sbs)
        .map_err(|_e| <span class="org-type">Error</span>::expected(<span class="org-string">"signature"</span>, <span class="org-type">None</span>::&lt;<span class="org-type">Item</span>&gt;))<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(pk.verify(<span class="org-rust-ampersand">&amp;</span>mbs, <span class="org-rust-ampersand">&amp;</span>sig).map(|_| mret).unwrap_or_default())
}

<span class="org-keyword">fn</span> <span class="org-function-name">random_bytes</span>(<span class="org-variable-name">n</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">bytes</span> = <span class="org-preprocessor">vec!</span>[0<span class="org-type">u8</span>; n]; <span class="org-comment-delimiter">// </span><span class="org-comment">Create a vector of n zeros</span>
    <span class="org-type">OsRng</span>.fill_bytes(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> bytes); <span class="org-comment-delimiter">// </span><span class="org-comment">Fill the vector with random bytes</span>
    bytes
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">random</span>(<span class="org-variable-name">n</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">n</span>: <span class="org-type">Int</span> = n.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(random_bytes(n <span class="org-keyword">as</span> <span class="org-type">usize</span>).into())
}
</pre>
</div></div>
</div>
</div>
</div>
<div id="outline-container-org332ea1f" class="outline-4">
<h4 id="org332ea1f"><span class="section-number-4">1.5.3.</span> Serialization</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
We'll define how kcats data structure are parsed and written (for
example, in order to read/write to/from disk).
</p>
<div class='tangle-wrapper' data-tangle='src/serialize.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! Serializes and parses kcats data. kcats serialization is inspired</span>
<span class="org-doc">//! by Joy, and implemented as a subset of edn (where only vector</span>
<span class="org-doc">//! containers from edn are used, no lists, maps or sets). Currently</span>
<span class="org-doc">//! one custom tag is used for encoding byte arrays, but this is</span>
<span class="org-doc">//! subject to change.</span>
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::{
    <span class="org-keyword">self</span> <span class="org-keyword">as</span> coll, associative <span class="org-keyword">as</span> assoc, <span class="org-constant">environment</span>::<span class="org-type">Environment</span>, <span class="org-constant">error</span>::<span class="org-type">Error</span>,
};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Number</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">VecDeque</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::fmt;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::string;

<span class="org-keyword">pub</span> <span class="org-keyword">trait</span> <span class="org-type">Display</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span>;
}

<span class="org-keyword">const</span> <span class="org-variable-name">BYTE_TAG</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span> = <span class="org-string">"b64"</span>;

<span class="org-doc">/// Parses a serialized value into an [Item].</span>
<span class="org-keyword">fn</span> <span class="org-function-name">to_item</span>(<span class="org-variable-name">item</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">edn_format</span>::<span class="org-type">Value</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("to item {:?}", item);</span>
    <span class="org-keyword">match</span> item {
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Integer</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(*i))),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(v) =&gt; <span class="org-type">Ok</span>({
            <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
                v.iter()
                    .map(to_item)
                    .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
            )
            .into()
        }),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Symbol</span>(s) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Word</span>(s.to_string().into())),
        <span class="org-comment-delimiter">// </span><span class="org-comment">we don't have booleans in kcats, so if we see 'false' that</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is the word false which is not defined in the base</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">language, but might be user-defined later.</span>
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Boolean</span>(b) =&gt; <span class="org-type">Ok</span>(<span class="org-keyword">if</span> *b { <span class="org-string">"yes"</span>.into() } <span class="org-keyword">else</span> { <span class="org-string">"false"</span>.into() }),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s) =&gt; <span class="org-type">Ok</span>(s.to_string().into()),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Float</span>(f) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Float</span>(f.into_inner()))),
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">TaggedElement</span>(tag, e) =&gt; {
            <span class="org-keyword">if</span> *tag == <span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(<span class="org-type">BYTE_TAG</span>) {
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-variable-name">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s) = <span class="org-rust-ampersand">&amp;</span>**e {
                    <span class="org-type">Ok</span>(<span class="org-constant">base64</span>::decode(s).unwrap().into())
                } <span class="org-keyword">else</span> {
                    <span class="org-type">Err</span>(<span class="org-type">Error</span>::parse(<span class="org-string">"Invalid tag datatype for byte literal"</span>))
                }
            } <span class="org-keyword">else</span> {
                <span class="org-type">Err</span>(<span class="org-type">Error</span>::parse(<span class="org-string">"Unsupported tag"</span>))
            }
        }
        <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Character</span>(c) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Char</span>(*c)),
        _ =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::parse(<span class="org-string">"Unsupported data literal"</span>)),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">from_sized</span>(<span class="org-variable-name">s</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span> {
    <span class="org-keyword">match</span> s {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Dictionary</span>(_)) =&gt; {
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Symbol</span>(<span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(<span class="org-string">"dictionary_redacted"</span>))
        }
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Env</span>(e)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>e.representation()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(s.to_string()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(bs) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">TaggedElement</span>(
            <span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(<span class="org-string">"b64"</span>),
            <span class="org-type">Box</span>::new(<span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">String</span>(<span class="org-constant">base64</span>::encode(bs))),
        ),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a) =&gt; {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">av</span> = a
                .clone()
                .into_iter()
                .collect::&lt;<span class="org-type">Vec</span>&lt;(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>, <span class="org-type">Item</span>)&gt;&gt;();
            av.sort_by(|(ka, _), (kb, _)| ka.cmp(kb));
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(
                av.into_iter()
                    .map(|i| from_item(<span class="org-rust-ampersand">&amp;</span>i.into()))
                    .collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">edn_format</span>::<span class="org-type">Value</span>&gt;&gt;(),
            )
        }
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s) =&gt; {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">v</span> = s.inner().into_iter().collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>&gt;&gt;();
            v.sort();
            <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(v.into_iter().map(|ki| from_item(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(ki))).collect())
        }
        v =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Vector</span>(
            v.clone()
                .into_iter()
                .map(|i| from_item(<span class="org-rust-ampersand">&amp;</span>i))
                .collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-constant">edn_format</span>::<span class="org-type">Value</span>&gt;&gt;(),
        ),
    }
}

<span class="org-doc">/// Serializes the item deterministically. Certain data is lost in</span>
<span class="org-doc">/// serialization, including the type of container (sets/maps/lists</span>
<span class="org-doc">/// all are serialized as vectors)</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">from_item</span>(<span class="org-variable-name">item</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>) -&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span> {
    <span class="org-keyword">match</span> item {
        <span class="org-comment-delimiter">// </span><span class="org-comment">dictionaries are big and it's ugly to print them for</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">environments.</span>
        <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i)) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Integer</span>(*i),
        <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Float</span>(f)) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::from(*f),
        <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Character</span>(*c),
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-constant">edn_format</span>::<span class="org-type">Value</span>::<span class="org-type">Symbol</span>(<span class="org-constant">edn_format</span>::<span class="org-type">Symbol</span>::from_name(w.into())),
        <span class="org-comment-delimiter">//</span><span class="org-comment">Item::Entry(w) =&gt; edn_format::Value::Symbol(edn_format::Symbol::from_name(&amp;w.word)),</span>
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>o.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>t.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(i)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>i.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)) =&gt; from_item(<span class="org-rust-ampersand">&amp;</span>t.representation()),
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)) =&gt; from_sized(s),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s)) =&gt; from_sized(s),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">parse</span>(<span class="org-variable-name">s</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">parser</span> = <span class="org-constant">edn_format</span>::<span class="org-type">Parser</span>::from_iter(s.chars(), <span class="org-constant">edn_format</span>::<span class="org-type">ParserOptions</span>::default());
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
        parser
            .map(<span class="org-keyword">move</span> |r| <span class="org-keyword">match</span> r {
                <span class="org-type">Ok</span>(expr) =&gt; <span class="org-type">Ok</span>(to_item(<span class="org-rust-ampersand">&amp;</span>expr)<span class="org-rust-question-mark">?</span>),
                <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::from(e)),
            })
            .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>,
    ))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">emit</span>(<span class="org-variable-name">item</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-constant">edn_format</span>::emit_str(<span class="org-rust-ampersand">&amp;</span>from_item(item))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">emit_all</span>(<span class="org-variable-name">items</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">s</span>: <span class="org-type">String</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">for</span> <span class="org-variable-name">i</span> <span class="org-keyword">in</span> items {
        s.push_str(<span class="org-constant">edn_format</span>::emit_str(<span class="org-rust-ampersand">&amp;</span>from_item(i)).as_str());
        s.push(<span class="org-string">' '</span>);
    }
    s.pop();
    s.to_string()
}

<span class="org-comment-delimiter">// </span><span class="org-comment">print out envs in error messages</span>
<span class="org-keyword">impl</span> <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Environment</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-preprocessor">write!</span>(
            f,
            <span class="org-string">"{{ stack: {}, program: {} }}"</span>,
            emit(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-keyword">self</span>.stack.clone())),
            emit(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-keyword">self</span>.program.clone())),
        )
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">fmt</span>::<span class="org-type">Debug</span> <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">fmt</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">f</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-constant">fmt</span>::<span class="org-type">Formatter</span>) -&gt; <span class="org-constant">fmt</span>::<span class="org-type">Result</span> {
        <span class="org-rust-builtin-formatting-macro">write!</span>(f, <span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, emit(<span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span>::from(<span class="org-keyword">self</span>.data.clone())))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">edn_format</span>::<span class="org-type">ParserError</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-constant">edn_format</span>::<span class="org-type">ParserError</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Error</span>::parse(e.to_string().as_str())
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">string</span>::<span class="org-type">FromUtf8Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">e</span>: <span class="org-constant">string</span>::<span class="org-type">FromUtf8Error</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Error</span>::parse(e.to_string().as_str())
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">insert_line_breaks</span>(<span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">max_items</span>: <span class="org-type">usize</span>, <span class="org-variable-name">max_chars</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">result</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">current_line_length</span> = 0;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">open_list_stack</span>: <span class="org-type">Vec</span>&lt;(<span class="org-type">usize</span>, <span class="org-type">usize</span>)&gt; = <span class="org-type">Vec</span>::new();
    open_list_stack.push((0, 0));
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">last_char</span>: <span class="org-type">char</span> = <span class="org-string">'\n'</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">in_string</span>: <span class="org-type">bool</span> = <span class="org-keyword">false</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">in_tag</span> = <span class="org-keyword">false</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">chars</span> = input.chars().peekable(); <span class="org-comment-delimiter">// </span><span class="org-comment">Convert to a Peekable iterator</span>

    <span class="org-keyword">while</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(c) = chars.next() {
        current_line_length += 1;

        <span class="org-keyword">match</span> c {
            <span class="org-string">'"'</span> =&gt; {
                <span class="org-keyword">if</span> last_char != <span class="org-string">'\\'</span> {
                    in_string = !in_string;
                }
                result.push(c);
            }
            <span class="org-string">'['</span> =&gt; {
                <span class="org-keyword">if</span> !in_string &amp;&amp; last_char != <span class="org-string">'\\'</span> {
                    open_list_stack.push((0, 0)); <span class="org-comment-delimiter">// </span><span class="org-comment">Start a new list</span>
                }
                result.push(c);
            }
            <span class="org-string">']'</span> =&gt; {
                result.push(c);
                <span class="org-keyword">if</span> !in_string &amp;&amp; last_char != <span class="org-string">'\\'</span> {
                    <span class="org-keyword">let</span> (last_count, break_count) = open_list_stack.pop().unwrap();
                    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("items, breaks: {}, {}", last_count, break_count);</span>
                    <span class="org-keyword">if</span> (last_count == 1 || last_count &gt;= 6 || break_count &gt; 0)
                        &amp;&amp; chars.peek() != <span class="org-type">Some</span>(&amp;<span class="org-string">']'</span>)
                    {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">Only add a newline if the next character is not a closing bracket</span>
                        result.push(<span class="org-string">'\n'</span>);
                        <span class="org-keyword">let</span> (_, break_count) = open_list_stack.last_mut().unwrap();
                        *break_count += 1;
                        current_line_length = 0;
                    }
                }
            }
            <span class="org-string">' '</span> =&gt; {
                <span class="org-keyword">if</span> !in_string {
                    <span class="org-keyword">let</span> (last_count, break_count) = open_list_stack.last_mut().unwrap();
                    <span class="org-keyword">if</span> in_tag {
                        in_tag = <span class="org-keyword">false</span>;
                    } <span class="org-keyword">else</span> {
                        *last_count += 1;
                    }
                    <span class="org-keyword">if</span> (*last_count &gt; 0 &amp;&amp; (*last_count % max_items) == 0)
                        || current_line_length &gt; max_chars
                    {
                        result.push(<span class="org-string">'\n'</span>);
                        *break_count += 1;
                        current_line_length = 0;
                        <span class="org-comment-delimiter">//</span><span class="org-comment">*last_count = 0;</span>
                    }
                }
                result.push(c);
            }
            <span class="org-string">'#'</span> =&gt; {
                <span class="org-keyword">if</span> !in_string {
                    in_tag = <span class="org-keyword">true</span>;
                }
                result.push(c);
            }
            _ =&gt; {
                result.push(c);
            }
        }
        last_char = c;
    }
    <span class="org-keyword">if</span> result.ends_with(<span class="org-string">'\n'</span>) {
        result.pop();
    }
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("broken output: {:?}", result);</span>
    result
}

<span class="org-keyword">fn</span> <span class="org-function-name">parse_indent</span>(<span class="org-variable-name">stack</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Vec</span>&lt;<span class="org-type">usize</span>&gt;, <span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">in_string</span> = <span class="org-keyword">false</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">escaped</span> = <span class="org-keyword">false</span>;

    <span class="org-keyword">for</span> (idx, c) <span class="org-keyword">in</span> input.chars().enumerate() {
        <span class="org-keyword">if</span> in_string {
            <span class="org-keyword">match</span> c {
                <span class="org-string">'"'</span> <span class="org-keyword">if</span> !escaped =&gt; in_string = <span class="org-keyword">false</span>,
                <span class="org-comment-delimiter">// </span><span class="org-comment">TODO handle \\ (escaped backslash char)</span>
                <span class="org-string">'\\'</span> <span class="org-keyword">if</span> !escaped =&gt; escaped = <span class="org-keyword">true</span>,
                _ =&gt; escaped = <span class="org-keyword">false</span>,
            }
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">match</span> c {
                <span class="org-string">'['</span> <span class="org-keyword">if</span> !escaped =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                    stack.push(idx);
                }
                <span class="org-string">']'</span> <span class="org-keyword">if</span> !escaped =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                    stack.pop();
                }
                <span class="org-string">'"'</span> =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                    in_string = <span class="org-keyword">true</span>;
                }
                <span class="org-string">';'</span> =&gt; {
                    <span class="org-keyword">break</span>;
                }
                <span class="org-string">'\\'</span> =&gt; {
                    escaped = <span class="org-keyword">true</span>;
                }
                _ =&gt; {
                    escaped = <span class="org-keyword">false</span>;
                }
            }
        }
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">format_indentation</span>(<span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">result</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">indentations</span> = <span class="org-type">Vec</span>::&lt;<span class="org-type">usize</span>&gt;::new();

    <span class="org-keyword">for</span> <span class="org-variable-name">line</span> <span class="org-keyword">in</span> input.lines() {
        <span class="org-keyword">let</span> <span class="org-variable-name">trimmed</span> = line.trim();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Deduce the new indentation based on the last item in the indentations stack</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">new_indent</span> = indentations.last().copied().map(|x| x + 1).unwrap_or(0);
        <span class="org-keyword">let</span> <span class="org-variable-name">padded_line</span> = <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}{}</span><span class="org-string">\n"</span>, <span class="org-string">" "</span>.repeat(new_indent), trimmed);
        result.push_str(padded_line.as_str());
        parse_indent(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> indentations, <span class="org-rust-ampersand">&amp;</span>padded_line);
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("indentations: {:?}: {:?}", padded_line, indentations);</span>
    }
    result.pop(); <span class="org-comment-delimiter">// </span><span class="org-comment">Remove the last newline</span>
    result
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">auto_format</span>(<span class="org-variable-name">input</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">max_items</span>: <span class="org-type">usize</span>, <span class="org-variable-name">max_chars</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">with_breaks</span> = insert_line_breaks(input, max_items, max_chars);
    format_indentation(<span class="org-rust-ampersand">&amp;</span>with_breaks)
}

<span class="org-preprocessor">#[cfg(test)]</span>
<span class="org-keyword">mod</span> <span class="org-constant">tests</span> {
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::*;

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_insert_line_breaks</span>() {
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[foo bar][baz [[quux floop][toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[foo bar]\n[baz [[quux floop]\n[toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = insert_line_breaks(input, 6, 80);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);

        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[[1 2 3] b][c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[[1 2 3] b]\n[c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = insert_line_breaks(input, 6, 80);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);

        <span class="org-comment-delimiter">// </span><span class="org-comment">multiline list</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[a b] [c d]] 5"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[a b]\n [c d]]\n 5"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = insert_line_breaks(input, 6, 80);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);
    }

    <span class="org-preprocessor">#[test]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_indentation</span>() {
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"[[foo bar]\n[baz [[quux floop]\n[toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"[[foo bar]\n [baz [[quux floop]\n       [toop poop]]]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = format_indentation(input);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);

        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = <span class="org-string">"\"hello\" [[a b]\n[c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">expected</span> = <span class="org-string">"\"hello\" [[a b]\n         [c d]]"</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">output</span> = format_indentation(input);
        <span class="org-preprocessor">assert_eq!</span>(output, expected);
    }
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-org0f479fe" class="outline-4">
<h4 id="org0f479fe"><span class="section-number-4">1.5.4.</span> Builtin words</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
We'll define some words as axioms (not in terms of other words, only defined in Rust). 
</p>
<div class='tangle-wrapper' data-tangle='src/axiom.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! All the core functions of kcats: Words that are implemented in</span>
<span class="org-doc">//! rust, instead of in terms of other kcats words.</span>
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::serialize;
<span class="org-preprocessor">#[cfg(feature = </span><span class="org-string">"database"</span><span class="org-preprocessor">)]</span>
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::db;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::{
    <span class="org-keyword">self</span> <span class="org-keyword">as</span> coll, associative <span class="org-keyword">as</span> assoc, dictionary <span class="org-keyword">as</span> dict, <span class="org-constant">environment</span>::<span class="org-type">Environment</span>, <span class="org-constant">error</span>::<span class="org-type">Error</span>,
    pipe,
};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::{<span class="org-type">Float</span>, <span class="org-type">Int</span>, <span class="org-type">Number</span>};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">cache</span>::cache;
<span class="org-keyword">use</span> <span class="org-constant">dynfmt</span>::{<span class="org-type">Format</span>, <span class="org-type">SimpleCurlyFormat</span>};
<span class="org-keyword">use</span> <span class="org-constant">futures</span>::<span class="org-constant">future</span>::<span class="org-type">FutureExt</span>;
<span class="org-keyword">use</span> <span class="org-constant">lazy_static</span>::lazy_static;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashMap</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">VecDeque</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">convert</span>::<span class="org-type">Infallible</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">default</span>::<span class="org-type">Default</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::mem;

<span class="org-keyword">pub</span> <span class="org-keyword">type</span> <span class="org-type">ItemResult</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt;;

<span class="org-doc">/// Convert results into Items, for use when we intend to put the</span>
<span class="org-doc">/// result on the stack whether it's an [Error] or some other [Item].</span>
<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>, <span class="org-type">U</span>&gt; <span class="org-type">From</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">T</span>, <span class="org-type">U</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span>
<span class="org-keyword">where</span>
    <span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-variable-name">U</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;,
{
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Result</span>&lt;<span class="org-type">T</span>, <span class="org-type">U</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Ok</span>(i) =&gt; i.into(),
            <span class="org-type">Err</span>(e) =&gt; e.into(),
        }
    }
}

<span class="org-doc">/// A higher order function that executes a simpler function `f`,</span>
<span class="org-doc">/// where `f` takes a stack item and returns a [Result] of another</span>
<span class="org-doc">/// stack item.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">f_stack1</span>&lt;<span class="org-type">T</span>, <span class="org-type">U</span>, <span class="org-type">R</span>&gt;(<span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">U</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">T</span>, <span class="org-type">R</span>&gt;) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt;
<span class="org-keyword">where</span>
    <span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-variable-name">U</span>: <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-type">U</span>::<span class="org-variable-name">Error</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
    <span class="org-variable-name">R</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
{
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env
            .tos()
            .ok_or_else(<span class="org-type">Error</span>::stack_underflow)
            .and_then(|x| <span class="org-type">U</span>::try_from(x.clone()).map_err(<span class="org-type">Into</span>::into));
        <span class="org-keyword">match</span> x {
            <span class="org-type">Ok</span>(x) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = f(x);
                <span class="org-keyword">match</span> res {
                    <span class="org-type">Ok</span>(r) =&gt; {
                        env.pop_prog();
                        env.pop();
                        env.push(r.into());
                    }
                    <span class="org-type">Err</span>(e) =&gt; {
                        <span class="org-keyword">let</span> <span class="org-variable-name">err</span>: <span class="org-type">Error</span> = e.into();
                        env.push(<span class="org-type">Item</span>::from(err));
                    }
                }
            }
            <span class="org-type">Err</span>(e) =&gt; {
                env.push(e);
            }
        }
        env.into()
    }
}

<span class="org-doc">/// A higher order function that executes a simpler function `f`,</span>
<span class="org-doc">/// where `f` takes two stack items and returns a [Result] of another</span>
<span class="org-doc">/// stack item.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">f_stack2</span>&lt;<span class="org-type">T</span>, <span class="org-type">U</span>, <span class="org-type">V</span>, <span class="org-type">R</span>&gt;(<span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">U</span>, <span class="org-type">V</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">T</span>, <span class="org-type">R</span>&gt;) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt;
<span class="org-keyword">where</span>
    <span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-variable-name">U</span>: <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-type">U</span>::<span class="org-variable-name">Error</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
    <span class="org-variable-name">V</span>: <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-type">V</span>::<span class="org-variable-name">Error</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
    <span class="org-variable-name">R</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
{
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env
            .tos()
            .ok_or_else(<span class="org-type">Error</span>::stack_underflow)
            .and_then(|x| <span class="org-type">V</span>::try_from(x.clone()).map_err(<span class="org-type">Into</span>::into));
        <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = env
            .stack
            .get(1)
            .ok_or_else(<span class="org-type">Error</span>::stack_underflow)
            .and_then(|y| <span class="org-type">U</span>::try_from(y.clone()).map_err(<span class="org-type">Into</span>::into));

        <span class="org-keyword">match</span> (x, y) {
            (<span class="org-type">Ok</span>(x), <span class="org-type">Ok</span>(y)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = f(y, x);
                <span class="org-keyword">match</span> res {
                    <span class="org-type">Ok</span>(r) =&gt; {
                        env.pop_prog();
                        env.pop();
                        env.pop();
                        env.push(r.into());
                    }
                    <span class="org-type">Err</span>(e) =&gt; {
                        env.push(e.into());
                    }
                }
            }
            (<span class="org-type">Err</span>(e), _) =&gt; {
                env.push(e);
            }
            (_, <span class="org-type">Err</span>(e)) =&gt; {
                env.push(e);
            }
        }
        env.into()
    }
}

<span class="org-doc">/// A higher order function that executes a simpler function `f`,</span>
<span class="org-doc">/// where `f` takes 3 stack items and returns a [Result] of another</span>
<span class="org-doc">/// stack item.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">f_stack3</span>&lt;<span class="org-type">T</span>, <span class="org-type">U</span>, <span class="org-type">V</span>, <span class="org-type">W</span>, <span class="org-type">R</span>&gt;(
    <span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">U</span>, <span class="org-type">V</span>, <span class="org-type">W</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">T</span>, <span class="org-type">R</span>&gt;,
) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt;
<span class="org-keyword">where</span>
    <span class="org-variable-name">T</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-variable-name">U</span>: <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-type">U</span>::<span class="org-variable-name">Error</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
    <span class="org-variable-name">V</span>: <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-type">V</span>::<span class="org-variable-name">Error</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
    <span class="org-variable-name">W</span>: <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt;,
    <span class="org-type">W</span>::<span class="org-variable-name">Error</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
    <span class="org-variable-name">R</span>: <span class="org-type">Into</span>&lt;<span class="org-type">Error</span>&gt;,
{
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env
            .tos()
            .ok_or_else(<span class="org-type">Error</span>::stack_underflow)
            .and_then(|x| <span class="org-type">W</span>::try_from(x.clone()).map_err(<span class="org-type">Into</span>::into));
        <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = env
            .stack
            .get(1)
            .ok_or_else(<span class="org-type">Error</span>::stack_underflow)
            .and_then(|y| <span class="org-type">V</span>::try_from(y.clone()).map_err(<span class="org-type">Into</span>::into));
        <span class="org-keyword">let</span> <span class="org-variable-name">z</span> = env
            .stack
            .get(2)
            .ok_or_else(<span class="org-type">Error</span>::stack_underflow)
            .and_then(|z| <span class="org-type">U</span>::try_from(z.clone()).map_err(<span class="org-type">Into</span>::into));
        <span class="org-keyword">match</span> (x, y, z) {
            (<span class="org-type">Ok</span>(x), <span class="org-type">Ok</span>(y), <span class="org-type">Ok</span>(z)) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = f(z, y, x);
                <span class="org-keyword">match</span> res {
                    <span class="org-type">Ok</span>(r) =&gt; {
                        env.pop_prog();
                        env.pop();
                        env.pop();
                        env.pop();
                        env.push(r.into());
                    }
                    <span class="org-type">Err</span>(e) =&gt; {
                        env.push(e.into());
                    }
                }
            }
            (<span class="org-type">Err</span>(e), _, _) =&gt; {
                env.push(e);
            }
            (_, <span class="org-type">Err</span>(e), _) =&gt; {
                env.push(e);
            }
            (_, _, <span class="org-type">Err</span>(e)) =&gt; {
                env.push(e);
            }
        }
        env.into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">f_stack2_async</span>(
    <span class="org-variable-name">f</span>: <span class="org-keyword">fn</span>(<span class="org-type">Item</span>, <span class="org-type">Item</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">ItemResult</span>&gt;,
) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = env.pop();
        <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = env.pop();
        <span class="org-type">Box</span>::pin(f(x, y).map(|r| {
            <span class="org-keyword">if</span> r.is_ok() {
                env.pop_prog();
            }
            env.push(<span class="org-type">Item</span>::from(r));
            env
        }))
    }
}

<span class="org-doc">/// Wrapper function that allows you to use the ? operator in your own</span>
<span class="org-doc">/// functions. If that function returns an error result, it will</span>
<span class="org-doc">/// append that error to the env. The function `f` should return</span>
<span class="org-doc">/// either unit or an Error. If it returns an [Error] it will be</span>
<span class="org-doc">/// pushed onto the stack.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">f_result</span>&lt;<span class="org-type">F</span>&gt;(<span class="org-variable-name">f</span>: <span class="org-type">F</span>) -&gt; <span class="org-keyword">impl</span> <span class="org-type">Fn</span>(<span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt;
<span class="org-keyword">where</span>
    <span class="org-variable-name">F</span>: <span class="org-type">Fn</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Environment</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;,
{
    <span class="org-keyword">move</span> |<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>| {
        <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = f(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env);
        <span class="org-keyword">match</span> r {
            <span class="org-type">Ok</span>(_) =&gt; env.into(),
            <span class="org-type">Err</span>(e) =&gt; {
                env.push(e);
                env.into()
            }
        }
    }
}

<span class="org-preprocessor">lazy_static!</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">static</span> <span class="org-keyword">ref</span> <span class="org-variable-name">BUILTIN_FUNCTIONS</span>: <span class="org-type">HashMap</span>&lt;<span class="org-type">Word</span>, <span class="org-constant">dict</span>::<span class="org-type">Definition</span>&gt; = {
<span class="org-preprocessor">#[cfg(not(feature = </span><span class="org-string">"database"</span><span class="org-preprocessor">))]</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">entries</span>: <span class="org-type">Vec</span>&lt;(<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-rust-ampersand">&amp;</span>'<span class="org-keyword">static</span> <span class="org-type">StepFn</span>)&gt;;
    <span class="org-preprocessor">#[cfg(feature = </span><span class="org-string">"database"</span><span class="org-preprocessor">)]</span>
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">entries</span>: <span class="org-type">Vec</span>&lt;(<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-rust-ampersand">&amp;</span>'<span class="org-keyword">static</span> <span class="org-type">StepFn</span>)&gt;;
    entries = <span class="org-preprocessor">vec!</span>[
        (<span class="org-string">"*"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(mult)))),
        (<span class="org-string">"+"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(plus)))),
        (<span class="org-string">"get"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(lookup)))),
        (<span class="org-string">"sort-indexed"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(sort_by_key)))),
        (<span class="org-string">"-"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(minus)))),
        (<span class="org-string">"/"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(div)))),
        (<span class="org-string">"&lt;"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(lt)))),
        (<span class="org-string">"&lt;="</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(lte)))),
        (<span class="org-string">"="</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(eq))),
        (<span class="org-string">"&gt;"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(gt)))),
        (<span class="org-string">"&gt;="</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(gte)))),
        (<span class="org-string">"abs"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(abs)))),
        (<span class="org-string">"and"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(and)))),
        (<span class="org-string">"animate"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(animate))),
        (<span class="org-string">"assign"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(assign)))),
        (
            <span class="org-string">"association"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1::&lt;<span class="org-constant">assoc</span>::<span class="org-type">Associative</span>, <span class="org-type">Item</span>, <span class="org-type">Error</span>&gt;(
                <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from,
            ))),
        ),
        (
            <span class="org-string">"association?"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_association))),
        ),
        (
            <span class="org-string">"attend"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">channel</span>::select))),
        ),
        (<span class="org-string">"autoformat"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(autoformat)))),
        (<span class="org-string">"branch"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(branch))),
        (<span class="org-string">"bytes?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_bytes)))),
        (<span class="org-string">"cache"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_result(write_blob)))),
        (<span class="org-string">"clone"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(clone))),
        (<span class="org-string">"contains?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(contains)))),
        (<span class="org-string">"ceiling"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(ceiling)))),
        (<span class="org-string">"compare"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(compare)))),
        (<span class="org-string">"count"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(count)))),
        (<span class="org-string">"dec"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(dec)))),
        (<span class="org-string">"decache"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_result(read_blob)))),
        (<span class="org-string">"decide"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(decide))),
        (<span class="org-string">"decodejson"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(decode_json)))),
        (<span class="org-string">"dip"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(dip))),
        (<span class="org-string">"dictionary"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(dictionary))),
        (<span class="org-string">"dipdown"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(dipdown))),
        (<span class="org-string">"drop"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(drop))),
        (<span class="org-string">"emit"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(emit)))),
        (<span class="org-string">"empty"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(empty)))),
        (<span class="org-string">"empty?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_empty)))),
        (<span class="org-string">"encodestring"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(encode_string)))),
        (<span class="org-string">"encodenumber"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(encode_number)))),
        (<span class="org-string">"encodejson"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(encode_json)))),
        (
            <span class="org-string">"environment"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1::&lt;<span class="org-type">Environment</span>, <span class="org-type">Item</span>, <span class="org-type">Error</span>&gt;(
                <span class="org-type">Environment</span>::try_from,
            ))),
        ),
        (<span class="org-string">"error?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_error)))),
        (<span class="org-string">"eval-step"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(eval_step_outer))),
        (<span class="org-string">"evaluate"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(evaluate))),
        (<span class="org-string">"even?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_even)))),
        (<span class="org-string">"evert"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(evert))),
        (<span class="org-string">"execute"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(execute))),
        (<span class="org-string">"exp"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(exp)))),
        (<span class="org-string">"fail"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_result(fail)))),
        (
            <span class="org-string">"file-in"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">fs</span>::file_in))),
        ),
        (
            <span class="org-string">"file-out"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">fs</span>::file_out))),
        ),
        (<span class="org-string">"first"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(first)))),
        (<span class="org-string">"float"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(float))),
        (<span class="org-string">"floor"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(floor)))),
        (<span class="org-string">"format"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(format)))),
        (<span class="org-string">"handle"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(handle)))),
        (
            <span class="org-string">"handoff"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">channel</span>::handoff)),
        ),
        (
            <span class="org-string">"hashbytes"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::hash))),
        ),
        (<span class="org-string">"inc"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(inc)))),
        (<span class="org-string">"intersection"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(intersection)))),
        (<span class="org-string">"inspect"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(inspect)))),
        (<span class="org-string">"join"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(join)))),
        (<span class="org-string">"key"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::key)))),
        (<span class="org-string">"last"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(last)))),
        (<span class="org-string">"list?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_list)))),
        (<span class="org-string">"log"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(log)))),
        (<span class="org-string">"loop"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(loop_))),
        (<span class="org-string">"mod"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(mod_)))),
        (<span class="org-string">"not"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(not)))),
        (<span class="org-string">"number?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_number)))),
        (<span class="org-string">"odd?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_odd)))),
        (<span class="org-string">"or"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(or)))),
        (<span class="org-string">"pop"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(pop))),
        (<span class="org-string">"put"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(put))),
        (<span class="org-string">"pipe?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_pipe)))),
        (
            <span class="org-string">"random"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::random))),
        ),
        (<span class="org-string">"range"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(range)))),
        (<span class="org-string">"read"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-constant">serialize</span>::parse)))),
        (
            <span class="org-string">"receiver"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">channel</span>::receiver))),
        ),
        (<span class="org-string">"recur"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(recur))),
        (<span class="org-string">"resume"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(identity))),
        (<span class="org-string">"reverse"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(reverse)))),
        (<span class="org-string">"round"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(round)))),
        (<span class="org-string">"second"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(second)))),
        (
            <span class="org-string">"sender"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">channel</span>::sender))),
        ),
        (
            <span class="org-string">"serversocket"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2_async(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">net</span>::server_socket))),
        ),
        (
            <span class="org-string">"set"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1::&lt;<span class="org-constant">coll</span>::<span class="org-type">Set</span>, <span class="org-type">Item</span>, <span class="org-type">Error</span>&gt;(
                <span class="org-constant">coll</span>::<span class="org-type">Set</span>::try_from,
            ))),
        ),
        (<span class="org-string">"set?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_set)))),
        (<span class="org-string">"sign"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::sign)))),
        (<span class="org-string">"sink"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(sink))),
        (<span class="org-string">"slice"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(slice)))),
        (
            <span class="org-string">"socket"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2_async(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">net</span>::socket))),
        ),
        (<span class="org-string">"sqrt"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(sqrt)))),
        (<span class="org-string">"standard"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(standard))),
        (<span class="org-string">"step"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(step))),
        (<span class="org-string">"string"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(string)))),
        (<span class="org-string">"string?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_string)))),
        (<span class="org-string">"swap"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(swap))),
        (<span class="org-string">"swapdown"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(swapdown))),
        (
            <span class="org-string">"timer"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">pipe</span>::<span class="org-constant">channel</span>::timer))),
        ),
        (<span class="org-string">"timestamps"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(timestamps))),
        (<span class="org-string">"unassign"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(unassign)))),
        (<span class="org-string">"take"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(take))),
        (<span class="org-string">"unwrap"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(unwrap))),
        (
            <span class="org-string">"verify"</span>,
            <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack3(<span class="org-keyword">crate</span>::<span class="org-constant">crypto</span>::verify))),
        ),
        <span class="org-comment-delimiter">//</span><span class="org-comment">("version", Box::leak(Box::new(f_stack2(version)))),</span>
        (<span class="org-string">"word?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_word)))),
        (<span class="org-string">"wrap"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(wrap))),
        (<span class="org-string">"xor"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(xor)))),
        (<span class="org-string">"yes"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(yes))),
        (<span class="org-string">"zero?"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(is_zero)))),
    ];

    <span class="org-preprocessor">#[cfg(feature = </span><span class="org-string">"database"</span><span class="org-preprocessor">)]</span>
    {
        entries.push((<span class="org-string">"database"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack2(<span class="org-constant">db</span>::query)))));
        entries.push((<span class="org-string">"persist"</span>, <span class="org-type">Box</span>::leak(<span class="org-type">Box</span>::new(f_stack1(<span class="org-constant">db</span>::insert_object)))));
    }
        <span class="org-type">HashMap</span>::from_iter(entries.into_iter().map(|(s, f)| (<span class="org-type">Word</span>::from(s), <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(f))))
    };
}

<span class="org-keyword">fn</span> <span class="org-function-name">pair</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Item</span> {
    <span class="org-preprocessor">list!</span>(i, j).into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">plus</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Number</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(i.add(j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">minus</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Number</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(i.subtract(j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">mult</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Number</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(i.multiply(j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">div</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Number</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Number</span>::<span class="org-type">Int</span>(i), <span class="org-type">Number</span>::<span class="org-type">Int</span>(j)) =&gt; i
            .checked_div(j)
            .ok_or_else(<span class="org-type">Error</span>::division_by_zero)
            .map(<span class="org-type">Number</span>::<span class="org-type">Int</span>),

        (<span class="org-type">Number</span>::<span class="org-type">Float</span>(i), <span class="org-type">Number</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Number</span>::divide(i, j).map(<span class="org-type">Number</span>::<span class="org-type">Float</span>),
        (<span class="org-type">Number</span>::<span class="org-type">Int</span>(i), <span class="org-type">Number</span>::<span class="org-type">Float</span>(j)) =&gt; <span class="org-type">Number</span>::divide(i <span class="org-keyword">as</span> <span class="org-type">Float</span>, j).map(<span class="org-type">Number</span>::<span class="org-type">Float</span>),
        (<span class="org-type">Number</span>::<span class="org-type">Float</span>(i), <span class="org-type">Number</span>::<span class="org-type">Int</span>(j)) =&gt; <span class="org-type">Number</span>::divide(i, j <span class="org-keyword">as</span> <span class="org-type">Float</span>).map(<span class="org-type">Number</span>::<span class="org-type">Float</span>),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">mod_</span>(<span class="org-variable-name">i</span>: <span class="org-type">Int</span>, <span class="org-variable-name">j</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(i % j)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">floor</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Number</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(i),
        <span class="org-type">Number</span>::<span class="org-type">Float</span>(i) =&gt; <span class="org-type">Ok</span>(i.floor() <span class="org-keyword">as</span> <span class="org-type">Int</span>),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">ceiling</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Number</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(i),
        <span class="org-type">Number</span>::<span class="org-type">Float</span>(i) =&gt; <span class="org-type">Ok</span>(i.ceil() <span class="org-keyword">as</span> <span class="org-type">Int</span>),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">round</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Number</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(i),
        <span class="org-type">Number</span>::<span class="org-type">Float</span>(i) =&gt; <span class="org-type">Ok</span>(i.round() <span class="org-keyword">as</span> <span class="org-type">Int</span>),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">exp</span>(<span class="org-variable-name">base</span>: <span class="org-type">Int</span>, <span class="org-variable-name">exponent</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Error</span>&gt; {
    base.checked_pow(exponent <span class="org-keyword">as</span> <span class="org-type">u32</span>).ok_or(<span class="org-type">Error</span>::overflow())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">log</span>(<span class="org-variable-name">value</span>: <span class="org-type">Int</span>, <span class="org-variable-name">base</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Float</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">if</span> base &lt;= 1 {
        <span class="org-type">Err</span>(<span class="org-type">Error</span>::too_small(base, 1))
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> value &lt;= 0 {
        <span class="org-type">Err</span>(<span class="org-type">Error</span>::too_small(value, 0))
    } <span class="org-keyword">else</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">base</span> = base <span class="org-keyword">as</span> <span class="org-type">Float</span>;
        <span class="org-keyword">let</span> <span class="org-variable-name">value</span> = value <span class="org-keyword">as</span> <span class="org-type">Float</span>;
        <span class="org-type">Ok</span>(value.log(base))
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">inc</span>(<span class="org-variable-name">i</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(i + 1)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dec</span>(<span class="org-variable-name">i</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(i - 1)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_zero</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Number</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(i == 0),
        <span class="org-type">Number</span>::<span class="org-type">Float</span>(i) =&gt; <span class="org-type">Ok</span>(i == 0.0),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_empty</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(i.is_empty())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">gt</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-type">Number</span>::gt(i, j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">lt</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-type">Number</span>::lt(i, j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">gte</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-type">Number</span>::gte(i, j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">lte</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>, <span class="org-variable-name">j</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-type">Number</span>::lte(i, j))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">join</span>(<span class="org-variable-name">i</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>, <span class="org-variable-name">j</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">Sized</span>, <span class="org-type">Error</span>&gt; {
    i.join(j)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
    <span class="org-keyword">let</span> <span class="org-variable-name">pr</span> = <span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::try_from(i);
    <span class="org-keyword">match</span> pr {
        <span class="org-type">Ok</span>(p) =&gt; <span class="org-type">Box</span>::pin(p.put(j).map(|f| {
            <span class="org-keyword">match</span> f {
                <span class="org-type">Ok</span>(p) =&gt; {
                    env.pop_prog();
                    env.push(<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(p))
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    env.push(i2);
                    env.push(e)
                }
            };
            env
        })),
        <span class="org-type">Err</span>(e) =&gt; {
            env.push(i2);
            env.push(e);
            env.into()
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">clone</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">clone</span> = env.stack.front().unwrap().clone();
    env.pop_prog();
    env.push(clone);
    env.into()
}

<span class="org-keyword">fn</span> <span class="org-function-name">swap2</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>, <span class="org-variable-name">offset</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack).swap(offset, offset + 1);
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">swap</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_prog();
    swap2(env, 0)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">swapdown</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_prog();
    swap2(env, 1)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sink</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack);
    s.swap(0, 2);
    s.swap(0, 1);
    env.pop_prog();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">float</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack);
    s.swap(0, 2);
    s.swap(1, 2);
    env.pop_prog();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">drop</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop();
    env.pop_prog();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = env.pop();
    env.pop_prog();
    env.push(i == j);
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">count</span>(<span class="org-variable-name">i</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Int</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(i.len() <span class="org-keyword">as</span> <span class="org-type">Int</span>)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_string</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(_)))
    ))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_bytes</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(_)))
    ))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_error</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(_),
        )))
    ))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_word</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-preprocessor">matches!</span>(i, <span class="org-type">Item</span>::<span class="org-type">Word</span>(_)))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_pipe</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-preprocessor">matches!</span>(
        i,
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(_))
            | <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(_))
    ))
}
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_number</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-preprocessor">matches!</span>(i, <span class="org-type">Item</span>::<span class="org-type">Number</span>(_)))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_list</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)
        .map(|s| <span class="org-preprocessor">matches!</span>(s, <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(_)))
        .unwrap_or(<span class="org-keyword">false</span>))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">first</span>(<span class="org-variable-name">c</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> (_, i) = c.take();
    <span class="org-type">Ok</span>(i.into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">second</span>(<span class="org-variable-name">c</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(c.get(1).cloned().unwrap_or_default())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">last</span>(<span class="org-variable-name">c</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(c.into_iter().last().unwrap_or_default())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">loop_</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop());
    <span class="org-keyword">match</span> p {
        <span class="org-type">Ok</span>(<span class="org-keyword">mut</span> p) =&gt; {
            env.pop_prog();
            <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = env.pop();
            <span class="org-keyword">if</span> is_truthy(f) {
                <span class="org-keyword">let</span> <span class="org-variable-name">p2</span> = p.clone();
                <span class="org-keyword">let</span> <span class="org-variable-name">pm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> p);
                pm.push_back(<span class="org-type">Item</span>::from(p2));
                pm.push_back(<span class="org-string">"loop"</span>.into());
                env.program.append(p);
            }
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(<span class="org-type">Item</span>::from(e)),
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">execute</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop();
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i) {
        <span class="org-type">Ok</span>(program) =&gt; {
            env.pop_prog();
            env.program.append(program);
        }
        <span class="org-type">Err</span>(e) =&gt; {
            env.push(e);
        }
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">wrap</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">item</span> = env.pop();
    env.pop_prog();
    env.push(<span class="org-preprocessor">list!</span>(item));
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">unwrap</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()) {
        <span class="org-type">Ok</span>(l) =&gt; {
            env.pop_prog();
            env.stack.extend(l.inner().into_iter().rev());
            env
        }
        <span class="org-type">Err</span>(e) =&gt; {
            env.push(e);
            env
        }
    }
    .into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dip</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()) {
        <span class="org-type">Ok</span>(program) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">item</span> = env.pop();
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = env.program.make_mut();
            expr.pop_front();
            expr.push_front(<span class="org-string">"unwrap"</span>.into());
            expr.push_front(<span class="org-preprocessor">list!</span>(item).into());
            env.program.append(program)
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e),
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dipdown</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()) {
        <span class="org-type">Ok</span>(program) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">item1</span> = env.pop();
            <span class="org-keyword">let</span> <span class="org-variable-name">item2</span> = env.pop();
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = env.program.make_mut();
            expr.pop_front();
            expr.push_front(<span class="org-string">"unwrap"</span>.into());
            expr.push_front(<span class="org-preprocessor">list!</span>(item2, item1).into());
            env.program.append(program)
        }
        <span class="org-type">Err</span>(e) =&gt; env.push(e),
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: handle Nothing case</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">coll</span> = {
        <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
        stack.pop_front()
    };
    <span class="org-keyword">match</span> coll {
        <span class="org-type">Some</span>(i) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
            <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = <span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::try_from(i);
            <span class="org-keyword">match</span> r {
                <span class="org-type">Ok</span>(it) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = it.take();
                    <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                        <span class="org-keyword">let</span> (c, i) = f.<span class="org-keyword">await</span>;
                        env.pop_prog();
                        <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
                        stack.push_front(c.into());
                        stack.push_front(i.unwrap_or_default());
                        env
                    })
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
                    stack.push_front(i2);
                    stack.push_front(e.into());
                    env.into()
                }
            }
        }
        <span class="org-type">None</span> =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
            stack.push_front(<span class="org-type">Error</span>::stack_underflow().into());
            env.into()
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">pop</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">coll</span> = {
        <span class="org-keyword">let</span> <span class="org-variable-name">stack</span> = env.stack.make_mut();
        stack.pop_front()
    };
    <span class="org-keyword">match</span> coll {
        <span class="org-type">Some</span>(i) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">i2</span> = i.clone();
            <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i);

            <span class="org-keyword">match</span> s {
                <span class="org-type">Ok</span>(it) =&gt; {
                    <span class="org-keyword">let</span> (c, i) = it.pop();
                    env.pop_prog();
                    env.push(c);
                    env.push(i.unwrap_or_default());
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    env.push(i2);
                    env.push(e);
                }
            }
        }
        <span class="org-type">None</span> =&gt; {
            env.push(<span class="org-type">Error</span>::stack_underflow());
        }
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_truthy</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">bool</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(d)) =&gt; !d.is_empty(),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(r)) =&gt; !r.is_empty(),
        _ =&gt; <span class="org-keyword">true</span>,
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">branch</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">match</span> (
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()),
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()),
    ) {
        (<span class="org-type">Ok</span>(false_branch), <span class="org-type">Ok</span>(true_branch)) =&gt; {
            env.pop_prog();
            <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = env.pop();

            env.program.append(<span class="org-keyword">if</span> is_truthy(b) {
                true_branch
            } <span class="org-keyword">else</span> {
                false_branch
            })
        }
        (<span class="org-type">Err</span>(e), _) =&gt; env.push(e),
        (_, <span class="org-type">Err</span>(e)) =&gt; env.push(e),
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">step</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">dispenser</span> = <span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::try_from(env.pop()).unwrap();
    <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> (dispenser, <span class="org-type">Some</span>(litem)) = dispenser.take().<span class="org-keyword">await</span> {
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = env.program.make_mut();
            <span class="org-comment-delimiter">// </span><span class="org-comment">prepare the next iteration, even if the iterator is now</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">empty. step is still the next instruction, so we don't</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">pop it off.</span>
            expr.push_front(p.clone().into());
            expr.push_front(dispenser.into());
            env.program.append(p);

            env.push(litem);
        } <span class="org-keyword">else</span> {
            <span class="org-comment-delimiter">// </span><span class="org-comment">if the container is empty, just pop off 'step' and we're done</span>
            env.pop_prog();
        }
        env
    })
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">range</span>(<span class="org-variable-name">from</span>: <span class="org-type">Int</span>, <span class="org-variable-name">to</span>: <span class="org-type">Int</span>, <span class="org-variable-name">stepby</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(
        (from..to).step_by(stepby <span class="org-keyword">as</span> <span class="org-type">usize</span>).map(<span class="org-type">Item</span>::from),
    ))
}

<span class="org-comment-delimiter">// </span><span class="org-comment">(effect [rec2 rec1 then pred]</span>
<span class="org-comment-delimiter">//                   </span><span class="org-comment">['[if]</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">[(concat rec1</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">[[pred then rec1 rec2 'recur]] rec2)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">then pred]])</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">recur</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">rec2</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">rec1</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">then</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">pred</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    env.pop_prog();
    env.push_prog(<span class="org-string">"if"</span>.into());
    <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = <span class="org-preprocessor">list!</span>(
        pred.clone(),
        then.clone(),
        rec1.clone(),
        rec2.clone(),
        <span class="org-string">"recur"</span>,
    )
    .into();
    <span class="org-comment-delimiter">// </span><span class="org-comment">I think i did this right - used to create a new list and extend</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">it with rec1, then push r, then extend again with rec2. now</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">start with rec1 (copied on write), then push r, then extend</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">with rec2.  That should be equivalent.</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">rm</span> = rec1.make_mut();
    rm.push_back(r);
    rm.extend(rec2.make_mut().drain(..));
    <span class="org-comment-delimiter">//</span><span class="org-comment">env.pop_expr();</span>
    env.push(pred);
    env.push(then);
    env.push(rec1);
    env.into()
}

<span class="org-comment-delimiter">//</span><span class="org-comment">(fn [{[l &amp; others] 'stack :as env}]</span>
<span class="org-comment-delimiter">//            </span><span class="org-comment">(assoc env 'stack (apply list (vec others) l)))</span>

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">evert</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-constant">mem</span>::swap(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.stack, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
    env.pop_prog();
    env.push(l);
    env.into()
}

<span class="org-keyword">fn</span> <span class="org-function-name">assoc_vec</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">l</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-variable-name">ks</span>: <span class="org-rust-ampersand">&amp;</span>[<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>], <span class="org-variable-name">k</span>: <span class="org-type">Int</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
    <span class="org-keyword">let</span> <span class="org-variable-name">idx</span> = k <span class="org-keyword">as</span> <span class="org-type">usize</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">extend the size of the vector to be big enough to set</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">the given index, pad with 'nothing' values.</span>
    <span class="org-keyword">if</span> lm.len() &lt;= idx {
        lm.resize(idx + 1, <span class="org-type">Item</span>::default());
    }
    <span class="org-keyword">let</span> <span class="org-variable-name">inner</span> = <span class="org-rust-ampersand">&amp;</span>lm[idx];

    lm[k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = <span class="org-keyword">if</span> <span class="org-keyword">let</span> [nextk, ..] = ks {
        <span class="org-keyword">let</span> <span class="org-variable-name">i</span>: <span class="org-type">Item</span> = <span class="org-keyword">match</span> (inner, nextk) {
            (
                <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
            ) =&gt; l.clone().into(),
            (
                <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
            ) =&gt; l.clone().into(),
            (_, <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_)) =&gt; <span class="org-constant">coll</span>::<span class="org-type">List</span>::default().into(),
            _ =&gt; <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new().into(),
        };
        assoc_in(i, ks, v)<span class="org-rust-question-mark">?</span>
    } <span class="org-keyword">else</span> {
        v
    };

    <span class="org-comment-delimiter">//</span><span class="org-comment">if the inner value isn't a list, overwrite it</span>
    <span class="org-type">Ok</span>(l.into())
}

<span class="org-keyword">fn</span> <span class="org-function-name">assoc_in</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-rust-ampersand">&amp;</span>[<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>], <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">if</span> <span class="org-keyword">let</span> [k, ks @ ..] = ks {
        <span class="org-keyword">if</span> ks.is_empty() {
            <span class="org-keyword">match</span> (i, k) {
                (
                    <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">vector set by index</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
                    <span class="org-keyword">let</span> <span class="org-variable-name">idx</span> = *k <span class="org-keyword">as</span> <span class="org-type">usize</span>;
                    <span class="org-comment-delimiter">// </span><span class="org-comment">extend the size of the vector to be big enough to set</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">the given index, pad with 'nothing' values.</span>
                    <span class="org-keyword">if</span> lm.len() &lt;= idx {
                        lm.resize(idx + 1, <span class="org-type">Item</span>::default());
                    }
                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = v;
                    <span class="org-type">Ok</span>(l.into())
                }
                (
                    <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-comment-delimiter">// </span><span class="org-comment">vector set by index</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> l);
                    <span class="org-keyword">let</span> <span class="org-variable-name">idx</span> = *k <span class="org-keyword">as</span> <span class="org-type">usize</span>;
                    <span class="org-comment-delimiter">// </span><span class="org-comment">extend the size of the vector to be big enough to set</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">the given index, pad with 'nothing' values.</span>
                    <span class="org-keyword">if</span> lm.len() &lt;= idx {
                        lm.resize(idx + 1, <span class="org-type">Item</span>::default());
                    }
                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = v;
                    <span class="org-type">Ok</span>(l.into())
                }
                (i, k) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
                    <span class="org-type">Ok</span>(a.insert(k.clone(), v).0.into())
                }
            }
            <span class="org-comment-delimiter">//</span><span class="org-comment">hm.insert(k.clone(), v);</span>
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">match</span> (i, k) {
                (
                    <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; assoc_vec(l, ks, *k, v),

                (
                    <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; assoc_vec(l, ks, *k, v),

                (i, k) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">let</span> <span class="org-variable-name">inner</span> = a.get(k).unwrap_or_default().clone();

                    <span class="org-comment-delimiter">// </span><span class="org-comment">if the inner value is a map, recurse. If it's a</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">list and the next key is a number,</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">recurse. Otherwise, overwrite the value with a new map.</span>
                    <span class="org-keyword">let</span> <span class="org-variable-name">next_key</span> = ks[0].clone();
                    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-keyword">match</span> (next_key, inner) {
                        (
                            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
                            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                        ) =&gt; l.clone().into(),
                        (
                            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(_),
                            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l))),
                        ) =&gt; l.clone().into(),
                        (
                            _,
                            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a))),
                        ) =&gt; a.clone().into(),
                        (
                            _,
                            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a))),
                        ) =&gt; a.clone().into(),
                        _ =&gt; <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::new().into(),
                    };
                    <span class="org-type">Ok</span>(a.insert(k.clone(), assoc_in(i, ks, v)<span class="org-rust-question-mark">?</span>).0.into())
                }
            }
        }
    } <span class="org-keyword">else</span> {
        <span class="org-type">Ok</span>(i)
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">unassoc_in</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-rust-ampersand">&amp;</span>[<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>]) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Item</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">if</span> <span class="org-keyword">let</span> [k, ks @ ..] = ks {
        <span class="org-keyword">if</span> ks.is_empty() {
            <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(a.remove(k).0.into())
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">match</span> (i, k) {
                (
                    <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(<span class="org-keyword">mut</span> l))),
                    <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k),
                ) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">lm</span> = l.make_mut();
                    <span class="org-keyword">let</span> <span class="org-variable-name">old_value</span> = <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(item) = lm.get_mut(*k <span class="org-keyword">as</span> <span class="org-type">usize</span>) {
                        <span class="org-constant">mem</span>::take(item)
                    } <span class="org-keyword">else</span> {
                        <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::short_list(*k)); <span class="org-comment-delimiter">// </span><span class="org-comment">replace with your error</span>
                    };
                    <span class="org-keyword">let</span> <span class="org-variable-name">new_value</span> = unassoc_in(old_value, ks)<span class="org-rust-question-mark">?</span>;
                    lm[*k <span class="org-keyword">as</span> <span class="org-type">usize</span>] = new_value;
                    <span class="org-type">Ok</span>(l.into())
                }
                (a, k) =&gt; {
                    <span class="org-keyword">let</span> <span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Associative</span> = a.try_into()<span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">a</span>: <span class="org-constant">assoc</span>::<span class="org-type">Association</span> = a.into_iter().collect();
                    <span class="org-keyword">let</span> <span class="org-variable-name">am</span> = a.make_mut();
                    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">res</span>: <span class="org-type">Option</span>&lt;<span class="org-type">Result</span>&lt;_, <span class="org-type">Error</span>&gt;&gt; = <span class="org-type">None</span>;
                    am.entry(k.clone()).and_modify(|v| {
                        <span class="org-keyword">let</span> <span class="org-variable-name">new_value</span> = unassoc_in(v.clone(), ks);
                        res = <span class="org-type">Some</span>(new_value.map(|nv| {
                            *v = nv;
                        }));
                    });
                    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(<span class="org-type">Err</span>(e)) = res {
                        <span class="org-keyword">return</span> <span class="org-type">Err</span>(e);
                    }
                    <span class="org-type">Ok</span>(a.into())
                }
            }
        }
    } <span class="org-keyword">else</span> {
        <span class="org-type">Ok</span>(i)
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">assign</span>(<span class="org-variable-name">m</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-type">Item</span>, <span class="org-variable-name">v</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">kit</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(ks)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ksvec</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span>::try_from_iter(kit.inner().into_iter())<span class="org-rust-question-mark">?</span>;
    ksvec.make_mut().make_contiguous();
    <span class="org-keyword">let</span> (ks, _) = ksvec.as_slices();
    assoc_in(m, ks, v)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">unassign</span>(<span class="org-variable-name">m</span>: <span class="org-type">Item</span>, <span class="org-variable-name">ks</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">kit</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(ks)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">ksvec</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyList</span>::try_from_iter(kit.inner().into_iter())<span class="org-rust-question-mark">?</span>;
    ksvec.make_mut().make_contiguous();
    <span class="org-keyword">let</span> (ks, _) = ksvec.as_slices();
    unassoc_in(m, ks)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">lookup</span>(<span class="org-variable-name">i</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>, <span class="org-variable-name">k</span>: <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("lookup {:?} \n {:?}", i, k);</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">let k = assoc::KeyItem::try_from(k)?;</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">let i = coll::Sized::try_from(i)?;</span>
    <span class="org-keyword">match</span> (i, k) {
        (<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l), <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k)) =&gt; {
            <span class="org-type">Ok</span>(l.get(k <span class="org-keyword">as</span> <span class="org-type">usize</span>).cloned().unwrap_or_default())
        }
        (<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s), <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k)) =&gt; {
            <span class="org-comment-delimiter">//</span><span class="org-comment">let s = s.inner();</span>
            s.chars()
                .nth(k <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .map_or(<span class="org-type">Ok</span>(<span class="org-type">Item</span>::default()), |c| <span class="org-type">Ok</span>(c.into()))
        }
        (<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b), <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Int</span>(k)) =&gt; b
            .get(k <span class="org-keyword">as</span> <span class="org-type">usize</span>)
            .cloned()
            .map_or(<span class="org-type">Ok</span>(<span class="org-type">Item</span>::default()), |c| <span class="org-type">Ok</span>((c <span class="org-keyword">as</span> <span class="org-type">i64</span>).into())),
        (i, k) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">m</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
            <span class="org-type">Ok</span>(m.get(<span class="org-rust-ampersand">&amp;</span>k).unwrap_or_default())
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">contains</span>(<span class="org-variable-name">c</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(c.contains(<span class="org-rust-ampersand">&amp;</span>i))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">or</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-keyword">if</span> is_truthy(i.clone()) {
        i
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> is_truthy(j.clone()) {
        j
    } <span class="org-keyword">else</span> {
        <span class="org-type">Item</span>::default()
    })
    <span class="org-comment-delimiter">//</span><span class="org-comment">Ok(Item::from(is_truthy(i) || is_truthy(j)))</span>
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">and</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-keyword">if</span> is_truthy(i) &amp;&amp; is_truthy(j.clone()) {
        j
    } <span class="org-keyword">else</span> {
        <span class="org-type">Item</span>::default()
    })
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">not</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(!is_truthy(i)))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_association</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)
        .map(|s| <span class="org-preprocessor">matches!</span>(s, <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(_)))
        .unwrap_or(<span class="org-keyword">false</span>))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_set</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(i)
        .map(|s| <span class="org-preprocessor">matches!</span>(s, <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Set</span>(_)))
        .unwrap_or(<span class="org-keyword">false</span>))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_odd</span>(<span class="org-variable-name">i</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(i &amp; 1 == 1)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">is_even</span>(<span class="org-variable-name">i</span>: <span class="org-type">Int</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">bool</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-type">Ok</span>(i &amp; 1 == 0)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">decide</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">clauses</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(env.pop()).unwrap();
    <span class="org-keyword">let</span> <span class="org-variable-name">clauses_data</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> clauses);
    <span class="org-keyword">let</span> <span class="org-variable-name">clause</span> = clauses_data.pop_front();

    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(clause) = clause {
        <span class="org-keyword">let</span> <span class="org-variable-name">clause</span>: <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; = clause.try_into();
        <span class="org-keyword">match</span> clause {
            <span class="org-type">Ok</span>(<span class="org-keyword">mut</span> clause) =&gt; {
                <span class="org-keyword">if</span> clause.len() != 2 {
                    env.push(<span class="org-type">Error</span>::list_count(2));
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">clause_data</span> = clause.make_mut();
                    <span class="org-keyword">let</span> <span class="org-variable-name">test</span>: <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; = clause_data
                        .pop_front()
                        .ok_or(<span class="org-type">Error</span>::list_count(2))
                        .and_then(|i| i.try_into());
                    <span class="org-keyword">let</span> <span class="org-variable-name">expr</span>: <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; = clause_data
                        .pop_front()
                        .ok_or(<span class="org-type">Error</span>::list_count(2))
                        .and_then(|i| i.try_into());

                    <span class="org-keyword">match</span> (test, expr) {
                        (<span class="org-type">Ok</span>(test), <span class="org-type">Ok</span>(expr)) =&gt; {
                            <span class="org-comment-delimiter">// </span><span class="org-comment">construct if</span>
                            <span class="org-keyword">let</span> <span class="org-variable-name">testp</span> = <span class="org-preprocessor">list!</span>(test, <span class="org-string">"shield"</span>);

                            <span class="org-keyword">let</span> <span class="org-variable-name">newexpr</span> = <span class="org-preprocessor">list!</span>(
                                testp,
                                expr,
                                <span class="org-preprocessor">list!</span>(clauses, <span class="org-string">"decide"</span>),
                                <span class="org-preprocessor">list!</span>(<span class="org-string">"shield"</span>),
                                <span class="org-comment-delimiter">// </span><span class="org-comment">This is the definition of 'dipdown'</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">which we don't want to depend on so</span>
                                <span class="org-comment-delimiter">// </span><span class="org-comment">early in bootstrapping</span>
                                <span class="org-string">"wrap"</span>,
                                <span class="org-preprocessor">list!</span>(<span class="org-string">"dip"</span>),
                                <span class="org-string">"join"</span>,
                                <span class="org-string">"dip"</span>,
                                <span class="org-comment-delimiter">// </span><span class="org-comment">end 'dipdown'</span>
                                <span class="org-string">"branch"</span>
                            );
                            env.pop_prog();
                            env.program.append(newexpr);
                        }
                        (<span class="org-type">Err</span>(test), _) =&gt; {
                            env.push(test);
                        }
                        (_, <span class="org-type">Err</span>(expr)) =&gt; {
                            env.push(expr);
                        }
                    }
                }
            }
            <span class="org-type">Err</span>(e) =&gt; {
                env.push(e);
            }
        }
    } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">clauses empty, return nothing</span>
        env.pop_prog();
        env.push(<span class="org-type">Item</span>::default());
    }
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">emit</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>i)),
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">autoformat</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">String</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(<span class="org-constant">serialize</span>::auto_format(s.as_str(), 20, 80)),
    )))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">eval_step</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("{:?}", env);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">next_item</span> = env.program.front();

    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(val) = next_item {
        <span class="org-keyword">match</span> val {
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(word) =&gt; {
                <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(dfn) = env.dictionary.get(word) {
                    {
                        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(spec) = <span class="org-rust-ampersand">&amp;</span>dfn.spec {
                            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Checking spec for {:?}: {:?}", word, spec.0);</span>
                            <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Err</span>(e) = env.check_input_spec(<span class="org-rust-ampersand">&amp;</span>spec.0) {
                                env.push(e);
                                <span class="org-keyword">return</span> env.into();
                            }
                        } <span class="org-keyword">else</span> {
                            <span class="org-comment-delimiter">//  </span><span class="org-comment">println!("No spec for {}!", word);</span>
                        }
                        <span class="org-keyword">match</span> <span class="org-rust-ampersand">&amp;</span>dfn.definition {
                            <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Axiom</span>(a) =&gt; (*a)(env),
                            <span class="org-constant">dict</span>::<span class="org-type">Definition</span>::<span class="org-type">Derived</span>(d) =&gt; {
                                <span class="org-keyword">let</span> <span class="org-variable-name">items</span> = d.clone();
                                env.pop_prog();
                                env.program.append(items);
                                env.into()
                            }
                        }
                    }
                } <span class="org-keyword">else</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">w</span> = word.clone();
                    env.push(<span class="org-type">Error</span>::undefined(w));
                    env.into()
                }
            }
            _ =&gt; {
                <span class="org-comment-delimiter">// </span><span class="org-comment">not a word, just push onto stack</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop_prog();
                env.push(i);
                env.into()
            }
        }
    } <span class="org-keyword">else</span> {
        env.push(<span class="org-type">Error</span>::short_list(1));
        env.into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">reverse</span>(<span class="org-variable-name">s</span>: <span class="org-constant">coll</span>::<span class="org-type">Sized</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">Sized</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">match</span> s {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(l) =&gt; <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(l.inner().into_iter().rev()).into()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s) =&gt; <span class="org-type">Ok</span>(s.chars().rev().collect::&lt;<span class="org-type">String</span>&gt;().into()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b) =&gt; <span class="org-type">Ok</span>(b.into_iter().rev().collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">u8</span>&gt;&gt;().into()),
        s =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"ordered"</span>, s)),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">encode_string</span>(<span class="org-variable-name">s</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Bytes</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(s.as_bytes().to_vec())
}

<span class="org-keyword">fn</span> <span class="org-function-name">encode_number</span>(<span class="org-variable-name">n</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Bytes</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-keyword">match</span> n {
        <span class="org-type">Number</span>::<span class="org-type">Int</span>(i) =&gt; <span class="org-type">Ok</span>(i.to_be_bytes().to_vec()),
        <span class="org-type">Number</span>::<span class="org-type">Float</span>(f) =&gt; <span class="org-type">Ok</span>(f.to_be_bytes().to_vec()),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">string</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">String</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; {
            <span class="org-type">Ok</span>(<span class="org-constant">std</span>::<span class="org-type">str</span>::from_utf8(<span class="org-rust-ampersand">&amp;</span>b).unwrap().to_string())
        }
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; {
            <span class="org-type">Ok</span>(<span class="org-constant">std</span>::<span class="org-type">str</span>::from_utf8(<span class="org-rust-ampersand">&amp;</span>b).unwrap().to_string())
        }
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(s)) =&gt; {
            <span class="org-keyword">if</span> s.is_empty() {
                <span class="org-type">Ok</span>(<span class="org-string">""</span>.to_string())
            } <span class="org-keyword">else</span> {
                <span class="org-type">Ok</span>(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>s.into()))
            }
        }
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(s)) =&gt; {
            <span class="org-keyword">if</span> s.is_empty() {
                <span class="org-type">Ok</span>(<span class="org-string">""</span>.to_string())
            } <span class="org-keyword">else</span> {
                <span class="org-type">Ok</span>(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>s.into()))
            }
        }
        i =&gt; <span class="org-type">Ok</span>(<span class="org-constant">serialize</span>::emit(<span class="org-rust-ampersand">&amp;</span>i)),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">get_error</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Error</span>&gt; {
    env.stack.front().and_then(|i| <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e),
        ))) =&gt; <span class="org-type">Some</span>(e.clone()),
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(e),
        ))) =&gt; <span class="org-type">Some</span>(e.clone()),
        _ =&gt; <span class="org-type">None</span>,
    })
}

<span class="org-keyword">fn</span> <span class="org-function-name">unwind</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">err</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">w</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Item</span> = &amp;<span class="org-string">"handle"</span>.into();

    <span class="org-keyword">let</span> <span class="org-variable-name">err</span> = <span class="org-keyword">match</span> err {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(<span class="org-keyword">mut</span> e),
        ))) =&gt; {
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">next</span> = env.program.front();
            <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">unwound</span> = <span class="org-type">Vec</span>::&lt;<span class="org-type">Item</span>&gt;::new();
            <span class="org-keyword">while</span> next.is_some() &amp;&amp; next.unwrap() != w {
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = env.pop_prog();
                unwound.push(i);
                next = env.program.front();
            }
            <span class="org-keyword">if</span> next.is_some() {
                env.pop_prog();
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">set the is_handled bit</span>
            e.is_handled = <span class="org-keyword">true</span>;
            <span class="org-keyword">let</span> <span class="org-variable-name">em</span> = <span class="org-constant">coll</span>::<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> e.data);
            em.insert(<span class="org-string">"unwound"</span>.into(), <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(unwound).into());
            e.into()
        }
        i =&gt; i,
    };
    env.push(err);
    env
}

<span class="org-keyword">pub</span> <span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">eval</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">loop</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(err) = get_error(<span class="org-rust-ampersand">&amp;</span>env) {
            <span class="org-keyword">if</span> !err.is_handled {
                env = unwind(env); <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: this should be done in eval_step</span>
            };
        }
        <span class="org-keyword">if</span> !env.program.is_empty() {
            env = eval_step(env).<span class="org-keyword">await</span>;
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">break</span>;
        }
    }
    env
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">eval_step_outer</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">tos</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">inner_env</span> = <span class="org-type">Environment</span>::try_from(tos);

    <span class="org-keyword">match</span> inner_env {
        <span class="org-type">Ok</span>(inner) =&gt; {
            env.pop_prog();
            <span class="org-keyword">if</span> inner.program.is_empty() {
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                    env.push(<span class="org-type">Item</span>::default());
                    env
                })
            } <span class="org-keyword">else</span> {
                <span class="org-type">Box</span>::pin(eval_step(inner).map(|inner_next| {
                    env.push(inner_next);
                    env
                }))
            }
        }
        <span class="org-type">Err</span>(e) =&gt; {
            env.push(e);
            env.into()
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">evaluate</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">tos</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">inner_env</span> = <span class="org-type">Environment</span>::try_from(tos);
    <span class="org-keyword">match</span> inner_env {
        <span class="org-type">Ok</span>(inner) =&gt; <span class="org-type">Box</span>::pin(eval(inner).map(|inner_done| {
            env.pop_prog();
            env.push(inner_done);
            env
        })),
        <span class="org-type">Err</span>(e) =&gt; {
            env.push(e);
            env.into()
        }
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">identity</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_prog();
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">dictionary</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">d</span> = env.dictionary.clone();
    env.pop_prog();
    env.push(d);
    env.into()
}

<span class="org-keyword">fn</span> <span class="org-function-name">sqrt</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Number</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(i.sqrt())
}

<span class="org-keyword">fn</span> <span class="org-function-name">abs</span>(<span class="org-variable-name">i</span>: <span class="org-type">Number</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Number</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(i.abs())
}

<span class="org-keyword">fn</span> <span class="org-function-name">handle</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> i {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(
            <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::<span class="org-type">Error</span>(<span class="org-keyword">mut</span> e),
        ))) =&gt; <span class="org-type">Ok</span>({
            e.is_handled = <span class="org-keyword">true</span>;
            e.into()
        }),
        i =&gt; <span class="org-type">Ok</span>(i),
    }
}

<span class="org-doc">/// Makes 'yes' a word that doesn't have to be quoted, just pushes</span>
<span class="org-doc">/// itself onto the stack.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">yes</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = env.pop_prog();
    env.push(t);
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">fail</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Environment</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">err</span> = <span class="org-type">Error</span>::try_from(env.pop())<span class="org-rust-question-mark">?</span>;
    err.is_handled = <span class="org-keyword">false</span>;
    env.pop_prog();
    env.push(err);
    <span class="org-type">Ok</span>(())
}

<span class="org-doc">/// Fetches a binary blob from the cache. The top of stack should be</span>
<span class="org-doc">/// either the hash of the content or its alias (a [Word]).</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">read_blob</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Environment</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Env: {:?}", env);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">contents</span> = <span class="org-keyword">match</span> env.pop() {
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(alias) =&gt; <span class="org-constant">cache</span>::<span class="org-type">Key</span>::<span class="org-type">Alias</span>(alias.to_string()).get()<span class="org-rust-question-mark">?</span>,
        i =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">hash</span> = <span class="org-type">Bytes</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
            <span class="org-constant">cache</span>::<span class="org-type">Key</span>::<span class="org-type">Hash</span>(hash).get()<span class="org-rust-question-mark">?</span>
        }
    };
    env.pop_prog();
    env.push(contents);
    <span class="org-type">Ok</span>(())
}

<span class="org-doc">/// Writes a given binary object to the cache. Supports [Bytes], and</span>
<span class="org-doc">/// certain kinds of pipes. The top of stack should be the alias to</span>
<span class="org-doc">/// store the contents under, which should be either a [Word] or</span>
<span class="org-doc">/// nothing. If nothing, the object will only be available via its</span>
<span class="org-doc">/// hash. Returns the hash.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">write_blob</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-type">Environment</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">alias</span> = <span class="org-keyword">match</span> env.pop() {
        <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Some</span>(w.to_string()),
        _ =&gt; <span class="org-type">None</span>,
    };
    <span class="org-keyword">match</span> env.pop() {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">hash</span> = <span class="org-constant">cache</span>::put(<span class="org-rust-ampersand">&amp;</span>b, alias)<span class="org-rust-question-mark">?</span>;
            env.push(hash);
            env.pop_prog();
            <span class="org-type">Ok</span>(())
        }
        i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"bytes"</span>, i)),
    }
}

<span class="org-doc">/// Takes an inner environment from the top of the stack, and spawns a</span>
<span class="org-doc">/// tokio task to evaluate that environment.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">animate</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">tos</span> = env.pop();
    <span class="org-keyword">let</span> <span class="org-variable-name">inner_env</span> = <span class="org-type">Environment</span>::try_from(tos);
    <span class="org-keyword">match</span> inner_env {
        <span class="org-type">Ok</span>(inner) =&gt; {
            env.pop_prog();
            <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { eval(inner).<span class="org-keyword">await</span> });
            env.into()
        }
        <span class="org-type">Err</span>(e) =&gt; {
            env.push(e);
            env.into()
        }
    }
}
<span class="org-keyword">fn</span> <span class="org-function-name">xor_</span>(<span class="org-variable-name">i</span>: <span class="org-type">Bytes</span>, <span class="org-variable-name">j</span>: <span class="org-type">Bytes</span>) -&gt; <span class="org-type">Bytes</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">len</span> = <span class="org-constant">std</span>::<span class="org-constant">cmp</span>::max(i.len(), j.len());
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">result</span> = <span class="org-type">Vec</span>::with_capacity(len);
    <span class="org-keyword">for</span> (byte_i, byte_j) <span class="org-keyword">in</span> i
        .iter()
        .chain(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::repeat(<span class="org-rust-ampersand">&amp;</span>0).take(len - i.len()))
        .zip(j.iter().chain(<span class="org-constant">std</span>::<span class="org-constant">iter</span>::repeat(<span class="org-rust-ampersand">&amp;</span>0).take(len - j.len())))
    {
        result.push(byte_i ^ byte_j);
    }
    result
}
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">xor</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">match</span> (i, j) {
        (<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i)), <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(j))) =&gt; {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i ^ j)))
        }
        (
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(j))),
        ) =&gt; <span class="org-type">Ok</span>(xor_(i, j).into()),
        (
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(i))),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(j))),
        ) =&gt; <span class="org-type">Ok</span>(xor_(i, j).into()),
        (i, j) =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"integers"</span>, pair(i, j))),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">inspect</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">String</span>, <span class="org-type">Infallible</span>&gt; {
    <span class="org-type">Ok</span>(<span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, i))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">timestamps</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_prog();
    env.push(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>::<span class="org-type">Time</span>)));
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">standard</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_prog();
    env.push(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(
        <span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Standard</span>,
    )));
    env.into()
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">intersection</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = <span class="org-constant">coll</span>::<span class="org-type">Set</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = <span class="org-constant">coll</span>::<span class="org-type">Set</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">ij</span> = i.intersection(<span class="org-rust-ampersand">&amp;</span>j);
    <span class="org-keyword">let</span> <span class="org-variable-name">h</span> = <span class="org-constant">std</span>::<span class="org-constant">collections</span>::<span class="org-type">HashSet</span>::from_iter(ij.cloned());
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">Set</span>::from(h).into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">compare</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">ki</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">kj</span> = <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">match</span> ki.partial_cmp(<span class="org-rust-ampersand">&amp;</span>kj) {
        <span class="org-type">Some</span>(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Less</span>) =&gt; <span class="org-type">Ok</span>(<span class="org-string">"less"</span>.into()),
        <span class="org-type">Some</span>(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Equal</span>) =&gt; <span class="org-type">Ok</span>(<span class="org-string">"equal"</span>.into()),
        <span class="org-type">Some</span>(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Greater</span>) =&gt; <span class="org-type">Ok</span>(<span class="org-string">"greater"</span>.into()),
        <span class="org-type">None</span> =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"comparable"</span>, pair(ki.into(), kj.into()))),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">as_pair</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;(<span class="org-type">Item</span>, <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>), <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">i</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">im</span> = i.make_mut();
    <span class="org-keyword">let</span> <span class="org-variable-name">j</span> = im.pop_front().ok_or(<span class="org-type">Error</span>::short_list(1))<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">k</span> = im
        .pop_front()
        .ok_or(<span class="org-type">Error</span>::short_list(2))
        .and_then(<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::try_from)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>((j, k))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sort_by_key</span>(<span class="org-variable-name">l</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">it</span> = l.inner().into_iter().map(as_pair);
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">it</span> = it.collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;(<span class="org-type">Item</span>, <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>)&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;
    it.sort_unstable_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(<span class="org-constant">std</span>::<span class="org-constant">cmp</span>::<span class="org-type">Ordering</span>::<span class="org-type">Less</span>));
    <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(it.into_iter().map(|(k, _)| k)))
}

<span class="org-keyword">fn</span> <span class="org-function-name">slice</span>(<span class="org-variable-name">arr</span>: <span class="org-type">Item</span>, <span class="org-variable-name">start</span>: <span class="org-type">Item</span>, <span class="org-variable-name">end</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Start: {:?}, End: {:?}", start, end);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">arr</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(arr)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">start</span> = <span class="org-type">Int</span>::try_from(start)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">end</span> = <span class="org-type">Int</span>::try_from(end)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">if</span> start &lt; 0 {
        start += arr.len() <span class="org-keyword">as</span> <span class="org-type">i64</span>;
    }
    <span class="org-keyword">if</span> end &lt;= 0 {
        end += arr.len() <span class="org-keyword">as</span> <span class="org-type">i64</span>;
    }
    <span class="org-keyword">if</span> start &lt; 0 {
        <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::negative(start));
    }
    <span class="org-keyword">if</span> end &lt; 0 {
        <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::negative(end));
    }
    <span class="org-keyword">if</span> start &gt; end {
        <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::create(
            <span class="org-preprocessor">list!</span>(<span class="org-string">"&lt;="</span>),
            <span class="org-string">"invalid index range"</span>,
            <span class="org-type">Some</span>(pair(start.into(), end.into())),
        ));
    }
    <span class="org-keyword">match</span> arr {
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(arr) =&gt; <span class="org-type">Ok</span>(arr
            .get(start <span class="org-keyword">as</span> <span class="org-type">usize</span>..end <span class="org-keyword">as</span> <span class="org-type">usize</span>)
            .map(|a| a.to_vec())
            .into()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(arr) =&gt; <span class="org-type">Ok</span>(arr
            .get(start <span class="org-keyword">as</span> <span class="org-type">usize</span>..end <span class="org-keyword">as</span> <span class="org-type">usize</span>)
            .map(|a| a.to_string())
            .into()),
        <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">List</span>(arr) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">owned_subset</span>: <span class="org-type">VecDeque</span>&lt;<span class="org-type">Item</span>&gt; = arr
                .iter()
                .skip(start <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .take(end <span class="org-keyword">as</span> <span class="org-type">usize</span> - start <span class="org-keyword">as</span> <span class="org-type">usize</span>)
                .cloned()
                .collect();
            <span class="org-type">Ok</span>(<span class="org-constant">coll</span>::<span class="org-type">List</span>::from(owned_subset).into())
        }
        i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"ordered"</span>, i)),
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">empty</span>(<span class="org-variable-name">s</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::try_from(s)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(s.empty().into())
}

<span class="org-keyword">fn</span> <span class="org-function-name">format</span>(<span class="org-variable-name">fstr</span>: <span class="org-type">Item</span>, <span class="org-variable-name">items</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">fstr</span> = <span class="org-type">String</span>::try_from(fstr)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">items</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(items)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">strings</span> = items
        .inner()
        .into_iter()
        .map(<span class="org-type">String</span>::try_from)
        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">String</span>&gt;, <span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-type">SimpleCurlyFormat</span>
        .format(fstr.as_str(), strings.as_slice())<span class="org-rust-question-mark">?</span>
        .into_owned()
        .into())
}

<span class="org-keyword">impl</span>&lt;'<span class="org-variable-name">a</span>&gt; <span class="org-type">From</span>&lt;<span class="org-constant">dynfmt</span>::<span class="org-type">Error</span>&lt;'<span class="org-variable-name">a</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">err</span>: <span class="org-constant">dynfmt</span>::<span class="org-type">Error</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"format"</span>), <span class="org-rust-ampersand">&amp;</span>err.to_string(), <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">decode_json</span>(<span class="org-variable-name">s</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-type">String</span>::try_from(s)<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-constant">serde_json</span>::from_str::&lt;<span class="org-type">Item</span>&gt;(s.as_str())<span class="org-rust-question-mark">?</span>)
}

<span class="org-keyword">fn</span> <span class="org-function-name">encode_json</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::from(<span class="org-constant">serde_json</span>::to_string(<span class="org-rust-ampersand">&amp;</span>i)<span class="org-rust-question-mark">?</span>))
}
</pre>
</div></div>
</div>
</div>
<div id="outline-container-orga3280ff" class="outline-4">
<h4 id="orga3280ff"><span class="section-number-4">1.5.5.</span> Top level execution</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
We'll define the main module which reads input for the kcats
interpreter process, and prints output.
</p>

<p>
We'll also define how to run unit tests.
</p>
<div class='tangle-wrapper' data-tangle='src/main.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-doc">//! The main kcats module, that executes the kcats interpreter. See [main]</span>
<span class="org-keyword">mod</span> <span class="org-constant">axiom</span>;
<span class="org-keyword">mod</span> <span class="org-constant">crypto</span>;
<span class="org-keyword">mod</span> <span class="org-constant">module_map</span>;
<span class="org-keyword">mod</span> <span class="org-constant">serialize</span>;
<span class="org-keyword">mod</span> <span class="org-constant">types</span>;

<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">io</span>::{<span class="org-keyword">self</span>, <span class="org-type">BufRead</span>, <span class="org-type">Read</span>, <span class="org-type">Write</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">types</span>::<span class="org-constant">container</span>::{<span class="org-constant">environment</span>::<span class="org-type">Environment</span>, error};

<span class="org-keyword">fn</span> <span class="org-function-name">print_result</span>(<span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) {
    <span class="org-keyword">if</span> env.program.is_empty() {
        <span class="org-rust-builtin-formatting-macro">println!</span>(
            <span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
            <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80)
        );
    } <span class="org-keyword">else</span> {
        <span class="org-rust-builtin-formatting-macro">println!</span>(
            <span class="org-string">"stack: </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">\nprogram: </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
            <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80),
            <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.program).as_str(), 20, 80)
        )
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">get_stdin</span>() -&gt; <span class="org-type">String</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-type">String</span>::new();
    <span class="org-keyword">for</span> <span class="org-variable-name">line</span> <span class="org-keyword">in</span> <span class="org-constant">io</span>::stdin().lock().lines() {
        buf.push_str(<span class="org-rust-ampersand">&amp;</span>line.unwrap());
        buf.push(<span class="org-string">'\n'</span>);
    }
    buf
}

<span class="org-comment-delimiter">// </span><span class="org-comment">A function that takes a handle to stdin. It reads a length from</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">stdin, then reads that many bytes and returns a string.</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">read_input</span>() -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">String</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">spawn a thread to read from stdin</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Reading input");</span>
    <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">stdin</span> = <span class="org-constant">io</span>::stdin().lock();
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-type">String</span>::new();
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Err</span>(e) = stdin.read_line(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf) {
            <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error reading content length </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
            <span class="org-keyword">return</span> <span class="org-type">None</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">parse an integer from buf</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">read_len</span> = buf.trim();
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Read length {}", read_len);</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">len</span> = read_len.parse::&lt;<span class="org-type">usize</span>&gt;().unwrap_or_default();
        <span class="org-keyword">if</span> len == 0 {
            <span class="org-keyword">return</span> <span class="org-type">None</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">read len bytes from stdin</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-preprocessor">vec!</span>[0; len];
        stdin.read_exact(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf).unwrap();

        <span class="org-comment-delimiter">// </span><span class="org-comment">convert the bytes to a string</span>
        <span class="org-type">Some</span>(<span class="org-type">String</span>::from_utf8(buf).unwrap())
    })
    .<span class="org-keyword">await</span>
    .unwrap()
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">print_with_length</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) {
    <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80);

    <span class="org-comment-delimiter">// </span><span class="org-comment">first print the length of the result</span>
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">\n</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, result.len(), result);
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">print</span>(<span class="org-variable-name">env</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Environment</span>) {
    <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = <span class="org-constant">serialize</span>::auto_format(<span class="org-constant">serialize</span>::emit_all(<span class="org-rust-ampersand">&amp;</span>env.stack).as_str(), 20, 80);
    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, result);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">a function that takes an env, and an input string. Parses the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">string, if it parses, returns the env with the input added to the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">program. Otherwise returns Error.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">parse_input</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>, <span class="org-variable-name">input</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Environment</span>, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">parsed</span> = <span class="org-constant">serialize</span>::parse(input)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = <span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> env.program);
    expr.extend(<span class="org-type">Arc</span>::make_mut(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> parsed).drain(..));
    <span class="org-type">Ok</span>(env)
}

<span class="org-comment-delimiter">//</span><span class="org-comment">It converts the bytes to a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">string, and then evaluates that string as a kcats program. It then</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">prints the length of the result, and then the result itself.</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">interactive_mode</span>() {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-type">Environment</span>::default();

    <span class="org-keyword">loop</span> {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(program) = read_input().<span class="org-keyword">await</span> {
            <span class="org-keyword">match</span> parse_input(env, program) {
                <span class="org-type">Ok</span>(parsed_env) =&gt; {
                    env = <span class="org-constant">axiom</span>::eval(parsed_env).<span class="org-keyword">await</span>;
                    print_with_length(<span class="org-rust-ampersand">&amp;</span>env).<span class="org-keyword">await</span>;
                }
                <span class="org-type">Err</span>(e) =&gt; {
                    <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
                    <span class="org-keyword">break</span>;
                }
            }
        } <span class="org-keyword">else</span> {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Blank input received, exiting");</span>
            <span class="org-keyword">continue</span>;
        }
    }
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">repl</span>() {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">env</span> = <span class="org-type">Environment</span>::default();

    <span class="org-keyword">loop</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Print the prompt and flush it to stdout immediately</span>
        <span class="org-rust-builtin-formatting-macro">print!</span>(<span class="org-string">"kcats&gt; "</span>);
        <span class="org-constant">io</span>::stdout().flush().unwrap();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Read a line from stdin</span>
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">line</span> = <span class="org-type">String</span>::new();
        <span class="org-constant">io</span>::stdin().read_line(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> line).unwrap();

        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the input is empty, if so, continue to the next loop iteration</span>
        <span class="org-keyword">if</span> line.trim().is_empty() {
            <span class="org-keyword">continue</span>;
        }

        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse and evaluate the input, then print the result</span>
        <span class="org-keyword">match</span> parse_input(env, line) {
            <span class="org-type">Ok</span>(parsed_env) =&gt; {
                env = <span class="org-constant">axiom</span>::eval(parsed_env).<span class="org-keyword">await</span>;
                print(<span class="org-rust-ampersand">&amp;</span>env).<span class="org-keyword">await</span>;
            }
            <span class="org-type">Err</span>(e) =&gt; {
                <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
                <span class="org-keyword">break</span>;
            }
        }
    }
}

<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">read_eval_print</span>(<span class="org-variable-name">program</span>: <span class="org-type">String</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">otherwise, read from stdin</span>
    <span class="org-keyword">match</span> parse_input(<span class="org-type">Environment</span>::default(), program) {
        <span class="org-type">Ok</span>(env) =&gt; {
            print_result(<span class="org-constant">axiom</span>::eval(env).<span class="org-keyword">await</span>);
        }
        <span class="org-type">Err</span>(e) =&gt; {
            <span class="org-rust-builtin-formatting-macro">println!</span>(<span class="org-string">"Error parsing input: </span><span class="org-rust-string-interpolation">{:?}</span><span class="org-string">"</span>, e);
        }
    }
}

<span class="org-doc">/// The main intepreter entry function that can start the interpreter</span>
<span class="org-doc">/// in several different modes.</span>
<span class="org-preprocessor">#[tokio::main]</span>
<span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">read command line options, to look for -i switch</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">args</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">String</span>&gt; = <span class="org-constant">std</span>::<span class="org-constant">env</span>::args().collect();
    <span class="org-comment-delimiter">// </span><span class="org-comment">if args contains "-i", read via handle_stdin</span>
    <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-i"</span>.to_string()) {
        interactive_mode().<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-r"</span>.to_string()) {
        repl().<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-f"</span>.to_string()) {
        <span class="org-keyword">let</span> <span class="org-variable-name">filename</span> = args.get(2).unwrap();
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">file</span> = <span class="org-constant">std</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>::open(filename).unwrap();
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = <span class="org-type">String</span>::new();
        file.read_to_string(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf).unwrap();
        read_eval_print(buf).<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> args.contains(&amp;<span class="org-string">"-p"</span>.to_string()) {
        <span class="org-keyword">let</span> <span class="org-variable-name">program</span> = args.get(2).unwrap();
        read_eval_print(program.clone()).<span class="org-keyword">await</span>;
    } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">otherwise, read from stdin</span>
        read_eval_print(get_stdin()).<span class="org-keyword">await</span>;
    }
}

<span class="org-preprocessor">#[cfg(test)]</span>
<span class="org-keyword">mod</span> <span class="org-constant">tests</span> {
    <span class="org-doc">//! Unit tests, in the form of all the examples of usage of the</span>
    <span class="org-doc">//! different lexicon words. Examples are all in the form of two</span>
    <span class="org-doc">//! programs that should be equivalent, something like `2 3 +` and</span>
    <span class="org-doc">//! `5`. Runs both programs in separate environments, compares the</span>
    <span class="org-doc">//! resulting stack to ensure they are equal.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note this useful idiom: importing names from outer (for mod tests) scope.</span>
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
    <span class="org-keyword">use</span> <span class="org-keyword">super</span>::*;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
    <span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-type">Item</span>, <span class="org-type">Word</span>};
    <span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">borrow</span>::<span class="org-type">Borrow</span>;
    <span class="org-keyword">use</span> <span class="org-constant">test_case</span>::test_case;

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">get_item</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">index</span>: <span class="org-type">usize</span>) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)
            .ok()
            .and_then(|l| l.get(index).cloned())
    }

    <span class="org-preprocessor">#[tokio::main]</span>
    <span class="org-keyword">async</span> <span class="org-keyword">fn</span> <span class="org-function-name">test_example</span>(
        <span class="org-keyword">mut</span> <span class="org-variable-name">prog_env</span>: <span class="org-type">Environment</span>,
        <span class="org-variable-name">program</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>,
        <span class="org-variable-name">expected</span>: <span class="org-constant">coll</span>::<span class="org-type">List</span>,
    ) -&gt; <span class="org-type">Option</span>&lt;<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">exp_env</span> = prog_env.clone();
        prog_env.program.append(program.clone());
        exp_env.program.append(expected.clone());

        <span class="org-keyword">let</span> <span class="org-variable-name">p_fut</span> = <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-constant">axiom</span>::eval(prog_env).<span class="org-keyword">await</span> });

        <span class="org-keyword">let</span> <span class="org-variable-name">exp_fut</span> = <span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-constant">axiom</span>::eval(exp_env).<span class="org-keyword">await</span> });
        <span class="org-keyword">let</span> (prog_env, exp_env) = <span class="org-constant">tokio</span>::<span class="org-preprocessor">join!</span>(p_fut, exp_fut);
        <span class="org-keyword">let</span> <span class="org-variable-name">prog_env</span> = prog_env.unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">exp_env</span> = exp_env.unwrap();

        <span class="org-keyword">if</span> prog_env.stack == exp_env.stack {
            <span class="org-rust-builtin-formatting-macro">println!</span>(
                <span class="org-string">"Nice expected </span><span class="org-rust-string-interpolation">{}</span><span class="org-string"> got </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
                <span class="org-constant">serialize</span>::emit_all(exp_env.stack.borrow()),
                <span class="org-constant">serialize</span>::emit_all(prog_env.stack.borrow())
            );
            <span class="org-type">None</span>
        } <span class="org-keyword">else</span> {
            <span class="org-rust-builtin-formatting-macro">println!</span>(
                <span class="org-string">"uh oh expected </span><span class="org-rust-string-interpolation">{}</span><span class="org-string"> got </span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>,
                <span class="org-constant">serialize</span>::emit_all(exp_env.stack.borrow()),
                <span class="org-constant">serialize</span>::emit_all(prog_env.stack.borrow())
            );
            <span class="org-comment-delimiter">// </span><span class="org-comment">println!(</span>
            <span class="org-comment-delimiter">//     </span><span class="org-comment">"Debug: expected {:?} got {:?}",</span>
            <span class="org-comment-delimiter">//     </span><span class="org-comment">exp_env.stack, prog_env.stack</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">);</span>
            <span class="org-type">Some</span>(<span class="org-type">Error</span>::test_assertion(program, expected, prog_env.stack))
        }
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">test_word</span>(<span class="org-variable-name">standard_env</span>: <span class="org-type">Environment</span>, <span class="org-variable-name">w</span>: <span class="org-type">Word</span>) -&gt; <span class="org-type">Vec</span>&lt;<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(d) = standard_env.dictionary.get(<span class="org-rust-ampersand">&amp;</span>w) {
            d.examples
                .clone()
                .unwrap()
                .iter()
                .filter_map(|ex| {
                    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(get_item(ex.clone(), 0).unwrap());
                    <span class="org-keyword">let</span> <span class="org-variable-name">exp</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(get_item(ex.clone(), 1).unwrap());
                    <span class="org-keyword">match</span> (p, exp) {
                        (<span class="org-type">Ok</span>(p), <span class="org-type">Ok</span>(exp)) =&gt; test_example(standard_env.clone(), p, exp),
                        (<span class="org-type">Err</span>(e), _) =&gt; <span class="org-type">Some</span>(e),
                        (_, <span class="org-type">Err</span>(e)) =&gt; <span class="org-type">Some</span>(e),
                    }
                })
                .collect::&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">Error</span>&gt;&gt;()
        } <span class="org-keyword">else</span> {
            <span class="org-preprocessor">vec!</span>[<span class="org-type">Error</span>::create(
                <span class="org-preprocessor">list!</span>(<span class="org-string">"dictionary"</span>, <span class="org-preprocessor">list!</span>(w.clone()), <span class="org-string">"lookup"</span>),
                <span class="org-string">"word is not defined"</span>,
                <span class="org-type">None</span>::&lt;<span class="org-type">Item</span>&gt;,
            )]
        }
    }

    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"+"</span><span class="org-preprocessor"> ; </span><span class="org-string">"plus"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"-"</span><span class="org-preprocessor"> ; </span><span class="org-string">"minus"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"="</span><span class="org-preprocessor"> ; </span><span class="org-string">"eq"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&gt;"</span><span class="org-preprocessor"> ; </span><span class="org-string">"gt"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&gt;="</span><span class="org-preprocessor"> ; </span><span class="org-string">"gte"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&lt;"</span><span class="org-preprocessor"> ; </span><span class="org-string">"lt"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"&lt;="</span><span class="org-preprocessor"> ; </span><span class="org-string">"lte"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"*"</span><span class="org-preprocessor"> ; </span><span class="org-string">"mult"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"/"</span><span class="org-preprocessor"> ; </span><span class="org-string">"divide"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"abs"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"addmethod"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"and"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"any?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_any"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"assemble"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"assign"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"association"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"association?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_association"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"bail"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"bits"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"both?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_both"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"branch"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"butlast"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"bytes?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_bytes"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"catcher"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"ceiling"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"clone"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"clonedown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"clonedeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"collect"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"compare"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"contains?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"contains"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"count"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"cram"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"cut"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dec"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decide"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decodejson"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decorate"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"decorated"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"definition"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dip"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dipdown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dipdeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dive"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"divedown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"divedeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">#[test_case("draft")]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"drop"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dropdown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dropdeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"dropper"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"each"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"emit"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"ends?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_ends"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"encode"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"encodejson"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"encodestring"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"encodenumber"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"environment"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"evaluate"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"eval-step"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"even?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_even"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"evert"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"every?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_every"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"execute"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"exp"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"filter"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"first"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"flip"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"float"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"floor"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"fold"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"format"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"future"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"get"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"generate"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"group"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"hashbytes"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"if"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"inc"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"indexed"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"inject"</span><span class="org-preprocessor">)]</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">#[test_case("inscribe")]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"intersection"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"into"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"join"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"joiner"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"keep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"label"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"let"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"list?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_list"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"lookup"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"loop"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"log"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"map"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"max"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"min"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"mod"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"not"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"empty?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_empty"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"number?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_number"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"odd?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_odd"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"or"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"over"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"pad"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"pair?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_pair"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"pairwise"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"partition"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"pipe?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_pipe"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"put"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"prepend"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"primrec"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"radix"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"range"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"recover"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"recur"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"repeat"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"rest"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"restore"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"retry"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"reverse"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"round"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"set"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"set?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_set"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"shield"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"shielddown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"shielddeep"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"sink"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"siphon"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"skipper"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"slice"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"snapshot"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"something?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_something"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"sqrt"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"starts?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_starts"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"step"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"string"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"string?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_string"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"spawn"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"split"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"swap"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"swapdown"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"take"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"taker"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"template"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"times"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"type"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"unassign"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"under"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"until"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"unwrap"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"update"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"value"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"when"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"while"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"within?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_within"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"word?"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"wrap"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"xor"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"zero?"</span><span class="org-preprocessor"> ; </span><span class="org-string">"is_zero"</span><span class="org-preprocessor">)]</span>
    <span class="org-preprocessor">#[test_case(</span><span class="org-string">"zip"</span><span class="org-preprocessor">)]</span>
    <span class="org-keyword">fn</span> <span class="org-function-name">test_lexicon</span>(<span class="org-variable-name">word</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>) {
        <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = <span class="org-type">Environment</span>::default();

        <span class="org-keyword">let</span> <span class="org-variable-name">r</span> = test_word(e.clone(), word.into());
        <span class="org-preprocessor">assert!</span>(r.is_empty(), <span class="org-string">"{:?}"</span>, r);
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">if let (Item::List(program), Item::List(expected)) = (program, expected) {</span>

<span class="org-comment-delimiter">//     </span><span class="org-comment">} else {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Err(Error::from("Example should be a pair"))</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">for ex in d.examples().iter() {</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let e = List::try_from(*ex).ok().unwrap();</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let p = List::try_from(*e.get(0).unwrap()).ok().unwrap();</span>
<span class="org-comment-delimiter">//             </span><span class="org-comment">let exp = List::try_from(*e.get(1).unwrap()).ok().unwrap();</span>

<span class="org-comment-delimiter">//             </span><span class="org-comment">test_example(axiom::standard_env.clone(), w, p,exp)</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">}.retain(|i| i.is_some()).collect::&lt;Vec&lt;Error&gt;&gt;()</span>
</pre>
</div></div>
</div>
</div>
<div id="outline-container-orgf536a96" class="outline-4">
<h4 id="orgf536a96"><span class="section-number-4">1.5.6.</span> Pipes (input/output)</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
Kcats will confine all i/o to pipes. You can put values into pipes and
they emerge elsewhere. Words that act on pipes are the only ones that
can be impure. Everything else is a value.
</p>
</div>
<ol class="org-ol">
<li><a id="org8086ebd"></a>Basic Types<br />
<div class="outline-text-6" id="text-1-5-6-0-1">
<p>
The basic pipe contracts.
</p>
<div class='tangle-wrapper' data-tangle='src/types/container/pipe.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">super</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">sync</span>::<span class="org-type">RwLock</span>;

<span class="org-keyword">use</span> <span class="org-constant">futures</span>::executor;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">channel</span>;

<span class="org-preprocessor">#[cfg(feature = </span><span class="org-string">"database"</span><span class="org-preprocessor">)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">db</span>;

<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">fs</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">net</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">standard</span>;
<span class="org-keyword">pub</span> <span class="org-keyword">mod</span> <span class="org-constant">time</span>;

<span class="org-doc">/// A pipe that accepts items.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">In</span> {
    <span class="org-doc">/// A pipe that takes bytes to write to a file on disk</span>
    <span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">fs</span>::<span class="org-type">StaticFile</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that takes bytes to write to a TCP/IP socket</span>
    <span class="org-type">Socket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">Socket</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that takes items to send through a channel to another</span>
    <span class="org-doc">/// part of the running program</span>
    <span class="org-type">Handoff</span>(<span class="org-constant">channel</span>::<span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-doc">/// A pipe that takes bytes to write to standard out</span>
    <span class="org-type">Standard</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">In</span>::<span class="org-type">StaticFile</span>(s1), <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">In</span>::<span class="org-type">Socket</span>(s1), <span class="org-type">In</span>::<span class="org-type">Socket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">In</span>::<span class="org-type">Handoff</span>(h1), <span class="org-type">In</span>::<span class="org-type">Handoff</span>(h2)) =&gt; h1 == h2,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}
<span class="org-doc">/// A pipe that produces items.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Out</span> {
    <span class="org-doc">/// A pipe that produces bytes from a file on disk</span>
    <span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">fs</span>::<span class="org-type">StaticFile</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that produces bytes from a TCP/IP socket</span>
    <span class="org-type">Socket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">Socket</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that produces sockets from a TCP/IP server socket</span>
    <span class="org-type">ServerSocket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">ServerSocket</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that produces items from a channel that comes from</span>
    <span class="org-doc">/// another part of the program</span>
    <span class="org-type">Handoff</span>(<span class="org-constant">channel</span>::<span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-doc">/// A pipe that produces a dummy value after a given amount of</span>
    <span class="org-doc">/// time. Can be used as a timeout mechanism when waiting on</span>
    <span class="org-doc">/// multiple pipes at once.</span>
    <span class="org-type">Timer</span>(<span class="org-constant">channel</span>::<span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-doc">/// A pipe that produces timestamps of the current UNIX time</span>
    <span class="org-type">Time</span>,
    <span class="org-doc">/// A pipe that produces bytes from standard in.</span>
    <span class="org-type">Standard</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(s1), <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Out</span>::<span class="org-type">Socket</span>(s1), <span class="org-type">Out</span>::<span class="org-type">Socket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(s1), <span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h1), <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h2)) =&gt; h1 == h2,
            (<span class="org-type">Out</span>::<span class="org-type">Time</span>, <span class="org-type">Out</span>::<span class="org-type">Time</span>) =&gt; <span class="org-keyword">true</span>,
            (<span class="org-type">Out</span>::<span class="org-type">Standard</span>, <span class="org-type">Out</span>::<span class="org-type">Standard</span>) =&gt; <span class="org-keyword">true</span>,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-doc">/// A bi-directional pipe that can accept and produce Items.</span>
<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">enum</span> <span class="org-type">Tunnel</span> {
    <span class="org-doc">/// A pipe that can both produce and accept bytes to read/write from a file.</span>
    <span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">fs</span>::<span class="org-type">StaticFile</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that can both produce and accept bytes to read/write</span>
    <span class="org-doc">/// from a TCP/IP socket.</span>
    <span class="org-type">Socket</span>(<span class="org-type">Arc</span>&lt;<span class="org-type">RwLock</span>&lt;<span class="org-constant">net</span>::<span class="org-type">Socket</span>&gt;&gt;),
    <span class="org-doc">/// A pipe that produces or accepts values to/from a channel that</span>
    <span class="org-doc">/// connects to another part of the program.</span>
    <span class="org-type">Handoff</span>(<span class="org-constant">channel</span>::<span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt;),
    <span class="org-doc">/// A pipe to standard in/out that produces/accepts bytes.</span>
    <span class="org-type">Standard</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Tunnel</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-keyword">self</span>, other) {
            (<span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(s1), <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s1), <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s2)) =&gt; <span class="org-type">Arc</span>::ptr_eq(s1, s2),
            (<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h1), <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h2)) =&gt; h1 == h2,
            (<span class="org-type">Tunnel</span>::<span class="org-type">Standard</span>, <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span>) =&gt; <span class="org-keyword">true</span>,
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Tunnel</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Tunnel</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> t {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(f),
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s) =&gt; <span class="org-type">Out</span>::<span class="org-type">Socket</span>(s),
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h) =&gt; <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-type">Out</span>::<span class="org-type">Standard</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Tunnel</span>&gt; <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Tunnel</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">match</span> t {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(f),
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(s) =&gt; <span class="org-type">In</span>::<span class="org-type">Socket</span>(s),
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h) =&gt; <span class="org-type">In</span>::<span class="org-type">Handoff</span>(h),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-type">In</span>::<span class="org-type">Standard</span>,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">In</span> {
    <span class="org-doc">/// Puts the [Item] into the pipe. Blocks if the pipe is full.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">In</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">In</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.put(i)), <span class="org-comment-delimiter">//</span><span class="org-comment">_ =&gt; Err(Error::expected("foo")),</span>
            <span class="org-type">In</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::put(i),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Tunnel</span> {
    <span class="org-doc">/// Puts the [Item] into the tunnel, blocks if the send side of</span>
    <span class="org-doc">/// the tunnel is full.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.put(i).<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.put(i)),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::put(i),
        }
    }

    <span class="org-doc">/// Takes an [Item] from the tunnel, blocks if the receive side of</span>
    <span class="org-doc">/// the tunnel is empty.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.take()),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::take(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Out</span> {
    <span class="org-doc">/// Takes an [Item] from the pipe, blocks if the pipe is empty.</span>
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Out</span>::<span class="org-type">Socket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = f.clone();
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write().<span class="org-keyword">await</span>.take().<span class="org-keyword">await</span> })
            }
            <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span>) =&gt; <span class="org-type">Box</span>::pin(h.take()),
            <span class="org-type">Out</span>::<span class="org-type">Timer</span>(<span class="org-keyword">ref</span> <span class="org-keyword">mut</span> <span class="org-variable-name">t</span>) =&gt; <span class="org-type">Box</span>::pin(t.take()),
            <span class="org-type">Out</span>::<span class="org-type">Time</span> =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">time</span>::take()),
            <span class="org-type">Out</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::take(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">In</span>::<span class="org-type">StaticFile</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">In</span>::<span class="org-type">Socket</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">In</span>::<span class="org-type">Handoff</span>(h) =&gt; h.representation(),
            <span class="org-type">In</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::representation(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() })
            }
            <span class="org-type">Out</span>::<span class="org-type">Socket</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(f) =&gt; {
                <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() })
            }
            <span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h) =&gt; h.representation(),
            <span class="org-type">Out</span>::<span class="org-type">Timer</span>(t) =&gt; t.representation(),
            <span class="org-type">Out</span>::<span class="org-type">Time</span> =&gt; <span class="org-constant">time</span>::representation(),
            <span class="org-type">Out</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::representation(),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Tunnel</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Tunnel</span>::<span class="org-type">StaticFile</span>(f) =&gt; {
                <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() })
            }
            <span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(f) =&gt; <span class="org-constant">executor</span>::block_on(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.read().<span class="org-keyword">await</span>.representation() }),
            <span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(h) =&gt; h.representation(),
            <span class="org-type">Tunnel</span>::<span class="org-type">Standard</span> =&gt; <span class="org-constant">standard</span>::representation(),
        }
    }
}
<span class="org-comment-delimiter">/* </span><span class="org-comment">Pipes can be "closed", from either end to signal that either the</span>
<span class="org-comment"> * putter or taker has gone away. Sometimes the type of pipe</span>
<span class="org-comment"> * may not really support this concept but an implementation is</span>
<span class="org-comment"> * required.  For example, files. When you open a file for writing and</span>
<span class="org-comment"> * then "close" it, that doesn't really do anything. Rust doesn't have</span>
<span class="org-comment"> * an explicit file close. You have to drop the reference to it, which</span>
<span class="org-comment"> * in kcats you can do by popping the pipe off the stack. Rust will</span>
<span class="org-comment"> * clean up automatically, other impls might have to reference count.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * The contract here is as follows:</span>
<span class="org-comment"> * 1. After calling close, put on the pipe returns an error</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * 2. After calling close, take on the pipe will return still-buffered</span>
<span class="org-comment"> * items (if the pipe has a buffer), but once buffer is exhausted it</span>
<span class="org-comment"> * will return error.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * 2. Errors cannot be put into a pipe (the taker can't distinguish</span>
<span class="org-comment"> * between io error and an error value). To work around this, wrap the</span>
<span class="org-comment"> * error value in a list to quote it. Putting error into a pipe will</span>
<span class="org-comment"> * return an io error.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * 3. Once closed pipes cannot be ever be put into again. closed? will always</span>
<span class="org-comment"> * return true thereafter.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * One use case that has to be handled specially is a file we've fully</span>
<span class="org-comment"> * read but later someone else might write more bytes to the end. Does</span>
<span class="org-comment"> * the pipe close when we reach EOF? I think we might need to support</span>
<span class="org-comment"> * both types (a type that closes when hitting eof and one that</span>
<span class="org-comment"> * doesn't). The former is the "normal" use case, which will be the</span>
<span class="org-comment"> * default.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * These two types are basically static vs dynamic content. Either all</span>
<span class="org-comment"> * the content is known now, or it isn't.</span>
<span class="org-comment"> *</span>
<span class="org-comment">*/</span>

<span class="org-keyword">fn</span> <span class="org-function-name">closed_error</span>(<span class="org-variable-name">on_take</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Error</span> {
    <span class="org-type">Error</span>::create(
        <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter([
            <span class="org-type">Item</span>::from(<span class="org-string">"close"</span>),
            <span class="org-keyword">if</span> on_take { <span class="org-string">"take"</span> } <span class="org-keyword">else</span> { <span class="org-string">"put"</span> }.into(),
        ]),
        <span class="org-string">"attempt to use closed pipe"</span>,
        <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>,
    )
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Tunnel</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Tunnel</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Out</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Out</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(t))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">In</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">In</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(t))
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">In</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(i)) =&gt; <span class="org-type">Ok</span>(i),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pipe"</span>, i)),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Out</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(o)) =&gt; <span class="org-type">Ok</span>(o),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(t)) =&gt; <span class="org-type">Ok</span>(t.into()),
            i =&gt; <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"pipe"</span>, i)),
        }
    }
}
</pre>
</div></div>
</div>
</li>
<li><a id="orgc53ee09"></a>Files<br />
<div class="outline-text-6" id="text-1-5-6-0-2">
<p>
How to interact with files on disk
</p>
<div class='tangle-wrapper' data-tangle='src/types/container/pipe/fs.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">pin</span>::<span class="org-type">Pin</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">io</span>::{<span class="org-type">AsyncReadExt</span>, <span class="org-type">AsyncWriteExt</span>};
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">sync</span>::<span class="org-type">RwLock</span>;

<span class="org-keyword">use</span> <span class="org-keyword">super</span>::closed_error;

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">file</span>: <span class="org-type">Option</span>&lt;<span class="org-type">File</span>&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">path</span>: <span class="org-type">String</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the 'file' fields of both structs are the same by reference</span>
        <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.file, <span class="org-rust-ampersand">&amp;</span>other.file)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
        <span class="org-variable-name">i</span>: <span class="org-type">Item</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span>.file.as_mut() {
            <span class="org-type">Some</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = <span class="org-type">Bytes</span>::try_from(i);

                <span class="org-keyword">match</span> b {
                    <span class="org-type">Ok</span>(bs) =&gt; <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { f.write_all(<span class="org-rust-ampersand">&amp;</span>bs).<span class="org-keyword">await</span>.map_err(|e| e.into()) }),
                    <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
                }
            }
            <span class="org-type">None</span> =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(closed_error(<span class="org-keyword">false</span>)))),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span>.file.as_mut() {
            <span class="org-type">Some</span>(f) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">bs</span> = [0<span class="org-type">u8</span>; 102400];
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                    <span class="org-keyword">let</span> <span class="org-variable-name">ct</span> = f.read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> bs).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;
                    <span class="org-keyword">if</span> ct == 0 {
                        <span class="org-comment-delimiter">// </span><span class="org-comment">EOF, no more takes since it's static</span>
                        <span class="org-type">Ok</span>(<span class="org-type">None</span>)
                    } <span class="org-keyword">else</span> {
                        <span class="org-type">Ok</span>(<span class="org-type">Some</span>(bs[0..ct].to_vec().into()))
                    }
                })
            }
            <span class="org-type">None</span> =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(closed_error(<span class="org-keyword">false</span>)))),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">StaticFile</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"tunnel"</span>.into()),
            (
                <span class="org-string">"values"</span>.into(),
                <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([(<span class="org-string">"type"</span>.into(), <span class="org-string">"bytes"</span>.into())]).into(),
            ),
            (
                <span class="org-string">"to"</span>.into(),
                <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([(<span class="org-string">"file"</span>.into(), <span class="org-keyword">self</span>.path.clone().into())]).into(),
            ),
        ])
        .into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">file_in</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">path</span> = <span class="org-type">String</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = <span class="org-constant">std</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>::options()
        .read(<span class="org-keyword">true</span>)
        .write(<span class="org-keyword">true</span>)
        .create_new(<span class="org-keyword">true</span>)
        .open(path.clone())<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">In</span>::<span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">StaticFile</span> {
        <span class="org-variable-name">file</span>: <span class="org-type">Some</span>(<span class="org-type">File</span>::from_std(file)),
        path,
    })))
    .into())
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">file_out</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">path</span> = <span class="org-type">String</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = <span class="org-constant">std</span>::<span class="org-constant">fs</span>::<span class="org-type">File</span>::open(path.clone())<span class="org-rust-question-mark">?</span>;
    <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">StaticFile</span> {
        <span class="org-variable-name">file</span>: <span class="org-type">Some</span>(<span class="org-type">File</span>::from_std(file)),
        path,
    })))
    .into())
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">StaticFile</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">f</span>: <span class="org-type">StaticFile</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-keyword">super</span>::<span class="org-type">Out</span>::<span class="org-type">StaticFile</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(f))).into()
    }
}
</pre>
</div></div>
</div>
</li>
<li><a id="org185d924"></a>Network<br />
<div class="outline-text-6" id="text-1-5-6-0-3">
<p>
How to interact with the network (TCP/IP sockets)
</p>
<div class='tangle-wrapper' data-tangle='src/types/container/pipe/net.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Int</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">futures</span>::<span class="org-constant">future</span>::<span class="org-type">FutureExt</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::{<span class="org-keyword">self</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">net</span>::{<span class="org-type">Ipv4Addr</span>, <span class="org-type">SocketAddrV4</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">pin</span>::<span class="org-type">Pin</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-type">str</span>::<span class="org-type">FromStr</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">io</span>::{<span class="org-type">AsyncReadExt</span>, <span class="org-type">AsyncWriteExt</span>};
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">net</span>::{<span class="org-type">TcpListener</span>, <span class="org-type">TcpStream</span>};
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">sync</span>::<span class="org-type">RwLock</span>;

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">socket</span>: <span class="org-type">TcpStream</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">addr</span>: (<span class="org-type">String</span>, <span class="org-type">u16</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the 'socket' fields of both structs are the same by reference</span>
        <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.socket, <span class="org-rust-ampersand">&amp;</span>other.socket)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
        <span class="org-variable-name">i</span>: <span class="org-type">Item</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Putting {:?}", i);</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = <span class="org-constant">types</span>::<span class="org-type">Bytes</span>::try_from(i);
        <span class="org-keyword">match</span> b {
            <span class="org-type">Ok</span>(bs) =&gt; {
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { <span class="org-keyword">self</span>.socket.write_all(<span class="org-rust-ampersand">&amp;</span>bs).<span class="org-keyword">await</span>.map_err(|e| e.into()) })
            }
            <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">bs</span> = [0<span class="org-type">u8</span>; 1024];
        <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
            <span class="org-keyword">let</span> <span class="org-variable-name">n</span> = <span class="org-keyword">self</span>.socket.read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> bs).<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;
            <span class="org-keyword">if</span> n == 0 {
                <span class="org-type">Ok</span>(<span class="org-type">None</span>)
            } <span class="org-keyword">else</span> {
                <span class="org-type">Ok</span>(<span class="org-type">Some</span>(bs[..n].to_vec().into()))
            }
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Socket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"tunnel"</span>.into()),
            (<span class="org-string">"realm"</span>.into(), <span class="org-string">"tcp"</span>.into()),
            (<span class="org-string">"address"</span>.into(), <span class="org-keyword">self</span>.addr.0.to_string().into()),
            (<span class="org-string">"port"</span>.into(), <span class="org-keyword">self</span>.addr.1.to_string().into()),
        ])
        .into()
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Server sockets</span>
<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">pub</span> <span class="org-variable-name">socket</span>: <span class="org-type">TcpListener</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the 'socket' fields of both structs are the same by reference</span>
        <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.socket, <span class="org-rust-ampersand">&amp;</span>other.socket)
    }
}

<span class="org-keyword">impl</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>&lt;'<span class="org-variable-name">a</span>&gt;(
        <span class="org-rust-ampersand">&amp;</span>'<span class="org-variable-name">a</span> <span class="org-keyword">mut</span> <span class="org-keyword">self</span>,
    ) -&gt; <span class="org-type">Pin</span>&lt;<span class="org-type">Box</span>&lt;<span class="org-keyword">dyn</span> <span class="org-constant">std</span>::<span class="org-constant">future</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Output</span> = <span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; + <span class="org-type">Send</span> + '<span class="org-variable-name">a</span>&gt;&gt; {
        <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
            <span class="org-keyword">let</span> (socket, addr) = <span class="org-keyword">self</span>.socket.accept().<span class="org-keyword">await</span><span class="org-rust-question-mark">?</span>;

            <span class="org-type">Ok</span>(<span class="org-type">Some</span>(
                <span class="org-keyword">super</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">Socket</span> {
                    socket,
                    <span class="org-variable-name">addr</span>: (addr.ip().to_string(), addr.port()),
                })))
                .into(),
            ))
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">ServerSocket</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"pipe"</span>.into()),
            (
                <span class="org-string">"serversocket"</span>.into(),
                <span class="org-string">"todo: fix serversocket local addr async issue"</span>.into(), <span class="org-comment-delimiter">//</span><span class="org-comment">Item::String(self.socket.lock().await.local_addr().unwrap().to_string()),</span>
            ),
        ])
        .into()
    }
}

<span class="org-keyword">fn</span> <span class="org-function-name">socket_addr</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">SocketAddrV4</span>, <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("socket: {:?} {:?}", i, j);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">addr</span> = <span class="org-type">Ipv4Addr</span>::from_str(<span class="org-type">String</span>::try_from(j)<span class="org-rust-question-mark">?</span>.as_str())<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">port</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span> <span class="org-keyword">as</span> <span class="org-type">u16</span>;
    <span class="org-type">Ok</span>(<span class="org-type">SocketAddrV4</span>::new(addr, port))
}

<span class="org-keyword">fn</span> <span class="org-function-name">host_addr</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;(<span class="org-type">String</span>, <span class="org-type">u16</span>), <span class="org-type">Error</span>&gt; {
    <span class="org-comment-delimiter">//</span><span class="org-comment">println!("socket: {:?} {:?}", i, j);</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">addr</span> = <span class="org-type">String</span>::try_from(j)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">port</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span> <span class="org-keyword">as</span> <span class="org-type">u16</span>;
    <span class="org-type">Ok</span>((addr, port))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">server_socket</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">ItemResult</span>&gt; {
    <span class="org-keyword">match</span> socket_addr(i, j) {
        <span class="org-type">Ok</span>(addr) =&gt; {
            <span class="org-type">Box</span>::pin(<span class="org-type">TcpListener</span>::bind(addr).map(|l| {
                <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">Out</span>::<span class="org-type">ServerSocket</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">ServerSocket</span> {
                    <span class="org-variable-name">socket</span>: l.unwrap(),
                })))
                .into())
            }))
        }
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">socket</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">j</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">ItemResult</span>&gt; {
    <span class="org-keyword">match</span> host_addr(i, j) {
        <span class="org-type">Ok</span>(addr) =&gt; <span class="org-type">Box</span>::pin(<span class="org-type">TcpStream</span>::connect(addr.clone()).map(<span class="org-keyword">move</span> |s| {
            <span class="org-type">Ok</span>(<span class="org-keyword">super</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Socket</span>(<span class="org-type">Arc</span>::new(<span class="org-type">RwLock</span>::new(<span class="org-type">Socket</span> {
                <span class="org-variable-name">socket</span>: s.unwrap(),
                addr,
            })))
            .into())
        })),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">pub fn server_socket(env: Environment) -&gt; environment::Future {</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">let addr = env.pop();</span>

<span class="org-comment-delimiter">//     </span><span class="org-comment">let inner_env = Environment::try_from(tos);</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">match inner_env {</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Ok(inner) =&gt; Box::pin(eval_step(inner).map(|inner_next| env.push(Item::Env(inner_next)))),</span>
<span class="org-comment-delimiter">//         </span><span class="org-comment">Err(e) =&gt; env.push(Item::Error(e)).into(),</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">std</span>::<span class="org-constant">net</span>::<span class="org-type">AddrParseError</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">err</span>: <span class="org-constant">std</span>::<span class="org-constant">net</span>::<span class="org-type">AddrParseError</span>) -&gt; <span class="org-type">Error</span> {
        <span class="org-type">Error</span>::create(<span class="org-preprocessor">list!</span>(<span class="org-string">"addrparse"</span>), <span class="org-rust-ampersand">&amp;</span>err.to_string(), <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>)
    }
}
</pre>
</div></div>
</div>
</li>
<li><a id="org01e6b3e"></a>Time<br />
<div class="outline-text-6" id="text-1-5-6-0-4">
<div class='tangle-wrapper' data-tangle='src/types/container/pipe/time.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::{<span class="org-type">Int</span>, <span class="org-type">Number</span>};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::*;

<span class="org-keyword">use</span> <span class="org-constant">std</span>::{
    future,
    <span class="org-constant">time</span>::{<span class="org-type">SystemTime</span>, <span class="org-type">UNIX_EPOCH</span>},
};

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>() -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = <span class="org-type">SystemTime</span>::now()
        .duration_since(<span class="org-type">UNIX_EPOCH</span>)
        .unwrap()
        .as_millis() <span class="org-keyword">as</span> <span class="org-type">Int</span>;
    <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Ok</span>(<span class="org-type">Some</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(t))))))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>() -&gt; <span class="org-type">Item</span> {
    <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
        (<span class="org-string">"type"</span>.into(), <span class="org-string">"out"</span>.into()),
        (<span class="org-string">"from"</span>.into(), <span class="org-string">"systemtime"</span>.into()),
        (
            <span class="org-string">"values"</span>.into(),
            <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
                (<span class="org-string">"type"</span>.into(), <span class="org-string">"integer"</span>.into()),
                (<span class="org-string">"units"</span>.into(), <span class="org-string">"milliseconds"</span>.into()),
            ])
            .into(),
        ),
    ])
    .into()
}
</pre>
</div></div>
</div>
</li>
<li><a id="org82b7848"></a>Standard in/out<br />
<div class="outline-text-6" id="text-1-5-6-0-5">
<div class='tangle-wrapper' data-tangle='src/types/container/pipe/standard.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::associative <span class="org-keyword">as</span> assoc;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::<span class="org-constant">error</span>::<span class="org-type">Error</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, *};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">io</span>::{<span class="org-keyword">self</span>, <span class="org-type">Read</span>, <span class="org-type">Write</span>};

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>() -&gt; <span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">buf</span> = [0<span class="org-type">u8</span>];
    <span class="org-keyword">let</span> <span class="org-variable-name">n</span> = <span class="org-constant">io</span>::stdin().read(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> buf);
    <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = <span class="org-keyword">match</span> n {
        <span class="org-type">Ok</span>(0) =&gt; <span class="org-type">Ok</span>(<span class="org-type">None</span>),
        <span class="org-type">Ok</span>(n) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Some</span>(buf[..n].to_vec().into())),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(e.into()),
    };
    <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(f))
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-type">Error</span>&gt;&gt; {
    <span class="org-keyword">let</span> <span class="org-variable-name">bs</span> = <span class="org-type">Bytes</span>::try_from(i);
    <span class="org-keyword">match</span> bs {
        <span class="org-type">Ok</span>(bs) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">f</span> = <span class="org-constant">io</span>::stdout().write(<span class="org-rust-ampersand">&amp;</span>bs);
            <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(f.map_err(|e| e.into()).map(|_| ())))
        }
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(e))),
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>() -&gt; <span class="org-type">Item</span> {
    <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
        (<span class="org-string">"type"</span>.into(), <span class="org-string">"tunnel"</span>.into()),
        (<span class="org-string">"peer"</span>.into(), <span class="org-string">"standard"</span>.into()),
    ])
    .into()
}
</pre>
</div></div>
</div>
</li>
<li><a id="orgf88e20c"></a>Channels<br />
<div class="outline-text-6" id="text-1-5-6-0-6">
<p>
Implement the <code>handoff</code> type
</p>
<div class='tangle-wrapper' data-tangle='src/types/container/pipe/channel.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::axiom;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::container <span class="org-keyword">as</span> coll;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::{associative <span class="org-keyword">as</span> assoc, <span class="org-constant">environment</span>::<span class="org-type">Environment</span>, error, pipe};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Int</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">flume</span>;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::future;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::ptr;
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-constant">atomic</span>::{<span class="org-type">AtomicUsize</span>, <span class="org-type">Ordering</span>};
<span class="org-keyword">use</span> <span class="org-constant">std</span>::<span class="org-constant">sync</span>::<span class="org-type">Arc</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">task</span>::<span class="org-type">JoinHandle</span>;
<span class="org-keyword">use</span> <span class="org-constant">tokio</span>::<span class="org-constant">time</span>::{sleep, <span class="org-type">Duration</span>};

<span class="org-preprocessor">#[derive(Debug, Clone)]</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Use Option because we want to be able to drop senders/receivers to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">close the channel</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">pub</span> <span class="org-variable-name">receiver</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Receiver</span>&lt;<span class="org-type">T</span>&gt;&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">sender</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Sender</span>&lt;<span class="org-type">T</span>&gt;&gt;,
    <span class="org-keyword">pub</span> <span class="org-variable-name">bidirectional</span>: <span class="org-type">bool</span>,
    <span class="org-keyword">pub</span> <span class="org-variable-name">id</span>: <span class="org-type">usize</span>,
}

<span class="org-keyword">impl</span>&lt;<span class="org-type">T</span>&gt; <span class="org-type">PartialEq</span> <span class="org-keyword">for</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">eq</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">other</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">Self</span>) -&gt; <span class="org-type">bool</span> {
        <span class="org-keyword">match</span> (<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.receiver, <span class="org-rust-ampersand">&amp;</span>other.receiver, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.sender, <span class="org-rust-ampersand">&amp;</span>other.sender) {
            (<span class="org-type">Some</span>(sr), <span class="org-type">Some</span>(or), <span class="org-type">Some</span>(ss), <span class="org-type">Some</span>(os)) =&gt; <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span>sr, <span class="org-rust-ampersand">&amp;</span>or) &amp;&amp; <span class="org-constant">ptr</span>::eq(<span class="org-rust-ampersand">&amp;</span>ss, <span class="org-rust-ampersand">&amp;</span>os),
            _ =&gt; <span class="org-keyword">false</span>,
        }
    }
}

<span class="org-keyword">static</span> <span class="org-variable-name">ID</span>: <span class="org-type">AtomicUsize</span> = <span class="org-type">AtomicUsize</span>::new(0);

<span class="org-keyword">impl</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>(<span class="org-variable-name">bidirectional</span>: <span class="org-type">bool</span>) -&gt; <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-keyword">let</span> (sender, receiver) = <span class="org-constant">flume</span>::bounded::&lt;<span class="org-type">Item</span>&gt;(0);
        <span class="org-keyword">let</span> <span class="org-variable-name">id</span> = <span class="org-type">ID</span>.fetch_add(1, <span class="org-type">Ordering</span>::<span class="org-type">Relaxed</span>);
        <span class="org-type">Handoff</span>::&lt;<span class="org-type">Item</span>&gt; {
            <span class="org-variable-name">sender</span>: <span class="org-type">Some</span>(sender),
            <span class="org-variable-name">receiver</span>: <span class="org-type">Some</span>(receiver),
            bidirectional,
            id,
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;(), <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt; {
        <span class="org-comment-delimiter">// </span><span class="org-comment">println!(</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">"Putting into channel: {} into {:?} on {:?}",</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">i.clone(),</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">self,</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">thread::current().id()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">);</span>
        <span class="org-keyword">if</span> !<span class="org-keyword">self</span>.bidirectional {
            <span class="org-keyword">self</span>.close_take()
        };
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(ch) = <span class="org-keyword">self</span>.sender.clone() {
            <span class="org-keyword">if</span> <span class="org-constant">axiom</span>::is_truthy(i.clone()) {
                <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                    ch.send_async(i)
                        .<span class="org-keyword">await</span>
                        .map_err(|_| <span class="org-constant">pipe</span>::closed_error(<span class="org-keyword">false</span>))
                })
            } <span class="org-keyword">else</span> {
                <span class="org-comment-delimiter">// </span><span class="org-comment">If we're putting 'nothing', that indicates end of</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">input, so we drop the sender.</span>
                <span class="org-keyword">self</span>.close_put();
                <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Ok</span>(())))
            }
        } <span class="org-keyword">else</span> {
            <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Err</span>(<span class="org-constant">pipe</span>::closed_error(<span class="org-keyword">false</span>))))
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt; {
        <span class="org-comment-delimiter">// </span><span class="org-comment">println!(</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">"Taking from channel: {:?} on {:?}",</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">self,</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">thread::current().id()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">);</span>
        <span class="org-keyword">if</span> !<span class="org-keyword">self</span>.bidirectional {
            <span class="org-keyword">self</span>.close_put();
        }
        <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(ch) = <span class="org-keyword">self</span>.receiver.clone() {
            <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> { ch.recv_async().<span class="org-keyword">await</span>.map(<span class="org-type">Some</span>).or_else(|_| <span class="org-type">Ok</span>(<span class="org-type">None</span>)) })
        } <span class="org-keyword">else</span> {
            <span class="org-type">Box</span>::pin(<span class="org-constant">future</span>::ready(<span class="org-type">Ok</span>(<span class="org-type">None</span>)))
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">close_take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.receiver.is_some() {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Dropping receiver");</span>
            <span class="org-keyword">self</span>.receiver = <span class="org-type">None</span>;
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">close_put</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.sender.is_some() {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Dropping sender");</span>
            <span class="org-keyword">self</span>.sender = <span class="org-type">None</span>;
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = <span class="org-keyword">match</span> (<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.sender, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>.receiver) {
            (<span class="org-type">Some</span>(_), <span class="org-type">Some</span>(_)) =&gt; <span class="org-string">"tunnel"</span>,
            (<span class="org-type">Some</span>(_), <span class="org-type">None</span>) =&gt; <span class="org-string">"in"</span>,
            (<span class="org-type">None</span>, <span class="org-type">Some</span>(_)) =&gt; <span class="org-string">"out"</span>,
            (<span class="org-type">None</span>, <span class="org-type">None</span>) =&gt; <span class="org-string">"closed"</span>,
        };
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), t.into()),
            (<span class="org-string">"handoff"</span>.into(), (<span class="org-keyword">self</span>.id <span class="org-keyword">as</span> <span class="org-type">Int</span>).into()),
        ])
        .into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">handoff</span>(<span class="org-keyword">mut</span> <span class="org-variable-name">env</span>: <span class="org-type">Environment</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Environment</span>&gt; {
    env.pop_prog();
    env.push(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(<span class="org-type">Handoff</span>::new(<span class="org-keyword">false</span>)));
    env.into()
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">RecvError</span>&gt; <span class="org-keyword">for</span> <span class="org-variable-name">error</span>::<span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">_</span>: <span class="org-constant">flume</span>::<span class="org-type">RecvError</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">pipe</span>::closed_error(<span class="org-keyword">false</span>) <span class="org-comment-delimiter">// </span><span class="org-comment">todo fix this</span>
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">SendError</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-variable-name">error</span>::<span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">_</span>: <span class="org-constant">flume</span>::<span class="org-type">SendError</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-constant">pipe</span>::closed_error(<span class="org-keyword">false</span>)
    }
}

<span class="org-keyword">enum</span> <span class="org-type">ChannelOp</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-type">Send</span>(<span class="org-type">Arc</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Sender</span>&lt;<span class="org-type">T</span>&gt;&gt;, <span class="org-type">usize</span>, <span class="org-type">T</span>),
    <span class="org-type">Receive</span>(<span class="org-type">Arc</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Receiver</span>&lt;<span class="org-type">T</span>&gt;&gt;, <span class="org-type">usize</span>),
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Given a list of pipes (channels) on top of stack, use flume's</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">selector to choose the next ready pipe.  A pipe means it's a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">receive, a pipe/item pair means it's a send.</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">select</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">original</span> = l.clone();

    <span class="org-comment-delimiter">//</span><span class="org-comment">Create references out of any [pipe item] pairs</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">lr</span> = l
        .inner()
        .into_iter()
        .enumerate()
        .map(<span class="org-keyword">move</span> |(idx, i)| <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(p))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(<span class="org-type">Arc</span>::new(p.receiver.unwrap()), idx))
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(<span class="org-type">Arc</span>::new(p.receiver.unwrap()), idx))
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">Handle timeout channels - start the timer and add receive op</span>
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>::<span class="org-type">Timer</span>(t))) =&gt; {
                <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">t</span> = t.clone();
                t.start();
                <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(<span class="org-type">Arc</span>::new(t.receiver.unwrap()), idx))
            }
            i =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">l</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::try_from(i.clone())<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = l.get(0);
                <span class="org-keyword">let</span> <span class="org-variable-name">i</span> = l.get(1);
                <span class="org-keyword">match</span> (p, i) {
                    (<span class="org-type">Some</span>(p), <span class="org-type">Some</span>(i)) =&gt; <span class="org-keyword">match</span> (p, i) {
                        (<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-constant">pipe</span>::<span class="org-type">In</span>::<span class="org-type">Handoff</span>(p))), i) =&gt; <span class="org-type">Ok</span>(
                            <span class="org-type">ChannelOp</span>::<span class="org-type">Send</span>(<span class="org-type">Arc</span>::new(p.sender.clone().unwrap()), idx, i.clone()),
                        ),
                        (
                            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))),
                            i,
                        ) =&gt; <span class="org-type">Ok</span>(<span class="org-type">ChannelOp</span>::<span class="org-type">Send</span>(
                            <span class="org-type">Arc</span>::new(p.sender.clone().unwrap()),
                            idx,
                            i.clone(),
                        )),
                        (p, _i) =&gt; <span class="org-type">Err</span>(<span class="org-constant">error</span>::<span class="org-type">Error</span>::expected(<span class="org-string">"handoff"</span>, p.clone())),
                    },
                    _ =&gt; <span class="org-type">Err</span>(<span class="org-constant">error</span>::<span class="org-type">Error</span>::short_list(2)),
                }
            }
        })
        .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Vec</span>&lt;<span class="org-type">ChannelOp</span>&lt;<span class="org-type">Item</span>&gt;&gt;, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt;()<span class="org-rust-question-mark">?</span>;

    <span class="org-keyword">let</span> (res, idx) = {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">selector</span> = <span class="org-constant">flume</span>::<span class="org-type">Selector</span>::new();

        <span class="org-comment-delimiter">// </span><span class="org-comment">loop over the operations and add them to the selector. Each one</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">returns the original index in the list, so we can use that to</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">fetch the original item from the list.</span>
        <span class="org-keyword">for</span> (idx, item) <span class="org-keyword">in</span> lr.iter().enumerate() {
            <span class="org-keyword">let</span> <span class="org-variable-name">idx_clone</span> = idx;
            <span class="org-keyword">match</span> <span class="org-rust-ampersand">&amp;</span>item {
                <span class="org-type">ChannelOp</span>::<span class="org-type">Receive</span>(r, _) =&gt; {
                    selector = selector.recv(<span class="org-rust-ampersand">&amp;</span>**r, <span class="org-keyword">move</span> |i| {
                        (i.map(<span class="org-type">Some</span>).map_err(<span class="org-constant">error</span>::<span class="org-type">Error</span>::from), idx_clone)
                    });
                }
                <span class="org-type">ChannelOp</span>::<span class="org-type">Send</span>(s, _, i) =&gt; {
                    selector = selector.send(<span class="org-rust-ampersand">&amp;</span>**s, i.clone(), <span class="org-keyword">move</span> |i| {
                        (i.map(|_| <span class="org-type">None</span>).map_err(<span class="org-constant">error</span>::<span class="org-type">Error</span>::from), idx)
                    });
                }
            }
        }

        selector.wait()
    };
    <span class="org-keyword">let</span> <span class="org-variable-name">selected</span> = original.get(idx).unwrap().clone();
    <span class="org-keyword">match</span> res {
        <span class="org-type">Ok</span>(<span class="org-type">Some</span>(i)) =&gt; {
            <span class="org-keyword">let</span> <span class="org-variable-name">l</span>: <span class="org-type">Item</span> = <span class="org-constant">coll</span>::<span class="org-type">List</span>::from_iter(<span class="org-preprocessor">vec!</span>[selected, i]).into();
            <span class="org-type">Ok</span>(l)
        }
        <span class="org-type">Ok</span>(<span class="org-type">None</span>) =&gt; <span class="org-type">Ok</span>(selected),
        <span class="org-type">Err</span>(e) =&gt; <span class="org-type">Err</span>(e),
    }
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">Item</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Handoff</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-constant">error</span>::<span class="org-type">Error</span>;

    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> i {
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-constant">pipe</span>::<span class="org-type">In</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Tunnel</span>(<span class="org-constant">pipe</span>::<span class="org-type">Tunnel</span>::<span class="org-type">Handoff</span>(p))) =&gt; <span class="org-type">Ok</span>(p),
            i =&gt; <span class="org-type">Err</span>(<span class="org-constant">error</span>::<span class="org-type">Error</span>::expected(<span class="org-string">"handoff"</span>, i)),
        }
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">drop the receiver side of the handoff and return the handoff item</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">sender</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span> = <span class="org-type">Handoff</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    h.close_take();
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">In</span>(<span class="org-constant">pipe</span>::<span class="org-type">In</span>::<span class="org-type">Handoff</span>(h))))
}

<span class="org-comment-delimiter">// </span><span class="org-comment">drop the sender side of the handoff and return the handoff item</span>
<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">receiver</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">h</span> = <span class="org-type">Handoff</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    h.close_put();
    <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>::<span class="org-type">Handoff</span>(h))))
}

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Timer</span>&lt;<span class="org-type">T</span>&gt; {
    <span class="org-variable-name">receiver</span>: <span class="org-type">Option</span>&lt;<span class="org-constant">flume</span>::<span class="org-type">Receiver</span>&lt;<span class="org-type">T</span>&gt;&gt;,
    <span class="org-variable-name">handle</span>: <span class="org-type">Option</span>&lt;<span class="org-type">JoinHandle</span>&lt;()&gt;&gt;,
    <span class="org-variable-name">duration</span>: <span class="org-type">Duration</span>,
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Cloning a timeout makes a new one, clears state</span>
<span class="org-keyword">impl</span> <span class="org-type">Clone</span> <span class="org-keyword">for</span> <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">clone</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Self</span> {
            <span class="org-variable-name">receiver</span>: <span class="org-type">None</span>,
            <span class="org-variable-name">handle</span>: <span class="org-type">None</span>,
            <span class="org-variable-name">duration</span>: <span class="org-keyword">self</span>.duration,
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">new</span>(<span class="org-variable-name">duration</span>: <span class="org-type">Duration</span>) -&gt; <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
        <span class="org-type">Timer</span> {
            <span class="org-variable-name">receiver</span>: <span class="org-type">None</span>,
            <span class="org-variable-name">handle</span>: <span class="org-type">None</span>,
            duration,
        }
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">start</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.handle.is_none() {
            <span class="org-keyword">let</span> (sender, receiver) = <span class="org-constant">flume</span>::bounded(1);
            <span class="org-keyword">let</span> <span class="org-variable-name">duration</span> = <span class="org-keyword">self</span>.duration;
            <span class="org-keyword">self</span>.receiver = <span class="org-type">Some</span>(receiver);
            <span class="org-keyword">self</span>.handle = <span class="org-type">Some</span>(<span class="org-constant">tokio</span>::spawn(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
                sleep(duration).<span class="org-keyword">await</span>;
                <span class="org-comment-delimiter">//</span><span class="org-comment">TODO handle error condition on send</span>
                <span class="org-keyword">let</span> <span class="org-variable-name">_</span> = sender.send(<span class="org-type">Item</span>::default());
            }));
        }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">take</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">mut</span> <span class="org-keyword">self</span>) -&gt; <span class="org-constant">types</span>::<span class="org-type">Future</span>&lt;<span class="org-type">Result</span>&lt;<span class="org-type">Option</span>&lt;<span class="org-type">Item</span>&gt;, <span class="org-constant">error</span>::<span class="org-type">Error</span>&gt;&gt; {
        <span class="org-keyword">self</span>.start();
        <span class="org-keyword">let</span> <span class="org-variable-name">receiver</span> = <span class="org-keyword">self</span>.receiver.clone().unwrap();
        <span class="org-type">Box</span>::pin(<span class="org-keyword">async</span> <span class="org-keyword">move</span> {
            <span class="org-comment-delimiter">//</span><span class="org-comment">println!("Receiving");</span>
            receiver.recv_async().<span class="org-keyword">await</span>.map(<span class="org-type">Some</span>).or_else(|_| <span class="org-type">Ok</span>(<span class="org-type">None</span>))
        })
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">t</span>: <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt;) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Out</span>(<span class="org-constant">pipe</span>::<span class="org-type">Out</span>::<span class="org-type">Timer</span>(t)))
    }
}

<span class="org-keyword">impl</span> <span class="org-keyword">crate</span>::<span class="org-constant">serialize</span>::<span class="org-type">Display</span> <span class="org-keyword">for</span> <span class="org-type">Timer</span>&lt;<span class="org-type">Item</span>&gt; {
    <span class="org-keyword">fn</span> <span class="org-function-name">representation</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Item</span> {
        <span class="org-constant">assoc</span>::<span class="org-type">Association</span>::from_iter([
            (<span class="org-string">"type"</span>.into(), <span class="org-string">"pipe"</span>.into()),
            (<span class="org-string">"timeout"</span>.into(), (<span class="org-keyword">self</span>.duration.as_millis() <span class="org-keyword">as</span> <span class="org-type">Int</span>).into()),
        ])
        .into()
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">timer</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">ms</span> = <span class="org-type">Int</span>::try_from(i)<span class="org-rust-question-mark">?</span>;
    <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: check for negative values</span>
    <span class="org-type">Ok</span>(<span class="org-type">Timer</span>::new(<span class="org-type">Duration</span>::from_millis(ms <span class="org-keyword">as</span> <span class="org-type">u64</span>)).into())
}
</pre>
</div></div>
</div>
</li>
<li><a id="org3e981c5"></a>Database<br />
<div class="outline-text-6" id="text-1-5-6-0-7">
<div class='tangle-wrapper' data-tangle='src/types/container/pipe/db.rs'><div class="org-src-container">
<pre class="src src-rust"><span class="org-keyword">use</span> <span class="org-keyword">crate</span>::axiom;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::list;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">container</span>::{<span class="org-keyword">self</span> <span class="org-keyword">as</span> coll, associative <span class="org-keyword">as</span> assoc, <span class="org-constant">error</span>::<span class="org-type">Error</span>};
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::<span class="org-constant">number</span>::<span class="org-type">Number</span>;
<span class="org-keyword">use</span> <span class="org-keyword">crate</span>::<span class="org-constant">types</span>::{<span class="org-keyword">self</span>, <span class="org-type">Item</span>};
<span class="org-keyword">use</span> <span class="org-constant">directories</span>::<span class="org-type">ProjectDirs</span>;

<span class="org-keyword">use</span> <span class="org-constant">rusqlite</span>::<span class="org-constant">types</span>::{<span class="org-type">ToSql</span>, <span class="org-type">ToSqlOutput</span>, <span class="org-type">Value</span>, <span class="org-type">ValueRef</span>};
<span class="org-keyword">use</span> <span class="org-constant">rusqlite</span>::{params, <span class="org-type">Connection</span>, <span class="org-type">Result</span>};
<span class="org-keyword">use</span> <span class="org-constant">uuid</span>;

<span class="org-preprocessor">#[derive(Debug)]</span>
<span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Db</span> {
    <span class="org-variable-name">conn</span>: <span class="org-type">Connection</span>,
}

<span class="org-keyword">impl</span> <span class="org-type">Db</span> {
    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>() -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>&gt; {
        <span class="org-keyword">let</span> <span class="org-variable-name">project_dirs</span> = <span class="org-type">ProjectDirs</span>::from(<span class="org-string">"org"</span>, <span class="org-string">"skyrod"</span>, <span class="org-string">"kcats"</span>).unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">project_dir</span> = project_dirs.data_dir();
        <span class="org-constant">std</span>::<span class="org-constant">fs</span>::create_dir_all(project_dir).unwrap();
        <span class="org-keyword">let</span> <span class="org-variable-name">db_file</span> = project_dir.join(<span class="org-string">"kcats-database.db"</span>);
        <span class="org-keyword">let</span> <span class="org-variable-name">conn</span> = <span class="org-type">Connection</span>::open(db_file)<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(<span class="org-type">Db</span> { conn })
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">query</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">query</span>: <span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-variable-name">params</span>: <span class="org-type">Vec</span>&lt;(<span class="org-type">String</span>, <span class="org-type">Item</span>)&gt;) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
        <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">stmt</span> = <span class="org-keyword">self</span>.conn.prepare(query)<span class="org-rust-question-mark">?</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Convert Vec&lt;Box&lt;dyn ToSql&gt;&gt; to Vec&lt;&amp;dyn ToSql&gt;</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">params_refs</span>: <span class="org-type">Vec</span>&lt;(<span class="org-rust-ampersand">&amp;</span><span class="org-type">str</span>, <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">dyn</span> <span class="org-type">ToSql</span>)&gt; = params
            .iter()
            .map(|(s, b)| (s.as_str(), b <span class="org-keyword">as</span> <span class="org-rust-ampersand">&amp;</span><span class="org-keyword">dyn</span> <span class="org-type">ToSql</span>))
            .collect();

        <span class="org-keyword">let</span> <span class="org-variable-name">rows</span> = stmt.query_and_then(params_refs.as_slice(), |row| {
            (0..row.as_ref().column_count())
                .map(|column_index| {
                    <span class="org-keyword">let</span> <span class="org-variable-name">column_name</span> = row.as_ref().column_name(column_index).unwrap().to_string();
                    <span class="org-keyword">let</span> <span class="org-variable-name">column_value</span>: <span class="org-type">ValueRef</span> = row.get_ref_unwrap(column_index);
                    <span class="org-type">Item</span>::try_from(column_value)
                        .map(|v| (<span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::from(column_name.as_str()), v))
                })
                .collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-constant">assoc</span>::<span class="org-type">Association</span>, _&gt;&gt;()
                .map(<span class="org-type">Item</span>::from)
        })<span class="org-rust-question-mark">?</span>;
        <span class="org-type">Ok</span>(rows.collect::&lt;<span class="org-type">Result</span>&lt;<span class="org-constant">coll</span>::<span class="org-type">List</span>, _&gt;&gt;()<span class="org-rust-question-mark">?</span>.into())
    }

    <span class="org-keyword">fn</span> <span class="org-function-name">insert_attribute</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">id</span>: <span class="org-constant">uuid</span>::<span class="org-type">Uuid</span>, <span class="org-variable-name">attribute</span>: <span class="org-type">Item</span>, <span class="org-variable-name">value</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">q</span> = <span class="org-string">"INSERT INTO EAV (entity, attribute, value) VALUES (?, ?, ?)"</span>;

        <span class="org-keyword">match</span> value {
            <span class="org-comment-delimiter">//</span><span class="org-comment">TODO: differentiate between strings and words as values</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">by prefixing with something like s: or w:</span>
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Associative</span>(a))) =&gt; {
                <span class="org-keyword">let</span> <span class="org-variable-name">id</span> = <span class="org-constant">uuid</span>::<span class="org-type">Uuid</span>::new_v4();
                <span class="org-keyword">self</span>.insert_item(a.into(), id)<span class="org-rust-question-mark">?</span>;
                <span class="org-keyword">self</span>.conn.execute(q, <span class="org-preprocessor">params!</span>[id, attribute, id])<span class="org-rust-question-mark">?</span>;
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Set</span>(s))) =&gt; {
                <span class="org-keyword">for</span> <span class="org-variable-name">v</span> <span class="org-keyword">in</span> s.iter() {
                    <span class="org-keyword">self</span>.insert_attribute(id, attribute.clone(), v.clone().into())<span class="org-rust-question-mark">?</span>;
                }
            }
            i =&gt; {
                <span class="org-keyword">self</span>.conn.execute(q, <span class="org-preprocessor">params!</span>[id, attribute, i])<span class="org-rust-question-mark">?</span>;
            } <span class="org-comment-delimiter">//</span><span class="org-comment">_ =&gt; todo!("Other item types as values in db"),</span>
        }
        <span class="org-type">Ok</span>(<span class="org-type">Item</span>::default())
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert_item</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>, <span class="org-variable-name">i</span>: <span class="org-type">Item</span>, <span class="org-variable-name">id</span>: <span class="org-constant">uuid</span>::<span class="org-type">Uuid</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
        <span class="org-keyword">let</span> <span class="org-variable-name">obj</span> = <span class="org-constant">assoc</span>::<span class="org-type">Associative</span>::try_from(i)<span class="org-rust-question-mark">?</span>;

        <span class="org-keyword">for</span> (k, v) <span class="org-keyword">in</span> obj.into_iter() {
            <span class="org-keyword">match</span> k {
                <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">Word</span>(w) =&gt; {
                    <span class="org-keyword">self</span>.insert_attribute(id, <span class="org-type">Item</span>::<span class="org-type">Word</span>(w), v)<span class="org-rust-question-mark">?</span>;
                }
                other =&gt; <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"word"</span>, other)),
            }
        }
        <span class="org-type">Ok</span>(<span class="org-type">Item</span>::default())
    }
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">query</span>(<span class="org-variable-name">q</span>: <span class="org-type">Item</span>, <span class="org-variable-name">params</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">query</span>: <span class="org-type">String</span> = q.try_into()<span class="org-rust-question-mark">?</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Needs to be association, and instead of a slice of ToSql,</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">we need &amp;[(&amp;str, &amp;dyn ToSql)] (slice of pairs of strings and ToSql)</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">params</span>: <span class="org-constant">assoc</span>::<span class="org-type">Associative</span> = params.try_into()<span class="org-rust-question-mark">?</span>;

    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">boxed_params</span>: <span class="org-type">Vec</span>&lt;(<span class="org-type">String</span>, <span class="org-type">Item</span>)&gt; = <span class="org-type">Vec</span>::new();
    <span class="org-keyword">for</span> (k, v) <span class="org-keyword">in</span> params.into_iter() {
        <span class="org-keyword">match</span> k {
            <span class="org-constant">assoc</span>::<span class="org-type">KeyItem</span>::<span class="org-type">String</span>(s) =&gt; boxed_params.push((s, v)),
            k =&gt; <span class="org-keyword">return</span> <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"string"</span>, k)),
        }
    }

    <span class="org-keyword">let</span> <span class="org-variable-name">db</span> = <span class="org-type">Db</span>::new()<span class="org-rust-question-mark">?</span>;
    db.query(<span class="org-rust-ampersand">&amp;</span>query, boxed_params)
}

<span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">insert_object</span>(<span class="org-variable-name">i</span>: <span class="org-type">Item</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">let</span> <span class="org-variable-name">db</span> = <span class="org-type">Db</span>::new()<span class="org-rust-question-mark">?</span>;
    <span class="org-keyword">let</span> <span class="org-variable-name">id</span> = <span class="org-constant">uuid</span>::<span class="org-type">Uuid</span>::new_v4();
    db.insert_item(i, id)
}

<span class="org-keyword">impl</span> <span class="org-type">TryFrom</span>&lt;<span class="org-type">ValueRef</span>&lt;'<span class="org-variable-name">_</span>&gt;&gt; <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">type</span> <span class="org-type">Error</span> = <span class="org-type">Error</span>;
    <span class="org-keyword">fn</span> <span class="org-function-name">try_from</span>(<span class="org-variable-name">value</span>: <span class="org-type">ValueRef</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Self</span>, <span class="org-type">Self</span>::<span class="org-type">Error</span>&gt; {
        <span class="org-keyword">match</span> value {
            <span class="org-type">ValueRef</span>::<span class="org-type">Integer</span>(i) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i))),
            <span class="org-type">ValueRef</span>::<span class="org-type">Real</span>(f) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Float</span>(f))),
            <span class="org-type">ValueRef</span>::<span class="org-type">Text</span>(t) =&gt; decode_string(<span class="org-type">String</span>::from_utf8_lossy(t).into_owned()),

            <span class="org-type">ValueRef</span>::<span class="org-type">Blob</span>(b) =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(
                b.to_vec(),
            )))),
            <span class="org-type">ValueRef</span>::<span class="org-type">Null</span> =&gt; <span class="org-type">Ok</span>(<span class="org-type">Item</span>::default()),
        }
    }
}
<span class="org-doc">/// Since sqlite doesn't have separate string/word/char types, we</span>
<span class="org-doc">/// store them all as String, and encode a prefix to note which type</span>
<span class="org-doc">/// it should be when decoded.</span>
<span class="org-keyword">fn</span> <span class="org-function-name">decode_string</span>(<span class="org-variable-name">s</span>: <span class="org-type">String</span>) -&gt; <span class="org-constant">axiom</span>::<span class="org-type">ItemResult</span> {
    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(w) = s.strip_prefix(<span class="org-string">"w|"</span>) {
        <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Word</span>(w.into()))
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(s) = s.strip_prefix(<span class="org-string">"s|"</span>) {
        <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(
            <span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s.to_string()),
        )))
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(c) = s.strip_prefix(<span class="org-string">"c|"</span>) {
        <span class="org-keyword">let</span> <span class="org-variable-name">char_seq</span> = c;
        <span class="org-keyword">if</span> char_seq.chars().count() == 1 {
            <span class="org-type">Ok</span>(<span class="org-type">Item</span>::<span class="org-type">Char</span>(char_seq.chars().next().unwrap()))
        } <span class="org-keyword">else</span> {
            <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"char"</span>, char_seq))
        }
    } <span class="org-keyword">else</span> {
        <span class="org-type">Err</span>(<span class="org-type">Error</span>::expected(<span class="org-string">"string"</span>, s))
    }
}

<span class="org-keyword">enum</span> <span class="org-type">EncodeAs</span> {
    <span class="org-type">String</span>(<span class="org-type">String</span>),
    <span class="org-type">Char</span>(<span class="org-constant">types</span>::<span class="org-type">Char</span>),
    <span class="org-type">Word</span>(<span class="org-constant">types</span>::<span class="org-type">Word</span>),
}

<span class="org-keyword">impl</span> <span class="org-type">EncodeAs</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">encode</span>(<span class="org-keyword">self</span>: <span class="org-type">EncodeAs</span>) -&gt; <span class="org-type">ToSqlOutput</span>&lt;'<span class="org-keyword">static</span>&gt; {
        <span class="org-type">ToSqlOutput</span>::<span class="org-type">Owned</span>(<span class="org-type">Value</span>::<span class="org-type">Text</span>(<span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">EncodeAs</span>::<span class="org-type">String</span>(s) =&gt; <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"s|</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, s),
            <span class="org-type">EncodeAs</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"w|</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, <span class="org-type">String</span>::from(w)),
            <span class="org-type">EncodeAs</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-rust-builtin-formatting-macro">format!</span>(<span class="org-string">"c|</span><span class="org-rust-string-interpolation">{}</span><span class="org-string">"</span>, <span class="org-type">String</span>::from(c)),
        }))
    }
}

<span class="org-keyword">impl</span> <span class="org-constant">rusqlite</span>::<span class="org-type">ToSql</span> <span class="org-keyword">for</span> <span class="org-type">Item</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">to_sql</span>(<span class="org-rust-ampersand">&amp;</span><span class="org-keyword">self</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">ToSqlOutput</span>&lt;'<span class="org-variable-name">_</span>&gt;&gt; {
        <span class="org-keyword">match</span> <span class="org-keyword">self</span> {
            <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Int</span>(i)) =&gt; i.to_sql(),
            <span class="org-type">Item</span>::<span class="org-type">Number</span>(<span class="org-type">Number</span>::<span class="org-type">Float</span>(f)) =&gt; f.to_sql(),
            <span class="org-type">Item</span>::<span class="org-type">Char</span>(c) =&gt; <span class="org-type">Ok</span>(<span class="org-type">EncodeAs</span>::<span class="org-type">Char</span>(*c).encode()),
            <span class="org-type">Item</span>::<span class="org-type">Word</span>(w) =&gt; <span class="org-type">Ok</span>(<span class="org-type">EncodeAs</span>::<span class="org-type">Word</span>(w.clone()).encode()),
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">EncodeAs</span>::<span class="org-type">String</span>(s.clone()).encode())
            }
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">String</span>(s))) =&gt; {
                <span class="org-type">Ok</span>(<span class="org-type">EncodeAs</span>::<span class="org-type">String</span>(s.clone()).encode())
            }
            <span class="org-type">Item</span>::<span class="org-type">Dispenser</span>(<span class="org-constant">coll</span>::<span class="org-type">Dispenser</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; b.to_sql(),
            <span class="org-type">Item</span>::<span class="org-type">Receptacle</span>(<span class="org-constant">coll</span>::<span class="org-type">Receptacle</span>::<span class="org-type">Sized</span>(<span class="org-constant">coll</span>::<span class="org-type">Sized</span>::<span class="org-type">Bytes</span>(b))) =&gt; b.to_sql(),

            _ =&gt; <span class="org-preprocessor">todo!</span>(<span class="org-string">"convert item variants to sql values"</span>),
        }
    }
}

<span class="org-keyword">impl</span> <span class="org-type">From</span>&lt;<span class="org-constant">rusqlite</span>::<span class="org-type">Error</span>&gt; <span class="org-keyword">for</span> <span class="org-type">Error</span> {
    <span class="org-keyword">fn</span> <span class="org-function-name">from</span>(<span class="org-variable-name">error</span>: <span class="org-constant">rusqlite</span>::<span class="org-type">Error</span>) -&gt; <span class="org-type">Self</span> {
        <span class="org-type">Error</span>::create(
            <span class="org-preprocessor">list!</span>(<span class="org-string">"io"</span>),
            error.to_string().as_str(),
            <span class="org-type">Option</span>::&lt;<span class="org-type">Item</span>&gt;::<span class="org-type">None</span>,
        )
    }
}
</pre>
</div></div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc5f82fd" class="outline-2">
<h2 id="orgc5f82fd"><span class="section-number-2">2.</span> Issues</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org02a8be5" class="outline-3">
<h3 id="org02a8be5"><span class="section-number-3">2.1.</span> <span class="todo INPROGRESS">INPROGRESS</span> Interactive mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tools">tools</span></span></h3>
<div class="outline-text-3" id="text-2-1">
<p>
run with <code>kcats -i</code> for interactive, where you get a repl-like
prompt. Each prompt accepts kcats items as input, and updates the
state accordingly. There are special commands to print the current
state, clear it, write to file, etc.
</p>
</div>
<div id="outline-container-org707b411" class="outline-4">
<h4 id="org707b411"><span class="section-number-4">2.1.1.</span> <span class="todo TODO">TODO</span> Only print the changed part of the stack</h4>
</div>
<div id="outline-container-org56b801f" class="outline-4">
<h4 id="org56b801f"><span class="section-number-4">2.1.2.</span> <span class="todo TODO">TODO</span> Emacs keybindings to send common stack ops</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>swap / swapdown</li>
<li>clear ([] evert drop)</li>
<li>clone</li>
<li>snapshot?</li>
<li>drop</li>
<li>sink / float</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org97ee71d" class="outline-3">
<h3 id="org97ee71d"><span class="section-number-3">2.2.</span> <span class="todo TODO">TODO</span> Source mapping&#xa0;&#xa0;&#xa0;<span class="tag"><span class="debugging">debugging</span>&#xa0;<span class="errorHandling">errorHandling</span></span></h3>
<div class="outline-text-3" id="text-2-2">
<p>
It would be nice if we could tell which file any given word was read
from. We could do this at read time, but i don't think our edn parser
remembers byte positions, so that might need modification.
</p>
</div>
</div>
<div id="outline-container-org7460ca7" class="outline-3">
<h3 id="org7460ca7"><span class="section-number-3">2.3.</span> <span class="todo TODO">TODO</span> Call stack in errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="debugging">debugging</span>&#xa0;<span class="errorHandling">errorHandling</span></span></h3>
<div class="outline-text-3" id="text-2-3">
<p>
It would be nice to see the call stack, if possible. For example if
foo calls bar, and bar fails, it'd be nice to know we're in the middle
of executing foo also. I have no idea how to implement this at the
moment though. Each time we look up a word during eval-step we could
add it to the call stack, and place a special word at the end of the
program to 'pop' from that stack. But I think if we ran <code>step</code> on 10,000
item list, the call stack would get at least that deep because step
puts itself back in the program.
</p>

<p>
So maybe a "call stack" isn't exactly what we want, I'm not even sure
it's possible to get what we want here.
</p>
</div>
</div>
<div id="outline-container-orgdcd2e86" class="outline-3">
<h3 id="orgdcd2e86"><span class="section-number-3">2.4.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement pipes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org3b1d125" class="outline-4">
<h4 id="org3b1d125"><span class="section-number-4">2.4.1.</span> <span class="done DONE">DONE</span> Write to a file</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar4"</span><span class="org-kcats-brackets">]]</span> pipe-in

<span class="org-kcats-brackets">[</span><span class="org-string">"hello world!"</span>
 <span class="org-string">"Nice to meet you!"</span>
 <span class="org-string">"My name is kcats"</span><span class="org-kcats-brackets">]</span>

<span class="org-kcats-brackets">[</span><span class="org-string">"\n"</span> <span class="org-function-name">join</span> bytes <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span>

<span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
[[asked [pipe]] [unwound [["Nice to meet you!" "My name is kcats"] ["\n" join bytes put] step]] [type error] [reason "type mismatch"]] [[type pipe] [file "/tmp/bar4"]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar101r7"</span><span class="org-kcats-brackets">]]</span> pipe-in

<span class="org-string">"hello world!"</span>

bytes <span class="org-function-name">put</span>

</pre>
</div>

<pre class="example">
[[type pipe] [file "/tmp/bar101r7"]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar101r7"</span><span class="org-kcats-brackets">]]</span> pipe-out

<span class="org-function-name">take</span>

string

</pre>
</div>

<pre class="example">
"hello world!" [[type pipe] [file "/tmp/bar101r7"]]
</pre>
</div>
</div>

<div id="outline-container-orgd462fa5" class="outline-4">
<h4 id="orgd462fa5"><span class="section-number-4">2.4.2.</span> <span class="done DONE">DONE</span> Read from a file</h4>
<div class="outline-text-4" id="text-2-4-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">""</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar2"</span><span class="org-kcats-brackets">]]</span> pipe-out

collect 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
stack: <span class="org-kcats-brackets">[[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/bar2"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type pipe<span class="org-kcats-brackets">]]</span> <span class="org-string">""</span><span class="org-kcats-brackets">]</span>
program: <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span>closed? not<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span>closed? not<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>collect spec<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
<span class="org-kcats-brackets">[[[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>reason <span class="org-string">"word is not defined"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>fail<span class="org-kcats-brackets">]]]</span>
 <span class="org-string">"Lookup attempted on non association value"</span>
 <span class="org-kcats-brackets">[</span>spec<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[</span>closed? not<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[</span>pipe program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]]]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org4d0ab39" class="outline-4">
<h4 id="org4d0ab39"><span class="section-number-4">2.4.3.</span> <span class="done DONE">DONE</span> Close a pipe</h4>
<div class="outline-text-4" id="text-2-4-3">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>file <span class="org-string">"/tmp/foopytoop"</span><span class="org-kcats-brackets">]]</span> pipe-in <span class="org-string">"foo"</span> bytes <span class="org-function-name">put</span> close <span class="org-string">"bar"</span> bytes <span class="org-function-name">put</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>file <span class="org-string">"/tmp/foopytoop"</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd208dd7" class="outline-4">
<h4 id="orgd208dd7"><span class="section-number-4">2.4.4.</span> <span class="done DONE">DONE</span> Serialize pipes with something sane</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
Maybe they can't be easily round-tripped, but at least we can print
something reasonable that will tell human eyes what it is.
something like[[type pipe-in] [file "/tmp/foo"]]
</p>
</div>
</div>
<div id="outline-container-orgcad62e5" class="outline-4">
<h4 id="orgcad62e5"><span class="section-number-4">2.4.5.</span> <span class="done DONE">DONE</span> Sockets</h4>
<div class="outline-text-4" id="text-2-4-5">
</div>
<div id="outline-container-orgc3576de" class="outline-5">
<h5 id="orgc3576de"><span class="section-number-5">2.4.5.1.</span> <span class="done DONE">DONE</span> Server Sockets</h5>
<div class="outline-text-5" id="text-2-4-5-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type ip-host<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>address <span class="org-string">"127.0.0.1"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>port 11211<span class="org-kcats-brackets">]]</span> pipe-out 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">socket: Int(11211) String(<span class="org-string">"127.0.0.1"</span>)
<span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>serversocket todo: fix serversocket local addr async issue<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"127.0.0.1"</span> 12345 serversocket 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">socket: Int(12345) String(<span class="org-string">"127.0.0.1"</span>)
<span class="org-kcats-brackets">[[</span>type pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>serversocket todo: fix serversocket local addr async issue<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type ip-host<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>address <span class="org-string">"127.0.0.1"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>port 11211<span class="org-kcats-brackets">]]</span> pipe-out <span class="org-comment-delimiter">;; </span><span class="org-comment">server socket</span>
<span class="org-function-name">take</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">accept connection by taking a socket out of the pipe</span>
<span class="org-string">"foo\n"</span> bytes <span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">write a message to the socket</span>
<span class="org-function-name">take</span> string <span class="org-comment-delimiter">;; </span><span class="org-comment">get a message from the socket</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">close the socket</span>
 <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">close the server socket</span>
<span class="org-preprocessor">dip</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>asked <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-string">"foo\n"</span> bytes <span class="org-function-name">put</span> <span class="org-function-name">take</span> string <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org18fd142" class="outline-5">
<h5 id="org18fd142"><span class="section-number-5">2.4.5.2.</span> <span class="done DONE">DONE</span> Sockets</h5>
</div>

<div id="outline-container-org96d46f8" class="outline-5">
<h5 id="org96d46f8"><span class="section-number-5">2.4.5.3.</span> <span class="done CANCELED">CANCELED</span> Assemble is broken when reading files</h5>
<div class="outline-text-5" id="text-2-4-5-3">
<ul class="org-ul">
<li>State "CANCELED"   from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-22 Sun 07:55]</span></span></li>
</ul>
<p>
I think it's because <code>closed?</code> is broken.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">""</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"bar"</span><span class="org-kcats-brackets">]]</span> pipe-out assemble
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">""</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>file <span class="org-string">"bar"</span><span class="org-kcats-brackets">]]</span> pipe-out <span class="org-function-name">take</span> <span class="org-builtin">drop</span> <span class="org-function-name">take</span> <span class="org-builtin">drop</span> closed? 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">checking file closed <span class="org-keyword">false</span>
Got 3 bytes
checking file closed <span class="org-keyword">false</span>
Got 0 bytes
Closing!
checking file closed <span class="org-keyword">false</span>
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>string <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-string">""</span>
</pre>
</div>

<p>
I see the problem. When we clone the pipe, we also clone the <code>closed</code>
boolean and we shouldn't be doing that. There should only be one copy
of that. The entire struct should be in an Arc&lt;Mutex&gt; and not just the
file field. And when we modify the boolean, we shouldn't 
</p>
</div>
</div>
</div>
<div id="outline-container-org3847a7a" class="outline-4">
<h4 id="org3847a7a"><span class="section-number-4">2.4.6.</span> <span class="done DONE">DONE</span> Convert In/Out traits to enums in pipes modules</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
Enums seem to work well elsewhere, and since pipes are also a closed
set, we can use them here too.
</p>

<p>
I don't think there will ever be user-created pipe types as it would
have to be done in rust and not in kcats.
</p>
</div>
</div>

<div id="outline-container-orgd018a4e" class="outline-4">
<h4 id="orgd018a4e"><span class="section-number-4">2.4.7.</span> <span class="done DONE">DONE</span> Composable transforms</h4>
<div class="outline-text-4" id="text-2-4-7">
<p>
There should be some way to compose transforms in a pipe. For example,
we can have a pipe that when you put bytes in it, it gets written to a
certain file on disk. But what we really want is that we put bytes
into it, and they get compressed with lz4 before being written to
disk.
</p>

<p>
I suppose pump could take an optional transducer-like thing, and <b>those</b>
could be composable. The transformations I'm thinking of generally
aren't going to be i/o, it's pure computation. Actually I guess any
pipe could take an optional transform. Clojure.core.async channels do this.
</p>

<p>
Maybe the first thing to do is implement transducers?
</p>
</div>
<div id="outline-container-org3045248" class="outline-5">
<h5 id="org3045248"><span class="section-number-5">2.4.7.1.</span> <span class="done DONE">DONE</span> Siphon from one pipe to another</h5>
<div class="outline-text-5" id="text-2-4-7-1">
<p>
A nice primitive would be a word that takes a program (the program
should expect an item on ToS and it should leave a transformed item)
and two pipes, and takes from one pipe, runs the program, and puts the
result back into the 2nd pipe. It should close the output pipe when
the input pipe closes. Should work with generators as input.
</p>

<p>
This should all work ok except for when programs somewhere in the
generator stack need access to items beneath the generator and we
don't know how to get to them.
</p>

<p>
The obvious solution to that is to include the needed values in the
program before giving it to the generator. Then the values will be in
a known place on the stack.
</p>

<p>
This little program will siphon directly from a generator to a
receptacle:
</p>
<div class="org-src-container">
<pre class="src src-kcats">integers 5 taker

<span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">receptacle</span>
<span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">placeholder that gets dropped (next iteration it will hold a</span>
   <span class="org-comment-delimiter">;; </span><span class="org-comment">copy of the last element which is only needed to check if the</span>
   <span class="org-comment-delimiter">;; </span><span class="org-comment">loop continues and can be dropped after)</span>
<span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">stop when generator returns nothing</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the last value</span>
 <span class="org-kcats-brackets">[</span>generate <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
 <span class="org-builtin">sink</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
<span class="org-preprocessor">until</span>
<span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">drop the now-empty dispenser</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>0 1 2 3 4 <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
4
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">integers 5 taker <span class="org-kcats-brackets">[]</span> siphon
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>actual <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>generator<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>siphon<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 5 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
-1
</pre>
</div>

<p>
And since pipes can have generator layers put on top of them, I think we're done. 
</p>
</div>
</div>
</div>
<div id="outline-container-orgd550a08" class="outline-4">
<h4 id="orgd550a08"><span class="section-number-4">2.4.8.</span> <span class="done CANCELED">CANCELED</span> Filled pipes</h4>
<div class="outline-text-4" id="text-2-4-8">
<p>
Mostly for testing purposes, takes a list and creates a buffered pipe
that offers list items until the list is exhausted and then returns pipe closed errors.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> filled <span class="org-function-name">take</span>
</pre>
</div>

<pre class="example">
1 [[type pipe] [filled todo: id-or-hash here]]
</pre>
</div>
</div>

<div id="outline-container-orgebb7b7d" class="outline-4">
<h4 id="orgebb7b7d"><span class="section-number-4">2.4.9.</span> <span class="todo INPROGRESS">INPROGRESS</span> Object pipes</h4>
<div class="outline-text-4" id="text-2-4-9">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-19 Thu 21:10]</span></span></li>
</ul>
<p>
These pipes should send serialized kcats objects and each put/take
should transfer 1 object. Maybe use protocol buffers or similar
</p>

<p>
This could be done using a network pipe, and an assemble function that
pulls byte chunks and builds objects when there are enough bytes for
one object, and puts them into a handoff pipe.
</p>

<p>
This should be possible to do entirely in kcats, similar to how the
interactive mode works. Send a length, then send that number of
bytes. Then the receiving transform can track how many bytes it has
left to receive and the partial encoded item it's got so far. It takes
the next chunk, knocks off that many bytes (if it's more than needed
for that item), and calls <code>read</code>. If it's still not enough for the full
item, append to the partial encoded item and decrease the 'bytes
needed' number.
</p>

<p>
This mechanism of using kcats serialization means we can't send
associations and sets over the wire as-is. We'd have to send them as a
list and convert them at the other end.
</p>

<p>
Let's see if we can make an object serializer that sends the length
first (separated by \n).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> emit bytes
<span class="org-kcats-brackets">[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
string <span class="org-string">"\n"</span> <span class="org-function-name">join</span> bytes
<span class="org-builtin">swap</span> <span class="org-function-name">join</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"NwpbMSAyIDNd"</span>
</pre>
</div>

<p>
That's pretty easy! The trickier part is a deserializer where we don't
know how many bytes we're going to get in a chunk.
</p>

<p>
First we might need a generator that divides into lines.
A generic splitter generator would do most of the work.
</p>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo\nbar\nbaz\n\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-string">"\n"</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">\f</span>
<span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
<span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span> ends? not<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> prime
 <span class="org-builtin">drop</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> ends?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> 
  <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-builtin">swap</span> - <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> slice<span class="org-kcats-brackets">]</span>
 when
 <span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span>
                                                                        ends? not<span class="org-kcats-brackets">]]</span>
                                                                   <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> prime <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> ends?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-builtin">swap</span> - <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> slice<span class="org-kcats-brackets">]</span>
                     when <span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">""</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo\nbar\nbaz\n\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
  <span class="org-string">"\n"</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">\f</span>
 split collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span>
                                                                        ends? not<span class="org-kcats-brackets">]]</span>
                                                                   <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> prime <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> ends?<span class="org-kcats-brackets">]</span>
                     <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dive</span> <span class="org-builtin">swap</span> - <span class="org-kcats-brackets">[</span>0<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> slice<span class="org-kcats-brackets">]</span>
                     when <span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">""</span>
</pre>
</div>

<p>
Ok this works but ultimately what we need is <code>resplit</code> which takes a
list of sized (all the same type presumably) and joins and splits
piece by piece.
</p>

<p>
We could just create something like <code>atomize</code> that takes a generator of
lists, and emits single items.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo\n"</span> <span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> generate <span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"foo\nbar\nbaz\n\n"</span> <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> generate <span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Ok the <code>atomize</code> is still handy but what I'm going to do is implement
splitter, that takes a string and emits fields. Then i can use that
generator <b>within</b> a re-split chunks generator, that keeps partial
content as state.
</p>

<p>
So here's that split gen:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;</span><span class="org-comment">"foo\nbar\nbaz\n\n" [take] "\n"</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">[1 2 3 2 5] [take] [2]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"foo\nbeep"</span> <span class="org-string">"bar\nba"</span> <span class="org-string">"z\n\n"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">"\n"</span>
<span class="org-kcats-brackets">[</span>empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">"foo\nbeep"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">while the state has no separator, pull chunks into it</span>
<span class="org-kcats-brackets">[</span>yes
 <span class="org-kcats-brackets">[[[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span> contains? not<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">state doesn't have sep?</span>
   <span class="org-kcats-brackets">[]]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">last item still something</span>
  <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> 
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the previous chunk</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">while</span>
 <span class="org-builtin">drop</span> 
 <span class="org-comment-delimiter">;; </span><span class="org-comment">now call the split generator internally</span>
 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">put</span> <span class="org-function-name">reverse</span>
 <span class="org-kcats-brackets">[</span>split <span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> 3 <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span> 
 <span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span> 

<span class="org-kcats-brackets">]</span>

collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"beepbar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>yes <span class="org-kcats-brackets">[[[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span> contains? not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]</span>
                              <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
                         <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
                          bail<span class="org-kcats-brackets">]</span>
                         <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">put</span> <span class="org-function-name">reverse</span> <span class="org-kcats-brackets">[</span>split <span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> 3
                                                                              <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span>
                         <span class="org-preprocessor">inject</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-string">"\n"</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
This is great and all, but maybe not quite what we need for object
serialization. Objects can have \n embedded within strings, so that
character doesn't necessarily mean "end of object". It's just used to
separate the byte count from the content.
</p>

<p>
I think we can implement this pretty directly and easily, especially
if we don't have to account for the case where the count is split
across chunks. We can have a generator with the following state: a
count of chars to read, current content.
</p>

<p>
Generate, read the count, then loop until there is more content left
in buffer than the count says to expect. Slice off [count] characters
from the buffer and return it if there's enough in the buffer,
otherwise generate and repeat. 
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;</span><span class="org-comment">["5\n[1 2]13\n[ooba " "bazquu]11\nboobooboobo"]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"3\n"</span> <span class="org-string">"fpp4\nfoo"</span><span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">[bytes] map</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">[string] each</span>
<span class="org-string">""</span> 0
<span class="org-kcats-brackets">[[[</span>complete? <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-function-name">count</span> &lt;=<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>readcount <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span>
              <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">"\n"</span> split generate
              <span class="org-kcats-brackets">[[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> 4 <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
              <span class="org-kcats-brackets">[</span>read <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> bail 0 or<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span>\newline contains? not<span class="org-kcats-brackets">]]</span>
     <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
    prime <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> 
   <span class="org-preprocessor">dip</span>
   <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> \newline contains?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>readcount<span class="org-kcats-brackets">]</span> when<span class="org-kcats-brackets">]</span>
  <span class="org-comment-delimiter">;</span><span class="org-comment">[dump [generate] dive [] [join] [drop] if readcount]</span>
  <span class="org-kcats-brackets">[</span>dump complete? not<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span>  <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> prime<span class="org-kcats-brackets">]</span>
 let dump cut 0 <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>read <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> each
collect
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb91313e" class="outline-4">
<h4 id="orgb91313e"><span class="section-number-4">2.4.10.</span> <span class="done DONE">DONE</span> Time pipe</h4>
<div class="outline-text-4" id="text-2-4-10">
<p>
Each take from the pipe return the current unix time in ms.  Should be
a "singleton" - probably using Box::leak, so that we can insert a copy
of this pipe whenever we want and it's always a reference to the same
object. Might be an Arc for compatibility even though we don't need to
ref count. (But I suspect we don't need the Arc).
</p>

<div class="org-src-container">
<pre class="src src-kcats">timestamps <span class="org-function-name">take</span>
</pre>
</div>

<pre class="example">
1687273991929 [[from systemtime] [values [[type integer] [units milliseconds]]] [type out]]
</pre>
</div>
</div>

<div id="outline-container-orgbf5d9cb" class="outline-4">
<h4 id="orgbf5d9cb"><span class="section-number-4">2.4.11.</span> <span class="done DONE">DONE</span> stdin/stdout pipes</h4>
<div class="outline-text-4" id="text-2-4-11">
<p>
Should also be singleton. Should it always be a tunnel or should we
allow separate access to in or out?
</p>

<div class="org-src-container">
<pre class="src src-kcats">standard <span class="org-string">"foo"</span> bytes <span class="org-function-name">put</span>
</pre>
</div>

<pre class="example">
foo[[type tunnel] [peer standard]]
</pre>


<p>
Stdin is not tested, since currently the interpreter reads the program
from stdin. May need to change that (read the program from filesystem
and let the program itself access stdin).
</p>
</div>
</div>
<div id="outline-container-org064164d" class="outline-4">
<h4 id="org064164d"><span class="section-number-4">2.4.12.</span> <span class="done CANCELED">CANCELED</span> Pipe take outcome</h4>
<div class="outline-text-4" id="text-2-4-12">
<ul class="org-ul">
<li><p>
State "CANCELED"   from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-09-22 Fri 09:14] </span></span> <br />
I don't think there's any glaring inconsistency here - indefinite (or
i guess I might call them 'unsized') dispensers will dispense <code>nothing</code>
when there's nothing left. That means that when you are using one of
these, <code>nothing</code> is not a valid value you can use in the sequence.
</p>

<p>
That means, for example, that if you wanted to print whether integers
are odd or not, you can't quite do that. You'd need to use pairs (the
original value and true/[] for whether it's odd).
</p>

<p>
Perhaps later we can think about signaling end-of-stream out of
band. One way to do that is to use an unhandled error value that
unwinds the stack, and you have to recover to catch it. But that
introduces a lot of complexity and I think it may be easier to just
work around the fact that you can't use <code>nothing</code> in the data. It's
possible that maybe the complexity in the out-of-band impl could be
abstracted away, so it's worth revisiting later.
</p></li>
</ul>
<p>
There is some inconsistency with what happens when there's nothing
left - empty lists just return nothing on take, but closed pipes
return an error. May need to resolve this inconsistency.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">List</th>
<th scope="col" class="org-left">Handoff</th>
<th scope="col" class="org-left">Socket</th>
<th scope="col" class="org-left">StaticFile</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">take Items</td>
<td class="org-left">Item</td>
<td class="org-left">Item</td>
<td class="org-left">Bytes</td>
<td class="org-left">Bytes</td>
</tr>

<tr>
<td class="org-left">take Past EOF</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
<td class="org-left">Nothing</td>
</tr>

<tr>
<td class="org-left">step Past EOF</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
<td class="org-left">Exit</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orga35527c" class="outline-3">
<h3 id="orga35527c"><span class="section-number-3">2.5.</span> <span class="todo INPROGRESS">INPROGRESS</span> Use a single word for all derivation/conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h3>
<div class="outline-text-3" id="text-2-5">
<p>
Right now there's different words for converting bytes to string
(string) or string to bytes (bytes). Proposing a more composable
mechanism here, where there's a single action word that derives one
data structure from another.
</p>

<p>
Here we use the association shorthand for <code>[[type bytes]]</code>
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> <span class="org-kcats-brackets">[</span>bytes<span class="org-kcats-brackets">]</span> derive
</pre>
</div>

<pre class="example">
No spec for derive!

[[] [bytes] "foo"]
</pre>


<p>
Here's a typical invocation
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> <span class="org-kcats-brackets">[[</span>type bytes<span class="org-kcats-brackets">]]</span> derive
</pre>
</div>

<pre class="example">
No spec for derive!

[[] [[type bytes]] "foo"]
</pre>


<p>
Here's a derivation with two steps: convert string to bytes, then use
the bytes as entropy to generate an AES encryption key.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span>
<span class="org-kcats-brackets">[[</span>bytes<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>type aes-key<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>length 128<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>derive<span class="org-kcats-brackets">]</span>
<span class="org-function-name">step</span>
</pre>
</div>

<pre class="example">
No spec for derive!
No spec for derive!

[[] [[type aes-key] [length 128]] [] [bytes] "foo"]
</pre>


<p>
This seems like a pretty straightforward syntax and should eliminate
an explosion of new words that just convert one type to another.
</p>

<p>
The difficulty is how to implement it. A naive way would just make
<code>derive</code> a multimethod and add lots of methods. The problem is the
<code>decide</code> based multimethods aren't really intended to have lots of
methods because it's inefficient - all the conditions are checked
until one is true. In this case, we can just do a straight lookup by
destination type (if we have different methods depending on input
type, THEN we can use <code>decide</code> internally).
</p>

<p>
But maybe even that isn't ideal - we could also lookup by <code>[sourcetype
destinationtype]</code> pairs. However we don't have explicit source
types. We just have a list that may or may not also act as a set or
association.
</p>

<p>
It should be possible to implement the <code>destinationtype</code> based lookup
pretty easily. Make <code>derive</code> a lexicon entry but insert it earlier so
that it will have an actual association object. It'll be refcounted or
possibly even static (if we don't care about leaking these - but that
would fail if we run through many envs in the same process).
</p>

<p>
Actually we can do this in kcats itself but it requires executing
arbitrary code. The lexicon doesn't really do that - it's just a data
file. 
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>derive<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>bytes string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]]</span> association <span class="org-function-name">wrap</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> type <span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">1 [string] =&gt; [number string]</span>
 lookup <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span>definition<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span>
<span class="org-function-name">wrap</span>
inscribe

<span class="org-string">"foo"</span> bytes <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> 
derive 
</pre>
</div>

<pre class="example">
No spec for derive!

stack: [[[reason "type mismatch"] [asked [[[list?] [string?]] [execute] any?]] [type error]] [string]]
program: [lookup execute]
</pre>



<p>
Ok here's the basic impl. Afterward, should change <code>string</code> to
<code>++string</code> to make them non-public, should use <code>[string] derive</code>
instead. The issue here is how do we add new conversions? We could
make the conversions a separate word, like <code>derivations</code>, but that
sticks out as different - it's a data structure and not an action
word.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">add some conversions</span>
derivations <span class="org-kcats-brackets">[[</span>bytes string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]</span> assign
<span class="org-comment-delimiter">;; </span><span class="org-comment">the list of conversions</span>
<span class="org-kcats-brackets">[[[</span>bytes string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]]]</span> association

<span class="org-string">"foo"</span> bytes <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span>


<span class="org-comment-delimiter">;; </span><span class="org-comment">determine the current type and look up the conversion</span>
<span class="org-kcats-brackets">[[</span>type<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> 
<span class="org-builtin">swap</span> lookup <span class="org-preprocessor">execute</span>
</pre>
</div>

<pre class="example">

["foo"]
</pre>

<div class="org-src-container">
<pre class="src src-kcats">dictionary <span class="org-kcats-brackets">[</span>assign spec<span class="org-kcats-brackets">]</span> lookup 
</pre>
</div>

<pre class="example">

[[[type error] [reason "word is not defined"] [asked [fail]]] "Lookup attempted on non association value" [spec] assign]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>a b<span class="org-kcats-brackets">]</span> c<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>a b<span class="org-kcats-brackets">]]</span> lookup
</pre>
</div>

<pre class="example">

[c]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>string <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> lookup
</pre>
</div>
<pre class="example">

[[foo]]
</pre>


<p>
Experiment with whether we can easily determine the 'from' type so
that we can dispatch on both 'from' and 'to'.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> type
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">
<span class="org-kcats-brackets">[[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 1 = <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[[[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>type<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">branch</span> <span class="org-kcats-brackets">[[[[</span><span class="org-function-name">count</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>type<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> +<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[[[[</span>association<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-function-name">unwrap</span> or <span class="org-kcats-brackets">[[[[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>or<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> or<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">recur</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">execute</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>list<span class="org-kcats-brackets">]]]</span> +<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>default<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span>
</pre>
</div>

<pre class="example">

[default]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>bar 12<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span>
<span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>5<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">]</span>
<span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
<span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">sink drop drop</span>
</pre>
</div>

<pre class="example">

[[[bar 12]] [[[foo] lookup] [[bar] lookup] [5] [6]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>bar 12<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[[[</span>foo<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> any?
</pre>
</div>

<pre class="example">

[12 [[bar 12]]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 2 or
</pre>
</div>

<pre class="example">

[1]
</pre>


<p>
Now that we have a fairly reliable <code>type</code> implementation, we can
dispatch on both <code>to</code> and <code>from</code> types for <code>derive</code>.
</p>

<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org16d048d" class="outline-3">
<h3 id="org16d048d"><span class="section-number-3">2.6.</span> <span class="todo TODO">TODO</span> Error should have actual struct fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></h3>
<div class="outline-text-3" id="text-2-6">
<p>
It's still implemented as generic Hashmap data field. 
</p>
</div>
</div>

<div id="outline-container-org7df8595" class="outline-3">
<h3 id="org7df8595"><span class="section-number-3">2.7.</span> <span class="todo INPROGRESS">INPROGRESS</span> Script</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-23 Fri 15:12]</span></span></li>
</ul>
</div>
<div id="outline-container-org0e30691" class="outline-4">
<h4 id="org0e30691"><span class="section-number-4">2.7.1.</span> <span class="done DONE">DONE</span> Cryptographic primitives</h4>
<div class="outline-text-4" id="text-2-7-1">
</div>
<div id="outline-container-orgb2a0623" class="outline-5">
<h5 id="orgb2a0623"><span class="section-number-5">2.7.1.1.</span> <span class="done DONE">DONE</span> SHA256</h5>
<div class="outline-text-5" id="text-2-7-1-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes hash <span class="org-string">"fop"</span> bytes hash =
</pre>
</div>

<pre class="example">
[]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> bytes key<span class="org-kcats-brackets">]</span> 2 <span class="org-preprocessor">times</span> =
</pre>
</div>

<pre class="example">
true
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key
</pre>
</div>

<pre class="example">
[[public #b64 "NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="] [type elliptic-curve-key] [secret #b64 "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="]]
</pre>
</div>
</div>

<div id="outline-container-org35909d3" class="outline-5">
<h5 id="org35909d3"><span class="section-number-5">2.7.1.2.</span> <span class="done DONE">DONE</span> Signing</h5>
<div class="outline-text-5" id="text-2-7-1-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dawn"</span> bytes <span class="org-kcats-brackets">[</span>sign<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> verify
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-keyword">true</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dawn"</span> bytes <span class="org-kcats-brackets">[</span>sign<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">now change the message</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-string">"we attack at dawn"</span> bytes<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
verify
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span>
</pre>
</div>

<p>
We need to be able to construct scripts and their hash. What is the
public key format? We can sort the assoc so that the serialization is
always the same.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-comment-delimiter">;; </span><span class="org-comment">new key</span>
<span class="org-kcats-brackets">[</span>secret<span class="org-kcats-brackets">]</span> unassign <span class="org-comment-delimiter">;; </span><span class="org-comment">discard the secret portion</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> sort <span class="org-comment-delimiter">;; </span><span class="org-comment">make sure the assoc is always serialized the same way</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">sink</span> verify<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> 
emit<span class="org-comment-delimiter">; </span><span class="org-comment">bytes hash </span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"[[[public #b64 \"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA=\"] [type elliptic-curve-key]] sink verify]"</span>
</pre>
</div>

<p>
So this is the script data. Then the high level script (that's always
the same) is: we've got inputs, a script, and a script hash. If the
hash of the script is equal the given hash, execute the program on the
given input.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"[[[public #b64 \"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA=\"] [type elliptic-curve-key]] sink verify]"</span> bytes <span class="org-kcats-brackets">[</span>hash<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> #b64 <span class="org-string">"W1tbcHVibGljICNiNjQgIk5OSmxlZHUwVm1rK1ZBWnl6NUl2VXQzZzFsTXVOYjhHdmdFNmZGTXZJT0E9Il0gW3R5cGUgZWxsaXB0aWMtY3VydmUta2V5XV0gc2luayB2ZXJpZnld"</span>
</pre>
</div>

<p>
Now let's make a signature with that same key
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dawn"</span> bytes <span class="org-kcats-brackets">[</span>sign<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
#b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span> <span class="org-kcats-brackets">[[</span>type elliptic-curve-key<span class="org-kcats-brackets">]</span>
                                 <span class="org-kcats-brackets">[</span>secret #b64 <span class="org-string">"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>public #b64 <span class="org-string">"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA="</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
Now use that data and execute the script on it
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
 #b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span><span class="org-kcats-brackets">]</span> emit
read <span class="org-function-name">first</span> 
<span class="org-string">"[[[public #b64 \"NNJledu0Vmk+VAZyz5IvUt3g1lMuNb8GvgE6fFMvIOA=\"] [type elliptic-curve-key]] sink verify]"</span> read <span class="org-function-name">first</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> string
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"we attack at dawn"</span>
</pre>
</div>

<p>
Now let's make a word 'authenticate', that takes a script hash, a
script, and its args, and returns true if it's the right script and it
validates. Important: check the hash before attempting to execute or
even read the script. That ensures that it's what the sender intended
(doesn't protect against malicious real sender, just malicious impostors).
</p>

<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script hash</span>
#b64 <span class="org-string">"W1tbcHVibGljICNiNjQgIk5OSmxlZHUwVm1rK1ZBWnl6NUl2VXQzZzFsTXVOYjhHdmdFNmZGTXZJT0E9Il0gW3R5cGUgZWxsaXB0aWMtY3VydmUta2V5XV0gc2luayB2ZXJpZnld"</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">"foo"</span>
<span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
 #b64 <span class="org-string">"d2UgYXR1YWNrIGF0IGRhd24="</span>
 <span class="org-kcats-brackets">]</span> emit bytes <span class="org-comment-delimiter">;; </span><span class="org-comment">the proof (key) as serialized bytes list - the sig and message</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">first check hash</span>
<span class="org-kcats-brackets">[[[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>string read <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> both functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover
 <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> bail <span class="org-comment-delimiter">;; </span><span class="org-comment">gives the message and who it's from</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span>
</pre>
</div>

<p>
Try where the actual script is not what the hash requires, should return <code>nothing</code>
</p>
<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script hash</span>
<span class="org-string">"[true]"</span> emit bytes
<span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"sAVOx61lJzZAcVMPNFBeDGjzaSej++hqjLctgr1stVcAMk+L1mSZC7nxbtj5+8rYj99zXKLZX6gQzO8bBvvlAA=="</span>
 #b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span>
 <span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">data as list</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">first check hash</span>
<span class="org-kcats-brackets">[[[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> string read <span class="org-function-name">first</span> functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span>
</pre>
</div>

<p>
Try where the signature is invalid by substituting a sig from a different message - same key.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes key <span class="org-string">"we attack at dusk"</span> bytes sign
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"XtOnDCT9+iiHV0BElSAckjo76e2yY3swEOOWo0FfstHgukymw9XXHm7+jLtEBsBjJzo5kyo6058WJ/XPpAe1Aw=="</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">script hash</span>
#b64 <span class="org-string">"W1tbcHVibGljICNiNjQgIk5OSmxlZHUwVm1rK1ZBWnl6NUl2VXQzZzFsTXVOYjhHdmdFNmZGTXZJT0E9Il0gW3R5cGUgZWxsaXB0aWMtY3VydmUta2V5XV0gc2luayB2ZXJpZnld"</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">lock</span>
<span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"XtOnDCT9+iiHV0BElSAckjo76e2yY3swEOOWo0FfstHgukymw9XXHm7+jLtEBsBjJzo5kyo6058WJ/XPpAe1Aw=="</span>
 #b64 <span class="org-string">"d2UgYXR0YWNrIGF0IGRhd24="</span>
 <span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">data as list</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">first check hash</span>
<span class="org-kcats-brackets">[[[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> string read <span class="org-function-name">first</span> functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"SsjPm5GDruW/Ixa/pY97y+Y2JI1+siSETU6yJwlSUvM="</span>
</pre>
</div>

<p>
try a dummy script that really does always validate
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> encode hash
<span class="org-string">"[true]"</span> encode <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[</span>dump <span class="org-kcats-brackets">[</span>hash =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> string read <span class="org-function-name">first</span> functional <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> lingo <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> recover
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[]</span> #b64 <span class="org-string">"W3RydWVd"</span> #b64 <span class="org-string">"M+LwVX3X2/aNUvQNUQxkH9+m5dpgq8cN+sB9K2tsvM8="</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> #b64 <span class="org-string">"M+LwVX3X2/aNUvQNUQxkH9+m5dpgq8cN+sB9K2tsvM8="</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeab5963" class="outline-5">
<h5 id="orgeab5963"><span class="section-number-5">2.7.1.3.</span> <span class="done DONE">DONE</span> Make verify return the message</h5>
<div class="outline-text-5" id="text-2-7-1-3">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-09-28 Thu 10:43]</span></span></li>
</ul>
<p>
one thing I hadn't considered before. We receive this package of
"proof" - proof of what? That this message is from the party
represented by the given script hash. What message?  It's contained in
the proof. The important thing is that if the proof is good <b>we return
the message</b>. I think a good contract is that we return the message (as
bytes) if it's valid proof, otherwise <code>nothing</code>.  If we only return <code>true</code>
on valid proof then we have to embark on digging out the message from
potentially nested proofs. If we just return the message from each
layer (on success) then we don't have to have this separate logic.
</p>

<p>
I think it's best to just have the contract of the word <code>verify</code> do this
for us - there's no reason to just return the truthy value <code>true</code> when
the message is a perfectly good truthy value. I suppose signing an
empty byte array could cause confusion (if that were considered
"nothing" which I suppose it should, but currently isn't). But I can't
think of any valid reason to sign 'nothing'.
</p>
</div>
</div>
<div id="outline-container-orgb883164" class="outline-5">
<h5 id="orgb883164"><span class="section-number-5">2.7.1.4.</span> <span class="todo TODO">TODO</span> AES Encryption</h5>
</div>
<div id="outline-container-orgc1d2c66" class="outline-5">
<h5 id="orgc1d2c66"><span class="section-number-5">2.7.1.5.</span> <span class="todo TODO">TODO</span> Random</h5>
</div>
</div>

<div id="outline-container-orgcd3bb03" class="outline-4">
<h4 id="orgcd3bb03"><span class="section-number-4">2.7.2.</span> <span class="done DONE">DONE</span> Pure functional env</h4>
<div class="outline-text-4" id="text-2-7-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>pipe-in pipe-out channel timeout handoff file-in file-out timestamps standard serversocket animate future spit tunnel <span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span> unassign<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> lingo
</pre>
</div>

<pre class="example">
1 2
</pre>
</div>
</div>
<div id="outline-container-orgd19224e" class="outline-4">
<h4 id="orgd19224e"><span class="section-number-4">2.7.3.</span> <span class="todo TODO">TODO</span> Infinite loop protection</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
We need to prevent an attacker presenting <code>true [clone] loop</code> as their
identity proof, which would never halt. It may be easiest to just
remove all the looping words from the dictionary, but that seems
overly restrictive, when the point is just to limit the resources an
attacker can consume, and we already have a direct solution for that:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span><span class="org-kcats-brackets">]]]</span> environment
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgccb6bbb" class="outline-3">
<h3 id="orgccb6bbb"><span class="section-number-3">2.8.</span> <span class="todo TODO">TODO</span> retry should have opposite argument order&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span>&#xa0;<span class="consistency">consistency</span></span></h3>
<div class="outline-text-3" id="text-2-8">
<p>
Currently it expects an error on ToS and then a program beneath. But
it seems like we'd nearly always have to <code>dip</code> the program beneath the
error. I think it would be better if <code>retry</code> expected the program to fix
the issue on top, and the error beneath.
</p>
</div>
</div>
<div id="outline-container-orgc1af7ca" class="outline-3">
<h3 id="orgc1af7ca"><span class="section-number-3">2.9.</span> <span class="todo INPROGRESS">INPROGRESS</span> Support Kademlia DHT</h3>
<div class="outline-text-3" id="text-2-9">
</div>
<div id="outline-container-org19e8b28" class="outline-4">
<h4 id="org19e8b28"><span class="section-number-4">2.9.1.</span> <span class="done DONE">DONE</span> XOR</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
We have a node id (maybe just the i2p destination address?) and we
want to calculate the distance to another node as the XOR
</p>
</div>
</div>
<div id="outline-container-orga9a7175" class="outline-4">
<h4 id="orga9a7175"><span class="section-number-4">2.9.2.</span> <span class="todo INPROGRESS">INPROGRESS</span> Simple API server</h4>
<div class="outline-text-4" id="text-2-9-2">
<p>
Construct a socket listener, and serve something from a trivial local
database. Disable exploitable words. Catch errors and return to the user.
</p>

<div class='tangle-wrapper' data-tangle='examples/api.kcats'><div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">create an API service</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Takes from the stack:</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* a Database (can be a regular data structure for read-only apis),</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">or a pipe to an actual (sql or other) database that accepts queries for</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">read/write ops</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* a program that modifies the dictionary that clients can</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">access. It should add words to make interaction easier (for</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">example, you might provide a word 'customers' that gets the customers</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">db table). It should also remove words that the clients should not be able</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">to use - for example, they shouldn't be able to create file or network pipes. </span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* a server socket pipe to serve from</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">The client sends a program to run in a fresh environment where he</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">can expect to find:</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">* The database (either a pipe or data structure)</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">His program runs and then the resulting stack is returned to him.</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">socket listener</span>
<span class="org-kcats-brackets">[[</span>type ip-host<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>port 12121<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>address <span class="org-string">"127.0.0.1"</span><span class="org-kcats-brackets">]]</span> pipe-out

<span class="org-comment-delimiter">;; </span><span class="org-comment">book db</span>
<span class="org-string">"examples/books.kcats"</span> file-out slurp read

<span class="org-comment-delimiter">;</span><span class="org-comment">functional ;; dictionary modifications, removes any io access </span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">API Server code begins here</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">dictionary swap execute ;; -&gt; new-dict db sock</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">start building the environment</span>
<span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the request as bytes</span>
           <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">we want the pipe on top so we can dip the user's program under it -&gt; pipe req db</span>
           <span class="org-kcats-brackets">[</span>string <span class="org-comment-delimiter">;; </span><span class="org-comment">translate to a string -&gt; req-str db</span>
            read <span class="org-function-name">first</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the request program into a data structure -&gt; prog db</span>
            <span class="org-builtin">clone</span> emit print <span class="org-comment-delimiter">;; </span><span class="org-comment">log the request</span>
            functional <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> recover<span class="org-kcats-brackets">]</span> lingo <span class="org-comment-delimiter">;; </span><span class="org-comment">the program -&gt; items*</span>
            <span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">under the pipe so the user's code has no access</span>
           <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; response pipe</span>
           emit <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; response-str pipe</span>
           bytes <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; response-bytes pipe</span>
           <span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the response into the pipe</span>
           <span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">close the connection</span>
          <span class="org-kcats-brackets">]]]</span> environment <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; env new-dict db sock </span>
<span class="org-comment-delimiter">;</span><span class="org-comment">[dictionary] float ;; -&gt; new-dict [dictionary] env db sock</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">assign  ;; -&gt; env db sock</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">now just need to assign the stack, which is [pipe db] </span>
<span class="org-builtin">float</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; sock env db</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">loop to accept connections and start new env with the db and a pipe</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">to take requests and reply</span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">float</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; pipe db env</span>
  pair <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; stack env</span>
  <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; stack ks env</span>
  assign <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; env</span>
  environment
  animate <span class="org-comment-delimiter">;; </span><span class="org-comment">let it fly  </span>
 <span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">shielded so as not to consume the db each time</span>
 <span class="org-builtin">drop</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">drop whatever the result is of this iteration, we don't need it</span>
<span class="org-kcats-brackets">]</span>

<span class="org-function-name">step</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">accepts incoming connections until killed</span>
</pre>
</div></div>

<p>
This works ok for a read-only database, but for the purposes of a DHT
we can't do it this way - we'd have to expose the database and there's
no way to prevent the api user from making arbitrary (and malicious)
changes.
</p>
</div>
</div>
<div id="outline-container-orgad5790c" class="outline-4">
<h4 id="orgad5790c"><span class="section-number-4">2.9.3.</span> <span class="todo INPROGRESS">INPROGRESS</span> Simple API client</h4>
<div class="outline-text-4" id="text-2-9-3">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"localhost"</span> 12121 socket
<span class="org-kcats-brackets">[[[</span>title<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span> 10 &lt;<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span><span class="org-kcats-brackets">]</span>
encode <span class="org-function-name">put</span>
<span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> joiner generate string read<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"George"</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Orwell"</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>title <span class="org-string">"1984"</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>year 1949<span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>government dystopia surveillance totalitarianism freedom<span class="org-kcats-brackets">]]]</span>
   <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Charlotte"</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Bronte"</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>title <span class="org-string">"Jane Eyre"</span><span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>year 1847<span class="org-kcats-brackets">]</span>
    <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>love morality society class womanhood independence<span class="org-kcats-brackets">]]]]]]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org869f6ea" class="outline-4">
<h4 id="org869f6ea"><span class="section-number-4">2.9.4.</span> <span class="todo TODO">TODO</span> Kademlia functions</h4>
</div>
</div>
<div id="outline-container-org560ba4b" class="outline-3">
<h3 id="org560ba4b"><span class="section-number-3">2.10.</span> <span class="todo TODO">TODO</span> read and emit don't have quite the same semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></h3>
<div class="outline-text-3" id="text-2-10">
<p>
read will read all the bytes and return however many objects were read.
emit will take an object and return its serialization.
</p>

<p>
There should be some way of round tripping here, maybe a word <code>read1</code> or
something that just reads one object. 
</p>
</div>
</div>
<div id="outline-container-orgc93ff7d" class="outline-3">
<h3 id="orgc93ff7d"><span class="section-number-3">2.11.</span> <span class="todo INPROGRESS">INPROGRESS</span> Inconsistent stack handling when encountering error&#xa0;&#xa0;&#xa0;<span class="tag"><span class="consistency">consistency</span></span></h3>
<div class="outline-text-3" id="text-2-11">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-30 Sat 14:17]</span></span></li>
</ul>
<p>
Some words pop the arguments off the stack, then if an error is
encountered, throws the error without the args on the stack. Others
leave the args intact. This needs to be consistent.
</p>

<p>
I would lean towards leaving the args intact so that <code>retry</code> is easily applied.
</p>
</div>
<div id="outline-container-orge63546c" class="outline-4">
<h4 id="orge63546c"><span class="section-number-4">2.11.1.</span> <span class="todo TODO">TODO</span> 'read' on invalid edn consumes the string argument</h4>
<div class="outline-text-4" id="text-2-11-1">
<p>
It should attempt to parse before popping the item off the stack.
</p>
</div>
</div>
<div id="outline-container-orga24d480" class="outline-4">
<h4 id="orga24d480"><span class="section-number-4">2.11.2.</span> <span class="todo TODO">TODO</span> Division by zero consumes stack items</h4>
<div class="outline-text-4" id="text-2-11-2">
<p>
<code>5 0 /</code> shouldn't consume the <code>5</code> and <code>0</code> - compare to <code>1 "2" +</code> behavior
(which leaves items on stack).
</p>
</div>
</div>
</div>
<div id="outline-container-org755be89" class="outline-3">
<h3 id="org755be89"><span class="section-number-3">2.12.</span> <span class="done DONE">DONE</span> Inconsistent expression handling when encountering error</h3>
<div class="outline-text-3" id="text-2-12">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-10-15 Sun 15:24]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-15 Sun 15:20]</span></span></li>
</ul>
<p>
Some errors lose the word on which they occurred. They should be in
the expression still.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[]]</span> <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> get
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>pair<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>actual <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>get<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
The word <code>get</code> should still be in the <code>unwound</code> field.
</p>

<p>
I think this only works correctly when the invalid argument is caught
by spec checking and not in the actual axiom function.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-string">""</span> +
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>actual <span class="org-string">""</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
<span class="org-string">""</span> 1
</pre>
</div>

<p>
Here's an example where the spec is too permissive and the actual
function throws the error.
</p>
<div class="org-src-container">
<pre class="src src-kcats">1 set
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>sized<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>set<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>actual 1<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
The question then is how to fix this? Hopefully this can be fixed
inside <code>eval_step</code>. After the function completes, we can check if there
was an error on top (if there wasn't before), and if so, we can replace the 
</p>
</div>
</div>
<div id="outline-container-org6e20a6d" class="outline-3">
<h3 id="org6e20a6d"><span class="section-number-3">2.13.</span> <span class="todo TODO">TODO</span> Performance optimizations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optimization">optimization</span></span></h3>
<div class="outline-text-3" id="text-2-13">
</div>
<div id="outline-container-orgaf63b8d" class="outline-4">
<h4 id="orgaf63b8d"><span class="section-number-4">2.13.1.</span> <span class="todo TODO">TODO</span> Compile programs</h4>
<div class="outline-text-4" id="text-2-13-1">
<p>
Here is how it could maybe be done. We already have a type StepFn
(which takes an env and returns a new one, in a future).
</p>

<p>
So let's say we have a program [1 2 +], and we want to convert that
into a StepFn. We could have a function <code>compose</code> and another
<code>self_insert</code>, and then call compose([self<sub>insert</sub>(1), self<sub>insert</sub>(2),
plus]), which would return a StepFn.
</p>

<p>
Let's look at something more complex:
</p>

<p>
<code>1 2 3 4 [+ *] dip</code>
</p>

<p>
In this case, the program is the composition of the 5 self-inserts and
dip. But what is self-inserted as the 5th item in this case could be
compiled because we know <code>dip</code> follows it. How we know in advance a list
can be compiled is difficult.
</p>

<p>
Let's try this:
</p>

<p>
<code>0 1 [2 3 4] [[+] dip] step</code>
</p>

<p>
In this case, the program for <code>step</code> is easy to spot, and in turn <code>dip</code>.
</p>

<p>
How about this:
</p>

<p>
<code>[+ *] [2 3 4] swap join execute</code>
</p>

<p>
We can't know the first two programs can be compiled until later on,
unless we look ahead in the program. Even then we can only know
what arguments end up being passed to join and execute by examining
the words' specs, and even that is not foolproof, as we have wildcard
specs like dip where the stack change is arbitrary.
</p>

<p>
One major issue with this optimization is that it will stop the
debugger from working properly, unless special care is taken: with the
debugger we can go step by step, but if the function composition is
bundled up, we can only "step over" that function and not "into" it. I
am not sure if it's possible to build this such that we preserve
stepping ability and increase performance substantially.
</p>
</div>
</div>
<div id="outline-container-org7159cb6" class="outline-4">
<h4 id="org7159cb6"><span class="section-number-4">2.13.2.</span> <span class="todo TODO">TODO</span> Programs as their own immutable type</h4>
<div class="outline-text-4" id="text-2-13-2">
<p>
Programs executing in a loop are generally not modified (exception -
the <code>recur</code> word, which can modify but usually just calls <code>execute</code>)- so
when we execute a program with <code>loop</code> we don't want to have to clone it
each time through the loop.
</p>

<p>
Instead we'll do the following: when <code>loop</code> places a program into the
program, instead of joining it, it's just going to put it right on
top as a <code>program</code> - we may need to differentiate programs that are
active vs meant to be run later. When <code>eval-step</code> runs, it sees an
active program on the top of the program, so it calls <code>next</code> and gets
a reference to the next word (or None if it's at the end, drop the
program). Then we lookup that word. If it's an axiom, we call it. If
it's derived, we place a new program on the top of the program,
with its PC set to 0. The actual programs are immutable, and behind an
Rc. Each "copy" of the program is just an Rc and a counter. Then all
programs are references except the counter.
</p>


<p>
example program:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>flip <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">0 </span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-builtin">swapdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>flip <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">0 1</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pc 0</span>
<span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pc 1 </span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">pc 0 1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">etc</span>
</pre>
</div>

<p>
So when printing out the program, we could cheat and only show the
remaining program (instead of a stack of partially executed programs).
</p>
</div>
</div>
</div>

<div id="outline-container-orga963f71" class="outline-3">
<h3 id="orga963f71"><span class="section-number-3">2.14.</span> <span class="todo INPROGRESS">INPROGRESS</span> Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h3>
<div class="outline-text-3" id="text-2-14">
</div>
<div id="outline-container-org66e743a" class="outline-4">
<h4 id="org66e743a"><span class="section-number-4">2.14.1.</span> <span class="done DONE">DONE</span> Basic functionality and generators</h4>
<div class="outline-text-4" id="text-2-14-1">
<p>
There's the concept of "lazy sequence" that I think maps nicely to
pipes - you can keep calling 'take' and it keeps calculating new
values. Everything it needs is contained in the object, it's not like
a network or filesystem pipe where the data is coming from somewhere
external. But it acts like a pipe.
</p>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">the producer - infinite seq of integers</span>
<span class="org-kcats-brackets">[[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; [1] 1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">the filter condition</span>
<span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">divisible by 3</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">filter-xf</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">pop</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>  

<span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">[generation filtration] [] 0 </span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">generate ;; [3]</span>
</pre>
</div>

<p>
The problem above is <code>generate</code> will not produce a value until one
passes the filter. I think filter needs to keep calling <code>generate</code> on the xf below it?
</p>
<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-function-name">pop</span> <span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]</span> 4
</pre>
</div>

<pre class="example">
1 [[unwound [[[[inc clone] dip swap put [pop [3 mod 0 =]] [put] [drop] if]] unwrap]] [type error] [asked [packable]] [actual 1] [reason "type mismatch"] [handled true]]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">the impl of filter-xf</span>
<span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">pop</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>  
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-function-name">pop</span> <span class="org-kcats-brackets">[</span>3 mod 0 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
<span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span>
<span class="org-builtin">drop</span> <span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span>
</pre>
</div>

<pre class="example">
2 [inc clone] 2
</pre>


<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">]</span>
</pre>
</div>

<pre class="example">
[[generate] dip] [] [inc] 1
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[1 2 3 4 6 9] liberate ;; produce from list</span>
1 <span class="org-kcats-brackets">[</span>2 * <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">infinite list</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">increment each</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">[3 * 3 -] each</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">drop the first few</span>
5 dropper
<span class="org-comment-delimiter">;; </span><span class="org-comment">limit the list</span>
10 taker
<span class="org-comment-delimiter">;; </span><span class="org-comment">collect into list</span>
collect
<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>64 128 256 512 1024 2048 4096 8192
 16384 32768<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> generate
</pre>
</div>

<pre class="example">
1 [inc clone] 1
</pre>


<p>
Now express the debugger interface in terms of generated environment states!
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">the steps of execution</span>
<span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>0 0 10 1 range <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span> environment
<span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup something?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[]]</span>
 <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the generator, which needs to emit 'nothing' once the program is empty</span>
<span class="org-kcats-brackets">[[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> each
50 taker
laster
generate
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>reason word is not defined<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>laster generate<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>laster<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled <span class="org-keyword">true</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 50 <span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[[</span>stack<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
           bail<span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup something?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>0 0 10 1 range <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<p>
implement 'laster' which returns only the last in the seq
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 100 1 range liberate
laster
generate
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> traversal <span class="org-comment-delimiter">;; </span><span class="org-comment">a generator for the list</span>
<span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> each
collect
</pre>
</div>
<pre class="example">
99 [generate [] swap [] [swap drop [generate] dip swap] while drop] liberate []
</pre>


<p>
Now implement 'keep' which returns only an item that passes the filter
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 
<span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> keep
1 dropper
10 taker
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]</span> each
collect
</pre>
</div>

<pre class="example">
[9 25 49 81 121 169 225 289 361 441] [generate [[clone *] bail] shielddown] [[positive?] [dec [generate] dip swap] [drop []] if] [[[positive?] [[generate drop] dip dec] while [generate swap] dip swapdown swap] bail] 0 [clone [[generate] dip [drop generate] while] dip swap] [[[something?] [odd? not]] [execute] every?] [inc clone] 21
</pre>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>something?<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> pair <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>every?<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">[odd? not]</span>

</pre>
</div>

<pre class="example">
[[[something?] [odd?]] every?]
</pre>


<p>
dropper (almost got it, doesn't detect end of parent stream yet)
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>0 20 1 range liberate
 5 dropper
 10 taker
 <span class="org-kcats-brackets">[</span>5 *<span class="org-kcats-brackets">]</span> each
 <span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> keep
 collect<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>25 35 45 55 65<span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
Collect fix
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate

generate <span class="org-comment-delimiter">;; </span><span class="org-comment">n</span>
<span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span> <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n n r</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">r</span>
 <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">r n</span>
 <span class="org-builtin">swap</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">n n r </span>
<span class="org-preprocessor">loop</span> <span class="org-builtin">drop</span>
</pre>
</div>

<pre class="example">
[1 2 3] liberate []
</pre>


<div class="org-src-container">
<pre class="src src-kcats">integers 10 taker collect <span class="org-builtin">drop</span> generate 
</pre>
</div>

<pre class="example">
[] [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 9
</pre>
</div>
</div>

<div id="outline-container-org325021b" class="outline-4">
<h4 id="org325021b"><span class="section-number-4">2.14.2.</span> <span class="done DONE">DONE</span> map</h4>
</div>
<div id="outline-container-org8ca0a37" class="outline-4">
<h4 id="org8ca0a37"><span class="section-number-4">2.14.3.</span> <span class="done DONE">DONE</span> filter</h4>
</div>
<div id="outline-container-org71d95a8" class="outline-4">
<h4 id="org71d95a8"><span class="section-number-4">2.14.4.</span> <span class="done DONE">DONE</span> take</h4>
</div>
<div id="outline-container-org4058f9d" class="outline-4">
<h4 id="org4058f9d"><span class="section-number-4">2.14.5.</span> <span class="done DONE">DONE</span> drop</h4>
<div class="outline-text-4" id="text-2-14-5">
<div class="org-src-container">
<pre class="src src-kcats">integers 15 taker 10 dropper <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> reduce
</pre>
</div>

<pre class="example">
60 [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [[positive?] [dec [generate] dive] [[]] if] 0 [inc clone] 14
</pre>
</div>
</div>
<div id="outline-container-orga45a68e" class="outline-4">
<h4 id="orga45a68e"><span class="section-number-4">2.14.6.</span> <span class="done DONE">DONE</span> drop-while (skipper)</h4>
<div class="outline-text-4" id="text-2-14-6">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-11-30 Thu 18:01]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-30 Thu 17:28]</span></span>
This is what drop-while looks like</li>
</ul>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>positive?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the state (whether threshold reached)</span>
<span class="org-kcats-brackets">[[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">condition - whether we've finished dropping or not </span>
 <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">true - pass everything else through</span>
 <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">prime init</span>
  <span class="org-kcats-brackets">[[[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">bring pred up and exec it</span>
  <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">if pred passes drop the value</span>
  prime <span class="org-comment-delimiter">;; </span><span class="org-comment">after this should have value on top</span>
  <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-keyword">true</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">set flag</span>
 <span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">false - generate, check pred, repeat</span>
 <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
collect
</pre>
</div>
</div>
</div>
<div id="outline-container-orge38153e" class="outline-4">
<h4 id="orge38153e"><span class="section-number-4">2.14.7.</span> <span class="done DONE">DONE</span> take-while (catcher)</h4>
<div class="outline-text-4" id="text-2-14-7">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-11-30 Thu 18:02]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-30 Thu 17:30]</span></span></li>
</ul>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 <span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>positive?<span class="org-kcats-brackets">]</span>

<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span>
 <span class="org-kcats-brackets">[[[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> bail not<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span>
 when<span class="org-kcats-brackets">]</span>




collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> bail not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span>
         when<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org44c89f3" class="outline-4">
<h4 id="org44c89f3"><span class="section-number-4">2.14.8.</span> <span class="done CANCELED">CANCELED</span> last</h4>
</div>
<div id="outline-container-org9c61d2c" class="outline-4">
<h4 id="org9c61d2c"><span class="section-number-4">2.14.9.</span> <span class="todo TODO">TODO</span> distinct</h4>
<div class="outline-text-4" id="text-2-14-9">
<p>
depends on sets
</p>

<p>
The difference between this and just calling <code>set</code> is that the result is
still a list, and it preserves the original order, just removes
duplicates. Should be a similar impl to <code>keep</code>.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 1 3<span class="org-kcats-brackets">]</span> liberate
<span class="org-kcats-brackets">[]</span> set <span class="org-comment-delimiter">;; </span><span class="org-comment">state</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n seen g</span>

 <span class="org-kcats-brackets">[</span>contains?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">seen g</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">n seen g</span>
 <span class="org-preprocessor">while</span>
<span class="org-kcats-brackets">]</span>
collect
</pre>
</div>

<pre class="example">
[1 1 3] [[generate] dive [contains?] [put [generate] dive] while] [] [take] []
</pre>
</div>
</div>

<div id="outline-container-orgab70474" class="outline-4">
<h4 id="orgab70474"><span class="section-number-4">2.14.10.</span> <span class="done DONE">DONE</span> partition</h4>
<div class="outline-text-4" id="text-2-14-10">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 17:39]</span></span></li>
</ul>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
2 <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-function-name">count</span> inc <span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-function-name">count</span> inc<span class="org-kcats-brackets">]]</span>
    <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> 2 <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3 4 5 6<span class="org-kcats-brackets">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org787e822" class="outline-4">
<h4 id="org787e822"><span class="section-number-4">2.14.11.</span> <span class="done DONE">DONE</span> joiner (aka catenate)</h4>
<div class="outline-text-4" id="text-2-14-11">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>7 8 9<span class="org-kcats-brackets">]]</span>
liberate
<span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span>
 <span class="org-kcats-brackets">[]</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span>
  <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> 
 <span class="org-preprocessor">while</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> 
generate
</pre>
</div>

<pre class="example">
[1 2 3 4 5 6 7 8 9] [generate [] swap [] [join [generate] dip swap] while drop] [take] []
</pre>
</div>
</div>

<div id="outline-container-org01a6321" class="outline-4">
<h4 id="org01a6321"><span class="section-number-4">2.14.12.</span> <span class="todo TODO">TODO</span> groupby</h4>
<div class="outline-text-4" id="text-2-14-12">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baaz"</span> <span class="org-string">"quux"</span><span class="org-kcats-brackets">]</span>
liberate <span class="org-comment-delimiter">;; </span><span class="org-comment">(the next word foo)</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">liberate ;; (the first letter f)</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>

<span class="org-function-name">wrap</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">k v state</span>
 <span class="org-function-name">wrap</span> <span class="org-builtin">swap</span>  <span class="org-comment-delimiter">;;  </span><span class="org-comment">v k state</span>
 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[]</span> association <span class="org-comment-delimiter">;; </span><span class="org-comment">state f</span>
<span class="org-builtin">swap</span>

cram
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>\q <span class="org-kcats-brackets">[</span><span class="org-string">"quux"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>\f <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>\b <span class="org-kcats-brackets">[</span><span class="org-string">"bar"</span> <span class="org-string">"baaz"</span><span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Ok so now we just need to insert the [take] program instead of
specifying it inline.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> group
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span>1 3<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>2 4<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd29357d" class="outline-4">
<h4 id="orgd29357d"><span class="section-number-4">2.14.13.</span> <span class="done CANCELED">CANCELED</span> Map/filter can't access lower stack items</h4>
<div class="outline-text-4" id="text-2-14-13">
</div>
<div id="outline-container-orgac75d43" class="outline-5">
<h5 id="orgac75d43"><span class="section-number-5">2.14.13.1.</span> Problem</h5>
<div class="outline-text-5" id="text-2-14-13-1">
<p>
this doesn't work:
</p>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> each
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> 10
</pre>
</div>

<p>
We should get <code>[11 12 13]</code> but it errors out.
</p>

<p>
The reason is that when + runs, the generators are still on the stack,
in between this mapping function, and the original stack arguments.
</p>

<p>
We need a way to break out of the generation part of the stack and let
the mapping function access the arguments below it.
</p>

<p>
I can't immediately think of a good way to do it.
</p>

<p>
Actually I think that instead of recursively calling generate, and
passing the values back up the stack, there might be a way to build up
the program recursively, and then execute it in one swoop? 
</p>

<p>
Perhaps we can split each stage into several parts:
</p>

<ul class="org-ul">
<li>Generate from the layer below (in which case we obviously need the
layers below to get the next value)</li>
<li>dip underneath the layers to calculate the next value using lower stack items</li>
<li>swap the new value to the top of stack</li>
<li></li>
</ul>
</div>
</div>
<div id="outline-container-org1f40179" class="outline-5">
<h5 id="org1f40179"><span class="section-number-5">2.14.13.2.</span> Debug session</h5>
<div class="outline-text-5" id="text-2-14-13-2">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> each generate<span class="org-kcats-brackets">]]]</span> environment
advance advance advance advance eval-<span class="org-function-name">step</span> <span class="org-kcats-brackets">[</span>advance<span class="org-kcats-brackets">]</span> 5 <span class="org-preprocessor">times</span> eval-<span class="org-function-name">step</span>
<span class="org-kcats-brackets">[</span>advance<span class="org-kcats-brackets">]</span> 2 <span class="org-preprocessor">times</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> 99 <span class="org-preprocessor">times</span> 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> liberate <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> each generate
</pre>
</div>

<pre class="example">
[[asked [number]] [reason "type mismatch"] [unwound [+ [[1 [take] [2 3] 10]] unwrap evert first swap drop [[generate [[+] bail] shielddown]] unwrap swap]] [actual [take]] [type error] [handled true]] 1 [take] [2 3] 10
</pre>



<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]]</span> environment advance<span class="org-kcats-brackets">]]]</span> environment advance advance eval-<span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">count</span> <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>&lt;=<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>stack <span class="org-kcats-brackets">[]]</span> <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]]]]]]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org751b1fb" class="outline-5">
<h5 id="org751b1fb"><span class="section-number-5">2.14.13.3.</span> Resolution</h5>
<div class="outline-text-5" id="text-2-14-13-3">
<p>
After thinking about this some more, my conclusion:
</p>

<p>
This is supporting multi-arity mapping functions, which did work in
the original map implementation but they are not supported in other
languages. The way you access multiple values there is by closing over
them. So the way you'd do it in kcats is like so:
</p>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the extra arg and the list</span>
<span class="org-kcats-brackets">[</span>-<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the multi-arity map fn</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">clone the 10</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend <span class="org-comment-delimiter">;; </span><span class="org-comment">prepend the word swap to the fn so that the 10 ends up beneath the list item</span>
<span class="org-builtin">float</span> prepend <span class="org-comment-delimiter">;; </span><span class="org-comment">prepend the 10</span>
<span class="org-function-name">map</span>
</pre>
</div>

<pre class="example">
[9 8 7] 10
</pre>


<p>
In theory we could write a helper function called <code>capture1</code> or something that does this for us, so you can write
</p>

<pre class="example">
10 [1 2 3] [-] capture1 map
</pre>

<div class="org-src-container">
<pre class="src src-kcats">10 <span class="org-kcats-brackets">[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the extra arg and the list</span>
<span class="org-kcats-brackets">[</span>-<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the multi-arity map fn</span>

<span class="org-kcats-brackets">[</span><span class="org-builtin">swapdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">f i</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend
 <span class="org-builtin">swap</span> prepend<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>
<span class="org-kcats-brackets">[</span>liberate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> each collect
</pre>
</div>

<pre class="example">
[9 8 7] [generate [[10 swap -] bail] shielddown] [take] [] 10
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 <span class="org-string">"oh fudge"</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>5 +<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> 5<span class="org-kcats-brackets">]</span>
 recover<span class="org-kcats-brackets">]</span>
<span class="org-function-name">map</span>
</pre>
</div>

<pre class="example">
[6 7 5]
</pre>
</div>
</div>
<div id="outline-container-org9cde317" class="outline-5">
<h5 id="org9cde317"><span class="section-number-5">2.14.13.4.</span> <span class="done DONE">DONE</span> Add functions to help capture environment for map/filter fns</h5>
<div class="outline-text-5" id="text-2-14-13-4">
<p>
It's too difficult to do this manually.
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-kcats-brackets">[</span>2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
</pre>
</div>

<p>
we want to redesign this so that we build the mapping function first:
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> capture
<span class="org-kcats-brackets">[</span>2 3 4<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">map</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>3 4 5<span class="org-kcats-brackets">]</span> 1
</pre>
</div>

<p>
and the generator equivalent
</p>
<div class="org-src-container">
<pre class="src src-kcats">5 <span class="org-kcats-brackets">[</span>* inc<span class="org-kcats-brackets">]</span> capture <span class="org-kcats-brackets">[</span>integers 100 dropper 10 taker<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> each collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>501 506 511 516 521 526 531 536 541 546<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[[</span>5<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> * inc<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
 <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 0 <span class="org-kcats-brackets">[[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>generate <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span>
                                                             <span class="org-preprocessor">dip</span> dec<span class="org-kcats-brackets">]</span>
                                                <span class="org-preprocessor">while</span> <span class="org-kcats-brackets">[</span>generate <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span>
                                                <span class="org-preprocessor">dip</span> <span class="org-builtin">float</span><span class="org-kcats-brackets">]</span>
                                               bail<span class="org-kcats-brackets">]</span>
0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
109 5
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5c301b5" class="outline-4">
<h4 id="org5c301b5"><span class="section-number-4">2.14.14.</span> <span class="done DONE">DONE</span> Reduce</h4>
<div class="outline-text-4" id="text-2-14-14">
<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 30 taker <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc f</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">drop [generate] divedown [] [float execute clone] [] if</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">acc f g</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i acc f g</span>
 <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">float</span> <span class="org-preprocessor">execute</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc f g</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 10 taker 
generate <span class="org-builtin">clone</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc </span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">drop [generate] divedown [] [float execute clone] [] if</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">acc g</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">i acc g</span>
 <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>+ <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">acc acc f g</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">55 <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 10
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 3 taker
<span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">build the 'then' branch</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">-&gt; [+ clone]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">build the loop body</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[]]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-kcats-brackets">[[]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">generate the first item under the loop body</span>
<span class="org-kcats-brackets">[</span>generate <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
<span class="org-preprocessor">loop</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">6 <span class="org-kcats-brackets">[[</span>positive?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>dec <span class="org-kcats-brackets">[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> 0 <span class="org-kcats-brackets">[</span>inc <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> 3
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">1 2 3 4 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span>
</pre>
</div>

<pre class="example">
3 4 3
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 <span class="org-keyword">true</span> <span class="org-kcats-brackets">[</span> inc <span class="org-builtin">clone</span> 5 &lt; <span class="org-kcats-brackets">]</span> <span class="org-preprocessor">loop</span>
</pre>
</div>

<pre class="example">
5
</pre>


<div class="org-src-container">
<pre class="src src-kcats">integers
1 dropper <span class="org-comment-delimiter">;; </span><span class="org-comment">start with 1</span>
1000 taker <span class="org-comment-delimiter">;; </span><span class="org-comment">take items</span>
<span class="org-kcats-brackets">[</span>3 *<span class="org-kcats-brackets">]</span> each
<span class="org-kcats-brackets">[</span>odd?<span class="org-kcats-brackets">]</span> keep
<span class="org-kcats-brackets">[</span>+ 37 mod<span class="org-kcats-brackets">]</span> reduce
</pre>
</div>

<pre class="example">
10 [clone [[generate] dip [drop generate] while] dive] [[[something?] [odd? not]] [execute] every?] [generate [[3 *] bail] shielddown] [[positive?] [dec [generate] dive] [drop []] if] [[[positive?] [[generate drop] dip dec] while [generate swap] dip float] bail] 0 [inc clone] 1000
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1025 8 mod
</pre>
</div>

<pre class="example">
1
</pre>


<p>
let's make an equivalent to <code>map</code> (that doesn't require a generator) for ease of use
</p>
<div class="org-src-container">
<pre class="src src-kcats">0 <span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span>  
</pre>
</div>

<p>
&#x2026;wait a minute, isn't that just <code>step</code>?
</p>
</div>
</div>

<div id="outline-container-org718cf19" class="outline-4">
<h4 id="org718cf19"><span class="section-number-4">2.14.15.</span> <span class="done CANCELED">CANCELED</span> Generator combinators?</h4>
<div class="outline-text-4" id="text-2-14-15">
<ul class="org-ul">
<li>State "CANCELED"   from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-01-16 Tue 17:10] </span></span> <br />
Not sure there's anything to do here.</li>
</ul>
<p>
When writing <code>partition</code>, it would be nice if we could use generators
<b>within</b> a generator. For example, we need to partition a list into
pairs. It would be nice if we could use <code>2 taker</code> repeatedly. Let's see if we can make that work:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5 6 7<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>2 taker collect <span class="org-builtin">dropdown</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> collect

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1 2<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>3 4<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>5 6<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>7<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span>2 taker collect <span class="org-builtin">dropdown</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Ok wow did not expect that to be so easy.
</p>

<p>
Maybe we can even implement the window shifting version?
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5 6 7<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
3 1  <span class="org-comment-delimiter">; </span><span class="org-comment">params: window-size, shift-size, state</span>
<span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[[</span>dotake <span class="org-kcats-brackets">[[</span>taker collect
            <span class="org-builtin">dropdown</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">; </span><span class="org-comment">drop the used-up taker generator</span>
           <span class="org-function-name">join</span> divedeep<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>doshift <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span> &lt;=<span class="org-kcats-brackets">]</span>
             <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> 0 slice<span class="org-kcats-brackets">]</span>
             <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[</span>
  <span class="org-kcats-brackets">[]</span>
  <span class="org-kcats-brackets">[</span>over <span class="org-function-name">wrap</span> dotake <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> doshift<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>over<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">wrap</span> dotake <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> doshift<span class="org-kcats-brackets">]</span>
  <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
 draft<span class="org-kcats-brackets">]</span>
collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1 2 3<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>3 4 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>4 5 6<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 6 7<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[[</span>dotake <span class="org-kcats-brackets">[[</span>taker collect <span class="org-builtin">dropdown</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span>
                                                     <span class="org-function-name">join</span> divedeep<span class="org-kcats-brackets">]]</span>
                                            <span class="org-kcats-brackets">[</span>doshift <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span> &lt;=<span class="org-kcats-brackets">]</span>
                                                       <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> 0 slice<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
                                                      <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
                                           <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>over <span class="org-function-name">wrap</span> dotake <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> doshift<span class="org-kcats-brackets">]</span>
                                                bail<span class="org-kcats-brackets">]</span>
                                            <span class="org-kcats-brackets">[[</span>over<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">wrap</span> dotake <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> doshift<span class="org-kcats-brackets">]</span>
                                            <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
                                           draft<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>6 7<span class="org-kcats-brackets">]</span>
1 3 <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9d301cc" class="outline-4">
<h4 id="org9d301cc"><span class="section-number-4">2.14.16.</span> <span class="done DONE">DONE</span> Applying generator to an existing container</h4>
<div class="outline-text-4" id="text-2-14-16">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 17:40]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-10 Fri 16:36]</span></span></li>
</ul>
<p>
we commonly have this construct: <code>[[1 2 3] ... collect] shield</code>, where
we're transducing a list and we want to just get the result.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>odd?<span class="org-kcats-brackets">]</span> keep<span class="org-kcats-brackets">]</span> 
<span class="org-kcats-brackets">[</span>xform dispenser<span class="org-kcats-brackets">]</span> label
<span class="org-kcats-brackets">[[[</span>poke dispenser<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>splice xform<span class="org-kcats-brackets">]</span> collect<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
template <span class="org-preprocessor">execute</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 3 5<span class="org-kcats-brackets">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b3d95e" class="outline-4">
<h4 id="org5b3d95e"><span class="section-number-4">2.14.17.</span> <span class="todo INPROGRESS">INPROGRESS</span> Combinations</h4>
<div class="outline-text-4" id="text-2-14-17">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-01-17 Wed 09:13]</span></span></li>
</ul>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> -1 <span class="org-comment-delimiter">;; </span><span class="org-comment">l idx i</span>
             <span class="org-kcats-brackets">[[[</span><span class="org-builtin">swap</span> <span class="org-function-name">count</span> =<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-function-name">take</span> 0 <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> when
              <span class="org-kcats-brackets">[[</span><span class="org-function-name">wrap</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[</span>pair<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span><span class="org-kcats-brackets">]</span>
             <span class="org-comment-delimiter">;</span><span class="org-comment">generate drop generate drop generate drop generate</span>
             collect<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>1 2<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>1 3<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>1 4<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>1 5<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>2 3<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>2 4<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>2 5<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>3 4<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>3 5<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>4 5<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
This isn't quite right because we're not using a lower generator as
the source, even though we could. We could start with an empty list as
the state, call generate, and then yield pairs for that item and every
item in the state. Then add it to the state and continue until the
lower generator yields nothing.
</p>

<p>
"combinations" may not be a good name since it implies all
combinations and not just pairs. Maybe put this on hold until we actually need it.
</p>

<p>
Ok let's do it this way, here's a python version:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">def</span> <span class="org-function-name">generate_recursive</span>(items_generator, current_combo, remaining_arity):
    <span class="org-keyword">if</span> remaining_arity <span class="org-operator">==</span> 0:
        <span class="org-keyword">yield</span> current_combo
    <span class="org-keyword">else</span>:
        <span class="org-keyword">for</span> item <span class="org-keyword">in</span> items_generator():
            <span class="org-keyword">yield</span> <span class="org-keyword">from</span> generate_recursive(items_generator, current_combo <span class="org-operator">+</span> [item], remaining_arity <span class="org-operator">-</span> 1)

<span class="org-keyword">def</span> <span class="org-function-name">generate_combinations</span>(items_generator, arity):
    <span class="org-keyword">for</span> item <span class="org-keyword">in</span> items_generator():
        <span class="org-keyword">yield</span> <span class="org-keyword">from</span> generate_recursive(items_generator, [item], arity <span class="org-operator">-</span> 1)

<span class="org-comment-delimiter"># </span><span class="org-comment">Example usage with a generator:</span>
<span class="org-keyword">def</span> <span class="org-function-name">item_generator</span>():
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, 4):
        <span class="org-keyword">yield</span> i

<span class="org-variable-name">arity</span> <span class="org-operator">=</span> 3
<span class="org-variable-name">result</span> <span class="org-operator">=</span> []

<span class="org-keyword">for</span> combo <span class="org-keyword">in</span> generate_combinations(item_generator, arity):
    result.append( combo)
<span class="org-keyword">return</span> result
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>combos <span class="org-kcats-brackets">[[]</span>
          <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> 1 =<span class="org-kcats-brackets">]</span>
           <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">clone</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
           <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> dec <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>self enumerate generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span> <span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">put a generator for tuples one smaller and get the first one</span>
           <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">]</span>

<span class="org-kcats-brackets">[[</span>a b c d<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> 2 combos generate<span class="org-kcats-brackets">]</span>
draft

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">2 <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">clone</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> dec <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span>
                                                          <span class="org-kcats-brackets">[</span>combos enumerate generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span><span class="org-kcats-brackets">]</span>
   <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>0 <span class="org-kcats-brackets">[</span>a<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span>pair<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> 1 <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span>
                                                                    <span class="org-builtin">clone</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
                                                        <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> dec <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>combos enumerate generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dipdown</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>a<span class="org-kcats-brackets">]</span> 1 <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b c d<span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
enumerate generator
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>a b c d<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
0 <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span>pair<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> 
collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>0 a<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>1 b<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>2 c<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>3 d<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[[</span>pair<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span> <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> 4 <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>a b c d e<span class="org-kcats-brackets">]</span> 1 3 <span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[[</span>= not<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span> <span class="org-kcats-brackets">[[</span>1 =<span class="org-kcats-brackets">]</span>
   <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span><span class="org-kcats-brackets">]</span>
   <span class="org-kcats-brackets">[]</span>
   <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span><span class="org-kcats-brackets">]</span> when

</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>a b c d e<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> 3 1 <span class="org-kcats-brackets">[</span>a b c d e<span class="org-kcats-brackets">]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org86d3cff" class="outline-3">
<h3 id="org86d3cff"><span class="section-number-3">2.15.</span> <span class="todo INPROGRESS">INPROGRESS</span> Implement sorting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stdlib">stdlib</span></span></h3>
<div class="outline-text-3" id="text-2-15">
</div>
<div id="outline-container-org8447034" class="outline-4">
<h4 id="org8447034"><span class="section-number-4">2.15.1.</span> <span class="todo TODO">TODO</span> Implement partialord</h4>
<div class="outline-text-4" id="text-2-15-1">
<p>
Each type needs to be comparable to another.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-string">"b"</span> 2<span class="org-kcats-brackets">][</span><span class="org-string">"g"</span> 5<span class="org-kcats-brackets">][</span><span class="org-string">"a"</span>, 1<span class="org-kcats-brackets">][</span><span class="org-string">"d"</span> 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"c"</span> 3<span class="org-kcats-brackets">]]</span> association sort-indexed
</pre>
</div>

<pre class="example">
[1 2 3 4 5]
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>-2 10 -8 -12 8 0 1 20<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>5 - abs<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span> pair<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-function-name">map</span>  sort-indexed 
</pre>
</div>

<pre class="example">
Pair is (Int(-2), Int(7))
Pair is (Int(10), Int(5))
Pair is (Int(-8), Int(13))
Pair is (Int(-12), Int(17))
Pair is (Int(8), Int(3))
Pair is (Int(0), Int(5))
Pair is (Int(1), Int(4))
Pair is (Int(20), Int(15))
[8 1 10 0 -2 -8 20 -12]
</pre>


<p>
UHOH
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"hi"</span> <span class="org-string">"there"</span> <span class="org-string">"what"</span> <span class="org-string">"is"</span> <span class="org-string">"your"</span> <span class="org-string">"birthdate"</span> <span class="org-string">"homeboy"</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span>pair<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-function-name">map</span>  sort-indexed 
</pre>
</div>

<pre class="example">
Pair is (Iterable(Sized(String("hi"))), String("hi"))
Pair is (Iterable(Sized(String("there"))), String("there"))
Pair is (Iterable(Sized(String("what"))), String("what"))
Pair is (Iterable(Sized(String("is"))), String("is"))
Pair is (Iterable(Sized(String("your"))), String("your"))
Pair is (Iterable(Sized(String("birthdate"))), String("birthdate"))
Pair is (Iterable(Sized(String("homeboy"))), String("homeboy"))
["birthdate" "hi" "homeboy" "is" "there" "what" "your"]
</pre>


<div class="org-src-container">
<pre class="src src-kcats">8 5 - 
</pre>
</div>

<pre class="example">
3
</pre>


<div class="org-src-container">
<pre class="src src-kcats">1 2 <span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> both
</pre>
</div>

<pre class="example">
[[reason "word is not defined"] [unwound [both]] [type error] [asked [both]] [handled true]] [inc] 2 1
</pre>
</div>
</div>

<div id="outline-container-org965dcdc" class="outline-4">
<h4 id="org965dcdc"><span class="section-number-4">2.15.2.</span> <span class="todo TODO">TODO</span> Make floats hashable</h4>
<div class="outline-text-4" id="text-2-15-2">
<p>
This will allow floats to be added to the <code>KeyItem</code> enum. Floats are not
normally hashable, because mathematically identical numbers are not
always represented the same way in memory and wouldn't hash the
same. But for the purposes of kcats, I think this doesn't matter. We
can document that you can't expect (10.0 + 10.0) and (15.0 + 5.0) to
be the same map key.
</p>

<p>
This will then allow a list that contains floats, to be sorted, or be
able to use float values as a sort-by key.
</p>
</div>
</div>

<div id="outline-container-org2382388" class="outline-4">
<h4 id="org2382388"><span class="section-number-4">2.15.3.</span> <span class="todo TODO">TODO</span> Implement compare</h4>
<div class="outline-text-4" id="text-2-15-3">
<p>
Should expose Rust's comparison function. That will allow a native
sort function, for max flexibility (but not performance).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"a"</span> <span class="org-string">"b"</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"a"</span> <span class="org-string">"a"</span> compare
</pre>
</div>

<pre class="example">
equal
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"a"</span> <span class="org-string">"c"</span><span class="org-kcats-brackets">]</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> bytes <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> compare
</pre>
</div>

<pre class="example">
less
</pre>


<p>
This should work - the empty set and map maybe can't be compared but Nothing should be in there.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> -1000 compare
</pre>
</div>

<pre class="example">
less
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb80af6e" class="outline-3">
<h3 id="orgb80af6e"><span class="section-number-3">2.16.</span> <span class="todo TODO">TODO</span> Stream transformation</h3>
<div class="outline-text-3" id="text-2-16">
<p>
Problem: kcats doesn't speak http or https or various other protocols
and formats, but rust does. We want to be able to use the complicated
bits of rust, but let kcats decide how to combine them.
</p>

<p>
Implementation: I think we may need to create a new Rust enum Item
type, that acts as a generator. It has an input method "next<sub>input</sub>"
that takes an input chunk which is the result of the generator
beneath, then it either returns None (updated the state, but no new
item yet), or Item (got a new item), or some signal for end of stream,
or Error. So it would have some program with a while loop to
iterate. All such transforms would probably have the same program.
</p>

<p>
I think what I am getting at here is that Items should implement Rust
traits where possible, eg Read/Write for file and network pipes.
</p>
</div>
</div>
<div id="outline-container-orgbe7eec1" class="outline-3">
<h3 id="orgbe7eec1"><span class="section-number-3">2.17.</span> <span class="todo INPROGRESS">INPROGRESS</span> Select from multiple pipes</h3>
<div class="outline-text-3" id="text-2-17">
<p>
A basic select (which I call <code>attend</code>) is in place. 
</p>
</div>

<div id="outline-container-org3f96bd0" class="outline-4">
<h4 id="org3f96bd0"><span class="section-number-4">2.17.1.</span> <span class="todo TODO">TODO</span> Attend should leave the pipe list argument</h4>
<div class="outline-text-4" id="text-2-17-1">
<p>
A lot of callers would want to re-use that argument so it shouldn't
need to be shielded by default.
</p>
</div>
</div>

<div id="outline-container-org9d52c06" class="outline-4">
<h4 id="org9d52c06"><span class="section-number-4">2.17.2.</span> <span class="todo TODO">TODO</span> Better error handling</h4>
<div class="outline-text-4" id="text-2-17-2">
<p>
There's lots of places where flume could throw an error and we don't
do anything about it.
</p>
</div>
</div>
</div>

<div id="outline-container-org1dbc0d5" class="outline-3">
<h3 id="org1dbc0d5"><span class="section-number-3">2.18.</span> <span class="todo TODO">TODO</span> Monitoring tools</h3>
<div class="outline-text-3" id="text-2-18">
</div>
<div id="outline-container-org12e3b17" class="outline-4">
<h4 id="org12e3b17"><span class="section-number-4">2.18.1.</span> <span class="todo TODO">TODO</span> Reporting back to the mothership</h4>
<div class="outline-text-4" id="text-2-18-1">
<p>
When we spawn/animate, the environment is in its own universe and the
main environment has no way to get any information about it, except by
whatever means are baked into the spawned env's program. Users can
come up with their own scheme of sending some kind of result via a
pipe, of course. But what happens if the program encounters an error?
</p>

<p>
It would be nice to wrap the program such that it reports the final
stack via a pipe, back to the main environment. And in the main env,
it would be nice to keep a list of those pipes so we can select and
get updates. Note, need to compare and contrast with the existing
mechanism in 'future'.
</p>

<p>
Another nice tool would be the ability to send the current state back
on demand (sort of like a thread dump) - in the spawned env, call
eval-step until some signal comes in on the pipe from the main env,
then send back a copy of the env. This mechanism could be used later
to implement a monitoring tool.
</p>

<p>
How to do this: I think a combination of "channel of channels", and
redefinition of <code>spawn</code> with <code>let</code> should go a long way. The
channel-channel lets new nested envs send back reply channels to the
master env, even if they are deeply nested. Redefining <code>spawn</code> lets us
insert the code to send those channels back (by passing in the channel
that leads back to the master env). What would be really handy is
parsing the inner env data to see which references to channels it
contains, seeing whether it's a sender or receiver, and drawing arrows
between envs so users can see they talk to each other.
</p>
</div>
</div>
<div id="outline-container-orge2c47b3" class="outline-4">
<h4 id="orge2c47b3"><span class="section-number-4">2.18.2.</span> <span class="todo TODO">TODO</span> Monitoring UI</h4>
<div class="outline-text-4" id="text-2-18-2">
<p>
We could show not only all the envs and ther recent state (perhaps
dumped every few seconds), we could show arrows between environments
that represent pipes (if two envs have a copy of the same pipe
anywhere in the stack or program, draw an arrow. If one env has a
sender and the other receiver, then show an arrow indicating the
direction of data flow along with the pipe id.
</p>

<p>
We could also allow views into a particular pipe where we copy the
last handful of values to pass through (this is doable for channels
but probably not file/network pipes).
</p>
</div>
</div>
</div>
<div id="outline-container-orgbf14566" class="outline-3">
<h3 id="orgbf14566"><span class="section-number-3">2.19.</span> <span class="todo INPROGRESS">INPROGRESS</span> Native REPL</h3>
<div class="outline-text-3" id="text-2-19">
</div>
<div id="outline-container-org6171dce" class="outline-4">
<h4 id="org6171dce"><span class="section-number-4">2.19.1.</span> <span class="done DONE">DONE</span> Main mode of reading program from cmdline or file</h4>
<div class="outline-text-4" id="text-2-19-1">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-19 Thu 21:08]</span></span></li>
</ul>
</div>
</div>
<div id="outline-container-org4294cb0" class="outline-4">
<h4 id="org4294cb0"><span class="section-number-4">2.19.2.</span> <span class="todo INPROGRESS">INPROGRESS</span> REPL as a kcats program</h4>
<div class="outline-text-4" id="text-2-19-2">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-10-19 Thu 21:08]</span></span></li>
</ul>
<p>
Read inputs from stdin, eval in a nested env, write to stdout.
</p>

<div class="org-src-container">
<pre class="src src-kcats">standard <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> 
<span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> each
<span class="org-string">""</span>
<span class="org-kcats-brackets">[[[</span>complete? <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-function-name">count</span> &lt;=<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>readcount <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">"\n"</span> split generate
              <span class="org-kcats-brackets">[[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> 4 <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
              <span class="org-kcats-brackets">[</span>read <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> bail 0 or<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span> readcount<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>complete? not<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">swapdown</span> <span class="org-function-name">join</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> prime<span class="org-kcats-brackets">]</span>
 draft cut<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>read<span class="org-kcats-brackets">]</span> each
collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[</span>read<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
    <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>complete? <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-function-name">count</span> &lt;=<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>readcount <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-string">"\n"</span> split generate <span class="org-kcats-brackets">[[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> 4 <span class="org-preprocessor">times</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-kcats-brackets">[</span>read <span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
              bail 0 or<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span> readcount<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>complete? not<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">divedown</span> <span class="org-builtin">swapdown</span> <span class="org-function-name">join</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> prime<span class="org-kcats-brackets">]</span>
 draft cut<span class="org-kcats-brackets">]</span>
<span class="org-string">""</span> <span class="org-kcats-brackets">[</span>generate <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
    <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>peer standard<span class="org-kcats-brackets">]</span>
        <span class="org-kcats-brackets">[</span>type tunnel<span class="org-kcats-brackets">]]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgabe5954" class="outline-3">
<h3 id="orgabe5954"><span class="section-number-3">2.20.</span> <span class="todo TODO">TODO</span> Words that quote programs instead of executing them</h3>
<div class="outline-text-3" id="text-2-20">
<p>
eg <code>liberate</code> - it is just <code>[take]</code>, so it doesn't actually do anything by
itself. It seems like the quotedness should remain and maybe the word
should always perform the action.
</p>

<p>
In that case we would have to write <code>5 [taker]</code>. I'm not thrilled with
that either, but maybe it's just not a good name.
</p>

<p>
It does seem like there's an inconsistency having a word quote a
program instead of the caller doing it.
</p>

<p>
There are certainly words that operate on programs without executing
them (like <code>each</code> which just modifies the mapping function to call the
generator below it, it doesn't add an entirely new generator to the
stack) but the word is still executing a program vs just
self-inserting one object.
</p>

<p>
So I think I do have to fix this. I'm just not sure what to do.
</p>

<p>
I think it will <b>look</b> inconsistent to write:
</p>
<div class="org-src-container">
<pre class="src src-kcats">integers
5 <span class="org-kcats-brackets">[</span>taker<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>inc<span class="org-kcats-brackets">]</span> each
</pre>
</div>
<p>
People will see that and wonder why <code>taker</code> is quoted but not <code>each</code>. It
makes sense when you dive into it.
</p>

<p>
Isn't this just an implementation detail? In theory <code>each</code> could be a
separate generator and honestly it probably should be.
</p>
</div>
<div id="outline-container-orgdce0c1e" class="outline-4">
<h4 id="orgdce0c1e"><span class="section-number-4">2.20.1.</span> <span class="todo TODO">TODO</span> Get rid of self-inserting programs (esp with generators)</h4>
<div class="outline-text-4" id="text-2-20-1">
<p>
Problem: words like <code>joiner</code> and <code>taker</code> don't do anything except insert a
program. That, i think, should be an anti-pattern in kcats. If you
want to put a program on the stack succintly,then define a word that
does what you want, and quote that word.
</p>

<p>
For example, some complex function <code>foo</code>, if you want a program on the
stack that does what foo does, use <code>[foo]</code>. <code>foo</code> itself should perform the action.
</p>

<p>
There's some confusion because <code>each</code> does perform an action: it
modifies the program already on the stack. So you would write <code>5 [taker]</code> but <code>[inc] each</code>.
</p>

<p>
One issue is with something like <code>partition</code> where there's boilerplate initial state
that needs to go on the stack before the generator program. With <code>taker</code>
the user provides the initial state because we don't know what it is in advance.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>1 2 3 4 5<span class="org-kcats-brackets">]</span> 2 2 <span class="org-kcats-brackets">[</span>partition<span class="org-kcats-brackets">]</span> generate
</pre>
</div>

<p>
It's possible for partition to check if the state is present and
create it (since the state is always a list and otherwise it would see
a number). But it's not generally possible for a generator to tell if
it needs to add state - it should already be there. So if we're just
quoting the generator, then what will add it?
</p>
</div>
</div>
</div>
<div id="outline-container-org4198c28" class="outline-3">
<h3 id="org4198c28"><span class="section-number-3">2.21.</span> <span class="todo TODO">TODO</span> Data compression</h3>
<div class="outline-text-3" id="text-2-21">
<p>
Data streams that we intend to produce later are going to need
compression - the streams should be as small as possible (they'll be
encrypted later so it's too late to compress them after that). lz4 maybe?
</p>
</div>
</div>
<div id="outline-container-org6127a6a" class="outline-3">
<h3 id="org6127a6a"><span class="section-number-3">2.22.</span> <span class="todo TODO">TODO</span> Multimethod improvements</h3>
<div class="outline-text-3" id="text-2-22">
</div>
<div id="outline-container-org0b54b82" class="outline-4">
<h4 id="org0b54b82"><span class="section-number-4">2.22.1.</span> <span class="todo TODO">TODO</span> Convert to multi</h4>
</div>
<div id="outline-container-org7bcc874" class="outline-4">
<h4 id="org7bcc874"><span class="section-number-4">2.22.2.</span> <span class="done DONE">DONE</span> Refactor addmethod</h4>
<div class="outline-text-4" id="text-2-22-2">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2023-12-04 Mon 16:24]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-04 Mon 16:13]</span></span></li>
</ul>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[[</span><span class="org-function-name">count</span> 3 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[[</span>not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"bar"</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]]]</span> decide<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">rest</span><span class="org-kcats-brackets">]</span>
pair <span class="org-comment-delimiter">;; </span><span class="org-comment">[c b] [[[...]] decide]</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>prepend<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-kcats-brackets">[[</span>0<span class="org-kcats-brackets">]]</span> <span class="org-preprocessor">dip</span> update
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[[</span><span class="org-function-name">count</span> 1 =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">rest</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[[</span><span class="org-function-name">count</span> 3 &gt;<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[[</span>not<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-string">"bar"</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]]]</span>
 decide<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>hash definition<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-string">"foo"</span> hash<span class="org-kcats-brackets">]</span> addmethod<span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span> <span class="org-kcats-brackets">[[</span>foo bar<span class="org-kcats-brackets">]]</span> association hash<span class="org-kcats-brackets">]</span>
lingo
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo bar<span class="org-kcats-brackets">]]</span> association type
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">foo
</pre>
</div>
</div>
</div>

<div id="outline-container-orga3216b6" class="outline-4">
<h4 id="orga3216b6"><span class="section-number-4">2.22.3.</span> <span class="done DONE">DONE</span> ismulti?</h4>
<div class="outline-text-4" id="text-2-22-3">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-04 Mon 16:25]</span></span></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org42618ad" class="outline-3">
<h3 id="org42618ad"><span class="section-number-3">2.23.</span> <span class="todo TODO">TODO</span> run multiple programs on same argument to get list</h3>
<div class="outline-text-3" id="text-2-23">
<div class="org-src-container">
<pre class="src src-kcats">5 2 <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>*<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>7 10<span class="org-kcats-brackets">]</span>
2 5
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ac10fc" class="outline-3">
<h3 id="org1ac10fc"><span class="section-number-3">2.24.</span> <span class="todo INPROGRESS">INPROGRESS</span> pairwise operations</h3>
<div class="outline-text-3" id="text-2-24">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-03 Sat 11:28]</span></span></li>
</ul>
<div class="org-src-container">
<pre class="src src-kcats">1 2 3 4 5 <span class="org-kcats-brackets">[]</span> both<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span>2 2 partition<span class="org-kcats-brackets">]</span> assemble<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
<span class="org-preprocessor">inject</span> <span class="org-kcats-brackets">[</span>joiner<span class="org-kcats-brackets">]</span> assemble <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span> <span class="org-builtin">evert</span> <span class="org-builtin">drop</span> 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">9 5 1
</pre>
</div>

<p>
this generator based impl doesn't support nil values on the stack:
</p>

<div class="org-src-container">
<pre class="src src-kcats">1 2 <span class="org-kcats-brackets">[]</span> 3 4 <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> pairwise
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"not enough items on stack"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span>joiner<span class="org-kcats-brackets">]</span> assemble <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span> <span class="org-builtin">evert</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>consume<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span>4 3<span class="org-kcats-brackets">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb91b4df" class="outline-3">
<h3 id="orgb91b4df"><span class="section-number-3">2.25.</span> <span class="todo INPROGRESS">INPROGRESS</span> Non-generator filter</h3>
<div class="outline-text-3" id="text-2-25">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-04 Sun 13:50]</span></span></li>
</ul>
<p>
map now doesn't require you to bind values (the map function has access to the rest of the stack).
 Do the same for <code>filter</code>.
</p>

<div class="org-src-container">
<pre class="src src-kcats">5 <span class="org-kcats-brackets">[</span>1 2 3 4<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>+ odd?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-builtin">sink</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">put empty results below list</span>
<span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> decorate <span class="org-comment-delimiter">;; </span><span class="org-comment">run map fn shielded and dipped under result</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> prepend <span class="org-comment-delimiter">;; </span><span class="org-comment">start by swapping the result back to the top</span>
<span class="org-kcats-brackets">[</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">end by checking pred, add to result</span>
<span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>2 4<span class="org-kcats-brackets">]</span>
5
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac0e0ab" class="outline-3">
<h3 id="orgac0e0ab"><span class="section-number-3">2.26.</span> <span class="todo TODO">TODO</span> Modules</h3>
<div class="outline-text-3" id="text-2-26">
</div>
<div id="outline-container-orgc01834e" class="outline-4">
<h4 id="orgc01834e"><span class="section-number-4">2.26.1.</span> Problem statement</h4>
<div class="outline-text-4" id="text-2-26-1">
</div>
<div id="outline-container-org57312aa" class="outline-5">
<h5 id="org57312aa"><span class="section-number-5">2.26.1.1.</span> <span class="todo TODO">TODO</span> Efficient use</h5>
<div class="outline-text-5" id="text-2-26-1-1">
<p>
When code is defining new vocabulary, and it gets called in a tight
 loop, it should not be modifying the dictionary each
 time. Dictionary shoud be append only (to avoid having to swap back
 and forth between a modified and unmodified version)
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">save a modified env or dictionary and use it</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">again.</span>
<span class="org-kcats-brackets">[</span>crypto<span class="org-kcats-brackets">]</span> stdmod <span class="org-comment-delimiter">;; </span><span class="org-comment">make the module</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">apply it to the dictionary</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span> encode hash<span class="org-kcats-brackets">]</span> confine
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">#b64 <span class="org-string">"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="</span>
</pre>
</div>

<p>
Let's make a word to load multiple modules
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>crypto time<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">apply the changes in order</span>
dictionary <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>decache string read <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">now execute</span>

</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">dictionary_redacted
</pre>
</div>

<p>
Let's divide up the functionality:
</p>
<ul class="org-ul">
<li>reading from cache and parsing (module)</li>
<li>apply module to dictionary (inscribe)</li>
<li>spawn env with new dict and program (spawn)</li>
<li>capture result as our stack</li>
</ul>
</div>
</div>

<div id="outline-container-orgcfff508" class="outline-5">
<h5 id="orgcfff508"><span class="section-number-5">2.26.1.2.</span> <span class="todo TODO">TODO</span> Modification happens once per program</h5>
<div class="outline-text-5" id="text-2-26-1-2">
<p>
Dictionary modification should not happen at "runtime" (when the
program is actually being executed) - it should be modified when the
program is <b>built</b>. However the consequence of this is pretty dire,
because much of the standard library is currently just programs that
are literals and don't need "building".
</p>
</div>
</div>
<div id="outline-container-org86b2849" class="outline-5">
<h5 id="org86b2849"><span class="section-number-5">2.26.1.3.</span> <span class="todo TODO">TODO</span> Nested library calls need to work</h5>
<div class="outline-text-5" id="text-2-26-1-3">
<p>
I should be able to call <code>af</code> that loads (or depends on <code>b</code> and calls <code>bf</code>
that loads <code>c</code> and calls <code>cf</code>, and those loads should only happen once
even if i call <code>af</code> in a tight loop.
</p>
</div>
</div>
<div id="outline-container-orgcc8990c" class="outline-5">
<h5 id="orgcc8990c"><span class="section-number-5">2.26.1.4.</span> <span class="todo TODO">TODO</span> Code should be shareable</h5>
<div class="outline-text-5" id="text-2-26-1-4">
<p>
That means, local names should generarlly not appear in code, as they
change meaning.
</p>
</div>
</div>
<div id="outline-container-orga2374e5" class="outline-5">
<h5 id="orga2374e5"><span class="section-number-5">2.26.1.5.</span> <span class="todo TODO">TODO</span> Building vocabulary and the programs that use that vocabulary need to be separable</h5>
<div class="outline-text-5" id="text-2-26-1-5">
<p>
(that's the whole point of a library). In practice there will be
some "mini-libs" that mostly just make code easier to read and stay
with the program that uses them. However we need to be able to
modify the dictionary, and then refer to that modification later (by
name? hash?), to support the typical library use case. That maps to
a use/require when a program starts, and then later, in some
arbitrary place in the code, you refer to the library's functions
via its namespace.
</p>
</div>
</div>
<div id="outline-container-orgac09dae" class="outline-5">
<h5 id="orgac09dae"><span class="section-number-5">2.26.1.6.</span> <span class="todo TODO">TODO</span> Sandboxing</h5>
<div class="outline-text-5" id="text-2-26-1-6">
</div>
<ol class="org-ol">
<li><a id="org400d49e"></a><span class="todo TODO">TODO</span> Preservation of meaning<br />
<div class="outline-text-6" id="text-2-26-1-6-1">
<p>
We execute untrusted code, then our own code, our code should mean the
same thing as it would have before executing the untrusted code.
</p>
</div>
</li>
<li><a id="org2595a0f"></a><span class="todo TODO">TODO</span> Access control<br />
<div class="outline-text-6" id="text-2-26-1-6-2">
<p>
We should be able to execute untrusted code in a limited environment
(where, for example, it does not have access to the filesystem
etc). 
</p>
</div>
<ol class="org-ol">
<li><a id="org7601e0d"></a><span class="todo TODO">TODO</span> Fine grained access control<br />
<div class="outline-text-7" id="text-2-26-1-6-2-1">
<p>
We could for example, limit filesystem access to a particular
directory, or network access to a particular host. One way this could
be done: have all such primitives run some other word as a predicate
lock, and respect the outcome of that predicate. However, some care
would need to be taken that the untrusted code couldn't just bootstrap
a new env without that lock in place. I'm not sure this is possible
within the overall language design.cause
</p>

<blockquote>
<p>
Integrating an authentication scripting language directly into the
core of your stack-based language and leveraging it for controlling
access to sensitive operations could indeed be a powerful and flexible
solution. This approach aligns well with your goal of making
authentication programmable while addressing the specific challenges
of providing fine-grained access control in a sandboxed
environment. Here's how to address potential concerns and make the
most out of this integration: Design Principles
</p>

<p>
Efficiency by Design: Since performance is a concern, designing
the authentication script execution to be as lightweight as
possible is crucial. Optimize the most common authentication paths
to reduce overhead. Consider caching results of authentication
checks where safe and applicable, especially in scenarios where
the same authentication decision is repeated.
</p>

<p>
Conditional Authentication Checks: Implement the authentication
scripts to run conditionally, i.e., only in contexts where
sandboxing is required. This minimizes the performance impact on
the overall system while still providing robust security measures
where they're most needed.
</p>

<p>
Customizable Script Complexity: Allow the complexity of the
authentication scripts to be tailored according to the security
needs of the sandbox environment. For less sensitive operations or
more trusted sandboxed environments, simpler scripts could be
used, reducing resource consumption.
</p>

<p>
Practical Implementation
</p>

<p>
Authentication Context: Provide a rich context to the
authentication scripts, including details about the requested
operation (e.g., file path for file access, URL for network
requests), the environment's security status, and any relevant
user or process identifiers. This enables writing precise and
effective authentication logic.
</p>

<p>
Digital Signatures and Proof Checking: As part of the
authentication scripts, leverage digital signatures for verifying
the integrity and authenticity of the scripts themselves or any
other supplied credentials. Although checking digital signatures
can be resource-intensive, optimizing the cryptographic operations
and selectively applying them can help manage the performance
impact.
</p>

<p>
Expandable Security Model: By integrating authentication scripting
into the core, you lay a foundation that's not only useful for
sandboxed environment control but can also be expanded for broader
security features in the future, such as secure inter-process
communication or encrypted data storage, using the same flexible
scripting approach.
</p>

<p>
Security and Performance Balance
</p>

<p>
Asynchronous Operations: When possible, make the authentication
checks asynchronous, especially for I/O bound tasks like network
requests or disk access. This can help mitigate the performance
impact on the rest of the system.
</p>

<p>
Resource Limits and Quotas: Introduce limits on the resources that
authentication scripts can consume, such as CPU time or memory
usage. This prevents potential abuse where overly complex scripts
could degrade system performance.
</p>

<p>
In sum, your approach to incorporate an authentication scripting layer
directly into the core of the language introduces a novel mechanism
for fine-grained access control, effectively turning authentication
checks into programmable gatekeepers for sensitive operations. While
it introduces challenges in terms of complexity and resource
management, careful design and optimizations can mitigate these
issues, offering a powerful and flexible tool for secure sandboxing.
I guess the question is, can the lock be unalterable? I can definitely
hardcode some aspects of these locks so that they are alterable from
the outside but not the inside. For example, if my trusted env wants
to create an untrusted one, it could insert a lock into a field of the
inner env, that is not accessible to the untrusted program. However,
the inner env can still construct a new env itself with a very
permissive lock and still use it to read the filesystem however it
wants. So somehow, the construct needs to force new envs to inherit
the locks of the current one. That's possible to implement. It could
be a series of locks (append only), and the key has to unlock all of
them.
</p>

<p>
&gt; I think the locks don't really even need cryptography in that case:
the lock would say "can only read/write to /tmp" and the key would
just be the file that the environment is trying to access. If it
starts with /tmp then it is allowed.
</p>

<p>
Yes, designing a lock mechanism that is both unalterable from inside
the untrusted environment and inheritable for any subsequently created
environments is indeed possible and can effectively secure the system
according to your requirements. The append-only series of locks, where
each new environment inherits the restrictions (locks) of its creator,
ensures that no matter how deeply nested an environment is, it cannot
escape the boundaries set by its original, trusted creator. Here's how
such a mechanism could be structured:
Lock Mechanism Design
</p>

<p>
Immutable Locks: Implement locks as immutable structures within
each environment. Once a lock is set, it cannot be modified from
within that environment. New environments inherit the lock state
of their parent environment upon creation.
</p>

<p>
Lock Inheritance and Aggregation: Ensure that when an environment
creates a new environment (even an untrusted one wants to create
another environment), the new environment inherits all the locks
of its parent environment, potentially adding its own restrictions
but never relaxing any existing ones. This could be done in an
append-only manner, where new locks add to the restrictions but do
not overwrite them.
</p>

<p>
Path-Based Access Control: Your description of using locks to
control file access based on paths (e.g., "can only read/write to
/tmp") is an example of path-based access control. This control is
straightforward yet effective and does not necessarily require
cryptographic keys for enforcement, simplifying implementation and
reducing overhead.
</p>

<p>
Implementation Considerations
</p>

<p>
System-Enforced Lock Checks: The core system that mediates access
to resources (file system, network, etc.) must enforce the lock
checks before granting any operation. This ensures that no
environment, regardless of its programming, can bypass the
restrictions placed upon it by its defined locks.
</p>

<p>
Auditing and Monitoring: Although the lock mechanism provides a
strong control mechanism, implementing auditing and monitoring on
the enforcement points can help identify potential attempts to
bypass restrictions or exploit weaknesses in the lock design.
</p>

<p>
Error Handling and Feedback: Define clear behavior and feedback
mechanisms for when an environment attempts to perform an
operation that is denied by its locks. Good error handling is
crucial for developers working within these environments to
understand the boundaries and work effectively within them.
</p>

<p>
Documentation and Transparency: Providing clear documentation on
how locks work, how they are inherited, and how they restrict
operations will aid in the adoption and correct usage of the
environment creation and management functionalities you are
designing.
</p>

<p>
In conclusion, your approach to using immutable, inheritable locks
that enforce path-based access control offers a robust method to
secure environments in a stack-based programming language, without
necessitating the complexity and overhead associated with
cryptographic solutions. This method provides a fine-grained control
mechanism that's both practical and efficient, aligning well with the
needs of a secure, sandboxed execution environment.
</p>
</blockquote>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-orga6fe108" class="outline-4">
<h4 id="orga6fe108"><span class="section-number-4">2.26.2.</span> Discussion</h4>
<div class="outline-text-4" id="text-2-26-2">
</div>
<div id="outline-container-orga70a1f2" class="outline-5">
<h5 id="orga70a1f2"><span class="section-number-5">2.26.2.1.</span> pairs of program/dictionary.</h5>
<div class="outline-text-5" id="text-2-26-2-1">
<p>
It's sort of like a passage of english prose, and a dictionary of what
all the words used in that prose mean. In terms of "true" meaning,
those two things are bound up together, you can change the meaning
either by changing the prose or the dictionary. So in a sense the
"meaning hash" is hash of the dict+program, not just the program
itself.
</p>

<p>
One potential hole in this concept is the existence of axiom words
(that aren't defined in terms of other words). It's not clear how to
hash them, we'd need the source of their implementation. Another issue
is it's possible to make alterations in the interpreter that still
execute the program the same way but the hash doesn't match. So
non-matching hash doesn't mean "different meaning", but same hash
generally means "same meaning". That's the way hashes work most places
though.
</p>

<p>
Can we do anything with this? Maybe not.
</p>
</div>
</div>


<div id="outline-container-org3adc66b" class="outline-5">
<h5 id="org3adc66b"><span class="section-number-5">2.26.2.2.</span> not having to recalculate the whole dictionary each time we want to use a module.</h5>
<div class="outline-text-5" id="text-2-26-2-2">
<p>
There's several possible mitigations:
</p>

<ul class="org-ul">
<li>Leave the modified dictionary on the stack so it can be reused</li>
<li>Make 2 levels of env nesting per library
<ul class="org-ul">
<li>One where the modified dict is in the dict (but words are not available)</li>
<li>One where we actually apply that dict so the words can be used</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgbe5dccf" class="outline-5">
<h5 id="orgbe5dccf"><span class="section-number-5">2.26.2.3.</span> Use of names</h5>
<div class="outline-text-5" id="text-2-26-2-3">
<p>
It occurred to me that we don't have to use names at all when it comes
to libaries or modules. We just let code refer to hashes, and the IDE
tools will help resolve those hashes to names or vice versa. But the
canonical form (in the actual code) will be hashes only.
</p>

<p>
This solves a lot of issues:
</p>

<ul class="org-ul">
<li>There is no chicken and egg problem. The kcats language itself
simply does not support names or local address books. It refers to
content by hash and that's it. That's how libraries are loaded,
etc. After the kcats language is complete, then we write naming
tooling in kcats, and we run those tools against a kcats program to
resolve hashes to names (possibly as part of IDE functionality). For
example, the IDE replaces hashes with names (if known) and you can
hover over the name to see the hash if needed.</li>
<li>Code is sharable because there are no local names present</li>
</ul>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">define a module</span>
<span class="org-kcats-brackets">[[</span>square <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]]</span> draft inscribe
<span class="org-comment-delimiter">;; </span><span class="org-comment">now the dictionary is on the stack</span>
<span class="org-kcats-brackets">[</span>9 square<span class="org-kcats-brackets">]</span> confine
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">81
</pre>
</div>

<p>
Defining a module hierarchy using only the stack can get diffcult. We
can create dictionaries and make them a dictionary entry to refer to them.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]]</span> draft inscribe
<span class="org-comment-delimiter">;; </span><span class="org-comment">so now we have an updated dictionary, let's make this an entry we</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">can access without polluting the dictionary with all the words we defined</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> entry dictionary <span class="org-builtin">swap</span> <span class="org-function-name">put</span>
<span class="org-kcats-brackets">[</span>math <span class="org-kcats-brackets">[</span>8 square<span class="org-kcats-brackets">]</span> confine<span class="org-kcats-brackets">]</span> confine
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">64
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9589bbe" class="outline-4">
<h4 id="org9589bbe"><span class="section-number-4">2.26.3.</span> <span class="todo INPROGRESS">INPROGRESS</span> inscribe currently re-defines words repeatedly at runtime</h4>
<div class="outline-text-4" id="text-2-26-3">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-08 Thu 17:17]</span></span></li>
</ul>
</div>
<div id="outline-container-orgc381fb2" class="outline-5">
<h5 id="orgc381fb2"><span class="section-number-5">2.26.3.1.</span> <span class="todo INPROGRESS">INPROGRESS</span> Current design</h5>
<div class="outline-text-5" id="text-2-26-3-1">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-12 Mon 08:22]</span></span></li>
</ul>
<p>
Have two separate words: one for loading new modules <code>loadlib</code>, and
other <code>using</code> for activating them in a given program.
</p>

<p>
Using hashes to refer to modules or namespaces is secure, but hard to
read. We can use aliases, but we need to be careful about which
aliases we use - should we trust an alias created by a module we
loaded? Can we overwrite aliases?
</p>

<p>
Attack scenario: we load a module foo, and it creates an alias bar and
then we later assume bar refers to something else, and call its 'quux'
word.
</p>

<p>
There are several different loading mechanisms which is what makes this functionality difficult:
</p>

<ul class="org-ul">
<li>defining a module inline (we provide the bytes and perhaps also an alias)</li>
<li>loading a stdlib module into the default namespace</li>
<li>loading a stdlib module into its own namespace</li>
<li>loading an externally-downloaded module and giving it an alias</li>
</ul>

<p>
I think for the last case, if you load a module and give it an alias
simultaneously, I don't see how an attacker can get you, as long as
it's an error trying to overwrite an alias. If the alias already
existed, you get an error, and if not, you're guaranteed the content
can't change after that point. It's only dangerous when you try to use
an alias you never attempted to create yourself.
</p>

<p>
This may at least mitigate RCE attacks, but it does still leave the
problem of aliases potentially colliding and those collisions being
hard to predict. I don't know that this is a problem unique to this
language though.
</p>

<p>
In terms of implementation details, we could leave it mostly as-is
except we need the ability to
</p>

<ul class="org-ul">
<li>load a library using an predefined alias (for stdlibs that aren't
loaded by default)</li>
<li>load libraries into the default (no) namespace</li>
</ul>

<p>
So how do we implement that? <code>inscribe</code> doesn't know or care about where
the content comes from, so we need a way of fetching from the
cache. We can check the mapping of alias-&gt;hash and if it exists,
verify a match, and if it doesn't exist, create the mapping. Since the
mapping will exist before calling <code>inscribe</code>, <code>inscribe</code> needs a way of
not creating the alias - we could do that by allowing <code>[]</code> as an alias.
</p>
</div>
</div>
<div id="outline-container-org3be0d14" class="outline-5">
<h5 id="org3be0d14"><span class="section-number-5">2.26.3.2.</span> <span class="todo INPROGRESS">INPROGRESS</span> Library loading</h5>
<div class="outline-text-5" id="text-2-26-3-2">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-17 Sat 14:51]</span></span></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org2289085"></a><span class="todo TODO">TODO</span> Make library loading primitives<br />
<ol class="org-ol">
<li><a id="org94b665d"></a><span class="done DONE">DONE</span> Move hash to earlier loading module<br />
<div class="outline-text-7" id="text-2-26-3-2-1-1">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2024-03-19 Tue 11:39]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-19 Tue 11:14]</span></span></li>
</ul>
<p>
We need it for library loading, can't stay as part of crypto lib.
</p>
</div>
</li>
<li><a id="orgbdbf611"></a><span class="done DONE">DONE</span> Primitive for namespacing a word<br />
<div class="outline-text-7" id="text-2-26-3-2-1-2">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2024-03-19 Tue 16:50]</span></span></li>
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-19 Tue 11:44]</span></span></li>
</ul>
</div>
</li>
<li><a id="org20b93b4"></a><span class="done DONE">DONE</span> Primitive for loading a blob from cache via hash or alias<br />
<div class="outline-text-7" id="text-2-26-3-2-1-3">
<ul class="org-ul">
<li>State "DONE"       from "INPROGRESS" <span class="timestamp-wrapper"><span class="timestamp">[2024-03-19 Tue 16:50]</span></span></li>
<li><p>
State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-19 Tue 16:34]</span></span>
</p>

<p>
This verifies the module being loaded from cache matches the builtin hash.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>crypto<span class="org-kcats-brackets">]</span> <span class="org-builtin">clone</span> <span class="org-function-name">unwrap</span>
decache <span class="org-builtin">swap</span> <span class="org-string">"modules"</span> encodestring hashbytes
<span class="org-builtin">swap</span> <span class="org-function-name">unwrap</span> namespaced <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>definition<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
 dictionary <span class="org-builtin">swap</span> lookup <span class="org-function-name">first</span> <span class="org-builtin">swap</span>
 hashbytes =
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">yes
</pre>
</div>

<p>
this just inscribes the module
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>pipes<span class="org-kcats-brackets">]</span> <span class="org-builtin">clone</span> <span class="org-function-name">unwrap</span>
  decache string read
  <span class="org-comment-delimiter">;;</span><span class="org-comment">inscribe</span>
  <span class="org-comment-delimiter">;;</span><span class="org-comment">[crypto] ["foo" hash] using</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>pipe-in <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span>
           <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>association <span class="org-kcats-brackets">[[[</span>type <span class="org-kcats-brackets">[</span>file<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>value file-in<span class="org-kcats-brackets">]]</span>
                                     <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>stdout<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>stdout<span class="org-kcats-brackets">]]]</span>
                        decide<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>tunnel <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span>
          <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>association <span class="org-kcats-brackets">[[[</span>type <span class="org-kcats-brackets">[</span>ip-host<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span>port<span class="org-kcats-brackets">]</span> lookup <span class="org-kcats-brackets">[[</span>address<span class="org-kcats-brackets">]</span>
                                                                                     lookup<span class="org-kcats-brackets">]</span>
                                                                <span class="org-preprocessor">dip</span> serversocket<span class="org-kcats-brackets">]]</span>
                                    <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>ip-client<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span>port<span class="org-kcats-brackets">]</span> lookup <span class="org-kcats-brackets">[[</span>address<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
                                                                  <span class="org-preprocessor">dip</span> socket<span class="org-kcats-brackets">]]]</span>
                       decide<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>pipe-out <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span>
            <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>association <span class="org-kcats-brackets">[[[</span>type <span class="org-kcats-brackets">[</span>file<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>value file-out<span class="org-kcats-brackets">]]</span>
                                      <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>ip-host<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-kcats-brackets">[</span>port<span class="org-kcats-brackets">]</span> lookup <span class="org-kcats-brackets">[[</span>address<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
                                                                  <span class="org-preprocessor">dip</span> serversocket<span class="org-kcats-brackets">]]]</span>
                         decide<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>spit <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>item <span class="org-kcats-brackets">[</span>item target<span class="org-kcats-brackets">]]</span>
               <span class="org-kcats-brackets">[]]]</span>
        <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span>pipe-in<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> encode <span class="org-function-name">put</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>slurp <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>item<span class="org-kcats-brackets">]]]</span>
         <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> fold string <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span>
                      <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>print <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]</span>
         <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[</span>standard<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-string">"\n"</span> <span class="org-function-name">join</span> encode <span class="org-function-name">put</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>sleep <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>integer<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]</span>
         <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>timer <span class="org-function-name">take</span> <span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[</span>future <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>program<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>pipe<span class="org-kcats-brackets">]]]</span>
          <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span>handoff <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dive</span> <span class="org-function-name">put</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> spawn animate<span class="org-kcats-brackets">]]</span>
          <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[</span>1 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]</span>
                       future <span class="org-function-name">take</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span>
                      <span class="org-kcats-brackets">[</span>1 <span class="org-kcats-brackets">[</span>3<span class="org-kcats-brackets">]]]]]]]</span>
 <span class="org-kcats-brackets">[</span>generator <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>program generator-maker<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[[</span>program wrapped-generator<span class="org-kcats-brackets">]]]]</span>
             <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">swap</span> <span class="org-preprocessor">inject</span> <span class="org-kcats-brackets">[[</span>generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">take</span><span class="org-kcats-brackets">]]]]]</span>
 <span class="org-kcats-brackets">[</span>siphon <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[[</span>receptacle output<span class="org-kcats-brackets">]</span>
                  <span class="org-kcats-brackets">[</span>program generator<span class="org-kcats-brackets">]]</span>
                 <span class="org-kcats-brackets">[[</span>receptacle output<span class="org-kcats-brackets">]]]]</span>
          <span class="org-kcats-brackets">[</span>description <span class="org-string">"Generates values from a wrapped generator (stacked generator inside a list), until exhausted, puts all items into the output receptacle"</span><span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>empty?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> <span class="org-kcats-brackets">[</span>generate <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
                                    <span class="org-preprocessor">dip</span> <span class="org-builtin">sink</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
                                    <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span>
                       <span class="org-preprocessor">until</span> <span class="org-builtin">drop</span> <span class="org-builtin">drop</span> <span class="org-builtin">sink</span> <span class="org-builtin">drop</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span>
          <span class="org-kcats-brackets">[</span>examples <span class="org-kcats-brackets">[[[[[</span>integers 5 taker<span class="org-kcats-brackets">]</span> generator <span class="org-kcats-brackets">[]</span> siphon<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span>
                      <span class="org-kcats-brackets">[[</span>0 1 2 3 4<span class="org-kcats-brackets">]]]]]]]</span>
 <span class="org-kcats-brackets">[</span>close <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[</span>pipe<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]]]</span>
         <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]]</span>
<span class="org-kcats-brackets">[</span>pipes<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>actual close<span class="org-kcats-brackets">]</span>
         <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>sized<span class="org-kcats-brackets">]]</span>
         <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]</span>
         <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
         <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
         <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>dictmerge <span class="org-kcats-brackets">[</span>generators<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>decache <span class="org-kcats-brackets">[]</span> <span class="org-builtin">swap</span> inscribe<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[]</span>
</pre>
</div></li>
</ul>
</div>
</li>


<li><a id="org15b2dc0"></a><span class="done CANCELED">CANCELED</span> Primitive for aliasing a module<br />
<div class="outline-text-7" id="text-2-26-3-2-1-4">
<ul class="org-ul">
<li>State "CANCELED"   from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-04-08 Mon 16:40] </span></span> <br />
Not going to use aliases.</li>
</ul>
<p>
Needs to respect the "no overwrite" rule.
</p>
</div>
</li>

<li><a id="orgb8f7cbe"></a><span class="todo TODO">TODO</span> Test out saving modules as dict entries<br />
<div class="outline-text-7" id="text-2-26-3-2-1-5">
<p>
We can think of a module as a dictionary modification program. We can
store those programs in the dictionary as definitions and use them
later? No not really, because we can't modify the current
dictionary. So there's no way to just install an alias to a module.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"123"</span> encode
<span class="org-kcats-brackets">[</span>crypto<span class="org-kcats-brackets">]</span> stdmod
<span class="org-kcats-brackets">[</span>hash<span class="org-kcats-brackets">]</span> boomerang
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM="</span>
</pre>
</div>

<p>
Ok so this is straight forward enough but what if we want to use a
module later? Do we need to reload it? We could save dictionaries but
that's not the same as saving the modules that comprise it so that
they can be combined in different ways.
</p>

<p>
In most languages, a module continues to be addressable by an alias
after you've loaded it (and doesn't result in loading it again).
</p>

<p>
A couple ways to deal with that - can store a diff instead of the
module program and just apply it. Can just reload the module every
time. Can keep the resulting dictionary somewhere (on the stack?).
</p>

<p>
Kcats is just function composition, I don't think there's any case
where more than one function needs to be available at a time. Dividing
the dictionary seems to be more of a security feature - you're saying
"this program should only need these functions but I don't know what
the lower levels try to do". In theory you could give different
dictionaries to every word of the program that consisted of all the
words that word calls, etc. So this whole system is more of a
"matching my expectations to the actual behavior" type of feature.
</p>
</div>
</li>

<li><a id="org0e07082"></a><span class="todo TODO">TODO</span> Test out nested envs as library mechanism<br />
<div class="outline-text-7" id="text-2-26-3-2-1-6">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">load a module</span>
<span class="org-kcats-brackets">[</span>crypto<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> decache string read
<span class="org-kcats-brackets">[[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>hash<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> spawn <span class="org-builtin">clone</span> evaluate

<span class="org-comment-delimiter">;;</span><span class="org-comment">boomerang</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>#b64 <span class="org-string">"LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="</span> #b64 <span class="org-string">"/N4rLtula/QIYB+3If6bXDONEO5CnqBPrlURto+/j7k="</span>
          #b64 <span class="org-string">"uqWglk0zIPvAxqkiFARTyFE+okq4/QV3A0gEqWckgJY="</span><span class="org-kcats-brackets">]]]]</span>
<span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span><span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>hash<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[]]]</span>
</pre>
</div>

<p>
So what is <code>let</code> in this model?
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>plus2 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>5 plus2<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>draft<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span>
boomerang
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">7
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-org894ed2e" class="outline-5">
<h5 id="org894ed2e"><span class="section-number-5">2.26.3.3.</span> <span class="todo INPROGRESS">INPROGRESS</span> Nesting scopes</h5>
<div class="outline-text-5" id="text-2-26-3-3">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-14 Wed 20:07]</span></span></li>
</ul>
<p>
We should be able to chain calls to <code>using</code> without repeating any
expensive calls.
</p>

<p>
That means we need a word that only modifies a program by resolving
the words in it (could call it <code>resolve</code>?)
</p>

<p>
test overriding behavior
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>+ <span class="org-kcats-brackets">[</span><span class="org-string">"oo"</span><span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"a"</span> <span class="org-string">"b"</span> +<span class="org-kcats-brackets">]</span>
let
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">Resolved: Word { data: 0x55b105c8ce50 : <span class="org-string">"+"</span>, namespace: Some(<span class="org-kcats-brackets">[</span>95, 8, 227, 46, 226, 44, 177, 198, 142, 175, 56, 167, 55, 63, 227, 254, 126, 182, 160, 134, 28, 68, 164, 57, 208, 15, 103, 59, 84, 173, 128, 139<span class="org-kcats-brackets">]</span>) }
<span class="org-kcats-brackets">[</span><span class="org-string">"oo"</span><span class="org-kcats-brackets">]</span> <span class="org-string">"b"</span> <span class="org-string">"a"</span>
</pre>
</div>

<p>
The issue is we're updating the definition but we end up keeping the
old spec and examples. we need to clear the whole entry.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>6<span class="org-kcats-brackets">]]]]</span>
<span class="org-kcats-brackets">[[</span>0<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update <span class="org-comment-delimiter">;; </span><span class="org-comment">wrap the word name to get a path to update</span>
 <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition<span class="org-kcats-brackets">]</span> label<span class="org-kcats-brackets">]</span> update <span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
<span class="org-kcats-brackets">[[</span>update<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
<span class="org-kcats-brackets">[</span>joiner<span class="org-kcats-brackets">]</span> assemble <span class="org-function-name">unwrap</span>  inscribe
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>actual <span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span>6<span class="org-kcats-brackets">]]]]]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>program<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"type mismatch"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>update dictmerge <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> using<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span>6<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> dictionary_redacted #b64 <span class="org-string">"DFyCLJSxw6T5kHmcZ0+a4jZT0gNq29vn/BE9oKcRSTU="</span>
foo
</pre>
</div>

<p>
ok this is too rigid, let's get rid of revise/draft in their current
terms and make words that bulld what <code>inscribe</code> needs.
</p>

<p>
After some internal debate, i think it's best to have inscribe take a
single update program - rationale is that there's no need at that
point to treat them separately, that can be done before.
</p>

<p>
So inscribe is currently correct, we need to &#x2026; revise <code>revise</code>. First
thing is a function that takes a list of word updates and translates
to a single dictionary update.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[[</span>definition <span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]]</span>
          <span class="org-kcats-brackets">[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]]]]]]</span>
<span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>0<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update <span class="org-comment-delimiter">;; </span><span class="org-comment">wrap the word name to get a path to update</span>
  <span class="org-kcats-brackets">[</span>update<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> each
 joiner generate<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span> 
inscribe
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">Resolved: Word { data: 0x56294637f420 : <span class="org-string">"swap"</span>, namespace: Some(<span class="org-kcats-brackets">[</span>59, 133, 203, 149, 9, 0, 17, 144, 86, 83, 103, 44, 36, 226, 184, 25, 62, 38, 28, 127, 173, 154, 55, 144, 71, 243, 173, 235, 59, 37, 10, 18<span class="org-kcats-brackets">]</span>) }
6
</pre>
</div>

<p>
Now we need a shortcut for when we don't want to specify the whole entry, just the definition
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>entry<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
updates inscribe <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">6
</pre>
</div>

<p>
Test draft
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span>6<span class="org-kcats-brackets">]]]</span> draft <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]</span> let
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">6
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>bar <span class="org-kcats-brackets">[</span><span class="org-string">"hi"</span><span class="org-kcats-brackets">]]]</span> draft inscribe
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">foo
</pre>
</div>

<p>
Ok this is all seems to be in order, there's now a problem in the
stdlib where a word calls <code>let</code> and defines some local functions, eg
<code>partition</code>. What we actually need is to do <code>resolve</code> as the stdlib is
being built, perhaps defining <code>partition</code> in its own little module, and
then resolving the module once. Something like this:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">functions partition uses</span>
<span class="org-kcats-brackets">[</span>partition<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span> <span class="org-kcats-brackets">[[</span>taker collect
         <span class="org-builtin">dropdown</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">; </span><span class="org-comment">drop the used-up taker generator</span>
        <span class="org-function-name">join</span> divedeep<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>shift <span class="org-kcats-brackets">[[[</span><span class="org-function-name">count</span> &lt;=<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> 0 slice<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[[]]</span> <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span> 
<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>entry<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
<span class="org-kcats-brackets">[</span>partition<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>spec <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>program<span class="org-kcats-brackets">]]]</span>
             <span class="org-kcats-brackets">[</span>definition <span class="org-kcats-brackets">[[]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">state</span>
                          <span class="org-comment-delimiter">;; </span><span class="org-comment">the generator</span>
                          <span class="org-kcats-brackets">[[[]</span>
                            <span class="org-kcats-brackets">[</span>over <span class="org-function-name">wrap</span> <span class="org-function-name">take</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> shift<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span>
                            <span class="org-kcats-brackets">[[</span>over<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dive</span> <span class="org-function-name">wrap</span> <span class="org-function-name">take</span> <span class="org-builtin">swap</span> <span class="org-builtin">drop</span> shift<span class="org-kcats-brackets">]</span>
                            <span class="org-preprocessor">if</span><span class="org-kcats-brackets">]]]]]</span> assign
updates inscribe

</pre>
</div>
</div>
</div>

<div id="outline-container-org7ba3199" class="outline-5">
<h5 id="org7ba3199"><span class="section-number-5">2.26.3.4.</span> <span class="todo TODO">TODO</span> Stack escape protection</h5>
<div class="outline-text-5" id="text-2-26-3-4">
<p>
If a program refers to a word, and at the time that program is put on
the stack, that word means something, it should still carry the same
meaning if that program is later run with <code>execute</code>. That means that
module changes must be permanent.
</p>
</div>
</div>
<div id="outline-container-org2a570be" class="outline-5">
<h5 id="org2a570be"><span class="section-number-5">2.26.3.5.</span> <span class="todo INPROGRESS">INPROGRESS</span> Sandboxing support</h5>
<div class="outline-text-5" id="text-2-26-3-5">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-04-03 Wed 20:41]</span></span></li>
</ul>
<p>
It must be possible for a module to <b>deny</b> access to a given word. Given
that dictionary changes are permanent, we can't just delete words from
the dictionary (once the given program is done, that word needs to be
available again somehow).
</p>

<p>
We can implement this with some sort of shadowing mechanism during
resolving: If we "delete" a word, we could actually define the word in
the module's namespace, such that all it does is throw a 'no such
word' error. That's one somewhat hacky way to implement it, but there
may be others.
</p>

<ul class="org-ul">
<li>There should be no way for code using the module to access the
"deleted" word. (Check for escape hatches via arbitrary dictionary
modification)</li>
<li>The word should be accessible again after the program using the
module has completed.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org7bfacc4"></a><span class="todo TODO">TODO</span> experiment with nested envs as module loading mechanism<br />
<div class="outline-text-6" id="text-2-26-3-5-1">
<p>
First let's see if a nested env allows sandboxing
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">make an env with no access to io</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">load the functional module code</span>
<span class="org-kcats-brackets">[</span>functional<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> decache string read

<span class="org-comment-delimiter">;; </span><span class="org-comment">get the current dictionary and modify it</span>
<span class="org-kcats-brackets">[</span>dictionary<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">execute</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Now create a new env with this dictionary and execute it</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"hi"</span> print<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>program dictionary<span class="org-kcats-brackets">]</span> label environment evaluate
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>asked <span class="org-kcats-brackets">[</span>standard<span class="org-kcats-brackets">]]</span>
          <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>reason <span class="org-string">"word is not defined"</span><span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>standard <span class="org-kcats-brackets">[</span><span class="org-string">"hi"</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> <span class="org-string">"\n"</span> <span class="org-function-name">join</span> encode <span class="org-function-name">put</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]]]]]</span>
</pre>
</div>

<p>
Yes!
</p>

<p>
Ok now let's make a word that takes a module and a program, builds a
new env.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"foo"</span> <span class="org-kcats-brackets">[</span>bar<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>plus2 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>entry<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
<span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span>
<span class="org-kcats-brackets">[</span>5 plus2<span class="org-kcats-brackets">]</span>
spawn
<span class="org-comment-delimiter">;</span><span class="org-comment">dictionary</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">float shielddown [dictionary program] label environment</span>
evaluate <span class="org-kcats-brackets">[</span>stack<span class="org-kcats-brackets">]</span> lookup restore
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">7 <span class="org-kcats-brackets">[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-string">"foo"</span>
</pre>
</div>

<p>
Also, for debugging purposes it would seem we need a way of running
eval-step (outer) in a loop - perhaps an axiom that checks if the
program is empty, if not eval-step it and place eval-step back in the
program? Slightly better than a <code>loop</code> impl. Maybe it's ok for now.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 2 3 +<span class="org-kcats-brackets">]]]</span> environment eval-<span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>2 3 +<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<p>
Let's see if it's possible to use an inner-env module and still debug it.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">the program we want to debug in the top level</span>
<span class="org-kcats-brackets">[</span>10 11
 <span class="org-kcats-brackets">[[</span>plus2 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]]]</span> draft inscribe
 <span class="org-kcats-brackets">[</span>plus2<span class="org-kcats-brackets">]</span> confine<span class="org-kcats-brackets">]</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">TODO: the issue here is that we can't just eval-step once, We have</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">to make the next instruction also eval-step (unless the program is</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">already empty)</span>
<span class="org-kcats-brackets">[[</span>evaluate definition<span class="org-kcats-brackets">]</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">The inner env debugger - when we call `confine`, it's going to</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">call `evaluate`, which will not allow us to step through the inner</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">env's execution. In order to do that, we have to just eval-step</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">it. Instead of running evaluate as a single atomic word we just</span>
 <span class="org-comment-delimiter">;; </span><span class="org-comment">make a kcats version of it.</span>
 <span class="org-kcats-brackets">[[[</span>program<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">while</span><span class="org-kcats-brackets">]</span> assign<span class="org-kcats-brackets">]</span> inscribe  
<span class="org-builtin">swap</span>
spawn <span class="org-kcats-brackets">[</span>advance<span class="org-kcats-brackets">]</span> 7 <span class="org-preprocessor">times</span> advance
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[]]</span>
 <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>13 10<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">the program we want to debug in the top level</span>
10 11
<span class="org-kcats-brackets">[[</span>plus2 <span class="org-kcats-brackets">[</span>2 +<span class="org-kcats-brackets">]]]</span> draft inscribe
<span class="org-kcats-brackets">[</span>plus2<span class="org-kcats-brackets">]</span> confine
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">13 10
</pre>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-org9a10034" class="outline-5">
<h5 id="org9a10034"><span class="section-number-5">2.26.3.6.</span> <span class="todo INPROGRESS">INPROGRESS</span> Access control</h5>
<div class="outline-text-5" id="text-2-26-3-6">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-04-07 Sun 13:53]</span></span></li>
</ul>
<p>
Take the word <code>define</code> which allows the caller to make arbitrary and
permanent changes to the dictionary. What if we wanted to restrict
access to that word such that authorized programs can call it but
others can't?
</p>
</div>
</div>
<div id="outline-container-org7da2d7e" class="outline-5">
<h5 id="org7da2d7e"><span class="section-number-5">2.26.3.7.</span> <span class="todo INPROGRESS">INPROGRESS</span> Words can refer to other words in the same library</h5>
<div class="outline-text-5" id="text-2-26-3-7">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-17 Sat 14:51]</span></span></li>
</ul>
</div>
</div>
<div id="outline-container-orgee92271" class="outline-5">
<h5 id="orgee92271"><span class="section-number-5">2.26.3.8.</span> <span class="todo TODO">TODO</span> Convenient module definition</h5>
<div class="outline-text-5" id="text-2-26-3-8">
<p>
We need a word that takes care of the common case: we want to define a
set of vocabulary, it's all additive, and some of the words refer to
each other. Previously we called that <code>draft</code>. Here's what the new <code>draft</code>
could look like, it breaks down into generating dictionary updates:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>spec definition<span class="org-kcats-brackets">]</span> label<span class="org-kcats-brackets">]</span>
 update
 <span class="org-kcats-brackets">[</span>cube<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-builtin">clone</span> square *<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>number<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>number<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>spec definition<span class="org-kcats-brackets">]</span> label<span class="org-kcats-brackets">]</span>
 update<span class="org-kcats-brackets">]</span>

  encode <span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> inscribe
</pre>
</div>

<p>
So we want the user to be able to write this:
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>cube <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> square *<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>0<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update
  <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition<span class="org-kcats-brackets">]</span> label <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
 <span class="org-kcats-brackets">[[</span>update<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
<span class="org-kcats-brackets">[</span>joiner<span class="org-kcats-brackets">]</span> assemble <span class="org-function-name">unwrap</span> encode<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">under the module name</span>
<span class="org-function-name">unwrap</span> inscribe
<span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>6 cube<span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">216
</pre>
</div>

<p>
can we recurse?
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>square <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>cube <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> square *<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>factorial <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> positive?<span class="org-kcats-brackets">]</span>
             <span class="org-kcats-brackets">[[</span>*<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span> <span class="org-kcats-brackets">[</span>dec<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> factorial<span class="org-kcats-brackets">]</span>
             when<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>0<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update
  <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>definition<span class="org-kcats-brackets">]</span> label <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
 <span class="org-kcats-brackets">[[</span>update<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
<span class="org-kcats-brackets">[</span>joiner<span class="org-kcats-brackets">]</span> assemble <span class="org-function-name">unwrap</span> encode<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">under the module name</span>
<span class="org-function-name">unwrap</span> <span class="org-comment-delimiter">; </span><span class="org-comment">inscribe</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">[math] [6 1 factorial dropdown] resolve [2] lookup inspect</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">720
</pre>
</div>

<p>
let's see if we can make revise first
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>f<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>fff <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]]</span> draft

<span class="org-kcats-brackets">[</span>hh<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>hash <span class="org-kcats-brackets">[[</span>type <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span>
         <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> fff hash<span class="org-kcats-brackets">]</span>
         addmethod <span class="org-kcats-brackets">[</span>f<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> resolve<span class="org-kcats-brackets">]]]</span> revise

<span class="org-kcats-brackets">[</span>hh<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>foo myfoo<span class="org-kcats-brackets">]]</span> association hash<span class="org-kcats-brackets">]</span> using

<span class="org-string">"foo"</span> hash =
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">yes
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>ff<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>f <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]]</span> draft

<span class="org-kcats-brackets">[</span>gg<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>g <span class="org-kcats-brackets">[[</span>ff<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>f<span class="org-kcats-brackets">]</span> resolve<span class="org-kcats-brackets">]]]</span>
revise

<span class="org-kcats-brackets">[</span>gg<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>g<span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"foo"</span>
</pre>
</div>


<p>
lets see if the draft in terms of revise works
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>square <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>cube <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> square *<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>factorial <span class="org-kcats-brackets">[[</span><span class="org-builtin">swap</span> positive?<span class="org-kcats-brackets">]</span>
             <span class="org-kcats-brackets">[[</span>*<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span> <span class="org-kcats-brackets">[</span>dec<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> factorial<span class="org-kcats-brackets">]</span>
             when<span class="org-kcats-brackets">]]]</span> draft

<span class="org-kcats-brackets">[</span>math<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>6 1 factorial <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">720
</pre>
</div>

<p>
Test if we can use resolve before a draft, to refer to existing
modules within a module. Now this works because inscribe can take
either serialized bytes or a parsed datastructure. If we pass the
latter, it can have words already resolved.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>innermodule<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>innerfn <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]]</span> draft

<span class="org-kcats-brackets">[</span>outermodule<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>innermodule<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>outerfn <span class="org-kcats-brackets">[</span>innerfn<span class="org-kcats-brackets">]]]</span> resolve
draft

<span class="org-kcats-brackets">[</span>outermodule<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>outerfn<span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-string">"foo"</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span>innermodule<span class="org-kcats-brackets">]</span>
           <span class="org-kcats-brackets">[[</span>innerfn <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]]</span> draft

           <span class="org-kcats-brackets">[</span>outermodule<span class="org-kcats-brackets">]</span>
           <span class="org-kcats-brackets">[[</span>outerfn <span class="org-kcats-brackets">[[</span>innermodule<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>innerfn<span class="org-kcats-brackets">]</span> resolve<span class="org-kcats-brackets">]]]</span> 
           revise

           <span class="org-kcats-brackets">[</span>outermodule<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>outerfn<span class="org-kcats-brackets">]</span> using
          <span class="org-kcats-brackets">]]]</span> environment
<span class="org-kcats-brackets">[</span>advance<span class="org-kcats-brackets">]</span> 10 <span class="org-preprocessor">times</span> 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span><span class="org-string">"foo"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">
<span class="org-kcats-brackets">[[</span>fiver <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>12 fiver<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[[</span>0<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">add an alias (0 means don't bother with creating the alias)</span>
 <span class="org-kcats-brackets">[</span>entry<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">create full entries for each definition</span>
 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">add 'join' to join the entries with the existing dictionary</span>
 inscribe <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">update dict and then wrap the hash as the module to be used </span>
using <span class="org-comment-delimiter">;; </span><span class="org-comment">execute the program </span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">17
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb9a0724" class="outline-5">
<h5 id="orgb9a0724"><span class="section-number-5">2.26.3.9.</span> <span class="todo TODO">TODO</span> convenient 'let'</h5>
<div class="outline-text-5" id="text-2-26-3-9">
<p>
We want define a module and use it inline without having to worry about its alias.
Let's see if we can implement <code>partition</code> this way.
</p>
<div class="org-src-container">
<pre class="src src-kcats">
<span class="org-comment-delimiter">;; </span><span class="org-comment">the module</span>

<span class="org-kcats-brackets">[[</span>square <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> *<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>cube <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> square *<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>9 cube<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span> <span class="org-builtin">sink</span> <span class="org-kcats-brackets">[</span>draft <span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> using 
<span class="org-comment-delimiter">; </span><span class="org-comment">[</span>
<span class="org-comment-delimiter">;  </span><span class="org-comment">[[]</span>
<span class="org-comment-delimiter">;   </span><span class="org-comment">[over wrap take [join shift] bail]</span>
<span class="org-comment-delimiter">;   </span><span class="org-comment">[[over] dive wrap take swap drop shift]</span>
<span class="org-comment-delimiter">;   </span><span class="org-comment">if]</span>
<span class="org-comment-delimiter">;  </span><span class="org-comment">draft]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">729
</pre>
</div>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[[</span>foo <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> revise<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">execute</span> <span class="org-comment-delimiter">;</span><span class="org-comment">tracer 100 taker collect</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[[</span>foo <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span>  <span class="org-function-name">map</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>foo <span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]]]]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b781ac" class="outline-5">
<h5 id="org4b781ac"><span class="section-number-5">2.26.3.10.</span> <span class="todo INPROGRESS">INPROGRESS</span> Break up the standard library</h5>
<div class="outline-text-5" id="text-2-26-3-10">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-04 Mon 20:22]</span></span></li>
</ul>
<p>
Question: how do we break it up? For example, does <code>io</code> refer to all I/O
operations or just the base stuff that they all depend on?
</p>

<p>
Some areas of functionality that already exist:
</p>
<ul class="org-ul">
<li>Debugger</li>
<li>Generators</li>
<li>Pipes
<ul class="org-ul">
<li>File</li>
<li>Network</li>
<li>Channel</li>
</ul></li>
<li>Encoding</li>
<li>Associations</li>
<li>Collections</li>
</ul>

<p>
There seem to be 3 types of modules:
</p>
<ul class="org-ul">
<li>Stuff that's part of the core functionality (can't do basic language
stuff without it, should be part of the binary). Could be up to and
including what's needed to call inscribe/using, which allows callers
to load their own modules.</li>
<li>Not core but can still be in the default namespace because it likely
doesn't collide with other stuff (io, nested env etc)</li>
<li>Stuff that's not used often enough to be in default namespace, or is
easy enough to refer in when needed (crypto, debugger)</li>
</ul>

<p>
The 2nd type, we can now use "inscribe" and make them normal modules,
but then they won't be in the default namespace. We can at least leave
them out of the binary. 
</p>
</div>
<ol class="org-ol">
<li><a id="orgce2d5db"></a><span class="todo INPROGRESS">INPROGRESS</span> Figure out where to put modules on disk<br />
<div class="outline-text-6" id="text-2-26-3-10-1">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-04 Mon 20:22]</span></span></li>
</ul>
<p>
This will make the build and packaging more complex as it will have to
include other files besides the binary and deal with platform-specific
issues. The standard env could, however, still load a bunch of libs,
but maybe this could be overridden with cmdline args.
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-builtin">clone</span> <span class="org-function-name">unwrap</span> decache inscribe<span class="org-kcats-brackets">]]]</span> environment <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span> collect
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">Warning, failed to insert into dictionary: Dispenser(Sized(List(<span class="org-kcats-brackets">[</span>Int(5), Word(Word { data: 0x55782137afc0 : <span class="org-string">"+"</span>, namespace: None })<span class="org-kcats-brackets">]</span>)))
Warning: empty local module
<span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-function-name">unwrap</span> decache inscribe<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> decache inscribe<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>decache inscribe<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>foo <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>inscribe<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>#b64 <span class="org-string">"W1tiYXJdIFs1ICtdIGFzc2lnbl0="</span> <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
             assign<span class="org-kcats-brackets">]</span>
            <span class="org-preprocessor">shielddown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shielddown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">shield</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span><span class="org-builtin">snapshot</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                      assign<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">snapshot</span> <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                       assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                                          assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                                       assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[]</span> dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                                 assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
           foo<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                           assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
           foo<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
                     assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
            foo<span class="org-kcats-brackets">]]</span> dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
              assign<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
           foo<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
            assign<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
                      foo<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">inject</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]</span> dictionary_redacted
          #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-builtin">evert</span> <span class="org-function-name">take</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]</span> dictionary_redacted
          #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-function-name">take</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
           foo<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
            assign<span class="org-kcats-brackets">]</span>
           dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
           assign<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]</span> dictionary_redacted
          #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span>
            assign <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
                     foo<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span>5 +<span class="org-kcats-brackets">]</span>
            assign <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
                     foo<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>bar<span class="org-kcats-brackets">]</span> dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>assign <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
                     foo<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>5 +<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>bar<span class="org-kcats-brackets">]</span> dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
              foo<span class="org-kcats-brackets">]]</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> <span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
            foo<span class="org-kcats-brackets">]]</span> dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
           foo<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
           foo<span class="org-kcats-brackets">]</span>
          dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span> foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-builtin">drop</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>dictmerge<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>dictionary_redacted #b64 <span class="org-string">"mz5w5sBIFt1413HhyrFOWKaa8MhJFlgZE/PeBAiaz40="</span>
          foo<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]]]]</span>
<span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>crypto-builtins<span class="org-kcats-brackets">]</span> <span class="org-builtin">clone</span> <span class="org-function-name">unwrap</span> decache
string read
<span class="org-kcats-brackets">[[</span>1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> update<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">wrap the definition so update leaves the literal value</span>
updates inscribe
<span class="org-function-name">wrap</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">the module alias</span>
<span class="org-kcats-brackets">[</span><span class="org-string">"foobar"</span> encode hashbytes<span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">#b64 <span class="org-string">"Zm9vYmFy"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[[</span>baryyyy<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>5 +<span class="org-kcats-brackets">]</span> assign<span class="org-kcats-brackets">]</span> inscribe <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>6 baryyyy<span class="org-kcats-brackets">]</span> using
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">Warning, failed to insert into dictionary: Dispenser(Sized(List(<span class="org-kcats-brackets">[</span>Int(5), Word(Word { data: 0x55a8be888030 : <span class="org-string">"+"</span>, namespace: None })<span class="org-kcats-brackets">]</span>)))
Warning: empty local module
<span class="org-kcats-brackets">[[</span>asked <span class="org-kcats-brackets">[</span>baryyyy<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"word is not defined"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>baryyyy<span class="org-kcats-brackets">]]]</span>
6
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>foo<span class="org-kcats-brackets">]</span>  <span class="org-kcats-brackets">[</span>bar<span class="org-kcats-brackets">]</span> resolve
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>actual foo<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>resolve<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"module not found"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>unwound <span class="org-kcats-brackets">[</span>resolve<span class="org-kcats-brackets">]]]</span>
</pre>
</div>
</div>
</li>
<li><a id="org8c482ee"></a><span class="todo INPROGRESS">INPROGRESS</span> Move core libs back to using include<sub>bytes</sub><br />
<div class="outline-text-6" id="text-2-26-3-10-2">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-14 Thu 17:11]</span></span></li>
</ul>
</div>
</li>
<li><a id="orgcc93d86"></a><span class="todo INPROGRESS">INPROGRESS</span> Figure out what to do about builtins<br />
<div class="outline-text-6" id="text-2-26-3-10-3">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-04 Mon 20:22]</span></span></li>
</ul>
</div>
</li>
<li><a id="org6c3f6e5"></a><span class="todo INPROGRESS">INPROGRESS</span> Group functions<br />
<div class="outline-text-6" id="text-2-26-3-10-4">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-02-27 Tue 11:58]</span></span></li>
</ul>
</div>
</li>
<li><a id="org58fe364"></a><span class="todo INPROGRESS">INPROGRESS</span> Determine module loading order<br />
<div class="outline-text-6" id="text-2-26-3-10-5">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-03-04 Mon 20:22]</span></span></li>
<li>stack ops builtins [drop clone evert]</li>
<li>stack motion builtins [swap swapdown float sink]</li>
<li>stack motion [flip] (only depends on own builtins)</li>
<li>collection builtins [join put count first step take wrap unwrap &#x2026;]</li>
<li>execution builtins [dip execute branch recur loop decide]</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgd8c1295" class="outline-5">
<h5 id="orgd8c1295"><span class="section-number-5">2.26.3.11.</span> <span class="done CANCELED">CANCELED</span> Disallow module alias overwriting</h5>
<div class="outline-text-5" id="text-2-26-3-11">
<ul class="org-ul">
<li>State "CANCELED"   from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2024-04-07 Sun 13:53] </span></span> <br />
We're not going to be using aliases in this branch</li>
</ul>
<p>
It is a security problem to allow code to overwrite some other code's
alias for a module. Throw an error in this case. We should call insert
on the aliases, and if it returns something, it better be equal to
what we inserted.
</p>
</div>
</div>
<div id="outline-container-org9be3a33" class="outline-5">
<h5 id="org9be3a33"><span class="section-number-5">2.26.3.12.</span> <span class="todo TODO">TODO</span> Store data sources</h5>
<div class="outline-text-5" id="text-2-26-3-12">
<p>
When we load modules we will eventually be getting them from the
network but for now the stdlib needs to be loaded from disk.  So we
could just always look there by default, i guess. But if we need to
allow custom sources, we could add that alongside the aliases
</p>
</div>
</div>
<div id="outline-container-org00bde3a" class="outline-5">
<h5 id="org00bde3a"><span class="section-number-5">2.26.3.13.</span> <span class="todo TODO">TODO</span> Find stdlib by alias</h5>
<div class="outline-text-5" id="text-2-26-3-13">
</div>
<ol class="org-ol">
<li><a id="org1297754"></a><span class="todo TODO">TODO</span> hardcode the aliases in the source<br /></li>
</ol>
</div>
<div id="outline-container-org6820103" class="outline-5">
<h5 id="org6820103"><span class="section-number-5">2.26.3.14.</span> <span class="todo TODO">TODO</span> LIbrary loading should be in order of decreasing trust</h5>
<div class="outline-text-5" id="text-2-26-3-14">
<p>
We shouldn't start with a standard env with access to the
filesystem. Instead the standard env should lack IO capability, and
force that to be loaded in an inner env.
</p>

<p>
So instead of dropping back to a functional env, we start with one and
load io capability when needed.
</p>

<p>
Questions:
</p>
<ul class="org-ul">
<li>How do we decide what "less trusted" means?</li>
<li>Does decreasing trust make sense?</li>
<li>Does that mean we should never need to delete words? Seems like
sometimes we might.</li>
</ul>

<p>
Decreasing trust seems to make sense, since you can't make a
trustworthy construct out of an untrusted, only vice versa.
</p>

<p>
What makes an env less trusted than its parent? Is it the additional
words? Is it just that any additional code requires more trust, since
it needs to be vetted?
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org903930d" class="outline-3">
<h3 id="org903930d"><span class="section-number-3">2.27.</span> <span class="todo INPROGRESS">INPROGRESS</span> Database</h3>
<div class="outline-text-3" id="text-2-27">
<ul class="org-ul">
<li>State "INPROGRESS" from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-31 Sun 10:17]</span></span></li>
</ul>
</div>
<div id="outline-container-org8799ee6" class="outline-4">
<h4 id="org8799ee6"><span class="section-number-4">2.27.1.</span> Books db</h4>
<div class="outline-text-4" id="text-2-27-1">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"George"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Orwell"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"1984"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1949<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>government dystopia surveillance totalitarianism freedom<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Aldous"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Huxley"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Brave New World"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1932<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>society technology dystopia happiness drugs<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"F. Scott"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Fitzgerald"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Great Gatsby"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1925<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>wealth love obsession american-dream tragedy<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"J.D."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Salinger"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Catcher in the Rye"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1951<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adolescence alienation innocence society adulthood<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Jane"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Austen"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Pride and Prejudice"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1813<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>love marriage society class reputation<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Mary"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Shelley"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Frankenstein"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1818<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>creation science responsibility monster humanity<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"John"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Steinbeck"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Of Mice and Men"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1937<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>friendship dream loneliness society tragedy<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Ernest"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Hemingway"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Old Man and the Sea"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1952<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>endurance nature old-age fisherman sea<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Harper"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Lee"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"To Kill a Mockingbird"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1960<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>racism innocence morality law childhood<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"J.R.R."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Tolkien"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Lord of the Rings"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1954<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adventure elf dwarf hobbit ring journey magic evil<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Joseph"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Conrad"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Heart of Darkness"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1899<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>colonization africa journey morality darkness europeans<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Leo"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Tolstoy"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"War and Peace"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1869<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>war peace society history love aristocracy<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Homer"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Odyssey"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year -800<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>journey odyssey homecoming gods heroism adventure<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Charlotte"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Bronte"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Jane Eyre"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1847<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>love morality society class womanhood independence<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Mark"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Twain"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Adventures of Huckleberry Finn"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1884<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adventure racism slavery morality friendship river<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Ray"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Bradbury"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Fahrenheit 451"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1953<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>censorship knowledge books society dystopia future<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Charles"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Dickens"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"A Tale of Two Cities"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1859<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>revolution love sacrifice resurrection society history<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"William"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Golding"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Lord of the Flies"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1954<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>society civilization savagery childhood morality island<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Miguel de"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Cervantes"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Don Quixote"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1605<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adventure idealism reality knight insanity literature<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"H.G."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Wells"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The War of the Worlds"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1898<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>invasion aliens society technology war humanity<span class="org-kcats-brackets">]]]</span>

</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats">db <span class="org-kcats-brackets">[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[[</span>type <span class="org-kcats-brackets">[</span>book<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> =<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[[</span>publishYear<span class="org-kcats-brackets">]</span> lookup 1940 &gt;=<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span>
keep
</pre>
</div>
</div>
</div>
<div id="outline-container-org0442e28" class="outline-4">
<h4 id="org0442e28"><span class="section-number-4">2.27.2.</span> EAVTO (entity, attribute, value, time, observer)</h4>
<div class="outline-text-4" id="text-2-27-2">
<p>
Here's a database of the most basic and abstract observations
(ignoring time and observer for now - those are all "now" and "me").
</p>

<p>
Down to a certain level, all attributes are also entities of their
own, but at some point they have to be either axiomatic or
circular. In the table below <code>type</code> and <code>format</code> are axiomatic.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Entity</th>
<th scope="col" class="org-left">Attribute</th>
<th scope="col" class="org-left">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-left">street</td>
<td class="org-left">123 Fake St</td>
</tr>

<tr>
<td class="org-left">Alice</td>
<td class="org-left">email</td>
<td class="org-left">alice@alice.com</td>
</tr>

<tr>
<td class="org-left">Alice</td>
<td class="org-left">birthdate</td>
<td class="org-left">1/1/1980</td>
</tr>

<tr>
<td class="org-left">street</td>
<td class="org-left">type</td>
<td class="org-left">attribute</td>
</tr>

<tr>
<td class="org-left">street</td>
<td class="org-left">format</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">email</td>
<td class="org-left">type</td>
<td class="org-left">attribute</td>
</tr>

<tr>
<td class="org-left">email</td>
<td class="org-left">format</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">birthdate</td>
<td class="org-left">type</td>
<td class="org-left">attribute</td>
</tr>

<tr>
<td class="org-left">birthdate</td>
<td class="org-left">format</td>
<td class="org-left">integer</td>
</tr>

<tr>
<td class="org-left">Alice</td>
<td class="org-left">relationship</td>
<td class="org-left">Bob</td>
</tr>

<tr>
<td class="org-left">Alice-Bob</td>
<td class="org-left">type</td>
<td class="org-left">relationship</td>
</tr>

<tr>
<td class="org-left">Alice-Bob</td>
<td class="org-left">nature</td>
<td class="org-left">friends</td>
</tr>

<tr>
<td class="org-left">Alice-Bob</td>
<td class="org-left">trust</td>
<td class="org-left">5/10</td>
</tr>
</tbody>
</table>

<p>
Let's create an EAV table
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"CREATE TABLE EAV</span>
<span class="org-string">( Entity STRING,</span>
<span class="org-string">  Attribute STRING,</span>
<span class="org-string">  Value</span>
<span class="org-string">   );"</span> <span class="org-kcats-brackets">[]</span> database 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"DROP TABLE EAV;"</span> <span class="org-kcats-brackets">[]</span> database 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Create indices (should really do this for all the columns)
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"CREATE INDEX idx_entity ON EAV (Entity);</span>
<span class="org-string">CREATE INDEX idx_attribute ON EAV (Attribute);</span>
<span class="org-string">CREATE INDEX idx_valuestring ON EAV (ValueString);</span>
<span class="org-string">"</span> <span class="org-kcats-brackets">[]</span> database
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>name <span class="org-string">"Butters"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>type dog<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>weight 59.1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>breed <span class="org-kcats-brackets">[</span>shepherd labrador<span class="org-kcats-brackets">]]]</span> <span class="org-kcats-brackets">[</span>breed<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>set<span class="org-kcats-brackets">]</span> update persist
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>name <span class="org-string">"Butters"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type dog<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>weight 59.1<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>breed <span class="org-kcats-brackets">[</span>shepherd labrador<span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span>breed<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>set<span class="org-kcats-brackets">]</span> update persist
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"select * from EAV where Attribute=:attr;"</span> <span class="org-kcats-brackets">[[</span><span class="org-string">":attr"</span> name<span class="org-kcats-brackets">]]</span> database
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>Entity #b64 <span class="org-string">"oGAP/g0nSc6LRwQJJti3HA=="</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>Value <span class="org-string">"Butters"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>Attribute name<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<p>
Insert some data
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"George"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Orwell"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"1984"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1949<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>government dystopia surveillance totalitarianism freedom<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Aldous"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Huxley"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Brave New World"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1932<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>society technology dystopia happiness drugs<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"F. Scott"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Fitzgerald"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Great Gatsby"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1925<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>wealth love obsession american-dream tragedy<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"J.D."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Salinger"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Catcher in the Rye"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1951<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adolescence alienation innocence society adulthood<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Jane"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Austen"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Pride and Prejudice"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1813<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>love marriage society class reputation<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Mary"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Shelley"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Frankenstein"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1818<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>creation science responsibility monster humanity<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"John"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Steinbeck"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Of Mice and Men"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1937<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>friendship dream loneliness society tragedy<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Ernest"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Hemingway"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Old Man and the Sea"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1952<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>endurance nature old-age fisherman sea<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Harper"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Lee"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"To Kill a Mockingbird"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1960<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>racism innocence morality law childhood<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"J.R.R."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Tolkien"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Lord of the Rings"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1954<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adventure elf dwarf hobbit ring journey magic evil<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Joseph"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Conrad"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Heart of Darkness"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1899<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>colonization africa journey morality darkness europeans<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Leo"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Tolstoy"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"War and Peace"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1869<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>war peace society history love aristocracy<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Homer"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Odyssey"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year -800<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>journey odyssey homecoming gods heroism adventure<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Charlotte"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Bronte"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Jane Eyre"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1847<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>love morality society class womanhood independence<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Mark"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Twain"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Adventures of Huckleberry Finn"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1884<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adventure racism slavery morality friendship river<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Ray"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Bradbury"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Fahrenheit 451"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1953<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>censorship knowledge books society dystopia future<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Charles"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Dickens"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"A Tale of Two Cities"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1859<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>revolution love sacrifice resurrection society history<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"William"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Golding"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Lord of the Flies"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1954<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>society civilization savagery childhood morality island<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"Miguel de"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Cervantes"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"Don Quixote"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1605<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>adventure idealism reality knight insanity literature<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>author-<span class="org-function-name">first</span> <span class="org-string">"H.G."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> <span class="org-string">"Wells"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>title <span class="org-string">"The War of the Worlds"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>year 1898<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>subjects <span class="org-kcats-brackets">[</span>invasion aliens society technology war humanity<span class="org-kcats-brackets">]]]]</span>
<span class="org-kcats-brackets">[[</span>subjects<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>set<span class="org-kcats-brackets">]</span> update persist<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span><span class="org-function-name">first</span>-name <span class="org-string">"George"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Orwell"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1903<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1950<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Nobel Prize in Literature"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Aldous"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Huxley"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1894<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1963<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Humanitarian Award"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"F. Scott"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Fitzgerald"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1896<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1940<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Pulitzer Prize"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"J.D."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Salinger"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1919<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 2010<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Jane"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Austen"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1775<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1817<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex f<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Mary"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Shelley"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1797<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1851<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex f<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"John"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Steinbeck"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1902<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1968<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Nobel Prize in Literature"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Ernest"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Hemingway"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1899<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1961<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Nobel Prize in Literature"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Harper"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Lee"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1926<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 2016<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex f<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Pulitzer Prize"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"J.R.R."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Tolkien"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1892<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1973<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Joseph"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Conrad"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"Poland"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1857<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1924<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Leo"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Tolstoy"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"Russia"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1828<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1910<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Homer"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">""</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"Greece"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year -800<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year -701<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Charlotte"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Bronte"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1816<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1855<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex f<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Mark"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Twain"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1835<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1910<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Ray"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Bradbury"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United States"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1920<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 2012<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Charles"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Dickens"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1812<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1870<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"William"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Golding"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1911<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1993<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[</span><span class="org-string">"Nobel Prize in Literature"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"Miguel de"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Cervantes"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"Spain"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1547<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1616<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]</span>
 <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span>-name <span class="org-string">"H.G."</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span>-name <span class="org-string">"Wells"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>country <span class="org-string">"United Kingdom"</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>birth-year 1866<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>death-year 1946<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>sex m<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>awards <span class="org-kcats-brackets">[]]]]</span>
<span class="org-kcats-brackets">[[</span>awards<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>set<span class="org-kcats-brackets">]</span> update persist<span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span> <span class="org-kcats-brackets">[]</span>
</pre>
</div>

<p>
Find book title/author that are about "adventure".
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>book? subjects adventure<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>book? title title?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>book? author-<span class="org-function-name">last</span> author?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[</span>title? author?<span class="org-kcats-brackets">]</span>
</pre>
</div>

<p>
Notes: It does seem like it should be possible to reuse sets of
constraints, or produce constraints from a partial object. Maybe make
this another layer on top of the datalog.
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>subjects adventure<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>title ?<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>author-<span class="org-function-name">last</span> ?<span class="org-kcats-brackets">]]</span>
</pre>
</div>

<p>
We could even write queries that cross objects - what authors of adventure books were born in 1900:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>subjects adventure<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>author <span class="org-kcats-brackets">[[</span>birthyear 1900<span class="org-kcats-brackets">]]]]</span>

</pre>
</div>

<p>
Notes: the select clause should use the variable names without the <code>?</code>
as the column alias. It's not clear when <code>book?</code> is used in all 3
constraints, which one should it join on? I don't think it matters but
we need to choose somehow. Variables that are only used in one place
<b>should</b> appear in the select clause, should error if it doesn't.
</p>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"select c2.value as title, c3.value as author</span>
<span class="org-string">   from EAV as c1</span>
<span class="org-string">   join EAV as c2 ON c1.entity = c2.entity AND c1.attribute = \"w|subjects\" AND c1.value = \"w|adventure\" AND c2.attribute = \"w|title\"</span>
<span class="org-string">   join EAV as c3 ON c1.entity = c3.entity AND c3.attribute = \"w|author-last\" </span>
<span class="org-string"> "</span> database 
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>title <span class="org-string">"The Lord of the Rings"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author <span class="org-string">"Tolkien"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>title <span class="org-string">"Adventures of Huckleberry Finn"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author <span class="org-string">"Twain"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>title <span class="org-string">"Don Quixote"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author <span class="org-string">"Cervantes"</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>book <span class="org-string">"author"</span> author<span class="org-kcats-brackets">]</span> 
 <span class="org-kcats-brackets">[</span>book <span class="org-string">"title"</span> title<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>author <span class="org-string">"birthYear"</span> 1945<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>author <span class="org-string">"name"</span> authorName<span class="org-kcats-brackets">]]</span>
<span class="org-kcats-brackets">[</span>authorName title<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"select c4.value, c2.value</span>
<span class="org-string"> from EAV as c1 </span>
<span class="org-string"> join EAV as c2 ON c1.entity = c2.entity AND c2.attribute = \"w|title\" AND c1.attribute = \"w|author\"</span>
<span class="org-string"> join EAV as c3 ON c1.value = c3.entity AND c3.attribute = \"w|birthYear\" AND c3.value = 1945</span>
<span class="org-string"> join EAV as c4 ON c1.value = c4.entity AND c4.attribute = \"w|name\""</span> database
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>unwound <span class="org-kcats-brackets">[</span>database<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>asked <span class="org-kcats-brackets">[</span>consume<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>reason <span class="org-string">"not enough items on stack"</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>type error<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>handled yes<span class="org-kcats-brackets">]]</span>
<span class="org-string">"select c4.value, c2.value\n from EAV as c1 \n join EAV as c2 ON c1.entity = c2.entity AND c2.attribute = \"w|title\" AND c1.attribute = \"w|author\"\n join EAV as c3 ON c1.value = c3.entity AND c3.attribute = \"w|birthYear\" AND c3.value = 1945\n join EAV as c4 ON c1.value = c4.entity AND c4.attribute = \"w|name\""</span>
</pre>
</div>

<p>
Let's copy the input/output here:
</p>

<pre class="example">
 [[book? subjects adventure]
  [book? title title?]
  [book? author-last author?]]

 [title? author?]

select c2.value as title, c3.value as author
    from EAV as c1
    join EAV as c2 ON c1.entity = c2.entity
                  AND c1.attribute = "w|subjects"
                  AND c1.value = "w|adventure"
                  AND c2.attribute = "w|title"
    join EAV as c3 ON c1.entity = c3.entity
                  AND c3.attribute = \"w|author-last\" 
</pre>
<p>
We need to be able to scan through the constraints and output pairs
that are linked via one or more variables. We could create a list of variables like so:
</p>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>book?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>book? title?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>book? author?<span class="org-kcats-brackets">]]</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>book? subjects adventure<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>book? title title?<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>book? subjects adventure<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>book? author-<span class="org-function-name">last</span> author?<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>book? title title?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>book? author-<span class="org-function-name">last</span> author?<span class="org-kcats-brackets">]]]</span>


</pre>
</div>
<p>
Then start with the first row, what other rows have intersection with
it? (May need to add some set-based words here).
</p>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>book?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>book? title?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>book? author?<span class="org-kcats-brackets">]]</span>

</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-comment-delimiter">;; </span><span class="org-comment">Module to operate on generic data, that are used throughout</span>
<span class="org-kcats-brackets">[[</span>fork <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>triangle <span class="org-kcats-brackets">[[[]</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">take</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span><span class="org-function-name">put</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">sink</span> <span class="org-builtin">swap</span> pair<span class="org-kcats-brackets">]</span> bail<span class="org-kcats-brackets">]</span> collect<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>indexed-as-property <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> indexed
                       <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> <span class="org-builtin">sink</span> assign<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span>-all <span class="org-kcats-brackets">[[</span><span class="org-function-name">first</span> empty<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>selectkeys <span class="org-kcats-brackets">[</span>set <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> contains?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>invert <span class="org-kcats-brackets">[[</span><span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> association<span class="org-kcats-brackets">]]</span>

 <span class="org-comment-delimiter">;; </span><span class="org-comment">datalog variables</span>
 <span class="org-kcats-brackets">[</span>variable? <span class="org-kcats-brackets">[[[</span>word?<span class="org-kcats-brackets">]</span>
              <span class="org-kcats-brackets">[</span>string <span class="org-function-name">last</span> \? =<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>variable= <span class="org-kcats-brackets">[[[</span>pair <span class="org-kcats-brackets">[</span>variable?<span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>=<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]]</span> 

 <span class="org-comment-delimiter">;; </span><span class="org-comment">datalog constraints</span>
 <span class="org-kcats-brackets">[</span>slots <span class="org-kcats-brackets">[[</span>entity attribute value<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[</span>slot-combos <span class="org-kcats-brackets">[</span>slots <span class="org-kcats-brackets">[</span>slots <span class="org-kcats-brackets">[</span>pair<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-function-name">join</span>-all<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>constraint <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> slots <span class="org-function-name">reverse</span> label<span class="org-kcats-brackets">]]</span> 

 <span class="org-comment-delimiter">;; </span><span class="org-comment">links between datalog constraints</span>
 <span class="org-kcats-brackets">[</span>links <span class="org-kcats-brackets">[</span>slot-combos
         <span class="org-kcats-brackets">[[</span><span class="org-function-name">wrap</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-function-name">unwrap</span> <span class="org-builtin">swapdown</span> 
          <span class="org-kcats-brackets">[[[</span>lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> both<span class="org-kcats-brackets">]</span> pairwise 
          variable=<span class="org-kcats-brackets">]</span>
         <span class="org-function-name">filter</span>   
         <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> pair <span class="org-builtin">sink</span> pair
          <span class="org-kcats-brackets">[[</span>index<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-builtin">swap</span> zip<span class="org-kcats-brackets">]</span>
         <span class="org-function-name">map</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>all-links <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">sink</span>
             <span class="org-kcats-brackets">[[[[</span>index<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]</span> both <span class="org-comment-delimiter">;; </span><span class="org-comment">lookup the indices of both constraints</span>
              <span class="org-kcats-brackets">[</span><span class="org-builtin">swapdown</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">sink</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">move the indices under the constraints</span>
              <span class="org-kcats-brackets">[</span>links<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span>
              <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-builtin">dropdown</span> <span class="org-builtin">dropdown</span> <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span><span class="org-kcats-brackets">]</span> 

             <span class="org-function-name">step</span> <span class="org-builtin">drop</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>format-link <span class="org-kcats-brackets">[[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
               <span class="org-string">"c{0}.{1} = c{2}.{3}"</span> <span class="org-builtin">swap</span> format<span class="org-kcats-brackets">]]</span> 

 <span class="org-comment-delimiter">;; </span><span class="org-comment">formatting pieces of query data into text</span>
 <span class="org-kcats-brackets">[</span>anded-together <span class="org-kcats-brackets">[</span><span class="org-string">" AND "</span> interpose <span class="org-function-name">join</span>-all<span class="org-kcats-brackets">]]</span>

 <span class="org-comment-delimiter">;; </span><span class="org-comment">where clause data processing</span>
 <span class="org-kcats-brackets">[</span>where-data <span class="org-kcats-brackets">[[[</span>index<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-builtin">swap</span> 
              <span class="org-kcats-brackets">[[[</span><span class="org-function-name">second</span> variable? not<span class="org-kcats-brackets">]</span>
                <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>index<span class="org-kcats-brackets">]</span> <span class="org-function-name">unwrap</span> = not<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> every?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span> 
              <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> prepend<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-builtin">dropdown</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>format-where <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> 
                <span class="org-string">"c{0}.{1} = :c{0}{1}"</span> <span class="org-builtin">swap</span> format<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>make-where <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span>where<span class="org-kcats-brackets">]</span> lookup anded-together<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>format-<span class="org-function-name">join</span> <span class="org-kcats-brackets">[[[[</span>on<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
                 <span class="org-kcats-brackets">[[</span>where<span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span>
                 <span class="org-kcats-brackets">[[</span>index<span class="org-kcats-brackets">]</span> lookup string<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
                <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span> anded-together<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">inject</span> 
                <span class="org-string">"JOIN EAV c{1} ON {0}"</span> <span class="org-builtin">swap</span> format<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>make-query <span class="org-kcats-brackets">[</span><span class="org-function-name">rest</span> <span class="org-kcats-brackets">[[</span>on<span class="org-kcats-brackets">]</span>
                    <span class="org-kcats-brackets">[[</span>format-link<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> update
                    <span class="org-kcats-brackets">[</span>format-<span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> assign<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]]</span>

 <span class="org-comment-delimiter">;; </span><span class="org-comment">SQL parameters for rusqlite</span>
 <span class="org-kcats-brackets">[</span>param-name <span class="org-kcats-brackets">[[</span>string<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-string">":c{0}{1}"</span> <span class="org-builtin">swap</span> format<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>extract-params <span class="org-kcats-brackets">[[]</span> association <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[</span>params<span class="org-kcats-brackets">]</span> lookup <span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">step</span><span class="org-kcats-brackets">]]</span>


 <span class="org-comment-delimiter">;; </span><span class="org-comment">SELECT clause</span>
 <span class="org-kcats-brackets">[</span>wordval? <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span> word?<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>invert <span class="org-kcats-brackets">[[</span><span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> association<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>validate <span class="org-kcats-brackets">[[[</span><span class="org-function-name">second</span> not<span class="org-kcats-brackets">]</span>
             <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-string">"All selected query variables must appear somewhere in constraints"</span>
              <span class="org-kcats-brackets">[</span>reason variable<span class="org-kcats-brackets">]</span> label fail<span class="org-kcats-brackets">]</span>
             when<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>select-data <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span>
               <span class="org-kcats-brackets">[[</span>slots selectkeys invert<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
                <span class="org-kcats-brackets">[</span>wordval?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span> <span class="org-function-name">join</span> association<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
               <span class="org-builtin">swap</span>
               <span class="org-kcats-brackets">[[[</span>index<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">make a list of the variable and 'index'</span>
                 <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>selectkeys<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">make the program to cut down</span>
                 <span class="org-function-name">map</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 2 =<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
                 <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> when<span class="org-kcats-brackets">]</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">items are in random order due to coming from association, fix the order</span>
                <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span>
               <span class="org-preprocessor">shield</span> dropdeep zip
               validate<span class="org-kcats-brackets">]]</span>

 <span class="org-comment-delimiter">;; </span><span class="org-comment">query </span>
 <span class="org-kcats-brackets">[</span>extract-data <span class="org-kcats-brackets">[[[[</span><span class="org-function-name">unwrap</span> all-links<span class="org-kcats-brackets">]</span>
                  <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> where-data   <span class="org-comment-delimiter">; </span><span class="org-comment">[join] inject unwrap</span>
                   <span class="org-comment-delimiter">;; </span><span class="org-comment">build the query param map</span>
                   <span class="org-kcats-brackets">[[[]</span> <span class="org-builtin">swap</span>
                     <span class="org-kcats-brackets">[[</span>param-name<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">last</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">wrap</span> <span class="org-builtin">swap</span> assign<span class="org-kcats-brackets">]</span>
                     <span class="org-function-name">step</span><span class="org-kcats-brackets">]</span>
                    <span class="org-comment-delimiter">;; </span><span class="org-comment">build the actual query where clauses</span>
                    <span class="org-kcats-brackets">[[</span>format-where<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]]</span>
                   fork<span class="org-kcats-brackets">]]</span>
                 fork<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span>
                <span class="org-comment-delimiter">;; </span><span class="org-comment">combine extracted items</span>

                <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">keep the original constraint to add properties to</span>
                <span class="org-function-name">unwrap</span> <span class="org-function-name">unwrap</span> <span class="org-kcats-brackets">[</span>where params on<span class="org-kcats-brackets">]</span> label <span class="org-function-name">join</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>format-select <span class="org-kcats-brackets">[[</span><span class="org-function-name">unwrap</span> <span class="org-builtin">swap</span>
                  string butlast <span class="org-comment-delimiter">;; </span><span class="org-comment">remove the ? from the variable name for result column</span>
                  <span class="org-function-name">put</span>
                  <span class="org-kcats-brackets">[</span>string<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
                  <span class="org-string">"c{1}.{0} as {2}"</span> <span class="org-builtin">swap</span> format<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-string">", "</span> interpose <span class="org-function-name">join</span>-all<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>query <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span>
         <span class="org-comment-delimiter">;; </span><span class="org-comment">expand all combinations of constraints</span>
         <span class="org-kcats-brackets">[</span>constraint<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> 
         <span class="org-comment-delimiter">;;</span><span class="org-comment">[] prepend ;; an empty constraint to represent the orignal EAV table we're joining with</span>
         <span class="org-kcats-brackets">[</span>index<span class="org-kcats-brackets">]</span> indexed-as-property
         triangle
         <span class="org-comment-delimiter">;; </span><span class="org-comment">for each pair of constraints, build the "ON" clause data for the JOIN</span>
         <span class="org-kcats-brackets">[</span>extract-data<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>

         <span class="org-kcats-brackets">[[</span>extract-params<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>make-query<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span>make-where<span class="org-kcats-brackets">]</span>
          <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> select-data<span class="org-kcats-brackets">]]</span> fork 
         <span class="org-builtin">dropdown</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">don't need original anymore</span>
         <span class="org-function-name">unwrap</span> <span class="org-builtin">float</span>
         <span class="org-kcats-brackets">[[</span><span class="org-function-name">join</span><span class="org-kcats-brackets">]</span> lookup<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>  
         <span class="org-builtin">swap</span> format-select 
         <span class="org-kcats-brackets">[</span><span class="org-string">" "</span> interpose <span class="org-function-name">join</span>-all<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> triplet <span class="org-function-name">reverse</span>
         <span class="org-string">"SELECT {0} from EAV as c0 {1} WHERE {2}"</span> <span class="org-builtin">swap</span> format
         <span class="org-builtin">swap</span> dropdeep<span class="org-kcats-brackets">]]]</span>
draft inscribe

<span class="org-kcats-brackets">[[[</span>book? subjects love<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>book? title title?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>book? author-<span class="org-function-name">last</span> author-<span class="org-function-name">last</span>?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>book? author-<span class="org-function-name">first</span> author-<span class="org-function-name">first</span>?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author? <span class="org-function-name">first</span>-name author-<span class="org-function-name">first</span>?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author? <span class="org-function-name">last</span>-name author-<span class="org-function-name">last</span>?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author? sex f<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author? birth-year birth-year?<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>title? author-<span class="org-function-name">first</span>? author-<span class="org-function-name">last</span>? birth-year?<span class="org-kcats-brackets">]</span>
 query
<span class="org-kcats-brackets">]</span> confine<span class="org-comment-delimiter">; </span><span class="org-comment">database</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span><span class="org-string">":c0attribute"</span> subjects<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c0value"</span> love<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c1attribute"</span> title<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c2attribute"</span> author-<span class="org-function-name">last</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c3attribute"</span> author-<span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c4attribute"</span> <span class="org-function-name">first</span>-name<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c5attribute"</span> <span class="org-function-name">last</span>-name<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c6attribute"</span> sex<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c6value"</span> f<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c7attribute"</span> birth-year<span class="org-kcats-brackets">]]</span>
<span class="org-string">"SELECT c1.value as \"title\", c3.value as \"author-first\", c2.value as \"author-last\", c7.value as \"birth-year\" from EAV as c0 JOIN EAV c1 ON c1.attribute = :c1attribute AND c0.entity = c1.entity JOIN EAV c2 ON c2.attribute = :c2attribute AND c0.entity = c2.entity AND c1.entity = c2.entity JOIN EAV c3 ON c3.attribute = :c3attribute AND c0.entity = c3.entity AND c1.entity = c3.entity AND c2.entity = c3.entity JOIN EAV c4 ON c4.attribute = :c4attribute AND c3.value = c4.value JOIN EAV c5 ON c5.attribute = :c5attribute AND c2.value = c5.value AND c4.entity = c5.entity JOIN EAV c6 ON c6.attribute = :c6attribute AND c6.value = :c6value AND c4.entity = c6.entity AND c5.entity = c6.entity JOIN EAV c7 ON c7.attribute = :c7attribute AND c4.entity = c7.entity AND c5.entity = c7.entity AND c6.entity = c7.entity WHERE c0.value = :c0value AND c0.attribute = :c0attribute"</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>definition <span class="org-kcats-brackets">[[</span>entity attribute value<span class="org-kcats-brackets">]]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"SELECT c2.value as title, c3.value as author from EAV as c1</span>
<span class="org-string">JOIN EAV c2 ON c2.attribute = :c2attribute</span>
<span class="org-string">   AND c1.entity = c2.entity</span>
<span class="org-string">JOIN EAV c3 ON c3.attribute = :c3attribute</span>
<span class="org-string">   AND c2.entity = c3.entity AND c1.entity = c3.entity</span>
<span class="org-string">WHERE c1.attribute = :c1attribute AND c1.value = :c1value"</span>
<span class="org-kcats-brackets">[[</span><span class="org-string">":c1value"</span> adventure<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c2attribute"</span> title<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c1attribute"</span> subjects<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span><span class="org-string">":c3attribute"</span> author-<span class="org-function-name">last</span><span class="org-kcats-brackets">]]</span>
database
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>author <span class="org-string">"Tolkien"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>title <span class="org-string">"The Lord of the Rings"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>title <span class="org-string">"Adventures of Huckleberry Finn"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author <span class="org-string">"Twain"</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[[</span>title <span class="org-string">"Don Quixote"</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>author <span class="org-string">"Cervantes"</span><span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-string">"SELECT COUNT(*)</span>
<span class="org-string">FROM EAV </span>
<span class="org-string">WHERE value = 's|Don Quixote'"</span>
<span class="org-kcats-brackets">[]</span> database
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>COUNT(*) 1<span class="org-kcats-brackets">]]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>a b c<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>c d e<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>e f g<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span><span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shielddown</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-builtin">swap</span>
</pre>
</div>
<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[</span>a c e<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span>b d f<span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>book? subjects adventure<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">[</span>book? title title?<span class="org-kcats-brackets">]]</span> indexed
<span class="org-kcats-brackets">[[]</span> <span class="org-preprocessor">inject</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>

<span class="org-kcats-brackets">[[</span>c0.entity c0.attribute c0.value<span class="org-kcats-brackets">]</span>
 <span class="org-kcats-brackets">]</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>entity book?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>attribute subjects<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>index 1<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>params <span class="org-kcats-brackets">[[</span><span class="org-string">":c1attribute"</span> subjects<span class="org-kcats-brackets">]</span>
           <span class="org-kcats-brackets">[</span><span class="org-string">":c1value"</span> adventure<span class="org-kcats-brackets">]]]</span>
  <span class="org-kcats-brackets">[</span>on <span class="org-kcats-brackets">[]]</span>
  <span class="org-kcats-brackets">[</span>value adventure<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>where <span class="org-kcats-brackets">[</span><span class="org-string">"c1.attribute = :c1attribute"</span> <span class="org-string">"c1.value = :c1value"</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>value title?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>attribute title<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>entity book?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>where <span class="org-kcats-brackets">[</span><span class="org-string">"c2.attribute = :c2attribute"</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>on <span class="org-kcats-brackets">[[[</span>2 entity<span class="org-kcats-brackets">]</span>
        <span class="org-kcats-brackets">[</span>1 entity<span class="org-kcats-brackets">]]]]</span>
  <span class="org-kcats-brackets">[</span>index 2<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>params <span class="org-kcats-brackets">[[</span><span class="org-string">":c2attribute"</span> title<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>params <span class="org-kcats-brackets">[[</span><span class="org-string">":c3attribute"</span> author-<span class="org-function-name">last</span><span class="org-kcats-brackets">]]]</span>
  <span class="org-kcats-brackets">[</span>entity book?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>index 3<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>attribute author-<span class="org-function-name">last</span><span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>on <span class="org-kcats-brackets">[[[</span>3 entity<span class="org-kcats-brackets">]</span>
        <span class="org-kcats-brackets">[</span>2 entity<span class="org-kcats-brackets">]]</span>
       <span class="org-kcats-brackets">[[</span>3 entity<span class="org-kcats-brackets">]</span>
        <span class="org-kcats-brackets">[</span>1 entity<span class="org-kcats-brackets">]]]]</span>
  <span class="org-kcats-brackets">[</span>value author?<span class="org-kcats-brackets">]</span>
  <span class="org-kcats-brackets">[</span>where <span class="org-kcats-brackets">[</span><span class="org-string">"c3.attribute = :c3attribute"</span><span class="org-kcats-brackets">]]]]</span>

<span class="org-kcats-brackets">[</span>title? author?<span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[[</span>selectkeys <span class="org-kcats-brackets">[</span>set <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> contains?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span><span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>wordval? <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span> word?<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>invert <span class="org-kcats-brackets">[[</span><span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> association<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>validate <span class="org-kcats-brackets">[[[</span><span class="org-function-name">second</span> not<span class="org-kcats-brackets">]</span>
             <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-string">"All selected query variables must appear somewhere in constraints"</span>
              <span class="org-kcats-brackets">[</span>reason variable<span class="org-kcats-brackets">]</span> label fail<span class="org-kcats-brackets">]</span>
             when<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]]]</span>
<span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[[</span>entity attribute value<span class="org-kcats-brackets">]</span> selectkeys invert<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> <span class="org-kcats-brackets">[</span>wordval?<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span> <span class="org-function-name">join</span> association<span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span>
 <span class="org-builtin">swap</span> <span class="org-kcats-brackets">[[[</span>index<span class="org-kcats-brackets">]</span> <span class="org-builtin">swap</span> <span class="org-function-name">put</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">make a list of the variable and 'index'</span>
        <span class="org-function-name">wrap</span> <span class="org-kcats-brackets">[</span>selectkeys<span class="org-kcats-brackets">]</span> <span class="org-function-name">join</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">make the program to cut down</span>
        <span class="org-function-name">map</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">count</span> 2 =<span class="org-kcats-brackets">]</span> <span class="org-function-name">filter</span> <span class="org-function-name">first</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">second</span><span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> number?<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[</span><span class="org-function-name">reverse</span><span class="org-kcats-brackets">]</span> when
       <span class="org-kcats-brackets">]</span> <span class="org-function-name">map</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span> dropdeep zip validate<span class="org-kcats-brackets">]</span>
draft
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>title? <span class="org-kcats-brackets">[</span>value 2<span class="org-kcats-brackets">]]</span>
 <span class="org-kcats-brackets">[</span>author? <span class="org-kcats-brackets">[</span>value 3<span class="org-kcats-brackets">]]]</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orged56b89" class="outline-3">
<h3 id="orged56b89"><span class="section-number-3">2.28.</span> <span class="todo TODO">TODO</span> Reduce CPU cost of `shield`</h3>
<div class="outline-text-3" id="text-2-28">
<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 2 3 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-preprocessor">shield</span><span class="org-kcats-brackets">]]]</span> environment stepper 0 <span class="org-kcats-brackets">[</span><span class="org-builtin">drop</span> inc<span class="org-kcats-brackets">]</span> cram
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats">25 <span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>1 2 3 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span>
           <span class="org-kcats-brackets">[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-comment-delimiter">; </span><span class="org-comment">[restore] dip dropdown</span>
           <span class="org-comment-delimiter">;</span><span class="org-comment">first take drop swap prepend restore ; take clonedown dip</span>
           <span class="org-kcats-brackets">]]]</span> environment
stepper collect
<span class="org-comment-delimiter">;</span><span class="org-comment">0 [drop inc] cram</span>
</pre>
</div>

<div class="org-src-container results">
<pre class="src src-kcats"><span class="org-kcats-brackets">[[[</span>program <span class="org-kcats-brackets">[</span>2 3 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>1<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span>3 <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[</span>2 1<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span>3 2 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[[]</span> <span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[[]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">clone</span> <span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">evert</span> <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">dip</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[</span><span class="org-preprocessor">execute</span><span class="org-kcats-brackets">]</span> <span class="org-kcats-brackets">[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]</span> <span class="org-kcats-brackets">[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span><span class="org-preprocessor">execute</span> <span class="org-kcats-brackets">[[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span> <span class="org-function-name">unwrap</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span>3 2 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span>+ <span class="org-kcats-brackets">[[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span> <span class="org-function-name">unwrap</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span>5 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[[[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span> <span class="org-function-name">unwrap</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[[[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]]</span> 5 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">unwrap</span> <span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-function-name">first</span> <span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]]</span> 5 1<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>program <span class="org-kcats-brackets">[</span><span class="org-builtin">swap</span><span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>stack <span class="org-kcats-brackets">[[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]</span> 5 1<span class="org-kcats-brackets">]]]</span>
 <span class="org-kcats-brackets">[[</span>stack <span class="org-kcats-brackets">[</span>5 <span class="org-kcats-brackets">[[</span>+<span class="org-kcats-brackets">]</span> 3 2 1<span class="org-kcats-brackets">]</span> 1<span class="org-kcats-brackets">]]</span>
  <span class="org-kcats-brackets">[</span>program <span class="org-kcats-brackets">[]]]]</span>
<span class="org-kcats-brackets">[</span>eval-<span class="org-function-name">step</span> <span class="org-builtin">clone</span><span class="org-kcats-brackets">]</span>
<span class="org-kcats-brackets">[]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org73625fd" class="outline-3">
<h3 id="org73625fd"><span class="section-number-3">2.29.</span> <span class="todo TODO">TODO</span> Sort out feature dependencies</h3>
<div class="outline-text-3" id="text-2-29">
<div class="org-src-container">
<pre class="src src-dot">digraph G {
    // Define nodes
    core [label="Core words", style=filled, fillcolor=lightgreen, shape=rect];
    pipes [label="I/O pipes", style=filled, fillcolor=lightgreen, shape=rect];
    generators [label="Generators", style=filled, fillcolor=lightgreen, shape=rect];
    debug [label="Debugger", style=filled, fillcolor=lightgreen, shape=rect];
    crypto [label="Cryptography", style=filled, fillcolor=yellow, shape=rect];
    auth [label="Authentication Scripting", style=filled, fillcolor=yellow, shape=rect];
    localmod [label="Local Modules", style=filled, fillcolor=yellow, shape=rect];
    remotemod [label="Remote Modules"];
    revocation [label="Revocation Lists"];
    db [label="Persistent Database", style=filled, fillcolor=yellow, shape=rect];
    storage [label="Storage", fillcolor=lightgreen];
    cache [label="Hash-keyed blob cache", style=filled, fillcolow=yellow, shape=rect];
    streams [label="Content streams"];
    payments [label="Payments BTC"];
    contacts [label="Address Book"];
    messaging [label="Messaging"];
    backup [label="Data backup"];
    keys [label="Encryption Key management"];
    peers [label="Peer discovery"];
    names [label="Naming"];

    // Define edges to represent dependencies
    pipes -&gt; core; 
    generators -&gt; core;
    debug -&gt; core;
    crypto -&gt; core;
    localmod -&gt; core;
    localmod -&gt; cache;
    localmod -&gt; names;
    cache -&gt; core;
    cache -&gt; storage;
    auth -&gt; crypto;
    auth -&gt; revocation;
    remotemod -&gt; localmod;
    remotemod -&gt; auth;
    revocation -&gt; db;
    db -&gt; core;
    db -&gt; localmod;
    db -&gt; pipes;
    db -&gt; storage;

    // Application level
    messaging -&gt; contacts;
    contacts -&gt; auth;
    contacts -&gt; db;
    messaging -&gt; db;
    messaging -&gt; streams;
    streams -&gt; db;
    streams -&gt; names;
    streams -&gt; peers;
    peers -&gt; crypto;
    streams -&gt; pipes;
    streams -&gt; keys;
    //remotemod -&gt; streams;
    keys -&gt; db;
    contacts -&gt; streams;
    revocation -&gt; streams;
    backup -&gt; streams;
    backup -&gt; payments;
    names -&gt; storage;
    names -&gt; crypto;

}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Skyrod Vactai</p>
<p class="date">Created: 2024-05-09 Thu 22:31</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
