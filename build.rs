use cache::cache;
use directories::ProjectDirs;
use std::env;
use std::error::Error;
use std::fs::File;
use std::fs::{self};
use std::io::Write;
use std::path::Path;
//use std::path::PathBuf;

#[derive(Debug)]
enum MyError {
    CustomError(String),
}

impl std::fmt::Display for MyError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match *self {
            MyError::CustomError(ref err) => write!(f, "Build Error: {}", err),
        }
    }
}

impl std::error::Error for MyError {}

fn main() -> Result<(), Box<dyn Error>> {
    // Print the current directory for debugging
    println!("Current dir: {:?}", std::env::current_dir()?);

    // Create a fallback cache directory in the target directory
    let cache_dir = if let Some(project_dirs) = ProjectDirs::from("org", "skyrod", "kcats") {
        let dir = project_dirs.data_dir().join("cache");
        println!("Using project cache dir: {:?}", dir);
        dir
    } else {
        let dir = Path::new("target").join("build_cache");
        println!("Using fallback cache dir: {:?}", dir);
        dir
    };

    // Create cache directory
    std::fs::create_dir_all(&cache_dir)
        .map_err(|e| MyError::CustomError(format!("Failed to create cache directory: {}", e)))?;

    let cache = cache::Cache::new(cache_dir)?;
    let src = "src/kcats/stdlib";
    let src_stdlib_path = Path::new(src);

    // Add debug information
    println!("Stdlib path: {:?}", src_stdlib_path);
    println!("Stdlib exists: {}", src_stdlib_path.exists());

    // Store mappings to generate code later
    let mut alias_to_hash = Vec::new();

    if src_stdlib_path.exists() && src_stdlib_path.is_dir() {
        let entries = fs::read_dir(src_stdlib_path)?;
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() {
                let module_name = path.file_stem().unwrap().to_str().unwrap().to_string();
                let formatted = std::fs::read_to_string(&path)?;
                let canonical = edn_format::canonicalize(formatted)?;

                // 1. Put in Cache and ESCALATE the Hash return value
                let hash_string =
                    cache.put(&canonical.as_bytes().to_vec(), Some(module_name.clone()))?; // returns Ok(String) e.g. "QmHash..."

                // 2. Collect for codegen
                alias_to_hash.push((module_name, hash_string));
            }
        }
    }

    // 3. GENERATE RUST CODE
    //let out_dir = env::var("OUT_DIR")?;
    let dest_path = Path::new("src").join("stdlib_hashes.rs");
    let mut f = File::create(&dest_path)?;
    writeln!(f, "/// Auto-generated by build.rs. DO NOT EDIT.")?;
    writeln!(f, "use std::collections::HashMap;")?;

    // Change return type to &'static [u8]
    writeln!(f, "pub fn get() -> HashMap<&'static str, &'static [u8]> {{")?;
    writeln!(
        f,
        "    let mut m = HashMap::<&'static str, &'static [u8]>::new();"
    )?;

    for (alias, hash_vec) in alias_to_hash {
        // Use {:?} to format Vec<u8> as `[10, 20, 255]`
        writeln!(f, "    m.insert(\"{}\", &{:?});", alias, hash_vec)?;
    }

    writeln!(f, "    m")?;
    writeln!(f, "}}")?;

    Ok(())
}
